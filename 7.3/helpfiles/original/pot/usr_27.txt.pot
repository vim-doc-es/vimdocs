# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the Vim package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.3\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2010-09-23 20:27+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: original/TXT/intro.txt:18 original/TXT/intro.txt:79
#: original/TXT/intro.txt:180 original/TXT/intro.txt:290
#: original/TXT/intro.txt:518 original/TXT/intro.txt:596
#: original/TXT/intro.txt:689 original/TXT/intro.txt:817
#: original/TXT/intro.txt:880 original/TXT/usr_toc.txt:7
#: original/TXT/usr_toc.txt:58 original/TXT/usr_toc.txt:172
#: original/TXT/usr_toc.txt:281 original/TXT/usr_toc.txt:340
#: original/TXT/usr_toc.txt:352 original/TXT/usr_01.txt:19
#: original/TXT/usr_01.txt:50 original/TXT/usr_01.txt:100
#: original/TXT/usr_01.txt:181 original/TXT/usr_02.txt:25
#: original/TXT/usr_02.txt:69 original/TXT/usr_02.txt:130
#: original/TXT/usr_02.txt:179 original/TXT/usr_02.txt:239
#: original/TXT/usr_02.txt:307 original/TXT/usr_02.txt:369
#: original/TXT/usr_02.txt:406 original/TXT/usr_02.txt:560
#: original/TXT/usr_03.txt:28 original/TXT/usr_03.txt:74
#: original/TXT/usr_03.txt:101 original/TXT/usr_03.txt:147
#: original/TXT/usr_03.txt:172 original/TXT/usr_03.txt:223
#: original/TXT/usr_03.txt:265 original/TXT/usr_03.txt:320
#: original/TXT/usr_03.txt:491 original/TXT/usr_03.txt:552
#: original/TXT/usr_03.txt:650 original/TXT/usr_04.txt:27
#: original/TXT/usr_04.txt:74 original/TXT/usr_04.txt:160
#: original/TXT/usr_04.txt:194 original/TXT/usr_04.txt:269
#: original/TXT/usr_04.txt:324 original/TXT/usr_04.txt:360
#: original/TXT/usr_04.txt:390 original/TXT/usr_04.txt:446
#: original/TXT/usr_04.txt:469 original/TXT/usr_04.txt:510
#: original/TXT/usr_05.txt:24 original/TXT/usr_05.txt:63
#: original/TXT/usr_05.txt:219 original/TXT/usr_05.txt:266
#: original/TXT/usr_05.txt:418 original/TXT/usr_05.txt:467
#: original/TXT/usr_05.txt:506 original/TXT/usr_05.txt:621
#: original/TXT/usr_06.txt:24 original/TXT/usr_06.txt:50
#: original/TXT/usr_06.txt:135 original/TXT/usr_06.txt:189
#: original/TXT/usr_06.txt:270 original/TXT/usr_06.txt:276
#: original/TXT/usr_07.txt:24 original/TXT/usr_07.txt:63
#: original/TXT/usr_07.txt:179 original/TXT/usr_07.txt:266
#: original/TXT/usr_07.txt:316 original/TXT/usr_07.txt:404
#: original/TXT/usr_07.txt:444 original/TXT/usr_07.txt:475
#: original/TXT/usr_08.txt:26 original/TXT/usr_08.txt:82
#: original/TXT/usr_08.txt:109 original/TXT/usr_08.txt:161
#: original/TXT/usr_08.txt:215 original/TXT/usr_08.txt:278
#: original/TXT/usr_08.txt:337 original/TXT/usr_08.txt:477
#: original/TXT/usr_08.txt:509 original/TXT/usr_08.txt:597
#: original/TXT/usr_09.txt:21 original/TXT/usr_09.txt:124
#: original/TXT/usr_09.txt:175 original/TXT/usr_09.txt:259
#: original/TXT/usr_09.txt:285 original/TXT/usr_10.txt:27
#: original/TXT/usr_10.txt:144 original/TXT/usr_10.txt:221
#: original/TXT/usr_10.txt:342 original/TXT/usr_10.txt:378
#: original/TXT/usr_10.txt:547 original/TXT/usr_10.txt:621
#: original/TXT/usr_10.txt:667 original/TXT/usr_10.txt:692
#: original/TXT/usr_10.txt:820 original/TXT/usr_11.txt:22
#: original/TXT/usr_11.txt:82 original/TXT/usr_11.txt:144
#: original/TXT/usr_11.txt:288 original/TXT/usr_11.txt:303
#: original/TXT/usr_12.txt:25 original/TXT/usr_12.txt:90
#: original/TXT/usr_12.txt:131 original/TXT/usr_12.txt:177
#: original/TXT/usr_12.txt:202 original/TXT/usr_12.txt:231
#: original/TXT/usr_12.txt:281 original/TXT/usr_12.txt:309
#: original/TXT/usr_12.txt:354 original/TXT/usr_20.txt:22
#: original/TXT/usr_20.txt:113 original/TXT/usr_20.txt:158
#: original/TXT/usr_20.txt:285 original/TXT/usr_20.txt:327
#: original/TXT/usr_20.txt:380 original/TXT/usr_21.txt:24
#: original/TXT/usr_21.txt:47 original/TXT/usr_21.txt:87
#: original/TXT/usr_21.txt:236 original/TXT/usr_21.txt:385
#: original/TXT/usr_21.txt:438 original/TXT/usr_21.txt:495
#: original/TXT/usr_22.txt:22 original/TXT/usr_22.txt:148
#: original/TXT/usr_22.txt:213 original/TXT/usr_22.txt:272
#: original/TXT/usr_22.txt:396 original/TXT/usr_23.txt:23
#: original/TXT/usr_23.txt:114 original/TXT/usr_23.txt:156
#: original/TXT/usr_23.txt:238 original/TXT/usr_23.txt:324
#: original/TXT/usr_23.txt:339 original/TXT/usr_24.txt:28
#: original/TXT/usr_24.txt:96 original/TXT/usr_24.txt:119
#: original/TXT/usr_24.txt:268 original/TXT/usr_24.txt:305
#: original/TXT/usr_24.txt:336 original/TXT/usr_24.txt:369
#: original/TXT/usr_24.txt:493 original/TXT/usr_24.txt:537
#: original/TXT/usr_24.txt:583 original/TXT/usr_24.txt:602
#: original/TXT/usr_25.txt:22 original/TXT/usr_25.txt:132
#: original/TXT/usr_25.txt:210 original/TXT/usr_25.txt:287
#: original/TXT/usr_25.txt:453 original/TXT/usr_25.txt:574
#: original/TXT/usr_26.txt:21 original/TXT/usr_26.txt:46
#: original/TXT/usr_26.txt:103 original/TXT/usr_26.txt:136
#: original/TXT/usr_26.txt:217 original/TXT/usr_27.txt:26
#: original/TXT/usr_27.txt:88 original/TXT/usr_27.txt:136
#: original/TXT/usr_27.txt:239 original/TXT/usr_27.txt:320
#: original/TXT/usr_27.txt:350 original/TXT/usr_27.txt:427
#: original/TXT/usr_27.txt:469 original/TXT/usr_27.txt:510
#: original/TXT/usr_27.txt:559 original/TXT/usr_28.txt:27
#: original/TXT/usr_28.txt:54 original/TXT/usr_28.txt:121
#: original/TXT/usr_28.txt:185 original/TXT/usr_28.txt:211
#: original/TXT/usr_28.txt:269 original/TXT/usr_28.txt:315
#: original/TXT/usr_28.txt:331 original/TXT/usr_28.txt:375
#: original/TXT/usr_28.txt:389 original/TXT/usr_28.txt:422
#: original/TXT/usr_29.txt:23 original/TXT/usr_29.txt:273
#: original/TXT/usr_29.txt:320 original/TXT/usr_29.txt:441
#: original/TXT/usr_29.txt:570 original/TXT/usr_29.txt:609
#: original/TXT/usr_30.txt:23 original/TXT/usr_30.txt:202
#: original/TXT/usr_30.txt:280 original/TXT/usr_30.txt:336
#: original/TXT/usr_30.txt:409 original/TXT/usr_30.txt:515
#: original/TXT/usr_30.txt:639 original/TXT/usr_31.txt:22
#: original/TXT/usr_31.txt:81 original/TXT/usr_31.txt:133
#: original/TXT/usr_31.txt:160 original/TXT/usr_31.txt:208
#: original/TXT/usr_31.txt:268
#, no-wrap
msgid "==============================================================================\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_toc.txt:4 original/TXT/usr_01.txt:4
#: original/TXT/usr_02.txt:4 original/TXT/usr_03.txt:4
#: original/TXT/usr_04.txt:4 original/TXT/usr_05.txt:4
#: original/TXT/usr_06.txt:4 original/TXT/usr_07.txt:4
#: original/TXT/usr_08.txt:4 original/TXT/usr_09.txt:4
#: original/TXT/usr_10.txt:4 original/TXT/usr_11.txt:4
#: original/TXT/usr_12.txt:4 original/TXT/usr_20.txt:4
#: original/TXT/usr_21.txt:4 original/TXT/usr_22.txt:4
#: original/TXT/usr_23.txt:4 original/TXT/usr_24.txt:4
#: original/TXT/usr_25.txt:4 original/TXT/usr_26.txt:4
#: original/TXT/usr_27.txt:4 original/TXT/usr_28.txt:4
#: original/TXT/usr_29.txt:4 original/TXT/usr_30.txt:4
#: original/TXT/usr_31.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_toc.txt:354 original/TXT/usr_01.txt:185
#: original/TXT/usr_02.txt:564 original/TXT/usr_03.txt:654
#: original/TXT/usr_04.txt:514 original/TXT/usr_05.txt:625
#: original/TXT/usr_06.txt:280 original/TXT/usr_07.txt:479
#: original/TXT/usr_08.txt:601 original/TXT/usr_09.txt:289
#: original/TXT/usr_10.txt:824 original/TXT/usr_11.txt:307
#: original/TXT/usr_12.txt:358 original/TXT/usr_20.txt:384
#: original/TXT/usr_21.txt:499 original/TXT/usr_22.txt:400
#: original/TXT/usr_23.txt:343 original/TXT/usr_24.txt:606
#: original/TXT/usr_25.txt:578 original/TXT/usr_26.txt:221
#: original/TXT/usr_27.txt:563 original/TXT/usr_28.txt:426
#: original/TXT/usr_29.txt:613 original/TXT/usr_30.txt:643
#: original/TXT/usr_31.txt:272
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_03.txt:261 original/TXT/usr_27.txt:110
#, no-wrap
msgid "\t:set ruler\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_03.txt:362 original/TXT/usr_27.txt:35
#, no-wrap
msgid "\t:set ignorecase\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_03.txt:367 original/TXT/usr_27.txt:42
#, no-wrap
msgid "\t:set noignorecase\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:2
#, no-wrap
msgid "*usr_27.txt*\tFor Vim version 7.3.  Last change: 2010 Mar 28\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:6
#, no-wrap
msgid "\t\t\t Search commands and patterns\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:11
msgid ""
"In chapter 3 a few simple search patterns were mentioned |03.9|.  Vim can do "
"much more complex searches.  This chapter explains the most often used "
"ones.  A detailed specification can be found here: |pattern|"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:21
#, no-wrap
msgid ""
"|27.1|\tIgnoring case\n"
"|27.2|\tWrapping around the file end\n"
"|27.3|\tOffsets\n"
"|27.4|\tMatching multiple times\n"
"|27.5|\tAlternatives\n"
"|27.6|\tCharacter ranges\n"
"|27.7|\tCharacter classes\n"
"|27.8|\tMatching a line break\n"
"|27.9|\tExamples\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:25
#, no-wrap
msgid ""
"     Next chapter: |usr_28.txt|  Folding\n"
" Previous chapter: |usr_26.txt|  Repeating\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:28
#, no-wrap
msgid "*27.1*\tIgnoring case\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:33
#, no-wrap
msgid ""
"By default, Vim's searches are case sensitive.  Therefore, \"include\",\n"
"\"INCLUDE\", and \"Include\" are three different words and a search will match\n"
"only one of them.\n"
"   Now switch on the 'ignorecase' option: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:40
#, no-wrap
msgid ""
"Search for \"include\" again, and now it will match \"Include\", \"INCLUDE\" and\n"
"\"InClUDe\".  (Set the 'hlsearch' option to quickly see where a pattern\n"
"matches.)\n"
"   You can switch this off again with: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:45
msgid ""
"But let's keep it set, and search for \"INCLUDE\".  It will match exactly "
"the same text as \"include\" did.  Now set the 'smartcase' option: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:47
#, no-wrap
msgid "\t:set ignorecase smartcase\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:53
#, no-wrap
msgid ""
"If you have a pattern with at least one uppercase character, the search\n"
"becomes case sensitive.  The idea is that you didn't have to type that\n"
"uppercase character, so you must have done it because you wanted case to\n"
"match.  That's smart!\n"
"    With these two options set you find the following matches:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:59
#, no-wrap
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\tword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\tWord\t\t\tWord\n"
"\tWORD\t\t\tWORD\n"
"\tWoRd\t\t\tWoRd\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:62
msgid "CASE IN ONE PATTERN"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:67
msgid ""
"If you want to ignore case for one specific pattern, you can do this by "
"prepending the \"\\c\" string.  Using \"\\C\" will make the pattern to match "
"case.  This overrules the 'ignorecase' and 'smartcase' options, when \"\\c\" "
"or \"\\C\" is used their value doesn't matter."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:73
#, no-wrap
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\t\\Cword\t\t\tword\n"
"\t\\CWord\t\t\tWord\n"
"\t\\cword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\t\\cWord\t\t\tword, Word, WORD, WoRd, etc.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:77
msgid ""
"A big advantage of using \"\\c\" and \"\\C\" is that it sticks with the "
"pattern.  Thus if you repeat a pattern from the search history, the same "
"will happen, no matter if 'ignorecase' or 'smartcase' was changed."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:83
#, no-wrap
msgid ""
"\tNote:\n"
"\tThe use of \"\\\" items in search patterns depends on the 'magic' option.\n"
"\tIn this chapter we will assume 'magic' is on, because that is the\n"
"\tstandard and recommended setting.  If you would change 'magic', many\n"
"\tsearch patterns would suddenly become invalid.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:87
#, no-wrap
msgid ""
"\tNote:\n"
"\tIf your search takes much longer than you expected, you can interrupt\n"
"\tit with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:90
#, no-wrap
msgid "*27.2*\tWrapping around the file end\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:98
#, no-wrap
msgid ""
"By default, a forward search starts searching for the given string at the\n"
"current cursor location.  It then proceeds to the end of the file.  If it has\n"
"not found the string by that time, it starts from the beginning and searches\n"
"from the start of the file to the cursor location.\n"
"   Keep in mind that when repeating the \"n\" command to search for the next\n"
"match, you eventually get back to the first match.  If you don't notice this\n"
"you keep searching forever!  To give you a hint, Vim displays this message:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:100
#, no-wrap
msgid "\tsearch hit BOTTOM, continuing at TOP ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:103
msgid ""
"If you use the \"?\" command, to search in the other direction, you get this "
"message:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:105
#, no-wrap
msgid "\tsearch hit TOP, continuing at BOTTOM ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:108
msgid ""
"Still, you don't know when you are back at the first match.  One way to see "
"this is by switching on the 'ruler' option: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:113
msgid ""
"Vim will display the cursor position in the lower righthand corner of the "
"window (in the status line if there is one).  It looks like this:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:115
#, no-wrap
msgid "\t101,29       84% ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:118
msgid ""
"The first number is the line number of the cursor.  Remember the line number "
"where you started, so that you can check if you passed this position again."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:121
msgid "NOT WRAPPING"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:123
msgid "To turn off search wrapping, use the following command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:125
#, no-wrap
msgid "\t:set nowrapscan\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:127
msgid ""
"Now when the search hits the end of the file, an error message displays:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:129
#, no-wrap
msgid "\tE385: search hit BOTTOM without match for: forever ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:133
#, no-wrap
msgid ""
"Thus you can find all matches by going to the start of the file with \"gg\" and\n"
"keep searching until you see this message.\n"
"   If you search in the other direction, using \"?\", you get:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:135
#, no-wrap
msgid "\tE384: search hit TOP without match for: forever ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:138
#, no-wrap
msgid "*27.3*\tOffsets\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:143
msgid ""
"By default, the search command leaves the cursor positioned on the beginning "
"of the pattern.  You can tell Vim to leave it some other place by specifying "
"an offset.  For the forward search command \"/\", the offset is specified by "
"appending a slash (/) and the offset: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:145
#, no-wrap
msgid "\t/default/2\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:150
msgid ""
"This command searches for the pattern \"default\" and then moves to the "
"beginning of the second line past the pattern.  Using this command on the "
"paragraph above, Vim finds the word \"default\" in the first line.  Then the "
"cursor is moved two lines down and lands on \"an offset\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:155
msgid ""
"If the offset is a simple number, the cursor will be placed at the beginning "
"of the line that many lines from the match.  The offset number can be "
"positive or negative.  If it is positive, the cursor moves down that many "
"lines; if negative, it moves up."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:158
msgid "CHARACTER OFFSETS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:161
msgid ""
"The \"e\" offset indicates an offset from the end of the match.  It moves "
"the cursor onto the last character of the match.  The command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:163
#, no-wrap
msgid "\t/const/e\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:167
#, no-wrap
msgid ""
"puts the cursor on the \"t\" of \"const\".\n"
"   From that position, adding a number moves forward that many characters.\n"
"This command moves to the character just after the match: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:169
#, no-wrap
msgid "\t/const/e+1\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:172
msgid ""
"A positive number moves the cursor to the right, a negative number moves it "
"to the left.  For example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:174
#, no-wrap
msgid "\t/const/e-1\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:176
msgid "moves the cursor to the \"s\" of \"const\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:181
msgid ""
"If the offset begins with \"b\", the cursor moves to the beginning of the "
"pattern.  That's not very useful, since leaving out the \"b\" does the same "
"thing.  It does get useful when a number is added or subtracted.  The cursor "
"then goes forward or backward that many characters.  For example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:183
#, no-wrap
msgid "\t/const/b+2\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:186
msgid ""
"Moves the cursor to the beginning of the match and then two characters to "
"the right.  Thus it lands on the \"n\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:189
msgid "REPEATING"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:192
msgid ""
"To repeat searching for the previously used search pattern, but with a "
"different offset, leave out the pattern: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:195
#, no-wrap
msgid ""
"\t/that\n"
"\t//e\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:197
msgid "Is equal to: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:199
#, no-wrap
msgid "\t/that/e\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:201
msgid "To repeat with the same offset: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:203
#, no-wrap
msgid "\t/\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:205
msgid ""
"\"n\" does the same thing.  To repeat while removing a previously used "
"offset: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:207
#, no-wrap
msgid "\t//\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:210
msgid "SEARCHING BACKWARDS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:213
msgid ""
"The \"?\" command uses offsets in the same way, but you must use \"?\" to "
"separate the offset from the pattern, instead of \"/\": >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:215
#, no-wrap
msgid "\t?const?e-2\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:218
msgid ""
"The \"b\" and \"e\" keep their meaning, they don't change direction with the "
"use of \"?\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:221
msgid "START POSITION"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:224
msgid ""
"When starting a search, it normally starts at the cursor position.  When you "
"specify a line offset, this can cause trouble.  For example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:226
#, no-wrap
msgid "\t/const/-2\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:234
#, no-wrap
msgid ""
"This finds the next word \"const\" and then moves two lines up.  If you\n"
"use \"n\" to search again, Vim could start at the current position and find the same\n"
"\"const\" match.  Then using the offset again, you would be back where you started.\n"
"You would be stuck!\n"
"   It could be worse: Suppose there is another match with \"const\" in the next\n"
"line.  Then repeating the forward search would find this match and move two\n"
"lines up.  Thus you would actually move the cursor back!\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:238
msgid ""
"When you specify a character offset, Vim will compensate for this.  Thus the "
"search starts a few characters forward or backward, so that the same match "
"isn't found again."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:241
#, no-wrap
msgid "*27.4*\tMatching multiple times\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:244
msgid ""
"The \"*\" item specifies that the item before it can match any number of "
"times.  Thus: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:246
#, no-wrap
msgid "\t/a*\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:253
#, no-wrap
msgid ""
"matches \"a\", \"aa\", \"aaa\", etc.  But also \"\" (the empty string), because zero\n"
"times is included.\n"
"   The \"*\" only applies to the item directly before it.  Thus \"ab*\" matches\n"
"\"a\", \"ab\", \"abb\", \"abbb\", etc.  To match a whole string multiple times, it\n"
"must be grouped into one item.  This is done by putting \"\\(\" before it and\n"
"\"\\)\" after it.  Thus this command: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:255
#, no-wrap
msgid "\t/\\(ab\\)*\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:257
msgid "Matches: \"ab\", \"abab\", \"ababab\", etc.  And also \"\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:260
msgid ""
"To avoid matching the empty string, use \"\\+\".  This makes the previous "
"item match one or more times. >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:262
#, no-wrap
msgid "\t/ab\\+\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:264
msgid ""
"Matches \"ab\", \"abb\", \"abbb\", etc.  It does not match \"a\" when no \"b"
"\" follows."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:266
msgid "To match an optional item, use \"\\=\".  Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:268
#, no-wrap
msgid "\t/folders\\=\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:270
msgid "Matches \"folder\" and \"folders\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:273
msgid "SPECIFIC COUNTS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:277
msgid ""
"To match a specific number of items use the form \"\\{n,m}\".  \"n\" and \"m"
"\" are numbers.  The item before it will be matched \"n\" to \"m\" times |"
"inclusive|.  Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:279
#, no-wrap
msgid "\t/ab\\{3,5}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:284
#, no-wrap
msgid ""
"matches \"abbb\", \"abbbb\" and \"abbbbb\".\n"
"  When \"n\" is omitted, it defaults to zero.  When \"m\" is omitted it defaults\n"
"to infinity.  When \",m\" is omitted, it matches exactly \"n\" times.\n"
"Examples:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:292
#, no-wrap
msgid ""
"\tpattern\t\tmatch count ~\n"
"\t\\{,4}\t\t0, 1, 2, 3 or 4\n"
"\t\\{3,}\t\t3, 4, 5, etc.\n"
"\t\\{0,1}\t\t0 or 1, same as \\=\n"
"\t\\{0,}\t\t0 or more, same as *\n"
"\t\\{1,}\t\t1 or more, same as \\+\n"
"\t\\{3}\t\t3\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:295
msgid "MATCHING AS LITTLE AS POSSIBLE"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:300
#, no-wrap
msgid ""
"The items so far match as many characters as they can find.  To match as few\n"
"as possible, use \"\\{-n,m}\".  It works the same as \"\\{n,m}\", except that the\n"
"minimal amount possible is used.\n"
"   For example, use: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:302
#, no-wrap
msgid "\t/ab\\{-1,3}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:310
#, no-wrap
msgid ""
"Will match \"ab\" in \"abbb\".  Actually, it will never match more than one b,\n"
"because there is no reason to match more.  It requires something else to force\n"
"it to match more than the lower limit.\n"
"   The same rules apply to removing \"n\" and \"m\".  It's even possible to remove\n"
"both of the numbers, resulting in \"\\{-}\".  This matches the item before it\n"
"zero or more times, as few as possible.  The item by itself always matches\n"
"zero times.  It is useful when combined with something else.  Example: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:312
#, no-wrap
msgid "\t/a.\\{-}b\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:314
msgid "This matches \"axb\" in \"axbxb\".  If this pattern would be used: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:316
#, no-wrap
msgid "\t/a.*b\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:319
msgid ""
"It would try to match as many characters as possible with \".*\", thus it "
"matches \"axbxb\" as a whole."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:322
#, no-wrap
msgid "*27.5*\tAlternatives\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:324
msgid "The \"or\" operator in a pattern is \"\\|\".  Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:326
#, no-wrap
msgid "\t/foo\\|bar\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:328
msgid ""
"This matches \"foo\" or \"bar\".  More alternatives can be concatenated: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:330
#, no-wrap
msgid "\t/one\\|two\\|three\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:333
#, no-wrap
msgid ""
"Matches \"one\", \"two\" and \"three\".\n"
"   To match multiple times, the whole thing must be placed in \"\\(\" and \"\\)\": >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:335
#, no-wrap
msgid "\t/\\(foo\\|bar\\)\\+\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:338
#, no-wrap
msgid ""
"This matches \"foo\", \"foobar\", \"foofoo\", \"barfoobar\", etc.\n"
"   Another example: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:340
#, no-wrap
msgid "\t/end\\(if\\|while\\|for\\)\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:342
msgid "This matches \"endif\", \"endwhile\" and \"endfor\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:345
msgid ""
"A related item is \"\\&\".  This requires that both alternatives match in "
"the same place.  The resulting match uses the last alternative.  Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:347
#, no-wrap
msgid "\t/forever\\&...\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:349
msgid ""
"This matches \"for\" in \"forever\".  It will not match \"fortuin\", for "
"example."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:352
#, no-wrap
msgid "*27.6*\tCharacter ranges\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:355
msgid ""
"To match \"a\", \"b\" or \"c\" you could use \"/a\\|b\\|c\".  When you want "
"to match all letters from \"a\" to \"z\" this gets very long.  There is a "
"shorter method: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:357
#, no-wrap
msgid "\t/[a-z]\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:360
msgid ""
"The [] construct matches a single character.  Inside you specify which "
"characters to match.  You can include a list of characters, like this: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:362
#, no-wrap
msgid "\t/[0123456789abcdef]\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:366
msgid ""
"This will match any of the characters included.  For consecutive characters "
"you can specify the range.  \"0-3\" stands for \"0123\".  \"w-z\" stands for "
"\"wxyz\".  Thus the same command as above can be shortened to: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:368
#, no-wrap
msgid "\t/[0-9a-f]\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:372
msgid ""
"To match the \"-\" character itself make it the first or last one in the "
"range.  These special characters are accepted to make it easier to use them "
"inside a [] range (they can actually be used anywhere in the search pattern):"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:377
#, no-wrap
msgid ""
"\t\\e\t<Esc>\n"
"\t\\t\t<Tab>\n"
"\t\\r\t<CR>\n"
"\t\\b\t<BS>\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:380
msgid ""
"There are a few more special cases for [] ranges, see |/[]| for the whole "
"story."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:383
msgid "COMPLEMENTED RANGE"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:386
msgid ""
"To avoid matching a specific character, use \"^\" at the start of the "
"range.  The [] item then matches everything but the characters included.  "
"Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:393
#, no-wrap
msgid ""
"\t/\"[^\"]*\"\n"
"<\n"
"\t \"\t  a double quote\n"
"\t  [^\"]\t  any character that is not a double quote\n"
"\t      *\t  as many as possible\n"
"\t       \"  a double quote again\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:395
msgid "This matches \"foo\" and \"3!x\", including the double quotes."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:398
msgid "PREDEFINED RANGES"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:401
msgid ""
"A number of ranges are used very often.  Vim provides a shortcut for these.  "
"For example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:403
#, no-wrap
msgid "\t/\\a\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:406
msgid ""
"Finds alphabetic characters.  This is equal to using \"/[a-zA-Z]\".  Here "
"are a few more of these:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:418
#, no-wrap
msgid ""
"\titem\tmatches\t\t\tequivalent ~\n"
"\t\\d\tdigit\t\t\t[0-9]\n"
"\t\\D\tnon-digit\t\t[^0-9]\n"
"\t\\x\thex digit\t\t[0-9a-fA-F]\n"
"\t\\X\tnon-hex digit\t\t[^0-9a-fA-F]\n"
"\t\\s\twhite space\t\t[ \t]     (<Tab> and <Space>)\n"
"\t\\S\tnon-white characters\t[^ \t]     (not <Tab> and <Space>)\n"
"\t\\l\tlowercase alpha\t\t[a-z]\n"
"\t\\L\tnon-lowercase alpha\t[^a-z]\n"
"\t\\u\tuppercase alpha\t\t[A-Z]\n"
"\t\\U\tnon-uppercase alpha\t[^A-Z]\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:424
#, no-wrap
msgid ""
"\tNote:\n"
"\tUsing these predefined ranges works a lot faster than the character\n"
"\trange it stands for.\n"
"\tThese items can not be used inside [].  Thus \"[\\d\\l]\" does NOT work to\n"
"\tmatch a digit or lowercase alpha.  Use \"\\(\\d\\|\\l\\)\" instead.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:426
msgid "See |/\\s| for the whole list of these ranges."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:429
#, no-wrap
msgid "*27.7*\tCharacter classes\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:434
#, no-wrap
msgid ""
"The character range matches a fixed set of characters.  A character class is\n"
"similar, but with an essential difference: The set of characters can be\n"
"redefined without changing the search pattern.\n"
"   For example, search for this pattern: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:436
#, no-wrap
msgid "\t/\\f\\+\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:442
#, no-wrap
msgid ""
"The \"\\f\" items stands for file name characters.  Thus this matches a sequence\n"
"of characters that can be a file name.\n"
"   Which characters can be part of a file name depends on the system you are\n"
"using.  On MS-Windows, the backslash is included, on Unix it is not.  This is\n"
"specified with the 'isfname' option.  The default value for Unix is: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:445
#, no-wrap
msgid ""
"\t:set isfname\n"
"\tisfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:449
msgid ""
"For other systems the default value is different.  Thus you can make a "
"search pattern with \"\\f\" to match a file name, and it will automatically "
"adjust to the system you are using it on."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:456
#, no-wrap
msgid ""
"\tNote:\n"
"\tActually, Unix allows using just about any character in a file name,\n"
"\tincluding white space.  Including these characters in 'isfname' would\n"
"\tbe theoretically correct.  But it would make it impossible to find the\n"
"\tend of a file name in text.  Thus the default value of 'isfname' is a\n"
"\tcompromise.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:458
msgid "The character classes are:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:468
#, no-wrap
msgid ""
"\titem\tmatches\t\t\t\toption ~\n"
"\t\\i\tidentifier characters\t\t'isident'\n"
"\t\\I\tlike \\i, excluding digits\n"
"\t\\k\tkeyword characters\t\t'iskeyword'\n"
"\t\\K\tlike \\k, excluding digits\n"
"\t\\p\tprintable characters\t\t'isprint'\n"
"\t\\P\tlike \\p, excluding digits\n"
"\t\\f\tfile name characters\t\t'isfname'\n"
"\t\\F\tlike \\f, excluding digits\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:471
#, no-wrap
msgid "*27.8*\tMatching a line break\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:476
#, no-wrap
msgid ""
"Vim can find a pattern that includes a line break.  You need to specify where\n"
"the line break happens, because all items mentioned so far don't match a line\n"
"break.\n"
"   To check for a line break in a specific place, use the \"\\n\" item: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:478
#, no-wrap
msgid "\t/the\\nword\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:482
msgid ""
"This will match at a line that ends in \"the\" and the next line starts with "
"\"word\".  To match \"the word\" as well, you need to match a space or a "
"line break.  The item to use for it is \"\\_s\": >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:484
#, no-wrap
msgid "\t/the\\_sword\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:486
msgid "To allow any amount of white space: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:488
#, no-wrap
msgid "\t/the\\_s\\+word\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:491
#, no-wrap
msgid ""
"This also matches when \"the  \" is at the end of a line and \"   word\" at the\n"
"start of the next one.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:496
msgid ""
"\"\\s\" matches white space, \"\\_s\" matches white space or a line break.  "
"Similarly, \"\\a\" matches an alphabetic character, and \"\\_a\" matches an "
"alphabetic character or a line break.  The other character classes and "
"ranges can be modified in the same way by inserting a \"_\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:499
msgid ""
"Many other items can be made to match a line break by prepending \"\\_\".  "
"For example: \"\\_.\" matches any character or a line break."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:503
#, no-wrap
msgid ""
"\tNote:\n"
"\t\"\\_.*\" matches everything until the end of the file.  Be careful with\n"
"\tthis, it can make a search command very slow.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:505
msgid ""
"Another example is \"\\_[]\", a character range that includes a line break: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:507
#, no-wrap
msgid "\t/\"\\_[^\"]*\"\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:509
msgid ""
"This finds a text in double quotes that may be split up in several lines."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:512
#, no-wrap
msgid "*27.9*\tExamples\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:515
msgid ""
"Here are a few search patterns you might find useful.  This shows how the "
"items mentioned above can be combined."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:518
msgid "FINDING A CALIFORNIA LICENSE PLATE"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:521
msgid ""
"A sample license plate number is \"1MGU103\".  It has one digit, three "
"uppercase letters and three digits.  Directly putting this into a search "
"pattern: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:523
#, no-wrap
msgid "\t/\\d\\u\\u\\u\\d\\d\\d\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:526
msgid ""
"Another way is to specify that there are three digits and letters with a "
"count: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:528
#, no-wrap
msgid "\t/\\d\\u\\{3}\\d\\{3}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:530
msgid "Using [] ranges instead: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:532
#, no-wrap
msgid "\t/[0-9][A-Z]\\{3}[0-9]\\{3}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:537
msgid ""
"Which one of these you should use? Whichever one you can remember.  The "
"simple way you can remember is much faster than the fancy way that you "
"can't.  If you can remember them all, then avoid the last one, because it's "
"both more typing and slower to execute."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:540
msgid "FINDING AN IDENTIFIER"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:544
msgid ""
"In C programs (and many other computer languages) an identifier starts with "
"a letter and further consists of letters and digits.  Underscores can be "
"used too.  This can be found with: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:546
#, no-wrap
msgid "\t/\\<\\h\\w*\\>\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:549
msgid ""
"\"\\<\" and \"\\>\" are used to find only whole words.  \"\\h\" stands for "
"\"[A-Za-z_]\" and \"\\w\" for \"[0-9A-Za-z_]\"."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:553
#, no-wrap
msgid ""
"\tNote:\n"
"\t\"\\<\" and \"\\>\" depend on the 'iskeyword' option.  If it includes \"-\",\n"
"\tfor example, then \"ident-\" is not matched.  In this situation use: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:558
#, no-wrap
msgid ""
"\t\t/\\w\\@<!\\h\\w*\\w\\@!\n"
"<\n"
"\tThis checks if \"\\w\" does not match before or after the identifier.\n"
"\tSee |/\\@<!| and |/\\@!|.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:562
msgid "Next chapter: |usr_28.txt| Folding"
msgstr ""
