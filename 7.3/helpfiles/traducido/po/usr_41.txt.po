# Spanish translations for Vim package
# Copyright (C) 2010 Free Software Foundation, Inc.
# This file is distributed under the same license as the Vim package.
# Automatically generated, 2010.
# Omar Campagne <ocampagne@gmail.com>, 2011.
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.3\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2010-12-09 16:51+0100\n"
"PO-Revision-Date: 2011-03-26 19:12-0500\n"
"Last-Translator: Javier Rojas <jerojasro@devnull.li>\n"
"Language-Team: vim-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Virtaal 0.7.0-beta4\n"
"X-Project-Style: default\n"

#. type: Plain text
#: original/txt/intro.txt:18 original/txt/intro.txt:79
#: original/txt/intro.txt:180 original/txt/intro.txt:290
#: original/txt/intro.txt:518 original/txt/intro.txt:596
#: original/txt/intro.txt:689 original/txt/intro.txt:817
#: original/txt/intro.txt:880 original/txt/usr_toc.txt:7
#: original/txt/usr_toc.txt:58 original/txt/usr_toc.txt:172
#: original/txt/usr_toc.txt:281 original/txt/usr_toc.txt:340
#: original/txt/usr_toc.txt:352 original/txt/usr_01.txt:19
#: original/txt/usr_01.txt:50 original/txt/usr_01.txt:100
#: original/txt/usr_01.txt:181 original/txt/usr_02.txt:25
#: original/txt/usr_02.txt:69 original/txt/usr_02.txt:130
#: original/txt/usr_02.txt:179 original/txt/usr_02.txt:239
#: original/txt/usr_02.txt:307 original/txt/usr_02.txt:369
#: original/txt/usr_02.txt:406 original/txt/usr_02.txt:560
#: original/txt/usr_03.txt:28 original/txt/usr_03.txt:74
#: original/txt/usr_03.txt:101 original/txt/usr_03.txt:147
#: original/txt/usr_03.txt:172 original/txt/usr_03.txt:223
#: original/txt/usr_03.txt:265 original/txt/usr_03.txt:320
#: original/txt/usr_03.txt:491 original/txt/usr_03.txt:552
#: original/txt/usr_03.txt:650 original/txt/usr_04.txt:27
#: original/txt/usr_04.txt:74 original/txt/usr_04.txt:160
#: original/txt/usr_04.txt:194 original/txt/usr_04.txt:269
#: original/txt/usr_04.txt:324 original/txt/usr_04.txt:360
#: original/txt/usr_04.txt:390 original/txt/usr_04.txt:446
#: original/txt/usr_04.txt:469 original/txt/usr_04.txt:510
#: original/txt/usr_05.txt:24 original/txt/usr_05.txt:63
#: original/txt/usr_05.txt:219 original/txt/usr_05.txt:266
#: original/txt/usr_05.txt:418 original/txt/usr_05.txt:467
#: original/txt/usr_05.txt:506 original/txt/usr_05.txt:621
#: original/txt/usr_06.txt:24 original/txt/usr_06.txt:50
#: original/txt/usr_06.txt:135 original/txt/usr_06.txt:189
#: original/txt/usr_06.txt:270 original/txt/usr_06.txt:276
#: original/txt/usr_07.txt:24 original/txt/usr_07.txt:63
#: original/txt/usr_07.txt:179 original/txt/usr_07.txt:266
#: original/txt/usr_07.txt:316 original/txt/usr_07.txt:404
#: original/txt/usr_07.txt:444 original/txt/usr_07.txt:475
#: original/txt/usr_08.txt:26 original/txt/usr_08.txt:82
#: original/txt/usr_08.txt:109 original/txt/usr_08.txt:161
#: original/txt/usr_08.txt:215 original/txt/usr_08.txt:278
#: original/txt/usr_08.txt:337 original/txt/usr_08.txt:477
#: original/txt/usr_08.txt:509 original/txt/usr_08.txt:597
#: original/txt/usr_09.txt:21 original/txt/usr_09.txt:124
#: original/txt/usr_09.txt:175 original/txt/usr_09.txt:259
#: original/txt/usr_09.txt:285 original/txt/usr_10.txt:27
#: original/txt/usr_10.txt:144 original/txt/usr_10.txt:221
#: original/txt/usr_10.txt:342 original/txt/usr_10.txt:378
#: original/txt/usr_10.txt:547 original/txt/usr_10.txt:621
#: original/txt/usr_10.txt:667 original/txt/usr_10.txt:692
#: original/txt/usr_10.txt:820 original/txt/usr_11.txt:22
#: original/txt/usr_11.txt:82 original/txt/usr_11.txt:144
#: original/txt/usr_11.txt:288 original/txt/usr_11.txt:303
#: original/txt/usr_12.txt:25 original/txt/usr_12.txt:90
#: original/txt/usr_12.txt:131 original/txt/usr_12.txt:177
#: original/txt/usr_12.txt:202 original/txt/usr_12.txt:231
#: original/txt/usr_12.txt:281 original/txt/usr_12.txt:309
#: original/txt/usr_12.txt:354 original/txt/usr_20.txt:22
#: original/txt/usr_20.txt:113 original/txt/usr_20.txt:158
#: original/txt/usr_20.txt:285 original/txt/usr_20.txt:327
#: original/txt/usr_20.txt:380 original/txt/usr_21.txt:24
#: original/txt/usr_21.txt:47 original/txt/usr_21.txt:87
#: original/txt/usr_21.txt:236 original/txt/usr_21.txt:385
#: original/txt/usr_21.txt:438 original/txt/usr_21.txt:495
#: original/txt/usr_22.txt:22 original/txt/usr_22.txt:148
#: original/txt/usr_22.txt:213 original/txt/usr_22.txt:272
#: original/txt/usr_22.txt:396 original/txt/usr_23.txt:23
#: original/txt/usr_23.txt:114 original/txt/usr_23.txt:156
#: original/txt/usr_23.txt:238 original/txt/usr_23.txt:324
#: original/txt/usr_23.txt:339 original/txt/usr_24.txt:28
#: original/txt/usr_24.txt:96 original/txt/usr_24.txt:119
#: original/txt/usr_24.txt:268 original/txt/usr_24.txt:305
#: original/txt/usr_24.txt:336 original/txt/usr_24.txt:369
#: original/txt/usr_24.txt:493 original/txt/usr_24.txt:537
#: original/txt/usr_24.txt:583 original/txt/usr_24.txt:602
#: original/txt/usr_25.txt:22 original/txt/usr_25.txt:132
#: original/txt/usr_25.txt:210 original/txt/usr_25.txt:287
#: original/txt/usr_25.txt:453 original/txt/usr_25.txt:574
#: original/txt/usr_26.txt:21 original/txt/usr_26.txt:46
#: original/txt/usr_26.txt:103 original/txt/usr_26.txt:136
#: original/txt/usr_26.txt:217 original/txt/usr_27.txt:26
#: original/txt/usr_27.txt:88 original/txt/usr_27.txt:136
#: original/txt/usr_27.txt:239 original/txt/usr_27.txt:320
#: original/txt/usr_27.txt:350 original/txt/usr_27.txt:427
#: original/txt/usr_27.txt:469 original/txt/usr_27.txt:510
#: original/txt/usr_27.txt:559 original/txt/usr_28.txt:27
#: original/txt/usr_28.txt:54 original/txt/usr_28.txt:121
#: original/txt/usr_28.txt:185 original/txt/usr_28.txt:211
#: original/txt/usr_28.txt:269 original/txt/usr_28.txt:315
#: original/txt/usr_28.txt:331 original/txt/usr_28.txt:375
#: original/txt/usr_28.txt:389 original/txt/usr_28.txt:422
#: original/txt/usr_29.txt:23 original/txt/usr_29.txt:273
#: original/txt/usr_29.txt:320 original/txt/usr_29.txt:441
#: original/txt/usr_29.txt:570 original/txt/usr_29.txt:609
#: original/txt/usr_30.txt:23 original/txt/usr_30.txt:202
#: original/txt/usr_30.txt:280 original/txt/usr_30.txt:336
#: original/txt/usr_30.txt:409 original/txt/usr_30.txt:515
#: original/txt/usr_30.txt:639 original/txt/usr_31.txt:22
#: original/txt/usr_31.txt:81 original/txt/usr_31.txt:133
#: original/txt/usr_31.txt:160 original/txt/usr_31.txt:208
#: original/txt/usr_31.txt:268 original/txt/usr_32.txt:21
#: original/txt/usr_32.txt:44 original/txt/usr_32.txt:92
#: original/txt/usr_32.txt:140 original/txt/usr_32.txt:176
#: original/txt/usr_40.txt:20 original/txt/usr_40.txt:279
#: original/txt/usr_40.txt:424 original/txt/usr_40.txt:653
#: original/txt/usr_41.txt:33 original/txt/usr_41.txt:133
#: original/txt/usr_41.txt:267 original/txt/usr_41.txt:345
#: original/txt/usr_41.txt:482 original/txt/usr_41.txt:532
#: original/txt/usr_41.txt:877 original/txt/usr_41.txt:1104
#: original/txt/usr_41.txt:1390 original/txt/usr_41.txt:1447
#: original/txt/usr_41.txt:1617 original/txt/usr_41.txt:2038
#: original/txt/usr_41.txt:2224 original/txt/usr_41.txt:2270
#: original/txt/usr_41.txt:2346 original/txt/usr_41.txt:2410
#: original/txt/usr_41.txt:2425 original/txt/usr_42.txt:21
#: original/txt/usr_42.txt:140 original/txt/usr_42.txt:254
#: original/txt/usr_42.txt:293 original/txt/usr_42.txt:361
#: original/txt/usr_90.txt:21 original/txt/usr_90.txt:214
#: original/txt/usr_90.txt:288 original/txt/usr_90.txt:341
#: original/txt/usr_90.txt:417 original/txt/usr_90.txt:494
#, no-wrap
msgid "==============================================================================\n"
msgstr "==============================================================================\n"

#. type: Plain text
#: original/txt/usr_toc.txt:4 original/txt/usr_01.txt:4
#: original/txt/usr_02.txt:4 original/txt/usr_03.txt:4
#: original/txt/usr_04.txt:4 original/txt/usr_05.txt:4
#: original/txt/usr_06.txt:4 original/txt/usr_07.txt:4
#: original/txt/usr_08.txt:4 original/txt/usr_09.txt:4
#: original/txt/usr_10.txt:4 original/txt/usr_11.txt:4
#: original/txt/usr_12.txt:4 original/txt/usr_20.txt:4
#: original/txt/usr_21.txt:4 original/txt/usr_22.txt:4
#: original/txt/usr_23.txt:4 original/txt/usr_24.txt:4
#: original/txt/usr_25.txt:4 original/txt/usr_26.txt:4
#: original/txt/usr_27.txt:4 original/txt/usr_28.txt:4
#: original/txt/usr_29.txt:4 original/txt/usr_30.txt:4
#: original/txt/usr_31.txt:4 original/txt/usr_32.txt:4
#: original/txt/usr_40.txt:4 original/txt/usr_41.txt:4
#: original/txt/usr_42.txt:4 original/txt/usr_90.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar\n"

#. type: Plain text
#: original/txt/usr_toc.txt:354 original/txt/usr_01.txt:185
#: original/txt/usr_02.txt:564 original/txt/usr_03.txt:654
#: original/txt/usr_04.txt:514 original/txt/usr_05.txt:625
#: original/txt/usr_06.txt:280 original/txt/usr_07.txt:479
#: original/txt/usr_08.txt:601 original/txt/usr_09.txt:289
#: original/txt/usr_10.txt:824 original/txt/usr_11.txt:307
#: original/txt/usr_12.txt:358 original/txt/usr_20.txt:384
#: original/txt/usr_21.txt:499 original/txt/usr_22.txt:400
#: original/txt/usr_23.txt:343 original/txt/usr_24.txt:606
#: original/txt/usr_25.txt:578 original/txt/usr_26.txt:221
#: original/txt/usr_27.txt:563 original/txt/usr_28.txt:426
#: original/txt/usr_29.txt:613 original/txt/usr_30.txt:643
#: original/txt/usr_31.txt:272 original/txt/usr_32.txt:180
#: original/txt/usr_40.txt:657 original/txt/usr_41.txt:2429
#: original/txt/usr_42.txt:365 original/txt/usr_90.txt:498
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: consulte |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"

#. type: Plain text
#: original/txt/usr_08.txt:153 original/txt/usr_24.txt:168
#: original/txt/usr_41.txt:2085
msgid "OPTIONS"
msgstr "OPCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:2
#, no-wrap
msgid "*usr_41.txt*\tFor Vim version 7.3.  Last change: 2010 Jul 20\n"
msgstr "*usr_41.esx*\tPara Vim versión 7.3.  Último cambio: 20/7/2010\n"

#. type: Plain text
#: original/txt/usr_41.txt:6
#, no-wrap
msgid "\t\t\t      Write a Vim script\n"
msgstr "\t\t\t     Escribir scripts para Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:11
msgid ""
"The Vim script language is used for the startup vimrc file, syntax files, "
"and many other things.  This chapter explains the items that can be used in "
"a Vim script.  There are a lot of them, thus this is a long chapter."
msgstr ""
"El lenguaje de programación de Vim se usa en el archivo de arranque vimrc, "
"los archivos de sintaxis, y muchas otras cosas. Este capítulo presenta y "
"explica en detalle los elementos que componen un script de Vim. Hay muchos "
"de ellos, por lo que éste es un capítulo largo."

#. type: Plain text
#: original/txt/usr_41.txt:28
#, no-wrap
msgid ""
"|41.1|\tIntroduction\n"
"|41.2|\tVariables\n"
"|41.3|\tExpressions\n"
"|41.4|\tConditionals\n"
"|41.5|\tExecuting an expression\n"
"|41.6|\tUsing functions\n"
"|41.7|\tDefining a function\n"
"|41.8|\tLists and Dictionaries\n"
"|41.9|\tExceptions\n"
"|41.10|\tVarious remarks\n"
"|41.11|\tWriting a plugin\n"
"|41.12|\tWriting a filetype plugin\n"
"|41.13|\tWriting a compiler plugin\n"
"|41.14|\tWriting a plugin that loads quickly\n"
"|41.15|\tWriting library scripts\n"
"|41.16|\tDistributing Vim scripts\n"
msgstr ""
"|41.1|\tIntroducción\n"
"|41.2|\tVariables\n"
"|41.3|\tExpresiones\n"
"|41.4|\tEstructuras de decisión\n"
"|41.5|\tEjecución de expresiones\n"
"|41.6|\tFunciones\n"
"|41.7|\tDefinición de funciones\n"
"|41.8|\tListas y Diccionarios\n"
"|41.9|\tExcepciones\n"
"|41.10|\tObservaciones\n"
"|41.11|\tEscribir extensiones\n"
"|41.12|\tEscribir extensiones para tipo de archivo\n"
"|41.13|\tEscribir extensiones para compiladores\n"
"|41.14|\tEscribir extensiones que carguen rápidamente\n"
"|41.15|\tEscribir bibliotecas\n"
"|41.16|\tDistribuir scripts de Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:32
#, no-wrap
msgid ""
"     Next chapter: |usr_42.txt|  Add new menus\n"
" Previous chapter: |usr_40.txt|  Make new commands\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""
" Capítulo siguiente: |usr_42.esx|  Añadir menús nuevos\n"
"  Capítulo anterior: |usr_40.esx|  Crear órdenes nuevas\n"
"Tabla de contenidos: |usr_toc.esx|\n"

#. type: Plain text
#: original/txt/usr_41.txt:35
#, no-wrap
msgid "*41.1*\tIntroduction\t\t\t\t*vim-script-intro* *script*\n"
msgstr "*41.1*\tIntroducción\t\t\t\t*vim-script-intro* *script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:43
#, no-wrap
msgid ""
"Your first experience with Vim scripts is the vimrc file.  Vim reads it when\n"
"it starts up and executes the commands.  You can set options to values you\n"
"prefer.  And you can use any colon command in it (commands that start with a\n"
"\":\"; these are sometimes referred to as Ex commands or command-line commands).\n"
"   Syntax files are also Vim scripts.  As are files that set options for a\n"
"specific file type.  A complicated macro can be defined by a separate Vim\n"
"script file.  You can think of other uses yourself.\n"
msgstr ""
"Su primer acercamiento a los scripts de Vim es el archivo vimrc. Vim lo lee en\n"
"el arranque y ejecuta las órdenes que se encuentren ahí. En este archivo puede\n"
"dar el valor que prefiera a las opciones existentes, así como usar\n"
"cualquier orden (algunas veces se hace referencia a las órdenes que empiezan\n"
"con «:» como órdenes Ex, o simplemente órdenes).\n"
"   Los archivos de sintaxis también son scripts de Vim, porque son archivos en\n"
"los que se configuran opciones para un tipo de archivo particular. Es posible\n"
"definir una macro complicada en un archivo Vim separado. También puede\n"
"idear otros usos.\n"

#. type: Plain text
#: original/txt/usr_41.txt:45
msgid "Let's start with a simple example: >"
msgstr "Empecemos con un ejemplo sencillo: >"

#. type: Plain text
#: original/txt/usr_41.txt:60
#, no-wrap
msgid ""
"\t:let i = 1\n"
"\t:while i < 5\n"
"\t:  echo \"count is\" i\n"
"\t:  let i += 1\n"
"\t:endwhile\n"
"<\n"
"\tNote:\n"
"\tThe \":\" characters are not really needed here.  You only need to use\n"
"\tthem when you type a command.  In a Vim script file they can be left\n"
"\tout.  We will use them here anyway to make clear these are colon\n"
"\tcommands and make them stand out from Normal mode commands.\n"
"\tNote:\n"
"\tYou can try out the examples by yanking the lines from the text here\n"
"\tand executing them with :@\"\n"
msgstr ""
"\t:let i = 1\n"
"\t:while i < 5\n"
"\t:  echo \"cuenta es\" i\n"
"\t:  let i += 1\n"
"\t:endwhile\n"
"<\n"
"\tNota:\n"
"\tEn realidad en el ejemplo de arriba los caracteres «:» no son\n"
"\tnecesarios. Sólo es necesario su uso al escribir una orden. En los\n"
"\tarchivos de script de Vim es posible omitirlos. Aquí se muestran para\n"
"\tevidenciar que son órdenes de la línea de órdenes, y no órdenes del\n"
"\tmodo Normal.\n"
"\tNota:\n"
"\tPuede probar los ejemplos que se muestran aquí copiando el texto\n"
"\tcorrespondiente, y ejecutándolo con la orden «:@\"»\n"

#. type: Plain text
#: original/txt/usr_41.txt:62
msgid "The output of the example code is:"
msgstr "La salida generada por el ejemplo tiene el siguiente aspecto:"

#. type: Plain text
#: original/txt/usr_41.txt:67
#, no-wrap
msgid ""
"\tcount is 1 ~\n"
"\tcount is 2 ~\n"
"\tcount is 3 ~\n"
"\tcount is 4 ~\n"
msgstr ""
"\tcuenta es 1 ~\n"
"\tcuenta es 2 ~\n"
"\tcuenta es 3 ~\n"
"\tcuenta es 4 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:70
msgid ""
"In the first line the \":let\" command assigns a value to a variable.  The "
"generic form is: >"
msgstr ""
"En la primera línea la orden «:let» le asigna un valor a una variable. La "
"forma genérica de hacerlo es: >"

#. type: Plain text
#: original/txt/usr_41.txt:72
#, no-wrap
msgid "\t:let {variable} = {expression}\n"
msgstr "\t:let {variable} = {expresión}\n"

#. type: Plain text
#: original/txt/usr_41.txt:76
#, no-wrap
msgid ""
"In this case the variable name is \"i\" and the expression is a simple value,\n"
"the number one.\n"
"   The \":while\" command starts a loop.  The generic form is: >\n"
msgstr ""
"En este caso el nombre de la variable es «i» y la expresión es simplemente un\n"
"valor, el número uno.\n"
"   La orden «:while» inicia un ciclo. La forma genérica de esta orden es: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:80
#, no-wrap
msgid ""
"\t:while {condition}\n"
"\t:  {statements}\n"
"\t:endwhile\n"
msgstr ""
"\t:while {condicion}\n"
"\t:  {instrucciones}\n"
"\t:endwhile\n"

#. type: Plain text
#: original/txt/usr_41.txt:87
#, no-wrap
msgid ""
"The statements until the matching \":endwhile\" are executed for as long as the\n"
"condition is true.  The condition used here is the expression \"i < 5\".  This\n"
"is true when the variable i is smaller than five.\n"
"\tNote:\n"
"\tIf you happen to write a while loop that keeps on running, you can\n"
"\tinterrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).\n"
msgstr ""
"Las instrucciones hasta el «:endwhile» correspondiente se ejecutan mientras\n"
"que la {condicion} se siga cumpliendo. La condición aquí es la expresión\n"
"«i < 5».  Ésta es verdadera cuando la variable i es menor a cinco.\n"
"\tNota:\n"
"\tSi llega a escribir un ciclo «while» que nunca termina de ejecutarse,\n"
"\tpuede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).\n"

#. type: Plain text
#: original/txt/usr_41.txt:90
msgid ""
"The \":echo\" command prints its arguments.  In this case the string \"count "
"is\" and the value of the variable i.  Since i is one, this will print:"
msgstr ""
"La orden «:echo» imprime en pantalla los argumentos que se le introduzcan. "
"En este caso son la cadena «cuenta es» y el valor de la variable i. Como i "
"vale uno, se imprimirá:"

#. type: Plain text
#: original/txt/usr_41.txt:92
#, no-wrap
msgid "\tcount is 1 ~\n"
msgstr "\tcuenta es 1 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:96
msgid ""
"Then there is the \":let i += 1\" command.  This does the same thing as \":"
"let i = i + 1\".  This adds one to the variable i and assigns the new value "
"to the same variable."
msgstr ""
"Luego está la orden «:let i += 1». Ésta tiene el mismo efecto que «:let i = "
"i + 1». Le añade uno a la variable i y asigna el resultado a la misma "
"variable."

#. type: Plain text
#: original/txt/usr_41.txt:99
msgid ""
"The example was given to explain the commands, but would you really want to "
"make such a loop it can be written much more compact: >"
msgstr ""
"El ejemplo se dio para ilustrar las órdenes usadas; si se quisiera un ciclo "
"con la funcionalidad mostrada, se puede escribir algo mucho más compacto: >"

#. type: Plain text
#: original/txt/usr_41.txt:103
#, no-wrap
msgid ""
"\t:for i in range(1, 4)\n"
"\t:  echo \"count is\" i\n"
"\t:endfor\n"
msgstr ""
"\t:for i in range(1, 4)\n"
"\t:  echo \"cuenta es\" i\n"
"\t:endfor\n"

#. type: Plain text
#: original/txt/usr_41.txt:106
msgid ""
"We won't explain how |:for| and |range()| work until later.  Follow the "
"links if you are impatient."
msgstr ""
"El funcionamiento de |:for| y |range()| se explicará después. Siga los "
"enlaces si no desea esperar."

#. type: Plain text
#: original/txt/usr_41.txt:109
msgid "THREE KINDS OF NUMBERS"
msgstr "TRES CLASES DE NÚMEROS"

#. type: Plain text
#: original/txt/usr_41.txt:115
#, no-wrap
msgid ""
"Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts\n"
"with \"0x\" or \"0X\".  For example \"0x1f\" is decimal 31.  An octal number starts\n"
"with a zero.  \"017\" is decimal 15.  Careful: don't put a zero before a decimal\n"
"number, it will be interpreted as an octal number!\n"
"   The \":echo\" command always prints decimal numbers.  Example: >\n"
msgstr ""
"Los números pueden ser decimales, hexadecimales, u octales. Un número\n"
"hexadecimal empieza con «0x» o «0X». Por ejemplo, «0x1f» es 31 en decimal. Un\n"
"número octal empieza con cero. «017» es 15 en decimal. Tenga cuidado: no ponga\n"
"ceros al comienzo de un número decimal, ¡será interpretado como un octal!\n"
"   La orden «:echo» siempre muestra los números como decimales. Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:118
#, no-wrap
msgid ""
"\t:echo 0x7f 036\n"
"<\t127 30 ~\n"
msgstr ""
"\t:echo 0x7f 036\n"
"<\t127 30 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:122
#, no-wrap
msgid ""
"A number is made negative with a minus sign.  This also works for hexadecimal\n"
"and octal numbers.   A minus sign is also used for subtraction.  Compare this\n"
"with the previous example: >\n"
msgstr ""
"Se pueden obtener números negativos añadiéndoles un signo de resta. Esto\n"
"funciona también para números octales y hexadecimales. El signo menos también\n"
"se usa para la substracción. Compare lo siguiente con el ejemplo anterior: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:125
#, no-wrap
msgid ""
"\t:echo 0x7f -036\n"
"<\t97 ~\n"
msgstr ""
"\t:echo 0x7f -036\n"
"<\t97 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:130
msgid ""
"White space in an expression is ignored.  However, it's recommended to use "
"it for separating items, to make the expression easier to read.  For "
"example, to avoid the confusion with a negative number above, put a space "
"between the minus sign and the following number: >"
msgstr ""
"En las expresiones se ignoran los espacios en blanco. Sin embargo, es "
"recomendable usarlo para separar elementos, para hacer que las expresiones "
"sean más legibles. Por ejemplo, para evitar confundir el ejemplo anterior "
"con un número negativo, ponga un espacio entre el signo de resta y el número "
"que lo sigue: >"

#. type: Plain text
#: original/txt/usr_41.txt:132
#, no-wrap
msgid "\t:echo 0x7f - 036\n"
msgstr "\t:echo 0x7f - 036\n"

#. type: Plain text
#: original/txt/usr_41.txt:135
#, no-wrap
msgid "*41.2*\tVariables\n"
msgstr "*41.2*\tVariables\n"

#. type: Plain text
#: original/txt/usr_41.txt:138
msgid ""
"A variable name consists of ASCII letters, digits and the underscore.  It "
"cannot start with a digit.  Valid variable names are:"
msgstr ""
"Los nombres de variables pueden consistir de las letras del código ASCII, "
"dígitos, y el guión bajo. No pueden empezar con dígitos. Los siguientes son "
"nombres válidos de variables:"

#. type: Plain text
#: original/txt/usr_41.txt:144
#, no-wrap
msgid ""
"\tcounter\n"
"\t_aap3\n"
"\tvery_long_variable_name_with_underscores\n"
"\tFuncLength\n"
"\tLENGTH\n"
msgstr ""
"\tcontador\n"
"\t_aap3\n"
"\tnombre_de_variable_largo_con_guion_bajo\n"
"\tFuncLongitud\n"
"\tLONGITUD\n"

#. type: Plain text
#: original/txt/usr_41.txt:148
#, no-wrap
msgid ""
"Invalid names are \"foo+bar\" and \"6var\".\n"
"   These variables are global.  To see a list of currently defined variables\n"
"use this command: >\n"
msgstr ""
"«foo+bar» y «6var» no son nombres válidos.\n"
"   Estas variables son globales. Para ver un listado de las variables\n"
"definidas actualmente, use la siguiente orden: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:150
#, no-wrap
msgid "\t:let\n"
msgstr "\t:let\n"

#. type: Plain text
#: original/txt/usr_41.txt:156
msgid ""
"You can use global variables everywhere.  This also means that when the "
"variable \"count\" is used in one script file, it might also be used in "
"another file.  This leads to confusion at least, and real problems at "
"worst.  To avoid this, you can use a variable local to a script file by "
"prepending \"s:\".  For example, one script contains this code: >"
msgstr ""
"Puede usar variables globales en cualquier parte. Esto implica que cuando "
"usa la variable «cuenta» en un archivo, ésta también puede ser usada en otro "
"archivo, lo que al menos crea confusión, y en el peor de los casos genera "
"problemas reales. Para evitar este problema, puede declarar variables como "
"locales respecto al archivo del script, anteponiendo «s:» a su nombre. Por "
"ejemplo, considere un script con las siguientes instrucciones: >"

#. type: Plain text
#: original/txt/usr_41.txt:162
#, no-wrap
msgid ""
"\t:let s:count = 1\n"
"\t:while s:count < 5\n"
"\t:  source other.vim\n"
"\t:  let s:count += 1\n"
"\t:endwhile\n"
msgstr ""
"\t:let s:cuenta = 1\n"
"\t:while s:cuenta < 5\n"
"\t:  source otro.vim\n"
"\t:  let s:cuenta += 1\n"
"\t:endwhile\n"

#. type: Plain text
#: original/txt/usr_41.txt:167
msgid ""
"Since \"s:count\" is local to this script, you can be sure that sourcing the "
"\"other.vim\" script will not change this variable.  If \"other.vim\" also "
"uses an \"s:count\" variable, it will be a different copy, local to that "
"script.  More about script-local variables here: |script-variable|."
msgstr ""
"Ya que el ámbito de «s:cuenta» es local al script, puede estar seguro de que "
"cargar el archivo «otro.vim» no hará cambios a dicha variable. Si «otro.vim» "
"también usa una variable «s:cuenta», será una copia distinta, local al "
"ámbito de ese script. Puede encontrar más información acerca de las "
"variables locales a un script en |script-variable|."

#. type: Plain text
#: original/txt/usr_41.txt:170
msgid ""
"There are more kinds of variables, see |internal-variables|.  The most often "
"used ones are:"
msgstr ""
"Existen más clases de variables, consulte |internal-variables|. Las que se "
"usan más frecuentemente son:"

#. type: Plain text
#: original/txt/usr_41.txt:175
#, no-wrap
msgid ""
"\tb:name\t\tvariable local to a buffer\n"
"\tw:name\t\tvariable local to a window\n"
"\tg:name\t\tglobal variable (also in a function)\n"
"\tv:name\t\tvariable predefined by Vim\n"
msgstr ""
"\tb:nombre\t\tvariable local a un búfer\n"
"\tw:nombre\t\tvariable local a una ventana\n"
"\tg:nombre\t\tvariable global (incluso dentro de funciones)\n"
"\tv:nombre\t\tvariable predeterminada por Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:178
msgid "DELETING VARIABLES"
msgstr "ELIMINAR VARIABLES"

#. type: Plain text
#: original/txt/usr_41.txt:181
msgid ""
"Variables take up memory and show up in the output of the \":let\" command.  "
"To delete a variable use the \":unlet\" command.  Example: >"
msgstr ""
"Las variables que aparecen en el listado que genera la orden «:let» consumen "
"recursos de memoria. Para eliminar una variable use la orden «:unlet». "
"Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:183
#, no-wrap
msgid "\t:unlet s:count\n"
msgstr "\t:unlet s:cuenta\n"

#. type: Plain text
#: original/txt/usr_41.txt:187
msgid ""
"This deletes the script-local variable \"s:count\" to free up the memory it "
"uses.  If you are not sure if the variable exists, and don't want an error "
"message when it doesn't, append !: >"
msgstr ""
"Esta orden elimina la variable «s:count», local al script actual, para "
"liberar la memoria que ésta usa. Si no está seguro de que una variable "
"exista, y no quiere obtener mensajes de error si no existe, añada ! a la "
"orden: >"

#. type: Plain text
#: original/txt/usr_41.txt:189
#, no-wrap
msgid "\t:unlet! s:count\n"
msgstr "\t:unlet! s:cuenta\n"

#. type: Plain text
#: original/txt/usr_41.txt:193
msgid ""
"When a script finishes, the local variables used there will not be "
"automatically freed.  The next time the script executes, it can still use "
"the old value.  Example: >"
msgstr ""
"Cuando la ejecución de un script termina, no se liberan automáticamente los "
"recursos usados por sus variables locales. La próxima vez que se ejecute el "
"script, los valores antiguos estarán disponibles. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:199
#, no-wrap
msgid ""
"\t:if !exists(\"s:call_count\")\n"
"\t:  let s:call_count = 0\n"
"\t:endif\n"
"\t:let s:call_count = s:call_count + 1\n"
"\t:echo \"called\" s:call_count \"times\"\n"
msgstr ""
"\t:if !exists(\"s:cuenta_llamadas\")\n"
"\t:  let s:cuenta_llamadas = 0\n"
"\t:endif\n"
"\t:let s:cuenta_llamadas = s:cuenta_llamadas + 1\n"
"\t:echo \"llamado\" s:cuenta_llamadas \"veces\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:203
msgid ""
"The \"exists()\" function checks if a variable has already been defined.  "
"Its argument is the name of the variable you want to check.  Not the "
"variable itself! If you would do this: >"
msgstr ""
"La función «exists()» comprueba la existencia de una variable. Recibe como "
"argumento el nombre de la variable a comprobar. ¡No la variable como tal! Si "
"intenta esto: >"

#. type: Plain text
#: original/txt/usr_41.txt:205
#, no-wrap
msgid "\t:if !exists(s:call_count)\n"
msgstr "\t:if !exists(s:cuenta_llamadas)\n"

#. type: Plain text
#: original/txt/usr_41.txt:218
#, no-wrap
msgid ""
"Then the value of s:call_count will be used as the name of the variable that\n"
"exists() checks.  That's not what you want.\n"
"   The exclamation mark ! negates a value.  When the value was true, it\n"
"becomes false.  When it was false, it becomes true.  You can read it as \"not\".\n"
"Thus \"if !exists()\" can be read as \"if not exists()\".\n"
"   What Vim calls true is anything that is not zero.  Zero is false.\n"
"\tNote:\n"
"\tVim automatically converts a string to a number when it is looking for\n"
"\ta number.  When using a string that doesn't start with a digit the\n"
"\tresulting number is zero.  Thus look out for this: >\n"
"\t\t:if \"true\"\n"
"<\tThe \"true\" will be interpreted as a zero, thus as false!\n"
msgstr ""
"El valor de «s:cuenta_llamadas» se usará como el nombre de variable que\n"
"exists() revisará. Ése no es el efecto esperado.\n"
"   El símbolo de exclamación ! niega un valor. Cuando un valor es verdadero,\n"
"se vuelve falso. Cuando es falso, se vuelve verdadero. Puede leer este "
"símbolo\n"
"como «not» (negación lógica). Así, «if !exists()» se lee como «if not\n"
"exists()».\n"
"   Vim considera como verdadero cualquier valor distinto de cero. Cero\n"
"equivale a falso.\n"
"\tNota:\n"
"\tVim convierte las cadenas de texto a números de manera automática\n"
"\tcuando se espera un número. Cuando se hace esta conversión con una\n"
"\tcadena que no empieza con un dígito el número resultante es cero.\n"
"\tDebido a esto, tenga cuidado con instrucciones como: >\n"
"\t\t:if \"verdadero\"\n"
"<\ten este caso, la cadena «verdadero» será interpretada como un cero, ¡y\n"
"\tpor tanto como falso!\n"

#. type: Plain text
#: original/txt/usr_41.txt:221
msgid "STRING VARIABLES AND CONSTANTS"
msgstr "VARIABLES CADENAS DE TEXTO Y CONSTANTES CADENAS DE TEXTO"

#. type: Plain text
#: original/txt/usr_41.txt:228
#, no-wrap
msgid ""
"So far only numbers were used for the variable value.  Strings can be used as\n"
"well.  Numbers and strings are the basic types of variables that Vim supports.\n"
"The type is dynamic, it is set each time when assigning a value to the\n"
"variable with \":let\".  More about types in |41.8|.\n"
"   To assign a string value to a variable, you need to use a string constant.\n"
"There are two types of these.  First the string in double quotes: >\n"
msgstr ""
"Hasta ahora sólo se han usado números como valores de variables. También es\n"
"posible usar cadenas de texto. Los tipos básicos de variables que Vim soporta\n"
"son números y cadenas. El tipo de cada variable es dinámico, y se fija cada\n"
"vez que se asigna un valor a una variable mediante «:let». Refiérase a |41.8|\n"
"para más información acerca de tipos.\n"
"   Para asignar un valor de tipo cadena a una variable, debe usar una\n"
"constante de cadena. Hay dos tipos de estas constantes. El primero es la\n"
"cadena con comillas dobles: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:232
#, no-wrap
msgid ""
"\t:let name = \"peter\"\n"
"\t:echo name\n"
"<\tpeter ~\n"
msgstr ""
"\t:let nombre = \"pedro\"\n"
"\t:echo nombre\n"
"<\tpedro ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:235
msgid ""
"If you want to include a double quote inside the string, put a backslash in "
"front of it: >"
msgstr ""
"Si quiere incluir una comilla doble en el contenido de la cadena, ponga una "
"barra inversa antes de la misma: > "

#. type: Plain text
#: original/txt/usr_41.txt:239
#, no-wrap
msgid ""
"\t:let name = \"\\\"peter\\\"\"\n"
"\t:echo name\n"
"<\t\"peter\" ~\n"
msgstr ""
"\t:let nombre = \"\\\"pedro\\\"\"\n"
"\t:echo nombre\n"
"<\t\"pedro\" ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:241
msgid ""
"To avoid the need for a backslash, you can use a string in single quotes: >"
msgstr ""
"Para evitar el uso de la barra inversa, puede usar una cadena con comillas "
"sencillas: >"

#. type: Plain text
#: original/txt/usr_41.txt:245
#, no-wrap
msgid ""
"\t:let name = '\"peter\"'\n"
"\t:echo name\n"
"<\t\"peter\" ~\n"
msgstr ""
"\t:let nombre = '\"pedro\"'\n"
"\t:echo nombre\n"
"<\t\"pedro\" ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:252
#, no-wrap
msgid ""
"Inside a single-quote string all the characters are as they are.  Only the\n"
"single quote itself is special: you need to use two to get one.  A backslash\n"
"is taken literally, thus you can't use it to change the meaning of the\n"
"character after it.\n"
"   In double-quote strings it is possible to use special characters.  Here are\n"
"a few useful ones:\n"
msgstr ""
"En una cadena de comillas sencillas todos los caracteres tienen solamente su\n"
"significado literal. Sólo la comilla sencilla es especial: debe usar dos\n"
"seguidas para obtener una dentro de una cadena. La barra inversa se considera\n"
"literalmente, por lo que no es posible usarla para cambiar el significado del\n"
"carácter después de ella.\n"
"   En las cadenas de comillas dobles es posible usar caracteres especiales. A\n"
"continuación algunos de los más usados:\n"

#. type: Plain text
#: original/txt/usr_41.txt:262
#, no-wrap
msgid ""
"\t\\t\t\t<Tab>\n"
"\t\\n\t\t<NL>, line break\n"
"\t\\r\t\t<CR>, <Enter>\n"
"\t\\e\t\t<Esc>\n"
"\t\\b\t\t<BS>, backspace\n"
"\t\\\"\t\t\"\n"
"\t\\\\\t\t\\, backslash\n"
"\t\\<Esc>\t\t<Esc>\n"
"\t\\<C-W>\t\tCTRL-W\n"
msgstr ""
"\t\\t\t\t<Tab>\n"
"\t\\n\t\t<NL>, salto de línea\n"
"\t\\r\t\t<CR>, <Enter>\n"
"\t\\e\t\t<Esc>\n"
"\t\\b\t\t<BS>, retroceso\n"
"\t\\\"\t\t\"\n"
"\t\\\\\t\t\\, barra inversa\n"
"\t\\<Esc>\t\t<Esc>\n"
"\t\\<C-W>\t\tCTRL-W\n"

#. type: Plain text
#: original/txt/usr_41.txt:266
#, no-wrap
msgid ""
"The last two are just examples.  The  \"\\<name>\" form can be used to include\n"
"the special key \"name\".\n"
"   See |expr-quote| for the full list of special items in a string.\n"
msgstr ""
"Los últimos dos sólo son ejemplos. Se puede usar la forma «\\<nombre>» para\n"
"incluir la tecla «nombre».\n"
"   Consulte |expr-quote| para ver la lista completa de elementos especiales\n"
"en una cadena de texto.\n"

#. type: Plain text
#: original/txt/usr_41.txt:269
#, no-wrap
msgid "*41.3*\tExpressions\n"
msgstr "*41.3*\tExpresiones\n"

#. type: Plain text
#: original/txt/usr_41.txt:276
#, no-wrap
msgid ""
"Vim has a rich, yet simple way to handle expressions.  You can read the\n"
"definition here: |expression-syntax|.  Here we will show the most common\n"
"items.\n"
"   The numbers, strings and variables mentioned above are expressions by\n"
"themselves.  Thus everywhere an expression is expected, you can use a number,\n"
"string or variable.  Other basic items in an expression are:\n"
msgstr ""
"Vim tiene una forma expresiva, pero sencilla, de manejar expresiones. Puede\n"
"leer la definición aquí: |expression-syntax|. A continuación mostraremos\n"
"algunos de los elementos más comunes.\n"
"   Los números, cadenas, y las variables mencionadas anteriormente son\n"
"expresiones por sí mismas. Así que, en donde sea que se espere una expresión,\n"
"puede usar un número, una cadena, o una variable. Otros de los elementos\n"
"comunes en una expresión son:\n"

#. type: Plain text
#: original/txt/usr_41.txt:280
#, no-wrap
msgid ""
"\t$NAME\t\tenvironment variable\n"
"\t&name\t\toption\n"
"\t@r\t\tregister\n"
msgstr ""
"\t$NOMBRE\t\tvariable de entorno\n"
"\t&nombre\t\topción\n"
"\t@r\t\tregistro\n"

#. type: Plain text
#: original/txt/usr_41.txt:282
msgid "Examples: >"
msgstr "Ejemplos: >"

#. type: Plain text
#: original/txt/usr_41.txt:286
#, no-wrap
msgid ""
"\t:echo \"The value of 'tabstop' is\" &ts\n"
"\t:echo \"Your home directory is\" $HOME\n"
"\t:if @a > 5\n"
msgstr ""
"\t:echo \"El valor de 'tabstop' es\" &ts\n"
"\t:echo \"Su directorio personal es\" $HOME\n"
"\t:if @a > 5\n"

#. type: Plain text
#: original/txt/usr_41.txt:289
msgid ""
"The &name form can be used to save an option value, set it to a new value, "
"do something and restore the old value.  Example: >"
msgstr ""
"Puede usar la forma «&nombre» para guardar el valor de una opción, fijarla a "
"un nuevo valor, hacer algo, y restaurar el valor original. Por ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:294
#, no-wrap
msgid ""
"\t:let save_ic = &ic\n"
"\t:set noic\n"
"\t:/The Start/,$delete\n"
"\t:let &ic = save_ic\n"
msgstr ""
"\t:let ic_orig = &ic\n"
"\t:set noic\n"
"\t:/El Principio/,$delete\n"
"\t:let &ic = ic_orig\n"

#. type: Plain text
#: original/txt/usr_41.txt:298
msgid ""
"This makes sure the \"The Start\" pattern is used with the 'ignorecase' "
"option off.  Still, it keeps the value that the user had set.  (Another way "
"to do this would be to add \"\\C\" to the pattern, see |/\\C|.)"
msgstr ""
"Con esto se asegura que el patrón «El Principio» se buscará con la opción "
"'ignorecase' desactivada. Sin embargo, se conserva y restaura el valor que "
"el usuario definió para la opción. (Otra forma de hacer esta búsqueda es "
"añadir «\\C» al patrón, consulte |/\\C|.)"

#. type: Plain text
#: original/txt/usr_41.txt:301
msgid "MATHEMATICS"
msgstr "MATEMÁTICAS"

#. type: Plain text
#: original/txt/usr_41.txt:304
msgid ""
"It becomes more interesting if we combine these basic items.  Let's start "
"with mathematics on numbers:"
msgstr ""
"Las cosas se hacen más interesantes si combinamos estos elementos básicos. "
"Empecemos con operaciones matemáticas sobre números:"

#. type: Plain text
#: original/txt/usr_41.txt:310
#, no-wrap
msgid ""
"\ta + b\t\tadd\n"
"\ta - b\t\tsubtract\n"
"\ta * b\t\tmultiply\n"
"\ta / b\t\tdivide\n"
"\ta % b\t\tmodulo\n"
msgstr ""
"\ta + b\t\tadición\n"
"\ta - b\t\tsustracción\n"
"\ta * b\t\tmultiplicación\n"
"\ta / b\t\tdivisión\n"
"\ta % b\t\tmódulo (residuo)\n"

#. type: Plain text
#: original/txt/usr_41.txt:312
msgid "The usual precedence is used.  Example: >"
msgstr "Se maneja la precendencia de operadores usual. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:315
#, no-wrap
msgid ""
"\t:echo 10 + 5 * 2\n"
"<\t20 ~\n"
msgstr ""
"\t:echo 10 + 5 * 2\n"
"<\t20 ~\n"

# TODO file bug on vim's documentation. Parentheses, not braces
#. type: Plain text
#: original/txt/usr_41.txt:317
msgid "Grouping is done with braces.  No surprises here.  Example: >"
msgstr ""
"Puede cambiar la precendencia de las operaciones usando paréntesis. Esto no "
"es nada nuevo.  Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:320
#, no-wrap
msgid ""
"\t:echo (10 + 5) * 2\n"
"<\t30 ~\n"
msgstr ""
"\t:echo (10 + 5) * 2\n"
"<\t30 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:322
msgid "Strings can be concatenated with \".\".  Example: >"
msgstr "Puede unir cadenas usando «.». Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:325
#, no-wrap
msgid ""
"\t:echo \"foo\" . \"bar\"\n"
"<\tfoobar ~\n"
msgstr ""
"\t:echo \"foo\" . \"bar\"\n"
"<\tfoobar ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:329
msgid ""
"When the \":echo\" command gets multiple arguments, it separates them with a "
"space.  In the example the argument is a single expression, thus no space is "
"inserted."
msgstr ""
"Cuando recibe varios argumentos, la orden «:echo» los muestra en pantalla "
"separados con espacios. En el ejemplo anterior el argumento es una única "
"expresión, por lo que no se insertan espacios."

#. type: Plain text
#: original/txt/usr_41.txt:331
msgid "Borrowed from the C language is the conditional expression:"
msgstr "Del lenguaje C se tomó la expresión condicional:"

#. type: Plain text
#: original/txt/usr_41.txt:333
#, no-wrap
msgid "\ta ? b : c\n"
msgstr "\ta ? b : c\n"

#. type: Plain text
#: original/txt/usr_41.txt:335
msgid ""
"If \"a\" evaluates to true \"b\" is used, otherwise \"c\" is used.  Example: "
">"
msgstr ""
"Si «a» se evalúa como verdadero, la expresión corresponderá a «b», y en caso "
"contrario a «c». Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:339
#, no-wrap
msgid ""
"\t:let i = 4\n"
"\t:echo i > 5 ? \"i is big\" : \"i is small\"\n"
"<\ti is small ~\n"
msgstr ""
"\t:let i = 4\n"
"\t:echo i > 5 ? \"i es grande\" : \"i es pequeño\"\n"
"<\ti es pequeño ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:342
msgid ""
"The three parts of the constructs are always evaluated first, thus you could "
"see it work as:"
msgstr ""
"Los tres elementos de la expresión condicional siempre son evaluados; es "
"conveniente verlos de la siguiente forma:"

#. type: Plain text
#: original/txt/usr_41.txt:344
#, no-wrap
msgid "\t(a) ? (b) : (c)\n"
msgstr "\t(a) ? (b) : (c)\n"

#. type: Plain text
#: original/txt/usr_41.txt:347
#, no-wrap
msgid "*41.4*\tConditionals\n"
msgstr "*41.4*\tEstructuras de decisión\n"

#. type: Plain text
#: original/txt/usr_41.txt:350
msgid ""
"The \":if\" commands executes the following statements, until the matching "
"\":endif\", only when a condition is met.  The generic form is:"
msgstr ""
"La orden «:if» ejecuta las órdenes a continuación de ella, hasta el «:endif» "
"correspondiente, cuando se cumple la condición especificada. La forma "
"genérica es:"

# TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
# llaves
#. type: Plain text
#: original/txt/usr_41.txt:354
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condicion}\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:359
#, no-wrap
msgid ""
"Only when the expression {condition} evaluates to true (non-zero) will the\n"
"{statements} be executed.  These must still be valid commands.  If they\n"
"contain garbage, Vim won't be able to find the \":endif\".\n"
"   You can also use \":else\".  The generic form for this is:\n"
msgstr ""
"Las {instrucciones} se ejecutan únicamente cuando la expresión {condicion} es\n"
"verdadera, esto es, diferente de cero. Dichas instrucciones deben ser órdenes\n"
"válidas. Si las órdenes tienen errores de sintaxis, Vim no podrá encontrar el\n"
"«:endif» correspondiente.\n"
"   También puede usar «:else». La forma genérica es:\n"

# TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
# llaves
#. type: Plain text
#: original/txt/usr_41.txt:365
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:else\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condicion}\n"
"\t   {instrucciones}\n"
"\t:else\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:368
#, no-wrap
msgid ""
"The second {statements} is only executed if the first one isn't.\n"
"   Finally, there is \":elseif\":\n"
msgstr ""
"El segundo grupo de {instrucciones} sólo se ejecuta si el primero no lo hace.\n"
"   Finalmente, está «:elseif»\n"

#. type: Plain text
#: original/txt/usr_41.txt:374
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:elseif {condition}\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condicion}\n"
"\t   {instrucciones}\n"
"\t:elseif {condicion}\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:379
#, no-wrap
msgid ""
"This works just like using \":else\" and then \"if\", but without the need for an\n"
"extra \":endif\".\n"
"   A useful example for your vimrc file is checking the 'term' option and\n"
"doing something depending upon its value: >\n"
msgstr ""
"Esta orden funciona como «:else» seguido de «:if», pero tiene la ventaja de no\n"
"requerir un «:endif» adicional.\n"
"   Un ejemplo útil que podría usar en su archivo vimrc es comprobar la opción\n"
"'term' y ejecutar órdenes diferentes de acuerdo a su valor: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:387
#, no-wrap
msgid ""
"\t:if &term == \"xterm\"\n"
"\t:  \" Do stuff for xterm\n"
"\t:elseif &term == \"vt100\"\n"
"\t:  \" Do stuff for a vt100 terminal\n"
"\t:else\n"
"\t:  \" Do something for other terminals\n"
"\t:endif\n"
msgstr ""
"\t:if &term == \"xterm\"\n"
"\t:  \" Configuración para xterm\n"
"\t:elseif &term == \"vt100\"\n"
"\t:  \" Configuración para la terminal vt100\n"
"\t:else\n"
"\t:  \" Configuración para otras terminales\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:390
msgid "LOGIC OPERATIONS"
msgstr "OPERACIONES LÓGICAS"

#. type: Plain text
#: original/txt/usr_41.txt:393
msgid ""
"We already used some of them in the examples.  These are the most often used "
"ones:"
msgstr ""
"Ya hemos usado algunas de ellas en los ejemplos anteriores. A continuación "
"listamos las más utilizadas:"

#. type: Plain text
#: original/txt/usr_41.txt:400
#, no-wrap
msgid ""
"\ta == b\t\tequal to\n"
"\ta != b\t\tnot equal to\n"
"\ta >  b\t\tgreater than\n"
"\ta >= b\t\tgreater than or equal to\n"
"\ta <  b\t\tless than\n"
"\ta <= b\t\tless than or equal to\n"
msgstr ""
"\ta == b\t\tigual a\n"
"\ta != b\t\tdiferente de\n"
"\ta >  b\t\tmayor que\n"
"\ta >= b\t\tmayor o igual a\n"
"\ta <  b\t\tmenor que\n"
"\ta <= b\t\tmenor o igual a\n"

#. type: Plain text
#: original/txt/usr_41.txt:402
msgid ""
"The result is one if the condition is met and zero otherwise.  An example: >"
msgstr ""
"El resultado es uno si la condición se cumple, y cero en caso contrario. Por "
"ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:408
#, no-wrap
msgid ""
"\t:if v:version >= 700\n"
"\t:  echo \"congratulations\"\n"
"\t:else\n"
"\t:  echo \"you are using an old version, upgrade!\"\n"
"\t:endif\n"
msgstr ""
"\t:if v:version >= 700\n"
"\t:  echo \"felicitaciones\"\n"
"\t:else\n"
"\t:  echo \"¡está usando una versión vieja, actualícese!\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:413
msgid ""
"Here \"v:version\" is a variable defined by Vim, which has the value of the "
"Vim version.  600 is for version 6.0.  Version 6.1 has the value 601.  This "
"is very useful to write a script that works with multiple versions of Vim.  |"
"v:version|"
msgstr ""
"La variable «v:version» es definida por Vim, y contiene el número de versión "
"de Vim. 600 corresponde a la versión 6.0. La versión 6.1 tiene el valor 601. "
"Esta variable es útil para escribir scripts que funcionen con distintas "
"versiones de Vim. |v:version|"

#. type: Plain text
#: original/txt/usr_41.txt:420
#, no-wrap
msgid ""
"The logic operators work both for numbers and strings.  When comparing two\n"
"strings, the mathematical difference is used.  This compares byte values,\n"
"which may not be right for some languages.\n"
"   When comparing a string with a number, the string is first converted to a\n"
"number.  This is a bit tricky, because when a string doesn't look like a\n"
"number, the number zero is used.  Example: >\n"
msgstr ""
"Los operadores lógicos funcionan con números y con cadenas de texto. Al\n"
"comparar dos cadenas, se trabaja con la diferencia matemática de las mismas.\n"
"Esto compara valores de bytes, lo que para algunos idiomas puede no entregar\n"
"resultados correctos.\n"
"   Al comparar cadenas con números, la cadena es convertida a un número antes\n"
"de hacer la comparación. Debe tener en cuenta que, cuando el contenido de una\n"
"cadena no se asemeja a un número, se usa el número cero. Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:424
#, no-wrap
msgid ""
"\t:if 0 == \"one\"\n"
"\t:  echo \"yes\"\n"
"\t:endif\n"
msgstr ""
"\t:if 0 == \"uno\"\n"
"\t:  echo \"sí\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:427
msgid ""
"This will echo \"yes\", because \"one\" doesn't look like a number, thus it "
"is converted to the number zero."
msgstr ""
"El ejemplo mostrará «sí», porque «uno» no puede ser convertido a un número, "
"por lo que se lo convierte al número cero."

#. type: Plain text
#: original/txt/usr_41.txt:429
msgid "For strings there are two more items:"
msgstr "Hay dos operadores más para cadenas de texto:"

#. type: Plain text
#: original/txt/usr_41.txt:432
#, no-wrap
msgid ""
"\ta =~ b\t\tmatches with\n"
"\ta !~ b\t\tdoes not match with\n"
msgstr ""
"\ta =~ b\t\tcoincide con\n"
"\ta !~ b\t\tno coincide con\n"

#. type: Plain text
#: original/txt/usr_41.txt:435
msgid ""
"The left item \"a\" is used as a string.  The right item \"b\" is used as a "
"pattern, like what's used for searching.  Example: >"
msgstr ""
"El operando de la izquierda, «a», se trata como una cadena. El operando de "
"la derecha, «b», se trata como un patrón para una búsqueda de texto. "
"Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:442
#, no-wrap
msgid ""
"\t:if str =~ \" \"\n"
"\t:  echo \"str contains a space\"\n"
"\t:endif\n"
"\t:if str !~ '\\.$'\n"
"\t:  echo \"str does not end in a full stop\"\n"
"\t:endif\n"
msgstr ""
"\t:if str =~ \" \"\n"
"\t:  echo \"str contiene un espacio\"\n"
"\t:endif\n"
"\t:if str !~ '\\.$'\n"
"\t:  echo \"str no termina con punto final\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:446
msgid ""
"Notice the use of a single-quote string for the pattern.  This is useful, "
"because backslashes would need to be doubled in a double-quote string and "
"patterns tend to contain many backslashes."
msgstr ""
"Tenga en cuenta el uso de una cadena de comillas sencillas como patrón de "
"búsqueda. En este caso es útil porque las barras inversas tendrían que "
"insertarse por partida doble en una cadena de comillas dobles, y los "
"patrones de búsqueda suelen contener muchas barras inversas."

#. type: Plain text
#: original/txt/usr_41.txt:452
msgid ""
"The 'ignorecase' option is used when comparing strings.  When you don't want "
"that, append \"#\" to match case and \"?\" to ignore case.  Thus \"==?\" "
"compares two strings to be equal while ignoring case.  And \"!~#\" checks if "
"a pattern doesn't match, also checking the case of letters.  For the full "
"table see |expr-==|."
msgstr ""
"Al comparar cadenas se tiene en cuenta la opción 'ignorecase'. Si no desea "
"este comportamiento, añada un «#» para diferenciar mayúsculas de minúsculas, "
"o «?» para ignorar dicha diferencia. Así, «==?» compara dos cadenas sin "
"diferenciar mayúsculas de minúsculas. «!~#» revisa la no coincidencia de un "
"patrón, teniendo en cuenta diferencias de mayúsculas y minúsculas. Puede "
"consultar la tabla completa de operadores de comparación en |expr-==|."

#. type: Plain text
#: original/txt/usr_41.txt:455
msgid "MORE LOOPING"
msgstr "MÁS SOBRE CICLOS"

#. type: Plain text
#: original/txt/usr_41.txt:458
msgid ""
"The \":while\" command was already mentioned.  Two more statements can be "
"used in between the \":while\" and the \":endwhile\":"
msgstr ""
"Ya hemos mencionado la orden «:while». Hay dos instrucciones adicionales que "
"pueden usarse entre «:while» y el «:endwhile» correspondiente:"

#. type: Plain text
#: original/txt/usr_41.txt:463
#, no-wrap
msgid ""
"\t:continue\t\tJump back to the start of the while loop; the\n"
"\t\t\t\tloop continues.\n"
"\t:break\t\t\tJump forward to the \":endwhile\"; the loop is\n"
"\t\t\t\tdiscontinued.\n"
msgstr ""
"\t:continue\t\tSalta hasta el inicio del ciclo «while»; el\n"
"\t\t\t\tciclo continúa.\n"
"\t:break\t\t\tSalta hasta después del «:endwhile»; provoca\n"
"\t\t\t\tla terminación del ciclo.\n"

#. type: Plain text
#: original/txt/usr_41.txt:465
msgid "Example: >"
msgstr "Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:476
#, no-wrap
msgid ""
"\t:while counter < 40\n"
"\t:  call do_something()\n"
"\t:  if skip_flag\n"
"\t:    continue\n"
"\t:  endif\n"
"\t:  if finished_flag\n"
"\t:    break\n"
"\t:  endif\n"
"\t:  sleep 50m\n"
"\t:endwhile\n"
msgstr ""
"\t:while contador < 40\n"
"\t:  call hacer_algo()\n"
"\t:  if opción_omitir\n"
"\t:    continue\n"
"\t:  endif\n"
"\t:  if opción_terminado\n"
"\t:    break\n"
"\t:  endif\n"
"\t:  sleep 50m\n"
"\t:endwhile\n"

#. type: Plain text
#: original/txt/usr_41.txt:479
msgid ""
"The \":sleep\" command makes Vim take a nap.  The \"50m\" specifies fifty "
"milliseconds.  Another example is \":sleep 4\", which sleeps for four "
"seconds."
msgstr ""
"La orden «:sleep» hace que Vim tome una pausa. El argumento «50m» especifica "
"una duración de 50 milisegundos. Otro ejemplo es «:sleep 4», que especifica "
"una pausa de cuatro segundos."

#. type: Plain text
#: original/txt/usr_41.txt:481
msgid ""
"Even more looping can be done with the \":for\" command, see below in |41.8|."
msgstr ""
"La orden «:for» es otra estructura de control para iteración, consulte la "
"sección |41.8|."

#. type: Plain text
#: original/txt/usr_41.txt:484
#, no-wrap
msgid "*41.5*\tExecuting an expression\n"
msgstr "*41.5*\tEjecución de expresiones\n"

#. type: Plain text
#: original/txt/usr_41.txt:489
#, no-wrap
msgid ""
"So far the commands in the script were executed by Vim directly.  The\n"
"\":execute\" command allows executing the result of an expression.  This is a\n"
"very powerful way to build commands and execute them.\n"
"   An example is to jump to a tag, which is contained in a variable: >\n"
msgstr ""
"Hasta ahora, todas las órdenes mostradas han sido ejecutadas directamente por\n"
"Vim. La orden «:execute» permite ejecutar el resultado de una expresión. Ésta\n"
"es una forma poderosa de construir y ejecutar órdenes.\n"
"   Un ejemplo es saltar a una etiqueta, cuyo nombre está almacenado en una\n"
"variable: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:491
#, no-wrap
msgid "\t:execute \"tag \" . tag_name\n"
msgstr "\t:execute \"tag \" . nombre_etiqueta\n"

#. type: Plain text
#: original/txt/usr_41.txt:495
msgid ""
"The \".\" is used to concatenate the string \"tag \" with the value of "
"variable \"tag_name\".  Suppose \"tag_name\" has the value \"get_cmd\", then "
"the command that will be executed is: >"
msgstr ""
"El «.» se usa para concatenar la cadena «tag » con el valor de la variable "
"«nombre_etiqueta». Si suponemos que «nombre_etiqueta» tiene el contenido "
"«obtener_orden», entonces la orden que se ejecutará es: >"

#. type: Plain text
#: original/txt/usr_41.txt:497
#, no-wrap
msgid "\t:tag get_cmd\n"
msgstr "\t:tag obtener_orden\n"

#. type: Plain text
#: original/txt/usr_41.txt:501
msgid ""
"The \":execute\" command can only execute colon commands.  The \":normal\" "
"command executes Normal mode commands.  However, its argument is not an "
"expression but the literal command characters.  Example: >"
msgstr ""
"La orden «:execute» sólo puede ejecutar órdenes de la línea de órdenes "
"(órdenes Ex, que empiezan con «:»). La orden «:normal» ejecuta órdenes del "
"modo Normal. Sin embargo, su argumento no es una expresión, sino los "
"caracteres literales de la orden. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:503
#, no-wrap
msgid "\t:normal gg=G\n"
msgstr "\t:normal gg=G\n"

#. type: Plain text
#: original/txt/usr_41.txt:507
#, no-wrap
msgid ""
"This jumps to the first line and formats all lines with the \"=\" operator.\n"
"   To make \":normal\" work with an expression, combine \":execute\" with it.\n"
"Example: >\n"
msgstr ""
"Se mueve hasta la primera línea y formatea todas las líneas usando el operador\n"
"«=».\n"
"   Para usar «:normal» con el resultado de una expresión, debe combinar\n"
"«:execute» con dicha orden. Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:509
#, no-wrap
msgid "\t:execute \"normal \" . normal_commands\n"
msgstr "\t:execute \"normal \" . ordenes_modo_normal\n"

#. type: Plain text
#: original/txt/usr_41.txt:514
#, no-wrap
msgid ""
"The variable \"normal_commands\" must contain the Normal mode commands.\n"
"   Make sure that the argument for \":normal\" is a complete command.  Otherwise\n"
"Vim will run into the end of the argument and abort the command.  For example,\n"
"if you start Insert mode, you must leave Insert mode as well.  This works: >\n"
msgstr ""
"La variables «ordenes_modo_normal» debe contener órdenes para el modo "
"Normal.\n"
"   Asegúrese de que el argumento para «:normal» es una orden completa. En "
"caso\n"
"contrario, Vim llegará al final del argumento e interrumpirá la orden. Por\n"
"ejemplo, si inicia el modo Insertar, debe salir del mismo. Lo siguiente\n"
"funciona adecuadamente: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:516
#, no-wrap
msgid "\t:execute \"normal Inew text \\<Esc>\"\n"
msgstr "\t:execute \"normal Itexto nuevo \\<Esc>\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:520
msgid ""
"This inserts \"new text \" in the current line.  Notice the use of the "
"special key \"\\<Esc>\".  This avoids having to enter a real <Esc> character "
"in your script."
msgstr ""
"Esta orden inserta «texto nuevo» en la línea actual. Observe el uso de la "
"tecla especial «\\<Esc>». Así se evita la necesidad de escribir un <Esc> "
"real en el script."

#. type: Plain text
#: original/txt/usr_41.txt:523
msgid ""
"If you don't want to execute a string but evaluate it to get its expression "
"value, you can use the eval() function: >"
msgstr ""
"Si lo que quiere es no ejecutar una cadena de texto, sino evaluarla para "
"obtener el valor de la expresión que contiene, use la función eval(): >"

#. type: Plain text
#: original/txt/usr_41.txt:526
#, no-wrap
msgid ""
"\t:let optname = \"path\"\n"
"\t:let optval = eval('&' . optname)\n"
msgstr ""
"\t:let nomopcion = \"path\"\n"
"\t:let valopcion = eval('&' . nomopcion)\n"

#. type: Plain text
#: original/txt/usr_41.txt:531
#, no-wrap
msgid ""
"A \"&\" character is prepended to \"path\", thus the argument to eval() is\n"
"\"&path\".  The result will then be the value of the 'path' option.\n"
"   The same thing can be done with: >\n"
"\t:exe 'let optval = &' . optname\n"
msgstr ""
"Se antepone un «&» a «path», y así el argumento para eval() es «&path». El\n"
"resultado será el valor de la opción 'path'.\n"
"   Puede obtener el mismo resultado con: >\n"
"\t:exe 'let optval = &' . optname\n"

#. type: Plain text
#: original/txt/usr_41.txt:534
#, no-wrap
msgid "*41.6*\tUsing functions\n"
msgstr "*24.1*\tFunciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:538
msgid ""
"Vim defines many functions and provides a large amount of functionality that "
"way.  A few examples will be given in this section.  You can find the whole "
"list here: |functions|."
msgstr ""
"Vim define muchas funciones y provee bastante funcionalidad a través de este "
"mecanismo. Aquí daremos algunos ejemplos. La referencia para la lista "
"completa se encuentra en |functions|."

#. type: Plain text
#: original/txt/usr_41.txt:541
msgid ""
"A function is called with the \":call\" command.  The parameters are passed "
"in between braces, separated by commas.  Example: >"
msgstr ""
"Las funciones se llaman con la orden «:call». Los parámetros se introducen "
"entre paréntesis, separados por comas. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:543
#, no-wrap
msgid "\t:call search(\"Date: \", \"W\")\n"
msgstr "\t:call search(\"Fecha: \", \"W\")\n"

#. type: Plain text
#: original/txt/usr_41.txt:548
msgid ""
"This calls the search() function, with arguments \"Date: \" and \"W\".  The "
"search() function uses its first argument as a search pattern and the second "
"one as flags.  The \"W\" flag means the search doesn't wrap around the end "
"of the file."
msgstr ""
"Se invoca a la función search(), con los argumentos «Fecha: » y «W». La "
"función search() usa su primer argumento como patrón de búsqueda y el "
"segundo como una serie de opciones. La opción «W» hace que la búsqueda "
"termine al alcanzar el final del archivo."

#. type: Plain text
#: original/txt/usr_41.txt:550
msgid "A function can be called in an expression.  Example: >"
msgstr "También es posible invocar funciones en expresiones.  Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:554
#, no-wrap
msgid ""
"\t:let line = getline(\".\")\n"
"\t:let repl = substitute(line, '\\a', \"*\", \"g\")\n"
"\t:call setline(\".\", repl)\n"
msgstr ""
"\t:let linea = getline(\".\")\n"
"\t:let reempl = substitute(linea, '\\a', \"*\", \"g\")\n"
"\t:call setline(\".\", reempl)\n"

#. type: Plain text
#: original/txt/usr_41.txt:566
#, no-wrap
msgid ""
"The getline() function obtains a line from the current buffer.  Its argument\n"
"is a specification of the line number.  In this case \".\" is used, which means\n"
"the line where the cursor is.\n"
"   The substitute() function does something similar to the \":substitute\"\n"
"command.  The first argument is the string on which to perform the\n"
"substitution.  The second argument is the pattern, the third the replacement\n"
"string.  Finally, the last arguments are the flags.\n"
"   The setline() function sets the line, specified by the first argument, to a\n"
"new string, the second argument.  In this example the line under the cursor is\n"
"replaced with the result of the substitute().  Thus the effect of the three\n"
"statements is equal to: >\n"
msgstr ""
"La función getline() extrae una línea del búfer actual. Su argumento\n"
"especifica un número de línea. En este caso se usa «.», que se interpreta "
"como\n"
"la línea en la que se encuentra el cursor.\n"
"   La función substitute() tiene un comportamiento similar al de la orden\n"
"«:substitute». El primer argumento es la cadena de texto sobre la cual "
"operar,\n"
"el segundo es el patrón de búsqueda, el tercero la cadena de reemplazo. El\n"
"último argumento se corresponde con las opciones de búsqueda.\n"
"   La función setline() reemplaza la línea que se especifique en el primer\n"
"argumento, con la cadena que se pase en el segundo argumento. En este "
"ejemplo\n"
"se reemplaza a la línea bajo el cursor con el resultado de substitute(). El\n"
"efecto de las tres instrucciones equivale a: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:568
#, no-wrap
msgid "\t:substitute/\\a/*/g\n"
msgstr "\t:substitute/\\a/*/g\n"

#. type: Plain text
#: original/txt/usr_41.txt:571
msgid ""
"Using the functions becomes more interesting when you do more work before "
"and after the substitute() call."
msgstr ""
"Usar estas funciones tiene efectos más interesantes cuando el procesamiento "
"se realiza antes y después de invocar substitute()."

#. type: Plain text
#: original/txt/usr_41.txt:574
#, no-wrap
msgid "FUNCTIONS\t\t\t\t\t\t*function-list*\n"
msgstr "FUNCIONES\t\t\t\t\t\t*function-list*\n"

#. type: Plain text
#: original/txt/usr_41.txt:578
msgid ""
"There are many functions.  We will mention them here, grouped by what they "
"are used for.  You can find an alphabetical list here: |functions|.  Use "
"CTRL-] on the function name to jump to detailed help on it."
msgstr ""
"Vim cuenta con muchas funciones. Las mencionaremos aquí, agrupadas de "
"acuerdo a su funcionalidad. En |functions| se encuentra una lista de ellas "
"ordenada alfabéticamente. Puede ubicar el cursor sobre el nombre de una "
"función y pulsar CTRL-] para ver documentación más detallada sobre ella."

#. type: Plain text
#: original/txt/usr_41.txt:607
#, no-wrap
msgid ""
"String manipulation:\t\t\t\t\t*string-functions*\n"
"\tnr2char()\t\tget a character by its ASCII value\n"
"\tchar2nr()\t\tget ASCII value of a character\n"
"\tstr2nr()\t\tconvert a string to a Number\n"
"\tstr2float()\t\tconvert a string to a Float\n"
"\tprintf()\t\tformat a string according to % items\n"
"\tescape()\t\tescape characters in a string with a '\\'\n"
"\tshellescape()\t\tescape a string for use with a shell command\n"
"\tfnameescape()\t\tescape a file name for use with a Vim command\n"
"\ttr()\t\t\ttranslate characters from one set to another\n"
"\tstrtrans()\t\ttranslate a string to make it printable\n"
"\ttolower()\t\tturn a string to lowercase\n"
"\ttoupper()\t\tturn a string to uppercase\n"
"\tmatch()\t\t\tposition where a pattern matches in a string\n"
"\tmatchend()\t\tposition where a pattern match ends in a string\n"
"\tmatchstr()\t\tmatch of a pattern in a string\n"
"\tmatchlist()\t\tlike matchstr() and also return submatches\n"
"\tstridx()\t\tfirst index of a short string in a long string\n"
"\tstrridx()\t\tlast index of a short string in a long string\n"
"\tstrlen()\t\tlength of a string\n"
"\tsubstitute()\t\tsubstitute a pattern match with a string\n"
"\tsubmatch()\t\tget a specific match in a \":substitute\"\n"
"\tstrpart()\t\tget part of a string\n"
"\texpand()\t\texpand special keywords\n"
"\ticonv()\t\t\tconvert text from one encoding to another\n"
"\tbyteidx()\t\tbyte index of a character in a string\n"
"\trepeat()\t\trepeat a string multiple times\n"
"\teval()\t\t\tevaluate a string expression\n"
msgstr ""
"Manipulación de cadenas:\t\t\t\t*string-functions*\n"
"\tnr2char()\t\tobtiene un carácter dado su valor ASCII\n"
"\tchar2nr()\t\tobtiene el número ASCII del carácter dado\n"
"\tstr2nr()\t\tconvierte una cadena a Número\n"
"\tstr2float()\t\tconvierte una cadena a Flotante\n"
"\tprintf()\t\tformatea una cadena de acuerdo a elementos %\n"
"\tescape()\t\tescapa caracteres en una cadena con '\\'\n"
"\tshellescape()\t\tescapa una cadena para usarse una orden de\n"
"\t\t\t\tconsola\n"
"\tfnameescape()\t\tescapa un nombre de archivo para usar en una\n"
"\t\t\t\torden Vim\n"
"\ttr()\t\t\ttraduce caracteres de un conjunto a otro\n"
"\tstrtrans()\t\ttraduce una cadena para que se pueda imprimir\n"
"\ttolower()\t\tconvierte una cadena a minúsculas\n"
"\ttoupper()\t\tconvierte una cadena a mayúsculas\n"
"\tmatch()\t\t\tposición en la que un patrón coincide en una\n"
"\t\t\t\tcadena\n"
"\tmatchend()\t\tposición en la que un patrón termina en una\n"
"\t\t\t\tcadena\n"
"\tmatchstr()\t\tcoincidencia de un patrón en una cadena\n"
"\tmatchlist()\t\tsimilar a matchstr() y retorna\n"
"\t\t\t\tsubcoincidencias\n"
"\tstridx()\t\tprimer índice de una cadena corta dentro de\n"
"\t\t\t\tuna larga\n"
"\tstrridx()\t\túltimo índice de una cadena corta dentro de\n"
"\t\t\t\tuna larga\n"
"\tstrlen()\t\tlongitud de una cadena\n"
"\tsubstitute()\t\tsustituye la coincidencia de un patrón con una\n"
"\t\t\t\tcadena\n"
"\tsubmatch()\t\tobtiene una subcoincidencia específica en un\n"
"\t\t\t\t«:substitute»\n"
"\tstrpart()\t\tobtiene parte de una cadena\n"
"\texpand()\t\texpande palabras clave\n"
"\ticonv()\t\t\tconvierte texto entre distintas codificaciones\n"
"\tbyteidx()\t\tíndice de byte de un carácter en una cadena\n"
"\trepeat()\t\trepite una cadena múltiples veces\n"
"\teval()\t\t\tevalúa una cadena como expresión\n"

#. type: Plain text
#: original/txt/usr_41.txt:632
#, no-wrap
msgid ""
"List manipulation:\t\t\t\t\t*list-functions*\n"
"\tget()\t\t\tget an item without error for wrong index\n"
"\tlen()\t\t\tnumber of items in a List\n"
"\tempty()\t\t\tcheck if List is empty\n"
"\tinsert()\t\tinsert an item somewhere in a List\n"
"\tadd()\t\t\tappend an item to a List\n"
"\textend()\t\tappend a List to a List\n"
"\tremove()\t\tremove one or more items from a List\n"
"\tcopy()\t\t\tmake a shallow copy of a List\n"
"\tdeepcopy()\t\tmake a full copy of a List\n"
"\tfilter()\t\tremove selected items from a List\n"
"\tmap()\t\t\tchange each List item\n"
"\tsort()\t\t\tsort a List\n"
"\treverse()\t\treverse the order of a List\n"
"\tsplit()\t\t\tsplit a String into a List\n"
"\tjoin()\t\t\tjoin List items into a String\n"
"\trange()\t\t\treturn a List with a sequence of numbers\n"
"\tstring()\t\tString representation of a List\n"
"\tcall()\t\t\tcall a function with List as arguments\n"
"\tindex()\t\t\tindex of a value in a List\n"
"\tmax()\t\t\tmaximum value in a List\n"
"\tmin()\t\t\tminimum value in a List\n"
"\tcount()\t\t\tcount number of times a value appears in a List\n"
"\trepeat()\t\trepeat a List multiple times\n"
msgstr ""
"Manipulación de Listas:\t\t\t\t\t*list-functions*\n"
"\tget()\t\t\tobtiene un elemento sin generar error al usar\n"
"\t\t\t\tíndices erróneos\n"
"\tlen()\t\t\tnúmero de elementos en una Lista\n"
"\tempty()\t\t\tcomprueba si una Lista está vacía\n"
"\tinsert()\t\tinserta un elemento en una Lista\n"
"\tadd()\t\t\tañade un elemento a una Lista\n"
"\textend()\t\tañade los contenidos de una Lista a otra Lista\n"
"\tremove()\t\telimina uno o más elementos de una lista\n"
"\tcopy()\t\t\thace una copia superficial de una Lista\n"
"\tdeepcopy()\t\thace una copia completa de una Lista\n"
"\tfilter()\t\telimina elementos particulares de una Lista\n"
"\tmap()\t\t\tcambia cada elemento de una Lista\n"
"\tsort()\t\t\tordena una Lista\n"
"\treverse()\t\tinvierte el orden de una Lista\n"
"\tsplit()\t\t\tdivide una cadena en una Lista\n"
"\tjoin()\t\t\tune los elementos de una Lista en una cadena\n"
"\trange()\t\t\tretorna una Lista con una secuencia de números\n"
"\tstring()\t\trepresentación de una Lista en una cadena\n"
"\tcall()\t\t\tinvoca una función con una Lista como\n"
"\t\t\t\targumentos\n"
"\tindex()\t\t\tíndice de un valor en una Lista\n"
"\tmax()\t\t\tvalor máximo en una Lista\n"
"\tmin()\t\t\tvalor mínimo en una Lista\n"
"\tcount()\t\t\tcuenta la cantidad de veces que un valor\n"
"\t\t\t\taparece en una Lista\n"
"\trepeat()\t\trepite una Lista múltiples veces\n"

#. type: Plain text
#: original/txt/usr_41.txt:651
#, no-wrap
msgid ""
"Dictionary manipulation:\t\t\t\t*dict-functions*\n"
"\tget()\t\t\tget an entry without an error for a wrong key\n"
"\tlen()\t\t\tnumber of entries in a Dictionary\n"
"\thas_key()\t\tcheck whether a key appears in a Dictionary\n"
"\tempty()\t\t\tcheck if Dictionary is empty\n"
"\tremove()\t\tremove an entry from a Dictionary\n"
"\textend()\t\tadd entries from one Dictionary to another\n"
"\tfilter()\t\tremove selected entries from a Dictionary\n"
"\tmap()\t\t\tchange each Dictionary entry\n"
"\tkeys()\t\t\tget List of Dictionary keys\n"
"\tvalues()\t\tget List of Dictionary values\n"
"\titems()\t\t\tget List of Dictionary key-value pairs\n"
"\tcopy()\t\t\tmake a shallow copy of a Dictionary\n"
"\tdeepcopy()\t\tmake a full copy of a Dictionary\n"
"\tstring()\t\tString representation of a Dictionary\n"
"\tmax()\t\t\tmaximum value in a Dictionary\n"
"\tmin()\t\t\tminimum value in a Dictionary\n"
"\tcount()\t\t\tcount number of times a value appears\n"
msgstr ""
"Manipulación de Diccionarios:\t\t\t\t*dict-functions*\n"
"\tget()\t\t\tobtiene una entrada sin generar error al usar\n"
"\t\t\t\tclaves erróneas\n"
"\tlen()\t\t\tnúmero de entradas en un Diccionario\n"
"\thas_key()\t\tcomprueba si una clave aparece en un\n"
"\t\t\t\tDiccionario\n"
"\tempty()\t\t\tcomprueba si un Diccionario está vacío\n"
"\tremove()\t\telimina una entrada de un Diccionario\n"
"\textend()\t\tañade las entradas de un Diccionario a otro\n"
"\tfilter()\t\telimina entradas particulares de un\n"
"\t\t\t\tDiccionario\n"
"\tmap()\t\t\tcambia cada entrada de un Diccionario\n"
"\tkeys()\t\t\tdevuelve una Lista con las claves de un\n"
"\t\t\t\tDiccionario\n"
"\tvalues()\t\tdevuelve una Lista con los valores de un\n"
"\t\t\t\tDiccionario\n"
"\titems()\t\t\tdevuelve una Lista de pares clave-valor de un\n"
"\t\t\t\tDiccionario\n"
"\tcopy()\t\t\thace una copia superficial de un Diccionario\n"
"\tdeepcopy()\t\thace una copia completa de un Diccionario\n"
"\tstring()\t\trepresentación de cadena de un Diccionario\n"
"\tmax()\t\t\tvalor máximo en un Diccionario\n"
"\tmin()\t\t\tvalor mínimo en un Diccionario\n"
"\tcount()\t\t\tcuenta la cantidad de veces que un valor\n"
"\t\t\t\taparece en un Diccionario\n"

#. type: Plain text
#: original/txt/usr_41.txt:665
#, no-wrap
msgid ""
"Floating point computation:\t\t\t\t*float-functions*\n"
"\tfloat2nr()\t\tconvert Float to Number\n"
"\tabs()\t\t\tabsolute value (also works for Number)\n"
"\tround()\t\t\tround off\n"
"\tceil()\t\t\tround up\n"
"\tfloor()\t\t\tround down\n"
"\ttrunc()\t\t\tremove value after decimal point\n"
"\tlog10()\t\t\tlogarithm to base 10\n"
"\tpow()\t\t\tvalue of x to the exponent y\n"
"\tsqrt()\t\t\tsquare root\n"
"\tsin()\t\t\tsine\n"
"\tcos()\t\t\tcosine\n"
"\tatan()\t\t\tarc tangent\n"
msgstr ""
"Operaciones de punto flotante:\t\t\t\t*float-functions*\n"
"\tfloat2nr()\t\tconvertir Flotante a Número\n"
"\tabs()\t\t\tvalor absoluto (también funciona para Números)\n"
"\tround()\t\t\tredondear\n"
"\tceil()\t\t\tredondear hacia arriba (techo)\n"
"\tfloor()\t\t\tredondear hacia abajo (piso)\n"
"\ttrunc()\t\t\teliminar valores después del punto decimal\n"
"\tlog10()\t\t\tlogaritmo en base 10\n"
"\tpow()\t\t\tvalor de x elevado a la y potencia\n"
"\tsqrt()\t\t\traíz cuadrada\n"
"\tsin()\t\t\tseno\n"
"\tcos()\t\t\tcoseno\n"
"\tatan()\t\t\tarcotangente\n"

#. type: Plain text
#: original/txt/usr_41.txt:679
#, no-wrap
msgid ""
"Variables:\t\t\t\t\t\t*var-functions*\n"
"\ttype()\t\t\ttype of a variable\n"
"\tislocked()\t\tcheck if a variable is locked\n"
"\tfunction()\t\tget a Funcref for a function name\n"
"\tgetbufvar()\t\tget a variable value from a specific buffer\n"
"\tsetbufvar()\t\tset a variable in a specific buffer\n"
"\tgetwinvar()\t\tget a variable from specific window\n"
"\tgettabvar()\t\tget a variable from specific tab page\n"
"\tgettabwinvar()\t\tget a variable from specific window & tab page\n"
"\tsetwinvar()\t\tset a variable in a specific window\n"
"\tsettabvar()\t\tset a variable in a specific tab page\n"
"\tsettabwinvar()\t\tset a variable in a specific window & tab page\n"
"\tgarbagecollect()\tpossibly free memory\n"
msgstr ""
"Variables:\t\t\t\t\t\t*var-functions*\n"
"\ttype()\t\t\ttipo de una variable\n"
"\tislocked()\t\tcomprueba si una variable ha sido bloqueada\n"
"\tfunction()\t\tobtiene una referencia a función para el\n"
"\t\t\t\tnombre de función dado\n"
"\tgetbufvar()\t\tobtiene una variable de un búfer específico\n"
"\tsetbufvar()\t\tdefine una variable en un búfer específico\n"
"\tgetwinvar()\t\tobtiene una variable de una ventana específica\n"
"\tgettabvar()\t\tobtiene una variable de una pestaña específica\n"
"\tgettabwinvar()\t\tobtiene una variable de una ventana y pestaña\n"
"\t\t\t\tespecíficas\n"
"\tsetwinvar()\t\tdefine una variable en una ventana\n"
"\t\t\t\tespecífica\n"
"\tsettabvar()\t\tdefine una variable en una pestaña\n"
"\t\t\t\tespecífica\n"
"\tsettabwinvar()\t\tdefine una variable en una ventana y pestaña\n"
"\t\t\t\tespecíficas\n"
"\tgarbagecollect()\tpotencialmente libera memoria\n"

#. type: Plain text
#: original/txt/usr_41.txt:692
#, no-wrap
msgid ""
"Cursor and mark position:\t\t*cursor-functions* *mark-functions*\n"
"\tcol()\t\t\tcolumn number of the cursor or a mark\n"
"\tvirtcol()\t\tscreen column of the cursor or a mark\n"
"\tline()\t\t\tline number of the cursor or mark\n"
"\twincol()\t\twindow column number of the cursor\n"
"\twinline()\t\twindow line number of the cursor\n"
"\tcursor()\t\tposition the cursor at a line/column\n"
"\tgetpos()\t\tget position of cursor, mark, etc.\n"
"\tsetpos()\t\tset position of cursor, mark, etc.\n"
"\tbyte2line()\t\tget line number at a specific byte count\n"
"\tline2byte()\t\tbyte count at a specific line\n"
"\tdiff_filler()\t\tget the number of filler lines above a line\n"
msgstr ""
"Posición de marcas y del cursor:\t*cursor-functions* *mark-functions*\n"
"\tcol()\t\t\tnúmero de columna del cursor o de una marca\n"
"\tvirtcol()\t\tnúmero de columna en pantalla del cursor o de\n"
"\t\t\t\tuna marca\n"
"\tline()\t\t\tnúmero de línea del cursor o de una marca\n"
"\twincol()\t\tnúmero de columna de ventana del cursor\n"
"\twinline()\t\tnúmero de línea de ventana del cursor\n"
"\tcursor()\t\tubica el cursor en una linea/columna\n"
"\tgetpos()\t\tobtiene la posición del cursor, marca, etc.\n"
"\tsetpos()\t\tdefine la posición del cursor, marca, etc.\n"
"\tbyte2line()\t\tobtiene el número de línea correspondiente a\n"
"\t\t\t\tun índice en bytes\n"
"\tline2byte()\t\tíndice en bytes correspondiente a una línea\n"
"\t\t\t\tespecífica\n"
"\tdiff_filler()\t\tobtiene la cantidad de líneas de relleno\n"
"\t\t\t\tencima de una línea\n"

#. type: Plain text
#: original/txt/usr_41.txt:707
#, no-wrap
msgid ""
"Working with text in the current buffer:\t\t*text-functions*\n"
"\tgetline()\t\tget a line or list of lines from the buffer\n"
"\tsetline()\t\treplace a line in the buffer\n"
"\tappend()\t\tappend line or list of lines in the buffer\n"
"\tindent()\t\tindent of a specific line\n"
"\tcindent()\t\tindent according to C indenting\n"
"\tlispindent()\t\tindent according to Lisp indenting\n"
"\tnextnonblank()\t\tfind next non-blank line\n"
"\tprevnonblank()\t\tfind previous non-blank line\n"
"\tsearch()\t\tfind a match for a pattern\n"
"\tsearchpos()\t\tfind a match for a pattern\n"
"\tsearchpair()\t\tfind the other end of a start/skip/end\n"
"\tsearchpairpos()\t\tfind the other end of a start/skip/end\n"
"\tsearchdecl()\t\tsearch for the declaration of a name\n"
msgstr ""
"Manipulación de texto en el búfer actual:\t\t*text-functions*\n"
"\tgetline()\t\tobtiene una línea o lista de líneas del búfer\n"
"\tsetline()\t\treemplaza una línea del búfer\n"
"\tappend()\t\tañade una línea o lista de líneas al búfer\n"
"\tindent()\t\tsangrado de una línea específica\n"
"\tcindent()\t\tsangrado de una línea de acuerdo al estilo\n"
"\t\t\t\tpara C\n"
"\tlispindent()\t\tsangrado de una línea de acuerdo al estilo\n"
"\t\t\t\tpara Lisp\n"
"\tnextnonblank()\t\tubica la siguiente línea no vacía\n"
"\tprevnonblank()\t\tubica la anterior línea no vacía\n"
"\tsearch()\t\t\tubica una coincidencia para un patrón\n"
"\tsearchpos()\t\tubica una coincidencia para un patrón\n"
"\tsearchpair()\t\tubica la parte correspondiente a un\n"
"\t\t\t\tinicio/medio/final\n"
"\tsearchpairpos()\tubica la parte correspondiente a un\n"
"\t\t\t\tinicio/medio/final\n"
"\tsearchdecl()\t\tbusca la declaración de un nombre\n"

#. type: Plain text
#: original/txt/usr_41.txt:735
#, no-wrap
msgid ""
"\t\t\t\t\t*system-functions* *file-functions*\n"
"System functions and manipulation of files:\n"
"\tglob()\t\t\texpand wildcards\n"
"\tglobpath()\t\texpand wildcards in a number of directories\n"
"\tfindfile()\t\tfind a file in a list of directories\n"
"\tfinddir()\t\tfind a directory in a list of directories\n"
"\tresolve()\t\tfind out where a shortcut points to\n"
"\tfnamemodify()\t\tmodify a file name\n"
"\tpathshorten()\t\tshorten directory names in a path\n"
"\tsimplify()\t\tsimplify a path without changing its meaning\n"
"\texecutable()\t\tcheck if an executable program exists\n"
"\tfilereadable()\t\tcheck if a file can be read\n"
"\tfilewritable()\t\tcheck if a file can be written to\n"
"\tgetfperm()\t\tget the permissions of a file\n"
"\tgetftype()\t\tget the kind of a file\n"
"\tisdirectory()\t\tcheck if a directory exists\n"
"\tgetfsize()\t\tget the size of a file\n"
"\tgetcwd()\t\tget the current working directory\n"
"\thaslocaldir()\t\tcheck if current window used |:lcd|\n"
"\ttempname()\t\tget the name of a temporary file\n"
"\tmkdir()\t\t\tcreate a new directory\n"
"\tdelete()\t\tdelete a file\n"
"\trename()\t\trename a file\n"
"\tsystem()\t\tget the result of a shell command\n"
"\thostname()\t\tname of the system\n"
"\treadfile()\t\tread a file into a List of lines\n"
"\twritefile()\t\twrite a List of lines into a file\n"
msgstr ""
"\t\t\t\t\t*system-functions* *file-functions*\n"
"Funciones del sistema y manipulación de archivos:\n"
"\tglob()\t\t\texpande comodines\n"
"\tglobpath()\texpande comodines en múltiples directorios\n"
"\tfindfile()\t\tubica un archivo en una lista de directorios\n"
"\tfinddir()\t\tubica un directorio en una lista de\n"
"\t\t\t\tdirectorios\n"
"\tresolve()\t\tdetermina a dónde apunta un acceso o enlace\n"
"\t\t\t\tdirecto\n"
"\tfnamemodify()\t\tmodifica un nombre de archivo\n"
"\tpathshorten()\t\tabrevia nombres de directorio en una ruta\n"
"\tsimplify()\t\tsimplifica una ruta sin cambiar su significado\n"
"\texecutable()\t\tcomprueba si un programa ejecutable existe\n"
"\tfilereadable()\t\tcomprueba si se puede leer un archivo\n"
"\tfilewritable()\t\tcomprueba si se puede escribir a un archivo\n"
"\tgetfperm()\t\tobtiene los permisos para un archivo\n"
"\tgetftype()\t\tobtiene el tipo de un archivo\n"
"\tisdirectory()\t\tcomprueba si un directorio existe\n"
"\tgetfsize()\t\tobtiene el tamaño de un archivo\n"
"\tgetcwd()\t\tobtiene el directorio de trabajo actual\n"
"\thaslocaldir()\t\tcomprueba si se ha usado |:lcd| en la ventana\n"
"\t\t\t\tactual\n"
"\ttempname()\t\tobtiene un nombre para un archivo temporal\n"
"\tmkdir()\t\t\tcrea un nuevo directorio\n"
"\tdelete()\t\tborra un archivo\n"
"\trename()\t\trenombra un archivo\n"
"\tsystem()\t\tobtiene el resultado de una orden de consola\n"
"\thostname()\t\tnombre del sistema\n"
"\treadfile()\t\tlee un archivo y devuelve una Lista de líneas\n"
"\twritefile()\t\tescribe una Lista de líneas a un archivo\n"

#. type: Plain text
#: original/txt/usr_41.txt:742
#, no-wrap
msgid ""
"Date and Time:\t\t\t\t*date-functions* *time-functions*\n"
"\tgetftime()\t\tget last modification time of a file\n"
"\tlocaltime()\t\tget current time in seconds\n"
"\tstrftime()\t\tconvert time to a string\n"
"\treltime()\t\tget the current or elapsed time accurately\n"
"\treltimestr()\t\tconvert reltime() result to a string\n"
msgstr ""
"Fecha y Hora:\t\t\t\t*date-functions* *time-functions*\n"
"\tgetftime()\t\tobtiene la hora de la última modificación de\n"
"\t\t\t\tun archivo\n"
"\tlocaltime()\t\tobtiene la hora actual en segundos\n"
"\tstrftime()\t\tconvierte la hora a una cadena\n"
"\treltime()\t\tdevuelve la hora actual o el tiempo\n"
"\t\t\t\ttranscurrido desde una hora\n"
"\treltimestr()\t\tconvierte el resultado de reltime() a una\n"
"\t\t\t\tcadena\n"

#. type: Plain text
#: original/txt/usr_41.txt:760
#, no-wrap
msgid ""
"\t\t\t*buffer-functions* *window-functions* *arg-functions*\n"
"Buffers, windows and the argument list:\n"
"\targc()\t\t\tnumber of entries in the argument list\n"
"\targidx()\t\tcurrent position in the argument list\n"
"\targv()\t\t\tget one entry from the argument list\n"
"\tbufexists()\t\tcheck if a buffer exists\n"
"\tbuflisted()\t\tcheck if a buffer exists and is listed\n"
"\tbufloaded()\t\tcheck if a buffer exists and is loaded\n"
"\tbufname()\t\tget the name of a specific buffer\n"
"\tbufnr()\t\t\tget the buffer number of a specific buffer\n"
"\ttabpagebuflist()\treturn List of buffers in a tab page\n"
"\ttabpagenr()\t\tget the number of a tab page\n"
"\ttabpagewinnr()\t\tlike winnr() for a specified tab page\n"
"\twinnr()\t\t\tget the window number for the current window\n"
"\tbufwinnr()\t\tget the window number of a specific buffer\n"
"\twinbufnr()\t\tget the buffer number of a specific window\n"
"\tgetbufline()\t\tget a list of lines from the specified buffer\n"
msgstr ""
"\t\t\t*buffer-functions* *window-functions* *arg-functions*\n"
"Búferes, ventanas, y la lista de argumentos:\n"
"\targc()\t\t\tnúmero de entradas en la lista de argumentos\n"
"\targidx()\t\tposición actual en la lista de argumentos\n"
"\targv()\t\t\tobtiene un elemento de la lista de argumentos\n"
"\tbufexists()\t\tcomprueba si un búfer existe\n"
"\tbuflisted()\t\tcomprueba si un búfer existe y está listado\n"
"\tbufloaded()\t\tcomprueba si un búfer existe y está cargado\n"
"\tbufname()\t\tobtiene el nombre de un búfer específico\n"
"\tbufnr()\t\t\tobtiene el número de búfer de un búfer\n"
"\t\t\t\tespecífico\n"
"\ttabpagebuflist()\tdevuelve la Lista de búfers de una pestaña\n"
"\ttabpagenr()\t\tobtiene el número de una pestaña\n"
"\ttabpagewinnr()\t\tsimilar a winnr(), pero especificando la\n"
"\t\t\t\tpestaña\n"
"\twinnr()\t\t\tobtiene el número de ventana de la ventana\n"
"\t\t\t\tactual\n"
"\tbufwinnr()\t\tobtiene el número de ventana del búfer\n"
"\t\t\t\tespecificado\n"
"\twinbufnr()\t\tobtiene el número de búfer de una ventana\n"
"\t\t\t\tespecífica\n"
"\tgetbufline()\t\tobtiene una lista de líneas del búfer\n"
"\t\t\t\tespecificado\n"

#. type: Plain text
#: original/txt/usr_41.txt:766
#, no-wrap
msgid ""
"Command line:\t\t\t\t\t*command-line-functions*\n"
"\tgetcmdline()\t\tget the current command line\n"
"\tgetcmdpos()\t\tget position of the cursor in the command line\n"
"\tsetcmdpos()\t\tset position of the cursor in the command line\n"
"\tgetcmdtype()\t\treturn the current command-line type\n"
msgstr ""
"Línea de órdenes:\t\t\t\t*command-line-functions*\n"
"\tgetcmdline()\t\tobtiene la línea de órdenes actual\n"
"\tgetcmdpos()\t\tobtiene la posición del cursor en la línea de\n"
"\t\t\t\tórdenes\n"
"\tsetcmdpos()\t\tcambia la posición del cursor en la línea de\n"
"\t\t\t\tórdenes\n"
"\tgetcmdtype()\t\tdevuelve el tipo de la línea de órdenes actual\n"

#. type: Plain text
#: original/txt/usr_41.txt:772
#, no-wrap
msgid ""
"Quickfix and location lists:\t\t\t*quickfix-functions*\n"
"\tgetqflist()\t\tlist of quickfix errors\n"
"\tsetqflist()\t\tmodify a quickfix list\n"
"\tgetloclist()\t\tlist of location list items\n"
"\tsetloclist()\t\tmodify a location list\n"
msgstr ""
"Listas de corrección rápida y de ubicación:\t\t*quickfix-functions*\n"
"\tgetqflist()\t\tobtiene una lista de errores de corrección\n"
"\t\t\t\trápida\n"
"\tsetqflist()\t\tmodifica una lista de corrección rápida\n"
"\tgetloclist()\tobtiene la lista de elementos de una lista de\n"
"\t\t\t\tubicación\n"
"\tsetloclist()\t\tmodifica una lista de ubicación\n"

#. type: Plain text
#: original/txt/usr_41.txt:778
#, no-wrap
msgid ""
"Insert mode completion:\t\t\t\t*completion-functions*\n"
"\tcomplete()\t\tset found matches\n"
"\tcomplete_add()\t\tadd to found matches\n"
"\tcomplete_check()\tcheck if completion should be aborted\n"
"\tpumvisible()\t\tcheck if the popup menu is displayed\n"
msgstr ""
"Completado automático en modo Insertar:\t\t*completion-functions*\n"
"\tcomplete()\t\tdefine coincidencias encontradas\n"
"\tcomplete_add()\t\tañade elementos a la lista de coincidencias\n"
"\t\t\t\tencontradas\n"
"\tcomplete_check()\tcomprueba si debería interrumpir el\n"
"\t\t\t\tcompletado\n"
"\tpumvisible()\t\tcomprueba si se está mostrando el menú\n"
"\t\t\t\tcontextual\n"

#. type: Plain text
#: original/txt/usr_41.txt:785
#, no-wrap
msgid ""
"Folding:\t\t\t\t\t*folding-functions*\n"
"\tfoldclosed()\t\tcheck for a closed fold at a specific line\n"
"\tfoldclosedend()\t\tlike foldclosed() but return the last line\n"
"\tfoldlevel()\t\tcheck for the fold level at a specific line\n"
"\tfoldtext()\t\tgenerate the line displayed for a closed fold\n"
"\tfoldtextresult()\tget the text displayed for a closed fold\n"
msgstr ""
"Plegado:\t\t\t\t\t*folding-functions*\n"
"\tfoldclosed()\t\tcomprueba si hay un pliegue cerrado en una\n"
"\t\t\t\tlínea específica\n"
"\tfoldclosedend()\tsimilar a foldclosed() pero devuelve la última\n"
"\t\t\t\tlínea\n"
"\tfoldlevel()\t\tobtiene el nivel de plegado de la línea\n"
"\t\t\t\tespecificada\n"
"\tfoldtext()\t\tgenera el texto mostrado en un pliegue cerrado\n"
"\tfoldtextresult()\tobtiene el texto mostrado en un pliegue\n"
"\t\t\t\tcerrado\n"

#. type: Plain text
#: original/txt/usr_41.txt:803
#, no-wrap
msgid ""
"Syntax and highlighting:\t  *syntax-functions* *highlighting-functions*\n"
"\tclearmatches()\t\tclear all matches defined by |matchadd()| and\n"
"\t\t\t\tthe |:match| commands\n"
"\tgetmatches()\t\tget all matches defined by |matchadd()| and\n"
"\t\t\t\tthe |:match| commands\n"
"\thlexists()\t\tcheck if a highlight group exists\n"
"\thlID()\t\t\tget ID of a highlight group\n"
"\tsynID()\t\t\tget syntax ID at a specific position\n"
"\tsynIDattr()\t\tget a specific attribute of a syntax ID\n"
"\tsynIDtrans()\t\tget translated syntax ID\n"
"\tdiff_hlID()\t\tget highlight ID for diff mode at a position\n"
"\tmatchadd()\t\tdefine a pattern to highlight (a \"match\")\n"
"\tmatcharg()\t\tget info about |:match| arguments\n"
"\tmatchdelete()\t\tdelete a match defined by |matchadd()| or a\n"
"\t\t\t\t|:match| command\n"
"\tsetmatches()\t\trestore a list of matches saved by\n"
"\t\t\t\t|getmatches()|\n"
msgstr ""
"Sintaxis y resaltado:\t  *syntax-functions* *highlighting-functions*\n"
"\tclearmatches()\telimina las coincidencias definidas por\n"
"\t\t\t\t|matchadd()| y las órdenes |:match|\n"
"\tgetmatches()\t\tobtiene todas las coincidencias definidas por\n"
"\t\t\t\t|matchadd()| y las órdenes |:match|\n"
"\thlexists()\t\tcomprueba la existencia de un grupo de\n"
"\t\t\t\tresaltado\n"
"\thlID()\t\t\tobtiene el ID de un grupo de resaltado\n"
"\tsynID()\t\t\tobtiene el ID de sintaxis en una posición\n"
"\t\t\t\tespecífica\n"
"\tsynIDattr()\t\tobtiene un atributo específico correspondiente\n"
"\t\t\t\ta un ID de sintaxis\n"
"\tsynIDtrans()\t\tobtiene un ID de sintaxis traducido\n"
"\tdiff_hlID()\t\tobtiene el ID de resaltado para el modo diff\n"
"\t\t\t\ten una posición dada\n"
"\tmatchadd()\t\tdefine un patrón a resaltar (una\n"
"\t\t\t\t«coincidencia»)\n"
"\tmatcharg()\t\tobtiene información acerca de los argumentos\n"
"\t\t\t\tpara |:match|\n"
"\tmatchdelete()\t\tborra una coincidencia definida por\n"
"\t\t\t\t|matchadd()| o una orden |:match|\n"
"\tsetmatches()\t\trestaura una lista de coincidencias guardada\n"
"\t\t\t\tpor |getmatches()|\n"

#. type: Plain text
#: original/txt/usr_41.txt:808
#, no-wrap
msgid ""
"Spelling:\t\t\t\t\t*spell-functions*\n"
"\tspellbadword()\t\tlocate badly spelled word at or after cursor\n"
"\tspellsuggest()\t\treturn suggested spelling corrections\n"
"\tsoundfold()\t\treturn the sound-a-like equivalent of a word\n"
msgstr ""
"Corrección ortográfica:\t\t\t\t\t*spell-functions*\n"
"\tspellbadword()\t\tubica palabras mal escritas a partir de la\n"
"\t\t\t\tposición actual del cursor\n"
"\tspellsuggest()\t\tdevuelve las correcciones ortográficas\n"
"\t\t\t\tsugeridas\n"
"\tsoundfold()\t\tretorna el homófono de una palabra\n"

#. type: Plain text
#: original/txt/usr_41.txt:814
#, no-wrap
msgid ""
"History:\t\t\t\t\t*history-functions*\n"
"\thistadd()\t\tadd an item to a history\n"
"\thistdel()\t\tdelete an item from a history\n"
"\thistget()\t\tget an item from a history\n"
"\thistnr()\t\tget highest index of a history list\n"
msgstr ""
"Historial:\t\t\t\t\t*history-functions*\n"
"\thistadd()\t\tañade un elemento a la historial\n"
"\thistdel()\t\telimina un elemento al historial\n"
"\thistget()\t\tobtiene un elemento al historial\n"
"\thistnr()\t\tobtiene el índice más grande de la lista de un\n"
"\t\t\t\thistorial\n"

#. type: Plain text
#: original/txt/usr_41.txt:828
#, no-wrap
msgid ""
"Interactive:\t\t\t\t\t*interactive-functions*\n"
"\tbrowse()\t\tput up a file requester\n"
"\tbrowsedir()\t\tput up a directory requester\n"
"\tconfirm()\t\tlet the user make a choice\n"
"\tgetchar()\t\tget a character from the user\n"
"\tgetcharmod()\t\tget modifiers for the last typed character\n"
"\tfeedkeys()\t\tput characters in the typeahead queue\n"
"\tinput()\t\t\tget a line from the user\n"
"\tinputlist()\t\tlet the user pick an entry from a list\n"
"\tinputsecret()\t\tget a line from the user without showing it\n"
"\tinputdialog()\t\tget a line from the user in a dialog\n"
"\tinputsave()\t\tsave and clear typeahead\n"
"\tinputrestore()\t\trestore typeahead\n"
msgstr ""
"Interacción:\t\t\t\t\t*interactive-functions*\n"
"\tbrowse()\t\tdespliega un diálogo de selección de archivos\n"
"\tbrowsedir()\t\tdespliega un diálogo de selección de\n"
"\t\t\t\tdirectorios\n"
"\tconfirm()\t\tsolicita al usuario hacer una elección\n"
"\tgetchar()\t\tsolicita un carácter al usuario\n"
"\tgetcharmod()\t\tobtiene los modificadores usados en el último\n"
"\t\t\t\tcarácter digitado\n"
"\tfeedkeys()\t\tinserta caracteres en la cola de inserción\n"
"\tinput()\t\t\tsolicita una línea de texto al usuario\n"
"\tinputlist()\t\tpermite al usuario elegir un elemento de una\n"
"\t\t\t\tlista\n"
"\tinputsecret()\t\tsolicita una línea de texto al usuario, sin\n"
"\t\t\t\tmostrarla\n"
"\tinputdialog()\t\tsolicita una línea de texto al usuario usando\n"
"\t\t\t\tun diálogo\n"
"\tinputsave()\t\tguarda y limpia el búfer de cola de inserción\n"
"\tinputrestore()\t\trestaura el búfer de la línea de inserción\n"

#. type: Plain text
#: original/txt/usr_41.txt:833
#, no-wrap
msgid ""
"GUI:\t\t\t\t\t\t*gui-functions*\n"
"\tgetfontname()\t\tget name of current font being used\n"
"\tgetwinposx()\t\tX position of the GUI Vim window\n"
"\tgetwinposy()\t\tY position of the GUI Vim window\n"
msgstr ""
"Interfaz gráfica:\t\t\t\t\t*gui-functions*\n"
"\tgetfontname()\t\tobtiene el nombre del tipo de letra actual\n"
"\tgetwinposx()\t\tposición X de la ventana gráfica de Vim\n"
"\tgetwinposy()\t\tposición Y de la ventana gráfica de Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:843
#, no-wrap
msgid ""
"Vim server:\t\t\t\t\t*server-functions*\n"
"\tserverlist()\t\treturn the list of server names\n"
"\tremote_send()\t\tsend command characters to a Vim server\n"
"\tremote_expr()\t\tevaluate an expression in a Vim server\n"
"\tserver2client()\t\tsend a reply to a client of a Vim server\n"
"\tremote_peek()\t\tcheck if there is a reply from a Vim server\n"
"\tremote_read()\t\tread a reply from a Vim server\n"
"\tforeground()\t\tmove the Vim window to the foreground\n"
"\tremote_foreground()\tmove the Vim server window to the foreground\n"
msgstr ""
"Servidor Vim:\t\t\t\t\t*server-functions*\n"
"\tserverlist()\t\tdevuelve una lista con nombres de servidores\n"
"\tremote_send()\t\tenvía órdenes (caracteres) a un servidor Vim\n"
"\tremote_expr()\t\tevalúa una expresión en un servidor Vim\n"
"\tserver2client()\t\tenvía una respuesta a un cliente de un\n"
"\t\t\t\tservidor Vim\n"
"\tremote_peek()\t\tcomprueba si hay respuestas de un servidor Vim\n"
"\tremote_read()\t\tlee una respuesta de un servidor Vim\n"
"\tforeground()\t\tdesplaza la ventana de Vim a primer plano\n"
"\tremote_foreground()\tdesplaza la ventana de un servidor Vim a\n"
"\t\t\t\tprimer plano\n"

#. type: Plain text
#: original/txt/usr_41.txt:850
#, no-wrap
msgid ""
"Window size and position:\t\t\t*window-size-functions*\n"
"\twinheight()\t\tget height of a specific window\n"
"\twinwidth()\t\tget width of a specific window\n"
"\twinrestcmd()\t\treturn command to restore window sizes\n"
"\twinsaveview()\t\tget view of current window\n"
"\twinrestview()\t\trestore saved view of current window\n"
msgstr ""
"Tamaño y posición de ventanas:\t\t\t*window-size-functions*\n"
"\twinheight()\t\tobtiene la altura de una ventana específica\n"
"\twinwidth()\t\tobtiene el ancho de una ventana específica\n"
"\twinrestcmd()\t\tdevuelve una orden para restaurar los tamaños\n"
"\t\t\t\tde ventana\n"
"\twinsaveview()\t\tobtiene una vista de la ventana actual\n"
"\twinrestview()\t\tdevuelve una vista almacenada en la ventana\n"
"\t\t\t\tactual\n"

#. type: Plain text
#: original/txt/usr_41.txt:864
#, no-wrap
msgid ""
"Various:\t\t\t\t\t*various-functions*\n"
"\tmode()\t\t\tget current editing mode\n"
"\tvisualmode()\t\tlast visual mode used\n"
"\thasmapto()\t\tcheck if a mapping exists\n"
"\tmapcheck()\t\tcheck if a matching mapping exists\n"
"\tmaparg()\t\tget rhs of a mapping\n"
"\texists()\t\tcheck if a variable, function, etc. exists\n"
"\thas()\t\t\tcheck if a feature is supported in Vim\n"
"\tchangenr()\t\treturn number of most recent change\n"
"\tcscope_connection()\tcheck if a cscope connection exists\n"
"\tdid_filetype()\t\tcheck if a FileType autocommand was used\n"
"\teventhandler()\t\tcheck if invoked by an event handler\n"
"\tgetpid()\t\tget process ID of Vim\n"
msgstr ""
"Varios:\t\t\t\t\t*various-functions*\n"
"\tmode()\t\t\tobtiene el modo de edición actual\n"
"\tvisualmode()\t\túltimo modo visual usado\n"
"\thasmapto()\t\tcomprueba la existencia de una macro\n"
"\tmapcheck()\t\tcomprueba la existencia de una macro que\n"
"\t\t\t\tcoincida con el argumento dado\n"
"\tmaparg()\t\tobtiene el rhs de una macro\n"
"\texists()\t\tcomprueba si la variable, función, etc.,\n"
"\t\t\t\texiste\n"
"\thas()\t\t\tcomprueba si Vim cuenta con la característica\n"
"\t\t\t\tdada\n"
"\tchangenr()\t\tdevuelve el número correspondiente al cambio\n"
"\t\t\t\tmás reciente\n"
"\tcscope_connection()\tcomprueba si hay una conexión a cscope\n"
"\tdid_filetype()\t\tcomprueba si se ha usado una orden automática\n"
"\t\t\t\tFileType\n"
"\teventhandler()\t\tcomprueba si se ha sido invocado desde un\n"
"\t\t\t\tmanejador de eventos\n"
"\tgetpid()\t\tobtiene el ID de proceso de Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:867
#, no-wrap
msgid ""
"\tlibcall()\t\tcall a function in an external library\n"
"\tlibcallnr()\t\tidem, returning a number\n"
msgstr ""
"\tlibcall()\t\tllama a una función en una biblioteca externa\n"
"\tlibcallnr()\t\tidéntica, pero devuelve un número en vez de\n"
"\t\t\t\tuna cadena\n"

#. type: Plain text
#: original/txt/usr_41.txt:871
#, no-wrap
msgid ""
"\tgetreg()\t\tget contents of a register\n"
"\tgetregtype()\t\tget type of a register\n"
"\tsetreg()\t\tset contents and type of a register\n"
msgstr ""
"\tgetreg()\t\tobtiene el contenido de un registro\n"
"\tgetregtype()\t\tobtiene el tipo de un registro\n"
"\tsetreg()\t\tasigna el tipo y contenido de un registro\n"

#. type: Plain text
#: original/txt/usr_41.txt:874
#, no-wrap
msgid ""
"\ttaglist()\t\tget list of matching tags\n"
"\ttagfiles()\t\tget a list of tags files\n"
msgstr ""
"\ttaglist()\t\tobtiene una lista de etiquetas coincidentes\n"
"\ttagfiles()\t\tobtiene una lista de archivos de etiquetas\n"

#. type: Plain text
#: original/txt/usr_41.txt:876
#, no-wrap
msgid "\tmzeval()\t\tevaluate |MzScheme| expression\n"
msgstr "\tmzeval()\t\tevalúa una expresión |MzScheme|\n"

#. type: Plain text
#: original/txt/usr_41.txt:879
#, no-wrap
msgid "*41.7*\tDefining a function\n"
msgstr "*41.7*\tDefinición de funciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:882
msgid ""
"Vim enables you to define your own functions.  The basic function "
"declaration begins as follows: >"
msgstr ""
"Vim permite definir nuevas funciones. La definición básica de una función "
"corresponde a lo siguiente: >"

#. type: Plain text
#: original/txt/usr_41.txt:889
#, no-wrap
msgid ""
"\t:function {name}({var1}, {var2}, ...)\n"
"\t:  {body}\n"
"\t:endfunction\n"
"<\n"
"\tNote:\n"
"\tFunction names must begin with a capital letter.\n"
msgstr ""
"\t:function {nombre}({var1}, {var2}, ...)\n"
"\t:  {instrucciones}\n"
"\t:endfunction\n"
"<\n"
"\tNota:\n"
"\tLos nombres de funciones deben empezar con una letra mayúscula.\n"

#. type: Plain text
#: original/txt/usr_41.txt:892
msgid ""
"Let's define a short function to return the smaller of two numbers.  It "
"starts with this line: >"
msgstr ""
"Vamos a definir una función pequeña que retorne el más pequeño de dos "
"números. Su definición empieza con esta línea: >"

#. type: Plain text
#: original/txt/usr_41.txt:894
#, no-wrap
msgid "\t:function Min(num1, num2)\n"
msgstr "\t:function Min(num1, num2)\n"

#. type: Plain text
#: original/txt/usr_41.txt:900
#, no-wrap
msgid ""
"This tells Vim that the function is named \"Min\" and it takes two arguments:\n"
"\"num1\" and \"num2\".\n"
"   The first thing you need to do is to check to see which number is smaller:\n"
"   >\n"
"\t:  if a:num1 < a:num2\n"
msgstr ""
"Ésta le indica a Vim que la función se llama «Min» y que recibe dos\n"
"argumentos: «num1» y «num2».\n"
"   El primer paso es comprobar qué número es el más pequeño:\n"
"   >\n"
"\t:   if a:num1 < a:num2\n"

#. type: Plain text
#: original/txt/usr_41.txt:903
msgid ""
"The special prefix \"a:\" tells Vim that the variable is a function "
"argument.  Let's assign the variable \"smaller\" the value of the smallest "
"number: >"
msgstr ""
"El prefijo especial «a:» le indica a Vim que la variable es un argumento de "
"la función. Asignemos ahora a la variable «menor» el valor del menor número: "
">"

#. type: Plain text
#: original/txt/usr_41.txt:909
#, no-wrap
msgid ""
"\t:  if a:num1 < a:num2\n"
"\t:    let smaller = a:num1\n"
"\t:  else\n"
"\t:    let smaller = a:num2\n"
"\t:  endif\n"
msgstr ""
"\t:  if a:num1 < a:num2\n"
"\t:    let menor = a:num1\n"
"\t:  else\n"
"\t:    let menor = a:num2\n"
"\t:  endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:912
msgid ""
"The variable \"smaller\" is a local variable.  Variables used inside a "
"function are local unless prefixed by something like \"g:\", \"a:\", or \"s:"
"\"."
msgstr ""
"La variable «menor» es una variable local. Las variables usadas dentro de "
"una función son locales a menos que tengan un prefijo como «g:», «a:», o "
"«s:»."

#. type: Plain text
#: original/txt/usr_41.txt:918
#, no-wrap
msgid ""
"\tNote:\n"
"\tTo access a global variable from inside a function you must prepend\n"
"\t\"g:\" to it.  Thus \"g:today\" inside a function is used for the global\n"
"\tvariable \"today\", and \"today\" is another variable, local to the\n"
"\tfunction.\n"
msgstr ""
"\tNota:\n"
"\tPara usar una variable global dentro de una función debe anteponer\n"
"\t«g:» a su nombre. Dentro de una función, «g:hoy» corresponde a la\n"
"\tvariable global «hoy», y «hoy» es otra variable, local respecto a la\n"
"\tfunción.\n"

#. type: Plain text
#: original/txt/usr_41.txt:921
msgid ""
"You now use the \":return\" statement to return the smallest number to the "
"user.  Finally, you end the function: >"
msgstr ""
"Ahora usamos la instrucción «:return» para devolver el menor de los dos "
"números al usuario. Finalmente, terminamos la función: >"

#. type: Plain text
#: original/txt/usr_41.txt:924
#, no-wrap
msgid ""
"\t:  return smaller\n"
"\t:endfunction\n"
msgstr ""
"\t:  return menor\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:926
msgid "The complete function definition is as follows: >"
msgstr "La función completa es la siguiente: >"

#. type: Plain text
#: original/txt/usr_41.txt:935
#, no-wrap
msgid ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    let smaller = a:num1\n"
"\t:  else\n"
"\t:    let smaller = a:num2\n"
"\t:  endif\n"
"\t:  return smaller\n"
"\t:endfunction\n"
msgstr ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    let menor = a:num1\n"
"\t:  else\n"
"\t:    let menor = a:num2\n"
"\t:  endif\n"
"\t:  return menor\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:937
msgid "For people who like short functions, this does the same thing: >"
msgstr ""
"Para los aficionados a las funciones cortas, lo siguiente es equivalente: >"

#. type: Plain text
#: original/txt/usr_41.txt:944
#, no-wrap
msgid ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    return a:num1\n"
"\t:  endif\n"
"\t:  return a:num2\n"
"\t:endfunction\n"
msgstr ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    return a:num1\n"
"\t:  endif\n"
"\t:  return a:num2\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:948
msgid ""
"A user defined function is called in exactly the same way as a built-in "
"function.  Only the name is different.  The Min function can be used like "
"this: >"
msgstr ""
"Las funciones definidas por el usuario se invocan exactamente de la misma "
"forma que las funciones internas. La única diferencia es el nombre. Puede "
"usar la función Min como sigue: >"

#. type: Plain text
#: original/txt/usr_41.txt:950
#, no-wrap
msgid "\t:echo Min(5, 8)\n"
msgstr "\t:echo Min(5, 8)\n"

#. type: Plain text
#: original/txt/usr_41.txt:955
msgid ""
"Only now will the function be executed and the lines be interpreted by Vim.  "
"If there are mistakes, like using an undefined variable or function, you "
"will now get an error message.  When defining the function these errors are "
"not detected."
msgstr ""
"Sólo en este momento se ejecutará la función y Vim interpretará las "
"instrucciones que la componen. Si hay errores, como usar una variable o "
"función no definida, se mostrará un mensaje de error. Al definir una función "
"estos errores no son detectados."

#. type: Plain text
#: original/txt/usr_41.txt:958
msgid ""
"When a function reaches \":endfunction\" or \":return\" is used without an "
"argument, the function returns zero."
msgstr ""
"Cuando una función llega a «:endfunction» o cuando se usa «:return» sin un "
"argumento, se retorna cero."

#. type: Plain text
#: original/txt/usr_41.txt:961
msgid ""
"To redefine a function that already exists, use the ! for the \":function\" "
"command: >"
msgstr "Para redefinir una función existente, use ! en la orden «:function»: >"

#. type: Plain text
#: original/txt/usr_41.txt:963
#, no-wrap
msgid "\t:function!  Min(num1, num2, num3)\n"
msgstr "\t:function!  Min(num1, num2, num3)\n"

#. type: Plain text
#: original/txt/usr_41.txt:966
msgid "USING A RANGE"
msgstr "USO DE RANGOS"

#. type: Plain text
#: original/txt/usr_41.txt:973
#, no-wrap
msgid ""
"The \":call\" command can be given a line range.  This can have one of two\n"
"meanings.  When a function has been defined with the \"range\" keyword, it will\n"
"take care of the line range itself.\n"
"  The function will be passed the variables \"a:firstline\" and \"a:lastline\".\n"
"These will have the line numbers from the range the function was called with.\n"
"Example: >\n"
msgstr ""
"La orden «:call» puede recibir un rango de líneas. Este rango puede tener dos\n"
"significados. Cuando la definición de una función tiene la palabra clave\n"
"«range», ésta se hará cargo del rango de líneas.\n"
"   La función recibirá las variables «a:firstline» y «a:lastline». Éstas\n"
"contendrán los números de línea del rango con el cual se invoca la función.\n"
"Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:983
#, no-wrap
msgid ""
"\t:function Count_words() range\n"
"\t:  let lnum = a:firstline\n"
"\t:  let n = 0\n"
"\t:  while lnum <= a:lastline\n"
"\t:    let n = n + len(split(getline(lnum)))\n"
"\t:    let lnum = lnum + 1\n"
"\t:  endwhile\n"
"\t:  echo \"found \" . n . \" words\"\n"
"\t:endfunction\n"
msgstr ""
"\t:function Contar_palabras() range\n"
"\t:  let lnum = a:firstline\n"
"\t:  let n = 0\n"
"\t:  while lnum <= a:lastline\n"
"\t:    let n = n + len(split(getline(lnum)))\n"
"\t:    let lnum = lnum + 1\n"
"\t:  endwhile\n"
"\t:  echo \"encontradas \" . n . \" palabras\"\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:985
msgid "You can call this function with: >"
msgstr "Puede invocar la función con: >"

#. type: Plain text
#: original/txt/usr_41.txt:987
#, no-wrap
msgid "\t:10,30call Count_words()\n"
msgstr "\t:10,30call Contar_palabras()\n"

#. type: Plain text
#: original/txt/usr_41.txt:992
#, no-wrap
msgid ""
"It will be executed once and echo the number of words.\n"
"   The other way to use a line range is by defining a function without the\n"
"\"range\" keyword.  The function will be called once for every line in the\n"
"range, with the cursor in that line.  Example: >\n"
msgstr ""
"La función se ejecutará una vez, y mostrará en la pantalla el número de\n"
"palabras.\n"
"   La otra forma de usar un rango de líneas es definiendo una función sin la\n"
"palabra clave «range». Se invocará la función una vez por cada línea en el\n"
"rango, y el cursor estará en la línea correspondiente a cada invocación.\n"
"Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:996
#, no-wrap
msgid ""
"\t:function  Number()\n"
"\t:  echo \"line \" . line(\".\") . \" contains: \" . getline(\".\")\n"
"\t:endfunction\n"
msgstr ""
"\t:function  Numero()\n"
"\t:  echo \"la línea \" . line(\".\") . \" contiene: \" . getline(\".\")\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:998
msgid "If you call this function with: >"
msgstr "Si invoca esta función con: >"

#. type: Plain text
#: original/txt/usr_41.txt:1000
#, no-wrap
msgid "\t:10,15call Number()\n"
msgstr "\t:10,15call Numero()\n"

#. type: Plain text
#: original/txt/usr_41.txt:1002
msgid "The function will be called six times."
msgstr "Se invocará la función seis veces."

#. type: Plain text
#: original/txt/usr_41.txt:1005
msgid "VARIABLE NUMBER OF ARGUMENTS"
msgstr "NÚMERO VARIABLE DE ARGUMENTOS"

#. type: Plain text
#: original/txt/usr_41.txt:1009
msgid ""
"Vim enables you to define functions that have a variable number of "
"arguments.  The following command, for instance, defines a function that "
"must have 1 argument (start) and can have up to 20 additional arguments: >"
msgstr ""
"Vim permite la definición de funciones que reciben una cantidad variable de "
"argumentos. Por ejemplo, la siguiente orden define una función que debe "
"recibir un argumento (inicio) y puede recibir hasta 20 argumentos "
"adicionales: >"

#. type: Plain text
#: original/txt/usr_41.txt:1011
#, no-wrap
msgid "\t:function Show(start, ...)\n"
msgstr "\t:function Mostrar(inicio, ...)\n"

#. type: Plain text
#: original/txt/usr_41.txt:1015
#, no-wrap
msgid ""
"The variable \"a:1\" contains the first optional argument, \"a:2\" the second, and\n"
"so on.  The variable \"a:0\" contains the number of extra arguments.\n"
"   For example: >\n"
msgstr ""
"La variable «a:1» contiene el primer argumento opcional, «a:2» contiene el\n"
"segundo, y así sucesivamente. La variable «a:0» contiene la cantidad de\n"
"argumentos adicionales.\n"
"   Por ejemplo: >\n"

# TODO check for bugs in the doc: it isn't "Show is ... a:start", but "start
# is" a:start
#. type: Plain text
#: original/txt/usr_41.txt:1027
#, no-wrap
msgid ""
"\t:function Show(start, ...)\n"
"\t:  echohl Title\n"
"\t:  echo \"Show is \" . a:start\n"
"\t:  echohl None\n"
"\t:  let index = 1\n"
"\t:  while index <= a:0\n"
"\t:    echo \"  Arg \" . index . \" is \" . a:{index}\n"
"\t:    let index = index + 1\n"
"\t:  endwhile\n"
"\t:  echo \"\"\n"
"\t:endfunction\n"
msgstr ""
"\t:function Mostrar(inicio, ...)\n"
"\t:  echohl Title\n"
"\t:  echo \"inicio es \" . a:inicio\n"
"\t:  echohl None\n"
"\t:  let indice = 1\n"
"\t:  while indice <= a:0\n"
"\t:    echo \"  Arg \" . indice . \" is \" . a:{indice}\n"
"\t:    let indice = indice + 1\n"
"\t:  endwhile\n"
"\t:  echo \"\"\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:1031
msgid ""
"This uses the \":echohl\" command to specify the highlighting used for the "
"following \":echo\" command.  \":echohl None\" stops it again.  The \":echon"
"\" command works like \":echo\", but doesn't output a line break."
msgstr ""
"Aquí se usa la orden «:echohl», que especifica el resaltado a usar en la "
"siguiente orden «:echo». «:echohl None» hace que no se use resaltado alguno. "
"La orden  «:echon» es similar a «:echo» pero no imprime el cambio de línea "
"final."

#. type: Plain text
#: original/txt/usr_41.txt:1034
msgid ""
"You can also use the a:000 variable, it is a List of all the \"...\" "
"arguments.  See |a:000|."
msgstr ""
"También puede usar la variable a:000. Es una Lista de todos los argumentos "
"opcionales («...»). Consulte |a:000|."

#. type: Plain text
#: original/txt/usr_41.txt:1037
msgid "LISTING FUNCTIONS"
msgstr "LISTAR FUNCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:1040
msgid ""
"The \":function\" command lists the names and arguments of all user-defined "
"functions: >"
msgstr ""
"La orden «:function» muestra una lista con los nombres y argumentos de todas "
"las funciones definidas por el usuario (esto incluye funciones de scripts y "
"extensiones instalados)."

#. type: Plain text
#: original/txt/usr_41.txt:1045
#, no-wrap
msgid ""
"\t:function\n"
"<\tfunction Show(start, ...) ~\n"
"\tfunction GetVimIndent() ~\n"
"\tfunction SetSyn(name) ~\n"
msgstr ""
"\t:function\n"
"<\tfunction Mostrar(inicio, ...) ~\n"
"\tfunction ObtenerSangradoVim() ~\n"
"\tfunction DefinirSintaxis(nombre) ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1047
msgid ""
"To see what a function does, use its name as an argument for \":function\": >"
msgstr ""
"Para ver la definición de una función, introduzca su nombre como argumento a "
"la orden «:function»: >"

#. type: Plain text
#: original/txt/usr_41.txt:1053
#, no-wrap
msgid ""
"\t:function SetSyn\n"
"<\t1     if &syntax == '' ~\n"
"\t2       let &syntax = a:name ~\n"
"\t3     endif ~\n"
"\t   endfunction ~\n"
msgstr ""
"\t:function DefinirSintaxis\n"
"<\t1     if &syntax == '' ~\n"
"\t2       let &syntax = a:nombre ~\n"
"\t3     endif ~\n"
"\t   endfunction ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1056
msgid "DEBUGGING"
msgstr "DEPURACIÓN"

#. type: Plain text
#: original/txt/usr_41.txt:1061
#, no-wrap
msgid ""
"The line number is useful for when you get an error message or when debugging.\n"
"See |debug-scripts| about debugging mode.\n"
"   You can also set the 'verbose' option to 12 or higher to see all function\n"
"calls.  Set it to 15 or higher to see every executed line.\n"
msgstr ""
"El número de línea de una instrucción es información útil cuando aparece un\n"
"mensaje de error o al depurar scripts. Acerca del modo de depurado,\n"
"consulte |debug-scripts|.\n"
"   Puede darle un valor de 12 o más a la opción 'verbose' para ver todas las\n"
"invocaciones a funciones. Con un valor de 15 o más verá cada línea ejecutada.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1064
msgid "DELETING A FUNCTION"
msgstr "ELIMINAR FUNCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:1066
msgid "To delete the Show() function: >"
msgstr "Para eliminar la función Mostrar(): >"

#. type: Plain text
#: original/txt/usr_41.txt:1068
#, no-wrap
msgid "\t:delfunction Show\n"
msgstr "\t:delfunction Mostrar\n"

#. type: Plain text
#: original/txt/usr_41.txt:1070
msgid "You get an error when the function doesn't exist."
msgstr "Si la función no existe obtendrá un error al usar esta orden."

#. type: Plain text
#: original/txt/usr_41.txt:1073
msgid "FUNCTION REFERENCES"
msgstr "REFERENCIAS A FUNCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:1077
msgid ""
"Sometimes it can be useful to have a variable point to one function or "
"another.  You can do it with the function() function.  It turns the name of "
"a function into a reference: >"
msgstr ""
"En ocasiones es útil que una variable pueda hacer referencia a una u otra "
"función . Puede hacerlo usando la función function(). Ésta función convierte "
"el nombre de una función en una referencia a la misma: >"

#. type: Plain text
#: original/txt/usr_41.txt:1093
#, no-wrap
msgid ""
"\t:let result = 0\t\t\" or 1\n"
"\t:function! Right()\n"
"\t:  return 'Right!'\n"
"\t:endfunc\n"
"\t:function! Wrong()\n"
"\t:  return 'Wrong!'\n"
"\t:endfunc\n"
"\t:\n"
"\t:if result == 1\n"
"\t:  let Afunc = function('Right')\n"
"\t:else\n"
"\t:  let Afunc = function('Wrong')\n"
"\t:endif\n"
"\t:echo call(Afunc, [])\n"
"<\tWrong! ~\n"
msgstr ""
"\t:let resultado = 0\t\t\" o 1\n"
"\t:function! Bien()\n"
"\t:  return '¡Bien!'\n"
"\t:endfunc\n"
"\t:function! Mal()\n"
"\t:  return '¡Mal!'\n"
"\t:endfunc\n"
"\t:\n"
"\t:if resultado == 1\n"
"\t:  let Unafunc = function('Bien')\n"
"\t:else\n"
"\t:  let Unafunc = function('Mal')\n"
"\t:endif\n"
"\t:echo call(Unafunc, [])\n"
"<\t¡Mal! ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1100
#, no-wrap
msgid ""
"Note that the name of a variable that holds a function reference must start\n"
"with a capital.  Otherwise it could be confused with the name of a builtin\n"
"function.\n"
"   The way to invoke a function that a variable refers to is with the call()\n"
"function.  Its first argument is the function reference, the second argument\n"
"is a List with arguments.\n"
msgstr ""
"Tenga en cuenta que el nombre de la variable que contiene la referencia a la\n"
"función debe empezar con una letra mayúscula. En caso contrario, es posible\n"
"que se confunda con el nombre de una de las funciones integradas de Vim.\n"
"   Para invocar una función usando una variable con una referencia a función\n"
"se usa la función call(). Como primer argumento recibe la referencia a la\n"
"función, y como segundo argumento una Lista con los argumentos para la "
"función\n"
"a invocar.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1103
msgid ""
"Function references are most useful in combination with a Dictionary, as is "
"explained in the next section."
msgstr ""
"Las referencias a funciones son particularmente útiles usadas con "
"Diccionarios, como se muestra en la siguiente sección."

#. type: Plain text
#: original/txt/usr_41.txt:1106
#, no-wrap
msgid "*41.8*\tLists and Dictionaries\n"
msgstr "*41.8*\tListas y Diccionarios\n"

#. type: Plain text
#: original/txt/usr_41.txt:1109
msgid ""
"So far we have used the basic types String and Number.  Vim also supports "
"two composite types: List and Dictionary."
msgstr ""
"Hasta ahora hemos usado los tipos básicos, Cadena de texto y Número. Vim "
"también ofrece otros dos: Lista y Diccionario."

#. type: Plain text
#: original/txt/usr_41.txt:1113
msgid ""
"A List is an ordered sequence of things.  The things can be any kind of "
"value, thus you can make a List of numbers, a List of Lists and even a List "
"of mixed items.  To create a List with three strings: >"
msgstr ""
"Una Lista es una secuencia ordenada de elementos. Los elementos pueden ser "
"de cualquier tipo, así que puede crear una Lista de números, una Lista de "
"Listas e incluso una Lista de elementos de tipos diferentes. Para crear una "
"Lista con tres cadenas de texto: >"

#. type: Plain text
#: original/txt/usr_41.txt:1115
#, no-wrap
msgid "\t:let alist = ['aap', 'mies', 'noot']\n"
msgstr "\t:let lista = ['aap', 'mies', 'noot']\n"

#. type: Plain text
#: original/txt/usr_41.txt:1118
msgid ""
"The List items are enclosed in square brackets and separated by commas.  To "
"create an empty List: >"
msgstr ""
"Los elementos de la Lista se rodean con corchetes y se separan con comas. "
"Para crear una Lista vacía: >"

#. type: Plain text
#: original/txt/usr_41.txt:1120
#, no-wrap
msgid "\t:let alist = []\n"
msgstr "\t:let lista = []\n"

#. type: Plain text
#: original/txt/usr_41.txt:1122
msgid "You can add items to a List with the add() function: >"
msgstr "Puede añadir elementos a una lista mediante la función add(): >"

#. type: Plain text
#: original/txt/usr_41.txt:1128
#, no-wrap
msgid ""
"\t:let alist = []\n"
"\t:call add(alist, 'foo')\n"
"\t:call add(alist, 'bar')\n"
"\t:echo alist\n"
"<\t['foo', 'bar'] ~\n"
msgstr ""
"\t:let lista = []\n"
"\t:call add(lista, 'foo')\n"
"\t:call add(lista, 'bar')\n"
"\t:echo lista\n"
"<\t['foo', 'bar'] ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1130
msgid "List concatenation is done with +: >"
msgstr "El operador de concatenación de Listas es «+»: >"

#. type: Plain text
#: original/txt/usr_41.txt:1133
#, no-wrap
msgid ""
"\t:echo alist + ['foo', 'bar']\n"
"<\t['foo', 'bar', 'foo', 'bar'] ~\n"
msgstr ""
"\t:echo lista + ['foo', 'bar']\n"
"<\t['foo', 'bar', 'foo', 'bar'] ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1135
msgid "Or, if you want to extend a List directly: >"
msgstr "O, si lo que desea es extender una Lista directamente: >"

#. type: Plain text
#: original/txt/usr_41.txt:1140
#, no-wrap
msgid ""
"\t:let alist = ['one']\n"
"\t:call extend(alist, ['two', 'three'])\n"
"\t:echo alist\n"
"<\t['one', 'two', 'three'] ~\n"
msgstr ""
"\t:let lista = ['uno']\n"
"\t:call extend(lista, ['dos', 'tres'])\n"
"\t:echo lista\n"
"<\t['uno', 'dos', 'tres'] ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1142
msgid "Notice that using add() will have a different effect: >"
msgstr "Observe que usar add() tendrá un resultado diferente: >"

#. type: Plain text
#: original/txt/usr_41.txt:1147
#, no-wrap
msgid ""
"\t:let alist = ['one']\n"
"\t:call add(alist, ['two', 'three'])\n"
"\t:echo alist\n"
"<\t['one', ['two', 'three']] ~\n"
msgstr ""
"\t:let lista = ['uno']\n"
"\t:call add(lista, ['dos', 'tres'])\n"
"\t:echo lista\n"
"<\t['uno', ['dos', 'tres']] ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1149
msgid "The second argument of add() is added as a single item."
msgstr ""
"El segundo argumento de add() se añade a la lista como un único elemento."

#. type: Plain text
#: original/txt/usr_41.txt:1152
msgid "FOR LOOP"
msgstr "CICLO FOR"

#. type: Plain text
#: original/txt/usr_41.txt:1154
msgid "One of the nice things you can do with a List is iterate over it: >"
msgstr ""
"Una de las cosas interesantes de las Listas es iterar sobre sus elementos: >"

#. type: Plain text
#: original/txt/usr_41.txt:1162
#, no-wrap
msgid ""
"\t:let alist = ['one', 'two', 'three']\n"
"\t:for n in alist\n"
"\t:  echo n\n"
"\t:endfor\n"
"<\tone ~\n"
"\ttwo ~\n"
"\tthree ~\n"
msgstr ""
"\t:let lista = ['uno', 'dos', 'tres']\n"
"\t:for n in lista\n"
"\t:  echo n\n"
"\t:endfor\n"
"<\tuno ~\n"
"\tdos ~\n"
"\ttres ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1165
msgid ""
"This will loop over each element in List \"alist\", assigning the value to "
"variable \"n\".  The generic form of a for loop is: >"
msgstr ""
"El código mostrado iterará sobre cada elemento en la Lista «lista», "
"asignando el valor del elemento a la variable «n». La forma genérica de un "
"ciclo «for» es: >"

#. type: Plain text
#: original/txt/usr_41.txt:1169
#, no-wrap
msgid ""
"\t:for {varname} in {listexpression}\n"
"\t:  {commands}\n"
"\t:endfor\n"
msgstr ""
"\t:for {nombrevar} in {expresiónlista}\n"
"\t:  {instrucciones}\n"
"\t:endfor\n"

#. type: Plain text
#: original/txt/usr_41.txt:1172
msgid ""
"To loop a certain number of times you need a List of a specific length.  The "
"range() function creates one for you: >"
msgstr ""
"Para iterar una cantidad determinada de veces necesita una Lista con una "
"longitud específica. La función range() puede crearla por usted: >"

#. type: Plain text
#: original/txt/usr_41.txt:1179
#, no-wrap
msgid ""
"\t:for a in range(3)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t0 ~\n"
"\t1 ~\n"
"\t2 ~\n"
msgstr ""
"\t:for a in range(3)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t0 ~\n"
"\t1 ~\n"
"\t2 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1183
#, no-wrap
msgid ""
"Notice that the first item of the List that range() produces is zero, thus the\n"
"last item is one less than the length of the list.\n"
"   You can also specify the maximum value, the stride and even go backwards: >\n"
msgstr ""
"Observe que el primer elemento de la Lista creada por range() es cero, y por\n"
"tanto el último elemento tiene un valor de uno menos que la longitud de la\n"
"lista.\n"
"   También puede especificar el valor máximo, y el incremento o decremento\n"
"deseado: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1190
#, no-wrap
msgid ""
"\t:for a in range(8, 4, -2)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t8 ~\n"
"\t6 ~\n"
"\t4 ~\n"
msgstr ""
"\t:for a in range(8, 4, -2)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t8 ~\n"
"\t6 ~\n"
"\t4 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1192
msgid "A more useful example, looping over lines in the buffer: >"
msgstr "Ahora un ejemplo más útil, iterar sobre las líneas de un búfer: >"

#. type: Plain text
#: original/txt/usr_41.txt:1198
#, no-wrap
msgid ""
"\t:for line in getline(1, 20)\n"
"\t:  if line =~ \"Date: \"\n"
"\t:    echo matchstr(line, 'Date: \\zs.*')\n"
"\t:  endif\n"
"\t:endfor\n"
msgstr ""
"\t:for line in getline(1, 20)\n"
"\t:  if line =~ \"Fecha: \"\n"
"\t:    echo matchstr(line, 'Fecha: \\zs.*')\n"
"\t:  endif\n"
"\t:endfor\n"

#. type: Plain text
#: original/txt/usr_41.txt:1200
msgid ""
"This looks into lines 1 to 20 (inclusive) and echoes any date found in there."
msgstr ""
"Este ejemplo examina las líneas 1 a 20 (inclusive) y muestra en pantalla las "
"fechas encontradas en ellas."

#. type: Plain text
#: original/txt/usr_41.txt:1203
msgid "DICTIONARIES"
msgstr "DICCIONARIOS"

#. type: Plain text
#: original/txt/usr_41.txt:1206
msgid ""
"A Dictionary stores key-value pairs.  You can quickly lookup a value if you "
"know the key.  A Dictionary is created with curly braces: >"
msgstr ""
"Un Diccionario almacena pares clave-valor. Esto le permite obtener un valor "
"almacenado de manera rápida, si conoce la clave del mismo. Los Diccionarios "
"se crean usando llaves: >"

#. type: Plain text
#: original/txt/usr_41.txt:1208
#, no-wrap
msgid "\t:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}\n"
msgstr "\t:let es2nl = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}\n"

#. type: Plain text
#: original/txt/usr_41.txt:1210
msgid "Now you can lookup words by putting the key in square brackets: >"
msgstr ""
"Ahora puede buscar palabras usando la clave, poniéndola entre corchetes: >"

#. type: Plain text
#: original/txt/usr_41.txt:1213
#, no-wrap
msgid ""
"\t:echo uk2nl['two']\n"
"<\ttwee ~\n"
msgstr ""
"\t:echo es2nl['dos']\n"
"<\ttwee ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1215
msgid "The generic form for defining a Dictionary is: >"
msgstr "La manera genérica de definir un Diccionario es: >"

#. type: Plain text
#: original/txt/usr_41.txt:1217
#, no-wrap
msgid "\t{<key> : <value>, ...}\n"
msgstr "\t{<clave> : <valor>, ...}\n"

#. type: Plain text
#: original/txt/usr_41.txt:1219
msgid "An empty Dictionary is one without any keys: >"
msgstr "Un Diccionario vacío se define como carente de claves: >"

#. type: Plain text
#: original/txt/usr_41.txt:1221
#, no-wrap
msgid "\t{}\n"
msgstr "\t{}\n"

#. type: Plain text
#: original/txt/usr_41.txt:1225
msgid ""
"The possibilities with Dictionaries are numerous.  There are various "
"functions for them as well.  For example, you can obtain a list of the keys "
"and loop over them: >"
msgstr ""
"Los Diccionarios ofrecen numerosas posibilidades. También dispone de varias "
"funciones para operar sobre ellos. Por ejemplo, puede obtener una lista de "
"las claves e iterar sobre ellas: >"

#. type: Plain text
#: original/txt/usr_41.txt:1232
#, no-wrap
msgid ""
"\t:for key in keys(uk2nl)\n"
"\t:  echo key\n"
"\t:endfor\n"
"<\tthree ~\n"
"\tone ~\n"
"\ttwo ~\n"
msgstr ""
"\t:for clave in keys(es2nl)\n"
"\t:  echo clave\n"
"\t:endfor\n"
"<\ttres ~\n"
"\tuno ~\n"
"\tdos ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1235
msgid ""
"You will notice the keys are not ordered.  You can sort the list to get a "
"specific order: >"
msgstr ""
"Habrá notado que las claves no están ordenadas. Puede ordenar la lista para "
"obtener un orden específico: >"

#. type: Plain text
#: original/txt/usr_41.txt:1242
#, no-wrap
msgid ""
"\t:for key in sort(keys(uk2nl))\n"
"\t:  echo key\n"
"\t:endfor\n"
"<\tone ~\n"
"\tthree ~\n"
"\ttwo ~\n"
msgstr ""
"\t:for clave in sort(keys(es2nl))\n"
"\t:  echo clave\n"
"\t:endfor\n"
"<\tdos ~\n"
"\ttres ~\n"
"\tuno ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1245
msgid ""
"But you can never get back the order in which items are defined.  For that "
"you need to use a List, it stores items in an ordered sequence."
msgstr ""
"No es posible recuperar el orden en el cual se definieron los elementos del "
"Diccionario. Para eso necesita una Lista, que almacena los elementos en una "
"secuencia ordenada."

#. type: Plain text
#: original/txt/usr_41.txt:1248
msgid "DICTIONARY FUNCTIONS"
msgstr "FUNCIONES PARA DICCIONARIOS"

#. type: Plain text
#: original/txt/usr_41.txt:1251
msgid ""
"The items in a Dictionary can normally be obtained with an index in square "
"brackets: >"
msgstr ""
"Habitualmente, puede acceder a los elementos de un Diccionario usando el "
"índice correspondiente entre corchetes: >"

#. type: Plain text
#: original/txt/usr_41.txt:1254
#, no-wrap
msgid ""
"\t:echo uk2nl['one']\n"
"<\teen ~\n"
msgstr ""
"\t:echo es2nl['uno']\n"
"<\teen ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1256
msgid ""
"A method that does the same, but without so many punctuation characters: >"
msgstr "Una forma de hacer lo mismo, sin tantos caracteres: >"

#. type: Plain text
#: original/txt/usr_41.txt:1259
#, no-wrap
msgid ""
"\t:echo uk2nl.one\n"
"<\teen ~\n"
msgstr ""
"\t:echo es2nl.uno\n"
"<\teen ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1262
msgid ""
"This only works for a key that is made of ASCII letters, digits and the "
"underscore.  You can also assign a new value this way: >"
msgstr ""
"Esto sólo funciona con claves compuestas de caracteres ASCII, dígitos, y el "
"guión bajo. También puede usar esta notación para asignar valores: >"

#. type: Plain text
#: original/txt/usr_41.txt:1266
#, no-wrap
msgid ""
"\t:let uk2nl.four = 'vier'\n"
"\t:echo uk2nl\n"
"<\t{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~\n"
msgstr ""
"\t:let es2nl.cuatro = 'vier'\n"
"\t:echo es2nl\n"
"<\t{'tres': 'drie', 'cuatro': 'vier', 'uno': 'een', 'dos': 'twee'} ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1269
msgid ""
"And now for something special: you can directly define a function and store "
"a reference to it in the dictionary: >"
msgstr ""
"Y ahora, algo especial: puede definir directamente una función y almacenar "
"una referencia a la misma en un diccionario: >"

#. type: Plain text
#: original/txt/usr_41.txt:1273
#, no-wrap
msgid ""
"\t:function uk2nl.translate(line) dict\n"
"\t:  return join(map(split(a:line), 'get(self, v:val, \"???\")'))\n"
"\t:endfunction\n"
msgstr ""
"\t:function es2nl.traducir(linea) dict\n"
"\t:  return join(map(split(a:linea), 'get(self, v:val, \"???\")'))\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:1275
msgid "Let's first try it out: >"
msgstr "Primero probémosla: >"

#. type: Plain text
#: original/txt/usr_41.txt:1278
#, no-wrap
msgid ""
"\t:echo uk2nl.translate('three two five one')\n"
"<\tdrie twee ??? een ~\n"
msgstr ""
"\t:echo es2nl.traducir('tres dos cinco uno')\n"
"<\tdrie twee ??? een ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1283
#, no-wrap
msgid ""
"The first special thing you notice is the \"dict\" at the end of the \":function\"\n"
"line.  This marks the function as being used from a Dictionary.  The \"self\"\n"
"local variable will then refer to that Dictionary.\n"
"   Now let's break up the complicated return command: >\n"
msgstr ""
"Lo que habrá notado primero es el «dict» al final de la línea «:function».\n"
"Así se indica que la función será usada desde un Diccionario. La variable\n"
"local «self» se referirá a dicho diccionario.\n"
"   Ahora, dividamos esa compleja instrucción de retorno: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1285
#, no-wrap
msgid "\tsplit(a:line)\n"
msgstr "\tsplit(a:linea)\n"

#. type: Plain text
#: original/txt/usr_41.txt:1288
msgid ""
"The split() function takes a string, chops it into white separated words and "
"returns a list with these words.  Thus in the example it returns: >"
msgstr ""
"La función split() toma una cadena, la divide en palabras separadas por "
"espacios en blanco, y entrega una lista con estas palabras. En el ejemplo "
"previo, entrega: >"

#. type: Plain text
#: original/txt/usr_41.txt:1291
#, no-wrap
msgid ""
"\t:echo split('three two five one')\n"
"<\t['three', 'two', 'five', 'one'] ~\n"
msgstr ""
"\t:echo split('tres dos cinco uno')\n"
"<\t['tres', 'dos', 'cinco', 'uno'] ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1295
msgid ""
"This list is the first argument to the map() function.  This will go through "
"the list, evaluating its second argument with \"v:val\" set to the value of "
"each item.  This is a shortcut to using a for loop.  This command: >"
msgstr ""
"Esta lista es el primer argumento para la función map(). Dicha función "
"analizará la lista, evaluando su segundo argumento con la variable «v:val» "
"definida con el valor de cada elemento en la lista. Es una abreviación de un "
"ciclo for. Esta instrucción: >"

#. type: Plain text
#: original/txt/usr_41.txt:1297
#, no-wrap
msgid "\t:let alist = map(split(a:line), 'get(self, v:val, \"???\")')\n"
msgstr "\t:let lista = map(split(a:linea), 'get(self, v:val, \"???\")')\n"

#. type: Plain text
#: original/txt/usr_41.txt:1299
msgid "Is equivalent to: >"
msgstr "Equivale a: >"

#. type: Plain text
#: original/txt/usr_41.txt:1304
#, no-wrap
msgid ""
"\t:let alist = split(a:line)\n"
"\t:for idx in range(len(alist))\n"
"\t:  let alist[idx] = get(self, alist[idx], \"???\")\n"
"\t:endfor\n"
msgstr ""
"\t:let lista = split(a:linea)\n"
"\t:for ind in range(len(lista))\n"
"\t:  let lista[ind] = get(self, lista[ind], \"???\")\n"
"\t:endfor\n"

#. type: Plain text
#: original/txt/usr_41.txt:1309
msgid ""
"The get() function checks if a key is present in a Dictionary.  If it is, "
"then the value is retrieved.  If it isn't, then the default value is "
"returned, in the example it's '???'.  This is a convenient way to handle "
"situations where a key may not be present and you don't want an error "
"message."
msgstr ""
"La función get() comprueba si una clave existe en un Diccionario. Si existe, "
"devuelve el valor asociado a la clave. Si no existe, devuelve el valor "
"definido como predeterminado, que en el ejemplo es '???'. Esto permite "
"manejar de una forma conveniente las situaciones en que una clave no existe "
"y no desea hacer el manejo del error que provocaría dicha situación."

#. type: Plain text
#: original/txt/usr_41.txt:1314
#, no-wrap
msgid ""
"The join() function does the opposite of split(): it joins together a list of\n"
"words, putting a space in between.\n"
"  This combination of split(), map() and join() is a nice way to filter a line\n"
"of words in a very compact way.\n"
msgstr ""
"La función join() es el complemento de split(): une una lista de palabras,\n"
"separándolas con un espacio.\n"
"   La combinación de split(), map(), y join() es una forma elegante de filtrar\n"
"una cadena de palabras de manera sucinta.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1317
msgid "OBJECT ORIENTED PROGRAMMING"
msgstr "PROGRAMACIÓN ORIENTADA A OBJETOS"

#. type: Plain text
#: original/txt/usr_41.txt:1323
#, no-wrap
msgid ""
"Now that you can put both values and functions in a Dictionary, you can\n"
"actually use a Dictionary like an object.\n"
"   Above we used a Dictionary for translating Dutch to English.  We might want\n"
"to do the same for other languages.  Let's first make an object (aka\n"
"Dictionary) that has the translate function, but no words to translate: >\n"
msgstr ""
"Ahora que podemos guardar valores y funciones en un Diccionario, podemos usar\n"
"un Diccionario como un objeto.\n"
"   Anteriormente hicimos uso de un Diccionario para traducir texto de Holandés\n"
"a Español. Querríamos hacer lo mismo para otros idiomas. Primero crearemos un\n"
"objeto (esto es, un Diccionario) que tenga la función traducir, pero no tenga\n"
"palabras para traducir: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1328
#, no-wrap
msgid ""
"\t:let transdict = {}\n"
"\t:function transdict.translate(line) dict\n"
"\t:  return join(map(split(a:line), 'get(self.words, v:val, \"???\")'))\n"
"\t:endfunction\n"
msgstr ""
"\t:let dicctraductor = {}\n"
"\t:function dicctraductor.traducir(linea) dict\n"
"\t:  return join(map(split(a:linea),\n"
"\t\t\t\\ 'get(self.palabras, v:val, \"???\")'))\n"
"\t:endfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:1332
msgid ""
"It's slightly different from the function above, using 'self.words' to "
"lookup word translations.  But we don't have a self.words.  Thus you could "
"call this an abstract class."
msgstr ""
"La definición es ligeramente diferente de la función anterior, ya que usa "
"'self.words' para buscar las traducciones de palabras. Pero no hay un self."
"words. Por esto decir que el Diccionario es una clase abstracta."

#. type: Plain text
#: original/txt/usr_41.txt:1334
msgid "Now we can instantiate a Dutch translation object: >"
msgstr "Ahora podemos instanciar un objeto para traducción al Holandés: >"

#. type: Plain text
#: original/txt/usr_41.txt:1339
#, no-wrap
msgid ""
"\t:let uk2nl = copy(transdict)\n"
"\t:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}\n"
"\t:echo uk2nl.translate('three one')\n"
"<\tdrie een ~\n"
msgstr ""
"\t:let es2nl = copy(dicctraductor)\n"
"\t:let es2nl.words = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}\n"
"\t:echo es2nl.translate('tres uno')\n"
"<\tdrie een ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1341
msgid "And a German translator: >"
msgstr "Y un traductor al alemán: >"

#. type: Plain text
#: original/txt/usr_41.txt:1346
#, no-wrap
msgid ""
"\t:let uk2de = copy(transdict)\n"
"\t:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}\n"
"\t:echo uk2de.translate('three one')\n"
"<\tdrei ein ~\n"
msgstr ""
"\t:let es2de = copy(dicctraductor)\n"
"\t:let es2de.words = {'uno': 'ein', 'dos': 'zwei', 'tres': 'drei'}\n"
"\t:echo es2de.translate('tres uno')\n"
"<\tdrei ein ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1350
msgid ""
"You see that the copy() function is used to make a copy of the \"transdict\" "
"Dictionary and then the copy is changed to add the words.  The original "
"remains the same, of course."
msgstr ""
"Puede ver que la función copy() se usa para crear una copia del Diccionario "
"«dicctraductor» y luego se cambia la copia, añadiendo las palabras. El "
"original, por supuesto, permanece intacto."

#. type: Plain text
#: original/txt/usr_41.txt:1352
msgid "Now you can go one step further, and use your preferred translator: >"
msgstr "Ahora puede ir un paso más allá, y usar su traductor preferido: >"

#. type: Plain text
#: original/txt/usr_41.txt:1360
#, no-wrap
msgid ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trans = uk2de\n"
"\t:else\n"
"\t:  let trans = uk2nl\n"
"\t:endif\n"
"\t:echo trans.translate('one two three')\n"
"<\teen twee drie ~\n"
msgstr ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trad = es2de\n"
"\t:else\n"
"\t:  let trad = es2nl\n"
"\t:endif\n"
"\t:echo trad.traducir('uno dos tres')\n"
"<\teen twee drie ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1364
msgid ""
"Here \"trans\" refers to one of the two objects (Dictionaries).  No copy is "
"made.  More about List and Dictionary identity can be found at |list-"
"identity| and |dict-identity|."
msgstr ""
"Aquí «trad» se refiere a uno de dos posibles objetos (Diccionarios). No se "
"hace ninguna copia. Puede encontrar más información acerca de la identidad "
"de Listas y Diccionarios en |list-identity| y |dict-identity|."

#. type: Plain text
#: original/txt/usr_41.txt:1367
msgid ""
"Now you might use a language that isn't supported.  You can overrule the "
"translate() function to do nothing: >"
msgstr ""
"Puede que use un idioma que aún no esté incluido. Para este caso, puede "
"redefinir la función traducir() para que no haga nada: >"

#. type: Plain text
#: original/txt/usr_41.txt:1374
#, no-wrap
msgid ""
"\t:let uk2uk = copy(transdict)\n"
"\t:function! uk2uk.translate(line)\n"
"\t:  return a:line\n"
"\t:endfunction\n"
"\t:echo uk2uk.translate('three one wladiwostok')\n"
"<\tthree one wladiwostok ~\n"
msgstr ""
"\t:let es2es = copy(dicctraductor)\n"
"\t:function! es2es.traducir(linea)\n"
"\t:  return a:linea\n"
"\t:endfunction\n"
"\t:echo es2es.traducir('tres one wladiwostok')\n"
"<\ttres uno wladiwostok ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1377
msgid ""
"Notice that a ! was used to overwrite the existing function reference.  Now "
"use \"uk2uk\" when no recognized language is found: >"
msgstr ""
"Note el «!» utilizado para redefinir la referencia a función existente. "
"Ahora puede usar «es2es» cuando no se encuentra ningún idioma reconocido: >"

#. type: Plain text
#: original/txt/usr_41.txt:1387
#, no-wrap
msgid ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trans = uk2de\n"
"\t:elseif $LANG =~ \"nl\"\n"
"\t:  let trans = uk2nl\n"
"\t:else\n"
"\t:  let trans = uk2uk\n"
"\t:endif\n"
"\t:echo trans.translate('one two three')\n"
"<\tone two three ~\n"
msgstr ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trad = es2de\n"
"\t:elseif $LANG =~ \"nl\"\n"
"\t:  let trad = es2nl\n"
"\t:else\n"
"\t:  let trad = es2es\n"
"\t:endif\n"
"\t:echo trad.traducir('uno dos tres')\n"
"<\tuno dos tres ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:1389
msgid "For further reading see |Lists| and |Dictionaries|."
msgstr "Para más detalles consulte |Lists| y |Dictionaries|."

#. type: Plain text
#: original/txt/usr_41.txt:1392
#, no-wrap
msgid "*41.9*\tExceptions\n"
msgstr "*41.9*\tExcepciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:1394
msgid "Let's start with an example: >"
msgstr "Empecemos con un ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:1400
#, no-wrap
msgid ""
"\t:try\n"
"\t:   read ~/templates/pascal.tmpl\n"
"\t:catch /E484:/\n"
"\t:   echo \"Sorry, the Pascal template file cannot be found.\"\n"
"\t:endtry\n"
msgstr ""
"\t:try\n"
"\t:   read ~/plantillas/pascal.tmpl\n"
"\t:catch /E484:/\n"
"\t:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»\n"
"\t:endtry\n"

# TODO instead no está como repetido?
#. type: Plain text
#: original/txt/usr_41.txt:1404
msgid ""
"The \":read\" command will fail if the file does not exist.  Instead of "
"generating an error message, this code catches the error and gives the user "
"a nice message instead."
msgstr ""
"La orden «:read» (leer) fallará si el archivo no existe. En vez de mostrar "
"un mensaje de error, este código atrapa el error y le muestra al usuario un "
"mensaje más agradable."

#. type: Plain text
#: original/txt/usr_41.txt:1410
msgid ""
"For the commands in between \":try\" and \":endtry\" errors are turned into "
"exceptions.  An exception is a string.  In the case of an error the string "
"contains the error message.  And every error message has a number.  In this "
"case, the error we catch contains \"E484:\".  This number is guaranteed to "
"stay the same (the text may change, e.g., it may be translated)."
msgstr ""
"Para las instrucciones entre «:try» y «:endtry» los errores se convierten en "
"excepciones. Una excepción es una cadena de texto. Cuando aparece un error "
"esta cadena contiene el mensaje de error. Y cada mensaje de error tiene un "
"número. En este caso, el error que atrapamos contiene «E484:». Vim garantiza "
"que este número permanece inalterado (el texto del mensaje de error puede "
"cambiar, por ejemplo, puede haber sido traducido.)"

#. type: Plain text
#: original/txt/usr_41.txt:1414
msgid ""
"When the \":read\" command causes another error, the pattern \"E484:\" will "
"not match in it.  Thus this exception will not be caught and result in the "
"usual error message."
msgstr ""
"Cuando la orden «:read» genera un error distinto, el patrón «E484:» no "
"coincidirá con él. La excepción no será atrapada y aparecerá el mensaje de "
"error habitual en esos casos."

#. type: Plain text
#: original/txt/usr_41.txt:1416
msgid "You might be tempted to do this: >"
msgstr "Puede sentirse tentado a hacer lo siguiente:: >"

#. type: Plain text
#: original/txt/usr_41.txt:1422
#, no-wrap
msgid ""
"\t:try\n"
"\t:   read ~/templates/pascal.tmpl\n"
"\t:catch\n"
"\t:   echo \"Sorry, the Pascal template file cannot be found.\"\n"
"\t:endtry\n"
msgstr ""
"\t:try\n"
"\t:   read ~/plantillas/pascal.tmpl\n"
"\t:catch\n"
"\t:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»\n"
"\t:endtry\n"

#. type: Plain text
#: original/txt/usr_41.txt:1425
msgid ""
"This means all errors are caught.  But then you will not see errors that are "
"useful, such as \"E21: Cannot make changes, 'modifiable' is off\"."
msgstr ""
"De esta forma se atrapan todos los errores. Pero al hacerlo no verá errores "
"que son útiles, como por ejemplo «E21: No se pudo modificar, 'modifiable' "
"está desactivado»"

#. type: Plain text
#: original/txt/usr_41.txt:1427
msgid "Another useful mechanism is the \":finally\" command: >"
msgstr "La orden «:finally» es otro mecanismo útil: >"

#. type: Plain text
#: original/txt/usr_41.txt:1437
#, no-wrap
msgid ""
"\t:let tmp = tempname()\n"
"\t:try\n"
"\t:   exe \".,$write \" . tmp\n"
"\t:   exe \"!filter \" . tmp\n"
"\t:   .,$delete\n"
"\t:   exe \"$read \" . tmp\n"
"\t:finally\n"
"\t:   call delete(tmp)\n"
"\t:endtry\n"
msgstr ""
"\t:let tmp = tempname()\n"
"\t:try\n"
"\t:   exe \".,$write \" . tmp\n"
"\t:   exe \"!filter \" . tmp\n"
"\t:   .,$delete\n"
"\t:   exe \"$read \" . tmp\n"
"\t:finally\n"
"\t:   call delete(tmp)\n"
"\t:endtry\n"

#. type: Plain text
#: original/txt/usr_41.txt:1443
msgid ""
"This filters the lines from the cursor until the end of the file through the "
"\"filter\" command, which takes a file name argument.  No matter if the "
"filtering works, something goes wrong in between \":try\" and \":finally\" "
"or the user cancels the filtering by pressing CTRL-C, the \"call delete"
"(tmp)\" is always executed.  This makes sure you don't leave the temporary "
"file behind."
msgstr ""
"Aquí se filtran las líneas desde el cursor hasta el final del archivo usando "
"la orden «filter», que toma como argumento un nombre de archivo. No importa "
"si el filtrado funciona, si algo sale mal entre «:try» y «:finally», o si el "
"usuario cancela el filtrado presionando CTRL-C, la instrucción «call delete"
"(tmp)» siempre se ejecuta. Así se asegura de que no queden archivos "
"temporales al acabar el proceso."

#. type: Plain text
#: original/txt/usr_41.txt:1446
msgid ""
"More information about exception handling can be found in the reference "
"manual: |exception-handling|."
msgstr ""
"Puede encontrar más información acerca del manejo de excepciones en el "
"manual de referencia: |exception-handling|."

#. type: Plain text
#: original/txt/usr_41.txt:1449
#, no-wrap
msgid "*41.10*\tVarious remarks\n"
msgstr "*41.10*\tObservaciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:1452
msgid ""
"Here is a summary of items that apply to Vim scripts.  They are also "
"mentioned elsewhere, but form a nice checklist."
msgstr ""
"A continuación tiene un resumen de los elementos relevantes para escribir "
"scripts de Vim. También se los menciona en otros lugares de la "
"documentación, pero aquí se presentan como una conveniente lista."

#. type: Plain text
#: original/txt/usr_41.txt:1456
msgid ""
"The end-of-line character depends on the system.  For Unix a single <NL> "
"character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is "
"used.  This is important when using mappings that end in a <CR>.  See |:"
"source_crnl|."
msgstr ""
"El carácter de fin de línea usado depende del sistema. En sistemas Unix se "
"usa <NL>. En MS-DOS, Windows, OS/2 y similares, se usa <CR><LF>. Éste es un "
"detalle importante a considerar al usar macros que terminan en <CR>. "
"Consulte |:source_crnl|."

#. type: Plain text
#: original/txt/usr_41.txt:1459
msgid "WHITE SPACE"
msgstr "ESPACIO EN BLANCO"

#. type: Plain text
#: original/txt/usr_41.txt:1461
msgid "Blank lines are allowed and ignored."
msgstr "Las líneas en blanco están permitidas, y son ignoradas."

#. type: Plain text
#: original/txt/usr_41.txt:1467
msgid ""
"Leading whitespace characters (blanks and TABs) are always ignored.  The "
"whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' "
"in the example below) are reduced to one blank character and plays the role "
"of a separator, the whitespaces after the last (visible) character may or "
"may not be ignored depending on the situation, see below."
msgstr ""
"Los espacios en blanco al principio de cada línea (espacios y tabulados) "
"siempre se ignoran. Los espacios en blanco entre parámetros (por ejemplo, "
"entre 'set' y 'cpoptions' en el ejemplo a continuación) se reducen a un solo "
"espacio blanco que actúa como separador, los espacios en blanco después del "
"último carácter (visible) se pueden o no ignorar dependiendo del caso, véase "
"a continuación."

#. type: Plain text
#: original/txt/usr_41.txt:1469
msgid "For a \":set\" command involving the \"=\" (equal) sign, such as in: >"
msgstr "Para una orden «:set» que incluye el símbolo «=» (igual), como en: >"

#. type: Plain text
#: original/txt/usr_41.txt:1471
#, no-wrap
msgid "\t:set cpoptions    =aABceFst\n"
msgstr "\t:set cpoptions    =aABceFst\n"

#. type: Plain text
#: original/txt/usr_41.txt:1474
msgid ""
"the whitespace immediately before the \"=\" sign is ignored.  But there can "
"be no whitespace after the \"=\" sign!"
msgstr ""
"se ignora el espacio en blanco inmediatamente antes del símbolo «=». ¡Pero "
"no puede haber espacios a continuación del símbolo «=»!"

#. type: Plain text
#: original/txt/usr_41.txt:1477
msgid ""
"To include a whitespace character in the value of an option, it must be "
"escaped by a \"\\\" (backslash)  as in the following example: >"
msgstr ""
"Para incluir un espacio en blanco como valor de una opción, hay que "
"escaparlo usando una «\\» (barra inversa) como en el siguiente ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:1479
#, no-wrap
msgid "\t:set tags=my\\ nice\\ file\n"
msgstr "\t:set tags=mi\\ lindo\\ archivo\n"

# TODO bug in vim doc?
#. type: Plain text
#: original/txt/usr_41.txt:1481
msgid "The same example written as >"
msgstr "Al escribir el ejemplo como: >"

#. type: Plain text
#: original/txt/usr_41.txt:1483
#, no-wrap
msgid "\t:set tags=my nice file\n"
msgstr "\t:set tags=mi lindo archivo\n"

#. type: Plain text
#: original/txt/usr_41.txt:1485
msgid "will issue an error, because it is interpreted as: >"
msgstr "se obtendría un error, porque se interpreta como: >"

#. type: Plain text
#: original/txt/usr_41.txt:1489
#, no-wrap
msgid ""
"\t:set tags=my\n"
"\t:set nice\n"
"\t:set file\n"
msgstr ""
"\t:set tags=mi\n"
"\t:set lindo\n"
"\t:set archivo\n"

#. type: Plain text
#: original/txt/usr_41.txt:1492
msgid "COMMENTS"
msgstr "COMENTARIOS"

#. type: Plain text
#: original/txt/usr_41.txt:1497
msgid ""
"The character \" (the double quote mark) starts a comment.  Everything after "
"and including this character until the end-of-line is considered a comment "
"and is ignored, except for commands that don't consider comments, as shown "
"in examples below.  A comment can start on any character position on the "
"line."
msgstr ""
"El carácter \" (comilla doble) marca el inicio de un comentario. Todo lo que "
"aparece a continuación de éste carácter hasta el fin de línea, e "
"incluyéndola, se considera un comentario y es ignorado, a excepción de las "
"órdenes que no tienen en cuenta los comentarios, como se puede ver en "
"ejemplos de esta sección. Un comentario puede empezar en cualquier punto de "
"una línea de texto."

#. type: Plain text
#: original/txt/usr_41.txt:1499
msgid ""
"There is a little \"catch\" with comments for some commands.  Examples: >"
msgstr ""
"Hay un pequeño «pero» con los comentarios y ciertas órdenes. Ejemplos: >"

#. type: Plain text
#: original/txt/usr_41.txt:1504
#, no-wrap
msgid ""
"\t:abbrev dev development\t\t\" shorthand\n"
"\t:map <F3> o#include\t\t\" insert include\n"
"\t:execute cmd\t\t\t\" do it\n"
"\t:!ls *.c\t\t\t\" list C files\n"
msgstr ""
"\t:abbrev des desarrollo\t\t\" abreviación\n"
"\t:map <F3> o#include\t\t\" insertar directiva include\n"
"\t:execute orden\t\t\t\" ejecutar\n"
"\t:!ls *.c\t\t\t\" listar archivos C\n"

#. type: Plain text
#: original/txt/usr_41.txt:1513
#, no-wrap
msgid ""
"The abbreviation 'dev' will be expanded to 'development     \" shorthand'.  The\n"
"mapping of <F3> will actually be the whole line after the 'o# ....' including\n"
"the '\" insert include'.  The \"execute\" command will give an error.  The \"!\"\n"
"command will send everything after it to the shell, causing an error for an\n"
"unmatched '\"' character.\n"
"   There can be no comment after \":map\", \":abbreviate\", \":execute\" and \"!\"\n"
"commands (there are a few more commands with this restriction).  For the\n"
"\":map\", \":abbreviate\" and \":execute\" commands there is a trick: >\n"
msgstr ""
"La abreviación 'dev' se expandirá a 'desarrollo     \" abreviación'. La\n"
"macro <F3> constará en realidad de toda la línea desde 'o# ....' incluyendo\n"
"'\" insertar directiva include'. La orden «execute» provocará un error. La\n"
"orden «!» enviará todos los caracteres a continuación al intérprete de\n"
"órdenes, provocando un error debido al carácter '\"' sin la comilla de cierre\n"
"correspondiente.\n"
"   No pueden existir comentarios a continuación de las órdenes «:map»,\n"
"«:abbreviate», «:execute», ni «!» (hay algunas órdenes más con esta\n"
"restricción). Para el caso de las órdenes «:map», «:abbreviate», y «:execute»\n"
"hay un truco disponible: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1517
#, no-wrap
msgid ""
"\t:abbrev dev development|\" shorthand\n"
"\t:map <F3> o#include|\" insert include\n"
"\t:execute cmd\t\t\t|\" do it\n"
msgstr ""
"\t:abbrev des desarrollo|\" abreviación\n"
"\t:map <F3> o#include|\" insertar directiva include\n"
"\t:execute orden\t\t\t|\" ejecutar\n"

#. type: Plain text
#: original/txt/usr_41.txt:1522
#, no-wrap
msgid ""
"With the '|' character the command is separated from the next one.  And that\n"
"next command is only a comment.  For the last command you need to do two\n"
"things: |:execute| and use '|': >\n"
"\t:exe '!ls *.c'\t\t\t|\" list C files\n"
msgstr ""
"El carácter «|» permite separar órdenes. En este caso, la siguiente orden es\n"
"simplemente un comentario. Para la última orden hay que hacer dos cosas:\n"
"|:execute| y usar «|»: >\n"
"\t:exe '!ls *.c'\t\t\t|\" listar archivos C\n"

#. type: Plain text
#: original/txt/usr_41.txt:1527
msgid ""
"Notice that there is no white space before the '|' in the abbreviation and "
"mapping.  For these commands, any character until the end-of-line or '|' is "
"included.  As a consequence of this behavior, you don't always see that "
"trailing whitespace is included: >"
msgstr ""
"Observe que no hay espacios en blanco antes de «|» en la abreviación ni en "
"la macro. En estas órdenes, se incluye cualquier carácter hasta el fin de "
"línea o hasta «|». Como consecuencia de este comportamiento, no siempre es "
"visible cuándo se incluyen espacios en blanco al final del a línea: >"

#. type: Plain text
#: original/txt/usr_41.txt:1529
#, no-wrap
msgid "\t:map <F4> o#include  \n"
msgstr "\t:map <F4> o#include  \n"

#. type: Plain text
#: original/txt/usr_41.txt:1532
msgid ""
"To spot these problems, you can set the 'list' option when editing vimrc "
"files."
msgstr ""
"Para ver estos problemas de forma más fácil, puede activar la opción 'list' "
"al editar archivos vimrc."

#. type: Plain text
#: original/txt/usr_41.txt:1538
#, no-wrap
msgid ""
"For Unix there is one special way to comment a line, that allows making a Vim\n"
"script executable: >\n"
"\t#!/usr/bin/env vim -S\n"
"\techo \"this is a Vim script\"\n"
"\tquit\n"
msgstr ""
"En Unix hay una forma especial de hacer un comentario, que permite hacer que\n"
"un script de Vim sea ejecutable: >\n"
"\t#!/usr/bin/env vim -S\n"
"\techo \"este es un script de Vim\"\n"
"\tquit\n"

#. type: Plain text
#: original/txt/usr_41.txt:1542
msgid ""
"The \"#\" command by itself lists a line with the line number.  Adding an "
"exclamation mark changes it into doing nothing, so that you can add the "
"shell command to execute the rest of the file. |:#!| |-S|"
msgstr ""
"Por sí misma, la orden «#» muestra una línea junto con su número de línea. "
"Al añadirle un símbolo de exclamación su comportamiento cambia y no tiene "
"efecto, así que puede añadir la orden de intérprete de órdenes para ejecutar "
"el resto del archivo. |:#!| |-S|"

#. type: Plain text
#: original/txt/usr_41.txt:1545
msgid "PITFALLS"
msgstr "PROBLEMAS"

#. type: Plain text
#: original/txt/usr_41.txt:1547
msgid "Even bigger problem arises in the following example: >"
msgstr "En el siguiente ejemplo aparecen problemas aún más grandes: >"

#. type: Plain text
#: original/txt/usr_41.txt:1550
#, no-wrap
msgid ""
"\t:map ,ab o#include\n"
"\t:unmap ,ab \n"
msgstr ""
"\t:map ,ab o#include\n"
"\t:unmap ,ab \n"

#. type: Plain text
#: original/txt/usr_41.txt:1555
msgid ""
"Here the unmap command will not work, because it tries to unmap \",ab \".  "
"This does not exist as a mapped sequence.  An error will be issued, which is "
"very hard to identify, because the ending whitespace character in \":unmap ,"
"ab \" is not visible."
msgstr ""
"Aquí la orden unmap no funcionará, porque trata de eliminar la macro «,ab ». "
"Ésta no existe como secuencia de ninguna macro. Se mostrará un error, que es "
"muy difícil de identificar, porque el carácter de espacio final en «:unmap ,"
"ab» no es visible."

#. type: Plain text
#: original/txt/usr_41.txt:1558
msgid ""
"And this is the same as what happens when one uses a comment after an "
"'unmap' command: >"
msgstr ""
"Lo mismo sucede cuando se pone un comentario a conti de una orden 'unmap': >"

#. type: Plain text
#: original/txt/usr_41.txt:1560
#, no-wrap
msgid "\t:unmap ,ab     \" comment\n"
msgstr "\t:unmap ,ab     \" comentario\n"

#. type: Plain text
#: original/txt/usr_41.txt:1563
#, no-wrap
msgid ""
"Here the comment part will be ignored.  However, Vim will try to unmap\n"
"',ab     ', which does not exist.  Rewrite it as: >\n"
msgstr ""
"La parte correspondiente al comentario será ignorada. Sin embargo, Vim tratará\n"
"de eliminar la macro ',ab     ', que no existe. Debe reescribir la orden como:\n"
">\n"

#. type: Plain text
#: original/txt/usr_41.txt:1565
#, no-wrap
msgid "\t:unmap ,ab|    \" comment\n"
msgstr "\t:unmap ,ab|    \" comentario\n"

#. type: Plain text
#: original/txt/usr_41.txt:1568
msgid "RESTORING THE VIEW"
msgstr "RESTAURAR LA VISTA"

#. type: Plain text
#: original/txt/usr_41.txt:1574
#, no-wrap
msgid ""
"Sometimes you want to make a change and go back to where cursor was.\n"
"Restoring the relative position would also be nice, so that the same line\n"
"appears at the top of the window.\n"
"   This example yanks the current line, puts it above the first line in the\n"
"file and then restores the view: >\n"
msgstr ""
"En ocasiones es deseable hacer un cambio y volver al sitio en que el cursor se\n"
"encontraba inicialmente. Recuperar la posición relativa también sería\n"
"agradable, de tal forma que la misma línea inicial aparezca al inicio de la\n"
"ventana.\n"
"   Este ejemplo copia la línea actual, la inserta antes de la primera línea en\n"
"el archivo y después restaura la vista original: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1576
#, no-wrap
msgid "\tmap ,p ma\"aYHmbgg\"aP`bzt`a\n"
msgstr "\tmap ,p ma\"aYHmbgg\"aP`bzt`a\n"

#. type: Plain text
#: original/txt/usr_41.txt:1587
#, no-wrap
msgid ""
"What this does: >\n"
"\tma\"aYHmbgg\"aP`bzt`a\n"
"<\tma\t\t\tset mark a at cursor position\n"
"\t  \"aY\t\t\tyank current line into register a\n"
"\t     Hmb\t\tgo to top line in window and set mark b there\n"
"\t\tgg\t\tgo to first line in file\n"
"\t\t  \"aP\t\tput the yanked line above it\n"
"\t\t     `b\t\tgo back to top line in display\n"
"\t\t       zt\tposition the text in the window as before\n"
"\t\t\t `a\tgo back to saved cursor position\n"
msgstr ""
"Esto es lo que hace: >\n"
"\tma\"aYHmbgg\"aP`bzt`a\n"
"<\tma\t\t\tpone una marca en la posición actual del\n"
"\t\t\t\tcursor\n"
"\t  \"aY\t\t\tcopia la línea actual al registro a\n"
"\t     Hmb\t\tva hasta la primera línea que se ve en la\n"
"\t\t\t\tventana y pone la marca b allí\n"
"\t\tgg\t\tva a la primera línea del archivo\n"
"\t\t  \"aP\t\tpega la línea copiada por encima de la línea\n"
"\t\t     `b\t\tvuelve a la línea superior de la vista inicial\n"
"\t\t       zt\tubica dicha línea como la primera de la\n"
"\t\t\t\tventana\n"
"\t\t\t `a\tvuelve a la posición del cursor almacenada\n"
"\t\t\t\toriginalmente\n"

#. type: Plain text
#: original/txt/usr_41.txt:1590
msgid "PACKAGING"
msgstr "EMPAQUETAR"

#. type: Plain text
#: original/txt/usr_41.txt:1599
#, no-wrap
msgid ""
"To avoid your function names to interfere with functions that you get from\n"
"others, use this scheme:\n"
"- Prepend a unique string before each function name.  I often use an\n"
"  abbreviation.  For example, \"OW_\" is used for the option window functions.\n"
"- Put the definition of your functions together in a file.  Set a global\n"
"  variable to indicate that the functions have been loaded.  When sourcing the\n"
"  file again, first unload the functions.\n"
"Example: >\n"
msgstr ""
"Para evitar que los nombres de funciones que defina interfieran con\n"
"otras funciones, use el siguiente esquema:\n"
"- Anteponga una cadena única a cada nombre de función. A menudo uso una\n"
"  abreviatura. Por ejemplo, uso «OV» para las funciones relacionadas con\n"
"  opciones de ventana.\n"
"- Ponga todas las definiciones de sus funciones en un mismo archivo. Cree una\n"
"  variable global para indicar que las funciones ya fueron cargadas. Cuando\n"
"  cargue el archivo de nuevo, elimine antes las definiciones de las funciones.\n"
"Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:1601
#, no-wrap
msgid "\t\" This is the XXX package\n"
msgstr "\t\" Este es el paquete XXX\n"

#. type: Plain text
#: original/txt/usr_41.txt:1606
#, no-wrap
msgid ""
"\tif exists(\"XXX_loaded\")\n"
"\t  delfun XXX_one\n"
"\t  delfun XXX_two\n"
"\tendif\n"
msgstr ""
"\tif exists(\"XXX_cargado\")\n"
"\t  delfun XXX_uno\n"
"\t  delfun XXX_dos\n"
"\tendif\n"

#. type: Plain text
#: original/txt/usr_41.txt:1610
#, no-wrap
msgid ""
"\tfunction XXX_one(a)\n"
"\t\t... body of function ...\n"
"\tendfun\n"
msgstr ""
"\tfunction XXX_uno(a)\n"
"\t\t... cuerpo de la función ...\n"
"\tendfun\n"

#. type: Plain text
#: original/txt/usr_41.txt:1614
#, no-wrap
msgid ""
"\tfunction XXX_two(b)\n"
"\t\t... body of function ...\n"
"\tendfun\n"
msgstr ""
"\tfunction XXX_dos(b)\n"
"\t\t... cuerpo de la función ...\n"
"\tendfun\n"

#. type: Plain text
#: original/txt/usr_41.txt:1616
#, no-wrap
msgid "\tlet XXX_loaded = 1\n"
msgstr "\tlet XXX_loaded = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:1619
#, no-wrap
msgid "*41.11*\tWriting a plugin\t\t\t\t*write-plugin*\n"
msgstr "*41.11*\tEscribir extensiones\t\t\t\t*write-plugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:1623
msgid ""
"You can write a Vim script in such a way that many people can use it.  This "
"is called a plugin.  Vim users can drop your script in their plugin "
"directory and use its features right away |add-plugin|."
msgstr ""
"Puede crear un script de Vim de tal forma que lo puedan usar varias "
"personas. Esto se llama una extensión. Los usuarios de Vim pueden copiar el "
"script en su directorio «plugin/», y utilizarlo en el momento con |add-"
"plugin|."

#. type: Plain text
#: original/txt/usr_41.txt:1625
msgid "There are actually two types of plugins:"
msgstr "Existen dos tipos de extensiones:"

#. type: Plain text
#: original/txt/usr_41.txt:1628
#, no-wrap
msgid ""
"  global plugins: For all types of files.\n"
"filetype plugins: Only for files of a specific type.\n"
msgstr ""
"          Extensiones globales: Empleadas con todos los tipos de archivo.\n"
"Extensiones de tipo de archivo: Empleadas con tipos de archivo específicos.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1632
msgid ""
"In this section the first type is explained.  Most items are also relevant "
"for writing filetype plugins.  The specifics for filetype plugins are in the "
"next section |write-filetype-plugin|."
msgstr ""
"En esta sección se describirán las extensiones globales («global plugins»). "
"La mayoría de elementos también son necesarios para escribir extensiones de "
"tipo de archivo («filetype plugins»). La sección a continuación, |write-"
"filetype-plugin|, detalla las extensiones de tipo de archivo."

#. type: Plain text
#: original/txt/usr_41.txt:1635
msgid "NAME"
msgstr "NOMBRE"

#. type: Plain text
#: original/txt/usr_41.txt:1641
msgid ""
"First of all you must choose a name for your plugin.  The features provided "
"by the plugin should be clear from its name.  And it should be unlikely that "
"someone else writes a plugin with the same name but which does something "
"different.  And please limit the name to 8 characters, to avoid problems on "
"old Windows systems."
msgstr ""
"Primero, debe elegir un nombre para su extensión. El nombre debería mostrar "
"las funcionalidades ofrecidas por la extensión. Así mismo, debería ser poco "
"probable que alguien escriba una extensión con el mismo nombre pero otras "
"funcionalidades. Por último, limite el nombre a ocho caracteres para evitar "
"problemas en antiguos sistemas de Windows."

#. type: Plain text
#: original/txt/usr_41.txt:1644
msgid ""
"A script that corrects typing mistakes could be called \"typecorr.vim\".  We "
"will use it here as an example."
msgstr ""
"Un script que corrige errores tipográficos se podría llamar «correccort."
"vim». Lo usaremos como ejemplo."

#. type: Plain text
#: original/txt/usr_41.txt:1647
msgid ""
"For the plugin to work for everybody, it should follow a few guidelines.  "
"This will be explained step-by-step.  The complete example plugin is at the "
"end."
msgstr ""
"Para que funcione en cualquier sistema, la extensión debería seguir algunas "
"normas, las cuales se detallarán paso a paso. La extensión de ejemplo "
"completa se encuentra al final de la sección."

#. type: Plain text
#: original/txt/usr_41.txt:1650
msgid "BODY"
msgstr "CUERPO"

#. type: Plain text
#: original/txt/usr_41.txt:1652
msgid ""
"Let's start with the body of the plugin, the lines that do the actual work: >"
msgstr ""
"Vamos a comenzar con el cuerpo de la extensión, las líneas que realmente "
"hacen el trabajo: >"

#. type: Plain text
#: original/txt/usr_41.txt:1659
#, no-wrap
msgid ""
" 14\tiabbrev teh the\n"
" 15\tiabbrev otehr other\n"
" 16\tiabbrev wnat want\n"
" 17\tiabbrev synchronisation\n"
" 18\t\t\\ synchronization\n"
" 19\tlet s:count = 4\n"
msgstr ""
" 14\tiabbrev csaa casa\n"
" 15\tiabbrev ootr otro\n"
" 16\tiabbrev qeu que\n"
" 17\tiabbrev sicronizacion\n"
" 18\t\t\\ sincronización\n"
" 19\tlet s:cuenta = 4\n"

#. type: Plain text
#: original/txt/usr_41.txt:1661
msgid "The actual list should be much longer, of course."
msgstr "Por supuesto, la lista debería ser mucho más larga."

#. type: Plain text
#: original/txt/usr_41.txt:1664
msgid ""
"The line numbers have only been added to explain a few things, don't put "
"them in your plugin file!"
msgstr ""
"Los números de línea se han añadido en pro de la claridad. ¡No los incluya "
"en su archivo de extensión!"

#. type: Plain text
#: original/txt/usr_41.txt:1667
msgid "HEADER"
msgstr "CABECERA"

#. type: Plain text
#: original/txt/usr_41.txt:1672
msgid ""
"You will probably add new corrections to the plugin and soon have several "
"versions laying around.  And when distributing this file, people will want "
"to know who wrote this wonderful plugin and where they can send remarks.  "
"Therefore, put a header at the top of your plugin: >"
msgstr ""
"Lo más probable es que añada nuevas correcciones a la extensión, y tenga en poco tiempo varias "
"versiones de ésta. Cuando distribuya el archivo, la gente querrá saber quién "
"escribió esta maravillosa extensión, y dónde pueden enviar comentarios. Por "
"ello, incluya un encabezado al principio de su extensión: >"

#. type: Plain text
#: original/txt/usr_41.txt:1676
#, no-wrap
msgid ""
"  1\t\" Vim global plugin for correcting typing mistakes\n"
"  2\t\" Last Change:\t2000 Oct 15\n"
"  3\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
msgstr ""
"  1\t\" Extensión global de Vim para la corrección de errores\n"
"  2\t\" Último cambio:\t15 de octubre de 2000\n"
"  3\t\" Desarrollador:\tBram Moolenaar <Bram@vim.org>\n"

#. type: Plain text
#: original/txt/usr_41.txt:1681
msgid ""
"About copyright and licensing: Since plugins are very useful and it's hardly "
"worth restricting their distribution, please consider making your plugin "
"either public domain or use the Vim |license|.  A short note about this near "
"the top of the plugin should be sufficient.  Example: >"
msgstr ""
"Derechos de autor y licencias: Debido a que las extensiones son útiles, y "
"que no merece la pena restringir su distribución, considere que su extensión "
"sea de dominio público, o use la licencia de Vim (|license|). Una breve "
"nota cerca del inicio de la extensión debería servir. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:1683
#, no-wrap
msgid "  4\t\" License:\tThis file is placed in the public domain.\n"
msgstr "  4\t\" Licencia:\tEste fichero pertenece al dominio público.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1686
#, no-wrap
msgid "LINE CONTINUATION, AVOIDING SIDE EFFECTS\t\t*use-cpo-save*\n"
msgstr "CONTINUACIÓN DE LÍNEA, EVITAR EFECTOS SECUNDARIOS\t*use-cpo-save*\n"

#. type: Plain text
#: original/txt/usr_41.txt:1693
msgid ""
"In line 18 above, the line-continuation mechanism is used |line-"
"continuation|.  Users with 'compatible' set will run into trouble here, they "
"will get an error message.  We can't just reset 'compatible', because that "
"has a lot of side effects.  To avoid this, we will set the 'cpoptions' "
"option to its Vim default value and restore it later.  That will allow the "
"use of line-continuation and make the script work for most people.  It is "
"done like this: >"
msgstr ""
"En la línea 18 del ejemplo anterior se usa el mecanismo |line-continuation|, "
"continuación de línea. Los usuarios que definan 'compatible' pueden "
"encontrar problemas con esto, y se les mostraría un mensaje de error. No "
"podemos simplemente reiniciar 'compatible' porque tiene muchos efectos "
"secundarios. Para evitarlo, definimos la opción 'cpoptions' con el valor "
"predeterminado de Vim para restaurarlo más tarde. Esto permite el uso de "
"«line-continuation» y que el script funcione en la mayoría de sistemas. Se "
"hace de la siguiente forma: >"

#. type: Plain text
#: original/txt/usr_41.txt:1698
#, no-wrap
msgid ""
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" ..\n"
" 42\tlet &cpo = s:save_cpo\n"
msgstr ""
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" ..\n"
" 42\tlet &cpo = s:save_cpo\n"

#. type: Plain text
#: original/txt/usr_41.txt:1701
msgid ""
"We first store the old value of 'cpoptions' in the s:save_cpo variable.  At "
"the end of the plugin this value is restored."
msgstr ""
"Primero almacenamos el valor antiguo de 'cpoptions'  en la variable «s:"
"save_cpo». El valor se restaurará al final de la extensión."

#. type: Plain text
#: original/txt/usr_41.txt:1705
msgid ""
"Notice that a script-local variable is used |s:var|.  A global variable "
"could already be in use for something else.  Always use script-local "
"variables for things that are only used in the script."
msgstr ""
"Tenga en cuenta que se usa una variable local de script, |s:var|. Puede que "
"se esté utilizando una variable global para otra cosa. Use siempre variables "
"locales en el script para aquello que se usa sólo en el script."

#. type: Plain text
#: original/txt/usr_41.txt:1708
msgid "NOT LOADING"
msgstr "EVITAR LA CARGA DE LA EXTENSIÓN"

#. type: Plain text
#: original/txt/usr_41.txt:1713
msgid ""
"It's possible that a user doesn't always want to load this plugin.  Or the "
"system administrator has dropped it in the system-wide plugin directory, but "
"a user has his own plugin he wants to use.  Then the user must have a chance "
"to disable loading this specific plugin.  This will make it possible: >"
msgstr ""
"Es posible que el usuario no desee cargar la extensión en cada momento. O que "
"el administrador del sistema lo haya copiado al directorio de extensiones del "
"sistema, pero el usuario quiere usar el suyo propio. En ese caso, el usuario "
"debe tener la posibilidad de desactivar cargar esta extensión en particular. "
"Lo siguiente lo hace posible: >"

#. type: Plain text
#: original/txt/usr_41.txt:1718
#, no-wrap
msgid ""
"  6\tif exists(\"g:loaded_typecorr\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_typecorr = 1\n"
msgstr ""
"  6\tif exists(\"g:loaded_correccort\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_correccort = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:1722
msgid ""
"This also avoids that when the script is loaded twice it would cause error "
"messages for redefining functions and cause trouble for autocommands that "
"are added twice."
msgstr ""
"También evita cargar el script dos veces, lo que provocaría mensajes de "
"error al redefinir las funciones, y provocar problemas con las órdenes "
"automáticas que se cargan por duplicado."

#. type: Plain text
#: original/txt/usr_41.txt:1727
msgid ""
"The name is recommended to start with \"loaded_\" and then the file name of "
"the plugin, literally.  The \"g:\" is prepended just to avoid mistakes when "
"using the variable in a function (without \"g:\" it would be a variable "
"local to the function)."
msgstr ""
"Se recomienda que el nombre empiece con «loaded_» y, a continuación, el "
"nombre literal de la extensión. La «g:» se añade para evitar errores al usar "
"la variable en una función (sin la «g:», sería una variable local a la "
"función)."

#. type: Plain text
#: original/txt/usr_41.txt:1730
msgid ""
"Using \"finish\" stops Vim from reading the rest of the file, it's much "
"quicker than using if-endif around the whole file."
msgstr ""
"Usar «finish» impide que Vim lea el resto del archivo, lo cual es mucho más "
"rápido que usar «if-endif» a lo largo del archivo."

#. type: Plain text
#: original/txt/usr_41.txt:1733
msgid "MAPPING"
msgstr "MACROS"

#. type: Plain text
#: original/txt/usr_41.txt:1739
msgid ""
"Now let's make the plugin more interesting: We will add a mapping that adds "
"a correction for the word under the cursor.  We could just pick a key "
"sequence for this mapping, but the user might already use it for something "
"else.  To allow the user to define which keys a mapping in a plugin uses, "
"the <Leader> item can be used: >"
msgstr ""
"Ahora, vamos a hacer que la extensión sea más interesante: vamos a añadir "
"una macro que añade una corrección para la palabra bajo el cursor. Podríamos "
"escoger una secuencia de teclas para esta macro, pero puede que el usuario "
"la esté usando para otra cosa. Puede usar el elemento <Leader> para permitir "
"que el usuario pueda definir las teclas que utiliza la macro de una "
"extensión: >"

#. type: Plain text
#: original/txt/usr_41.txt:1741
#, no-wrap
msgid " 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
msgstr " 22\t  map <unique> <Leader>a  <Plug>CorreccortAñadir\n"

#. type: Plain text
#: original/txt/usr_41.txt:1743
msgid ""
"The \"<Plug>TypecorrAdd\" thing will do the work, more about that further on."
msgstr ""
"El elemento «<Plug>CorreccortAñadir» daría un buen resultado, a continuación "
"dispone de más información."

#. type: Plain text
#: original/txt/usr_41.txt:1746
msgid ""
"The user can set the \"mapleader\" variable to the key sequence that he "
"wants this mapping to start with.  Thus if the user has done: >"
msgstr ""
"El usuario puede definir la variable «mapleader» con la secuencia de teclas "
"con la que desea iniciar esta macro. Por lo tanto, si el usuario define: >"

#. type: Plain text
#: original/txt/usr_41.txt:1748
#, no-wrap
msgid "\tlet mapleader = \"_\"\n"
msgstr "\tlet mapleader = \"_\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:1751
msgid ""
"the mapping will define \"_a\".  If the user didn't do this, the default "
"value will be used, which is a backslash.  Then a map for \"\\a\" will be "
"defined."
msgstr ""
"la macro se definirá como «_a». En caso contrario se usará el valor "
"predeterminado, que es una barra inversa. Por ello, se definiría una macro "
"como «\\a»."

#. type: Plain text
#: original/txt/usr_41.txt:1754
msgid ""
"Note that <unique> is used, this will cause an error message if the mapping "
"already happened to exist. |:map-<unique>|"
msgstr ""
"Tenga en cuenta se usa <unique>, lo que provocaría un mensaje de error si la "
"macro ya existe.  |:map-<unique>|"

#. type: Plain text
#: original/txt/usr_41.txt:1757
msgid ""
"But what if the user wants to define his own key sequence? We can allow that "
"with this mechanism: >"
msgstr ""
"Puede usar el siguiente mecanismo para permitir que el usuario defina su "
"propia secuencia de teclas si así lo desea: >"

#. type: Plain text
#: original/txt/usr_41.txt:1761
#, no-wrap
msgid ""
" 21\tif !hasmapto('<Plug>TypecorrAdd')\n"
" 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
" 23\tendif\n"
msgstr ""
" 21\tif !hasmapto('<Plug>CorreccortAñadir')\n"
" 22\t  map <unique> <Leader>a  <Plug>CorreccortAñadir\n"
" 23\tendif\n"

#. type: Plain text
#: original/txt/usr_41.txt:1765
msgid ""
"This checks if a mapping to \"<Plug>TypecorrAdd\" already exists, and only "
"defines the mapping from \"<Leader>a\" if it doesn't.  The user then has a "
"chance of putting this in his vimrc file: >"
msgstr ""
"Esto comprueba si ya existe una macro para «<Plug>CorrecortAñadir», y sólo "
"define la macro de «<Leader>a» si no existe. Así, el usuario tiene la "
"posibilidad de insertar esto en su archivo «vimrc»: >"

#. type: Plain text
#: original/txt/usr_41.txt:1767
#, no-wrap
msgid "\tmap ,c  <Plug>TypecorrAdd\n"
msgstr "\tmap ,c  <Plug>CorreccortAñadir\n"

#. type: Plain text
#: original/txt/usr_41.txt:1769
msgid ""
"Then the mapped key sequence will be \",c\" instead of \"_a\" or \"\\a\"."
msgstr ""
"Así, la secuencia de teclas asignada sería «,c» en lugar de «_a» o «\\a»."

#. type: Plain text
#: original/txt/usr_41.txt:1772
msgid "PIECES"
msgstr "SEGMENTOS"

#. type: Plain text
#: original/txt/usr_41.txt:1779
msgid ""
"If a script gets longer, you often want to break up the work in pieces.  You "
"can use functions or mappings for this.  But you don't want these functions "
"and mappings to interfere with the ones from other scripts.  For example, "
"you could define a function Add(), but another script could try to define "
"the same function.  To avoid this, we define the function local to the "
"script by prepending it with \"s:\"."
msgstr ""
"Habitualmente querrá dividir un script en segmentos cuando es demasiado "
"largo. Para ello, puede usar funciones o macros, pero no desea que estas "
"funciones y macros interfieran con los presentes en otros scripts. Por "
"ejemplo, podría definir la función «Anadir()» pero otro script podría "
"intentar definir la misma función. Para evitar esto, definimos la función "
"como local al script anteponiendo a este «s:»."

#. type: Plain text
#: original/txt/usr_41.txt:1781
msgid "We will define a function that adds a new typing correction: >"
msgstr ""
"A continuación definimos una función que añade una nueva corrección "
"ortográfica: >"

#. type: Plain text
#: original/txt/usr_41.txt:1787
#, no-wrap
msgid ""
" 30\tfunction s:Add(from, correct)\n"
" 31\t  let to = input(\"type the correction for \" . a:from . \": \")\n"
" 32\t  exe \":iabbrev \" . a:from . \" \" . to\n"
" ..\n"
" 36\tendfunction\n"
msgstr ""
" 30\tfunction s:Anadir(desde, correccion)\n"
" 31\t  let a = input(\"Introduzca la corrección para \" . a:desde . \": \")\n"
" 32\t  exe \":iabbrev \" . a:desde . \" \" . a\n"
" ..\n"
" 36\tendfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:1792
msgid ""
"Now we can call the function s:Add() from within this script.  If another "
"script also defines s:Add(), it will be local to that script and can only be "
"called from the script it was defined in.  There can also be a global Add()  "
"function (without the \"s:\"), which is again another function."
msgstr ""
"Ahora invocamos la función «s:Anadir()» desde el mismo script. Si otro script "
"también define «s:Anadir()», será local a ese script y solo se invocará desde "
"el script en el que se define. También puede existir una función global "
"«Anadir()» (sin la «s:»), que es otra función distinta."

#. type: Plain text
#: original/txt/usr_41.txt:1795
msgid ""
"<SID> can be used with mappings.  It generates a script ID, which identifies "
"the current script.  In our typing correction plugin we use it like this: >"
msgstr ""
"Puede usar <SID> en una macro. Genera un identificador de script, que "
"identifica al script actual. En nuestra extensión de corrección usaremos "
"algo similar a esto: >"

#. type: Plain text
#: original/txt/usr_41.txt:1799
#, no-wrap
msgid ""
" 24\tnoremap <unique> <script> <Plug>TypecorrAdd  <SID>Add\n"
" ..\n"
" 28\tnoremap <SID>Add  :call <SID>Add(expand(\"<cword>\"), 1)<CR>\n"
msgstr ""
" 24\tnoremap <unique> <script> <Plug>CorreccortAñadir  <SID>Añadir\n"
" ..\n"
" 28\tnoremap <SID>Añadir  :call <SID>Anadir(expand(\"<cword>\"), 1)<CR>\n"

#. type: Plain text
#: original/txt/usr_41.txt:1801
msgid "Thus when a user types \"\\a\", this sequence is invoked: >"
msgstr "Así, cuando el usuario teclea «\\a», se invoca esta secuencia: >"

#. type: Plain text
#: original/txt/usr_41.txt:1803
#, no-wrap
msgid "\t\\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()\n"
msgstr "\t\\a -> <Plug>CorreccortAñadir -> <SID>Añadir -> :call <SID>Anadir()\n"

#. type: Plain text
#: original/txt/usr_41.txt:1806
msgid ""
"If another script would also map <SID>Add, it would get another script ID "
"and thus define another mapping."
msgstr ""
"Si otro script asigna <SID>Añadir a una macro, tendría otro identificador de "
"script y por ello definiría otra macro."

#. type: Plain text
#: original/txt/usr_41.txt:1811
msgid ""
"Note that instead of s:Add() we use <SID>Add() here.  That is because the "
"mapping is typed by the user, thus outside of the script.  The <SID> is "
"translated to the script ID, so that Vim knows in which script to look for "
"the Add() function."
msgstr ""
"Tenga en cuenta que se usó «<SID>Anadir()» en lugar de «s:Anadir()» aquí. "
"Eso es porque la macro es tecleada por el usuario, y por ello, se hace desde "
"fuera del script. <SID> se expande al identificador del script, de forma "
"que Vim sabe en qué script buscar la función «Anadir()»."

#. type: Plain text
#: original/txt/usr_41.txt:1815
msgid ""
"This is a bit complicated, but it's required for the plugin to work together "
"with other plugins.  The basic rule is that you use <SID>Add() in mappings "
"and s:Add() in other places (the script itself, autocommands, user commands)."
msgstr ""
"Es un poco complicado, pero es necesario para que la extensión funcione "
"adecuadamente con otras. La norma básica es que debe usar <SID>Anadir() en "
"las macros y s:Anadir() en otros sitios (el mismo script, órdenes "
"automáticas, órdenes de usuario)."

#. type: Plain text
#: original/txt/usr_41.txt:1817
msgid "We can also add a menu entry to do the same as the mapping: >"
msgstr ""
"También podemos añadir una entrada de menú para que haga lo mismo que la "
"macro: >"

#. type: Plain text
#: original/txt/usr_41.txt:1819
#, no-wrap
msgid " 26\tnoremenu <script> Plugin.Add\\ Correction      <SID>Add\n"
msgstr " 26\tnoremenu <script> Plugin.Añadir\\ Corrección      <SID>Añadir\n"

#. type: Plain text
#: original/txt/usr_41.txt:1824
msgid ""
"The \"Plugin\" menu is recommended for adding menu items for plugins.  In "
"this case only one item is used.  When adding more items, creating a submenu "
"is recommended.  For example, \"Plugin.CVS\" could be used for a plugin that "
"offers CVS operations \"Plugin.CVS.checkin\", \"Plugin.CVS.checkout\", etc."
msgstr ""
"Se recomienda el menú «Plugin» para añadir elementos de menú de extensiones. "
"En este caso, sólo se usa un elemento. Recomendamos crear un menú secundario "
"si añade más elementos. Por ejemplo, podría usar «Plugin.CVS» para una "
"extensión que ofrezca operaciones CVS como «Plugin.CVS.checkin», «Plugin.CVS."
"checkout», etc."

#. type: Plain text
#: original/txt/usr_41.txt:1831
msgid ""
"Note that in line 28 \":noremap\" is used to avoid that any other mappings "
"cause trouble.  Someone may have remapped \":call\", for example.  In line "
"24 we also use \":noremap\", but we do want \"<SID>Add\" to be remapped.  "
"This is why \"<script>\" is used here.  This only allows mappings which are "
"local to the script. |:map-<script>| The same is done in line 26 for \":"
"noremenu\".  |:menu-<script>|"
msgstr ""
"Tenga en cuenta que «:noremap» se usa en la línea 28 para evitar problemas "
"con otras macros. Puede que alguien haya asignado otra macro a «:call», por "
"ejemplo. En la línea 24 también usamos «:noremap», pero queremos reasignar "
"«<SID>Añadir». Por ello usamos aquí «<script>». Esto solo permite el uso de "
"macros locales al script; para más información consulte |:map-<script>|. Se "
"realiza la misma acción en la línea 26 con «:noremenu»; para más información "
"consulte  |:menu-<script>|."

#. type: Plain text
#: original/txt/usr_41.txt:1834
#, no-wrap
msgid "<SID> AND <Plug>\t\t\t\t\t*using-<Plug>*\n"
msgstr "<SID> Y <Plug>\t\t\t\t\t\t*using-<Plug>*\n"

#. type: Plain text
#: original/txt/usr_41.txt:1838
msgid ""
"Both <SID> and <Plug> are used to avoid that mappings of typed keys "
"interfere with mappings that are only to be used from other mappings.  Note "
"the difference between using <SID> and <Plug>:"
msgstr ""
"<SID> y <Plug> se usan para evitar que las macros de las teclas pulsadas "
"interfieran con macros sólo usadas desde otras macros. Note la diferencia "
"entre <SID> y <Plug>:"

#. type: Plain text
#: original/txt/usr_41.txt:1848
#, no-wrap
msgid ""
"<Plug>\tis visible outside of the script.  It is used for mappings which the\n"
"\tuser might want to map a key sequence to.  <Plug> is a special code\n"
"\tthat a typed key will never produce.\n"
"\tTo make it very unlikely that other plugins use the same sequence of\n"
"\tcharacters, use this structure: <Plug> scriptname mapname\n"
"\tIn our example the scriptname is \"Typecorr\" and the mapname is \"Add\".\n"
"\tThis results in \"<Plug>TypecorrAdd\".  Only the first character of\n"
"\tscriptname and mapname is uppercase, so that we can see where mapname\n"
"\tstarts.\n"
msgstr ""
"<Plug>\tes visible fuera del script. Se usa para macros que el usuario\n"
"\tpueda querer ligar a un secuencia de teclas. <Plug> es un código\n"
"\tespecial que una tecla nunca podrá producir.\n"
"\tPara evitar que otras extensiones usen la misma secuencia de\n"
"\tcaracteres, use la estructura: <Plug> nombre-script nombre-macro\n"
"\tEn nuestro ejemplo, el nombre del script es «Correccort», y el nombre\n"
"\tde la macro es «Añadir».\n"
"\tEl resultado es «<Plug>CorreccortAñadir». Solo el primer carácter de\n"
"\tlos nombres es mayúscula, facilitando ver el principio del nombre de\n"
"\tla macro.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1856
#, no-wrap
msgid ""
"<SID>\tis the script ID, a unique identifier for a script.\n"
"\tInternally Vim translates <SID> to \"<SNR>123_\", where \"123\" can be any\n"
"\tnumber.  Thus a function \"<SID>Add()\" will have a name \"<SNR>11_Add()\"\n"
"\tin one script, and \"<SNR>22_Add()\" in another.  You can see this if\n"
"\tyou use the \":function\" command to get a list of functions.  The\n"
"\ttranslation of <SID> in mappings is exactly the same, that's how you\n"
"\tcan call a script-local function from a mapping.\n"
msgstr ""
"<SID>\tes el identificador (ID) del script, un número único.\n"
"\tInternamente, Vim traduce <SID> como «<SNR>123_», donde «123» puede\n"
"\tser cualquier número. Por ello, la función «<SID>Anadir()» tendría el\n"
"\tnombre «<SNR>11_Anadir()» en un script, y «<SNR>22_Anadir()» en otro.\n"
"\tPuede verlo si usa la orden «:function» para obtener la lista de\n"
"\tfunciones.\n"
"\tLa traducción de <SID> en las macros es idéntica, y así puede invocar\n"
"\tuna función local de un script mediante una macro.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1859
msgid "USER COMMAND"
msgstr "ORDEN DE USUARIO"

#. type: Plain text
#: original/txt/usr_41.txt:1861
msgid "Now let's add a user command to add a correction: >"
msgstr "Vamos a añadir una orden de usuario para añadir una corrección: >"

#. type: Plain text
#: original/txt/usr_41.txt:1865
#, no-wrap
msgid ""
" 38\tif !exists(\":Correct\")\n"
" 39\t  command -nargs=1  Correct  :call s:Add(<q-args>, 0)\n"
" 40\tendif\n"
msgstr ""
" 38\tif !exists(\":Corregir\")\n"
" 39\t  command -nargs=1  Corregir  :call s:Anadir(<q-args>, 0)\n"
" 40\tendif\n"

#. type: Plain text
#: original/txt/usr_41.txt:1870
msgid ""
"The user command is defined only if no command with the same name already "
"exists.  Otherwise we would get an error here.  Overriding the existing user "
"command with \":command!\" is not a good idea, this would probably make the "
"user wonder why the command he defined himself doesn't work.  |:command|"
msgstr ""
"La orden de usuario se define únicamente si no existe una orden con el mismo "
"nombre. En caso contrario, provocaría un error. Sobrescribir la orden de "
"usuario existente con «:command!» no es una buena idea, ya que haría que el "
"usuario se pregunte porqué no funciona la orden que ha definido. |:command|"

#. type: Plain text
#: original/txt/usr_41.txt:1873
msgid "SCRIPT VARIABLES"
msgstr "VARIABLES DE SCRIPT"

#. type: Plain text
#: original/txt/usr_41.txt:1879
msgid ""
"When a variable starts with \"s:\" it is a script variable.  It can only be "
"used inside a script.  Outside the script it's not visible.  This avoids "
"trouble with using the same variable name in different scripts.  The "
"variables will be kept as long as Vim is running.  And the same variables "
"are used when sourcing the same script again. |s:var|"
msgstr ""
"Cuando una variable comienza con «s:», es una variable de script. Sólo se "
"puede usar dentro de un script, y no es visible desde fuera. Esto evita "
"problemas al usar el mismo nombre de variable en diferentes scripts. Las "
"variables se preservarán durante la ejecución de Vim, y se usan al cargar el "
"mismo script otra vez. |s:var|"

#. type: Plain text
#: original/txt/usr_41.txt:1883
msgid ""
"The fun is that these variables can also be used in functions, autocommands "
"and user commands that are defined in the script.  In our example we can add "
"a few lines to count the number of corrections: >"
msgstr ""
"Lo interesante es que estas variables se pueden usar en funciones, órdenes "
"automáticas y órdenes de usuario definidas en el script. En nuestro ejemplo, "
"añadimos unas pocas líneas para contar el número de correcciones: >"

#. type: Plain text
#: original/txt/usr_41.txt:1891
#, no-wrap
msgid ""
" 19\tlet s:count = 4\n"
" ..\n"
" 30\tfunction s:Add(from, correct)\n"
" ..\n"
" 34\t  let s:count = s:count + 1\n"
" 35\t  echo s:count . \" corrections now\"\n"
" 36\tendfunction\n"
msgstr ""
" 19\tlet s:cuenta = 4\n"
" ..\n"
" 30\tfunction s:Anadir(desde, correccion)\n"
" ..\n"
" 34\t  let s:cuenta = s:cuenta + 1\n"
" 35\t  echo s:cuenta . \" correcciones en este punto\"\n"
" 36\tendfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:1896
msgid ""
"First s:count is initialized to 4 in the script itself.  When later the s:Add"
"() function is called, it increments s:count.  It doesn't matter from where "
"the function was called, since it has been defined in the script, it will "
"use the local variables from this script."
msgstr ""
"Al principio, «s:cuenta» se inicializa en el mismo script con un valor de 4. "
"Al invocar la función «Anadir()» posteriormente, incrementa la variable «s:"
"cuenta». No importa desde dónde se ha invocado la función, ya que está "
"definida en el script, y usará las variables locales al script."

#. type: Plain text
#: original/txt/usr_41.txt:1899
msgid "THE RESULT"
msgstr "EL RESULTADO"

#. type: Plain text
#: original/txt/usr_41.txt:1901
msgid "Here is the resulting complete example: >"
msgstr "Aquí tiene el ejemplo completo finalizado: >"

# TODO the script doesn't do what it says it does. Fails at replacement of
# newly-added corrections
#. type: Plain text
#: original/txt/usr_41.txt:1944
#, no-wrap
msgid ""
"  1\t\" Vim global plugin for correcting typing mistakes\n"
"  2\t\" Last Change:\t2000 Oct 15\n"
"  3\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
"  4\t\" License:\tThis file is placed in the public domain.\n"
"  5\n"
"  6\tif exists(\"g:loaded_typecorr\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_typecorr = 1\n"
" 10\n"
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" 13\n"
" 14\tiabbrev teh the\n"
" 15\tiabbrev otehr other\n"
" 16\tiabbrev wnat want\n"
" 17\tiabbrev synchronisation\n"
" 18\t\t\\ synchronization\n"
" 19\tlet s:count = 4\n"
" 20\n"
" 21\tif !hasmapto('<Plug>TypecorrAdd')\n"
" 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
" 23\tendif\n"
" 24\tnoremap <unique> <script> <Plug>TypecorrAdd  <SID>Add\n"
" 25\n"
" 26\tnoremenu <script> Plugin.Add\\ Correction      <SID>Add\n"
" 27\n"
" 28\tnoremap <SID>Add  :call <SID>Add(expand(\"<cword>\"), 1)<CR>\n"
" 29\n"
" 30\tfunction s:Add(from, correct)\n"
" 31\t  let to = input(\"type the correction for \" . a:from . \": \")\n"
" 32\t  exe \":iabbrev \" . a:from . \" \" . to\n"
" 33\t  if a:correct | exe \"normal viws\\<C-R>\\\" \\b\\e\" | endif\n"
" 34\t  let s:count = s:count + 1\n"
" 35\t  echo s:count . \" corrections now\"\n"
" 36\tendfunction\n"
" 37\n"
" 38\tif !exists(\":Correct\")\n"
" 39\t  command -nargs=1  Correct  :call s:Add(<q-args>, 0)\n"
" 40\tendif\n"
" 41\n"
" 42\tlet &cpo = s:save_cpo\n"
msgstr ""
"  1 \" Extensión global de Vim para la corrección de errores\n"
"  2\t\" Último cambio:\t15 de Octubre de 2000\n"
"  3\t\" Desarrollador:\tBram Moolenaar <Bram@vim.org>\n"
"  5\n"
"  6\tif exists(\"g:loaded_correccort\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_correccort = 1\n"
" 10\n"
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" 13\n"
" 14\tiabbrev csaa casa\n"
" 15\tiabbrev ootr otro\n"
" 16\tiabbrev qeu que\n"
" 17\tiabbrev sicronizacion\n"
" 18\t\t\\ sincronización\n"
" 19\tlet s:cuenta = 4\n"
" 20\n"
" 21\tif !hasmapto('<Plug>CorreccortAñadir')\n"
" 22\t  map <unique> <Leader>a  <Plug>CorreccortAñadir\n"
" 23\tendif\n"
" 24\tnoremap <unique> <script> <Plug>CorreccortAñadir  <SID>Añadir\n"
" 25\n"
" 26\tnoremenu <script> Plugin.Añadir\\ Corrección      <SID>Añadir\n"
" 27\n"
" 28\tnoremap <SID>Añadir  :call <SID>Anadir(expand(\"<cword>\"), 1)<CR>\n"
" 29\n"
" 30\tfunction s:Anadir(desde, correccion)\n"
" 31\t  let a = input(\"introduce la corrección de \" . a:desde . \": \")\n"
" 32\t  exe \":iabbrev \" . a:desde . \" \" . a\n"
" 33\t  if a:correccion | exe \"normal viws\\<C-R>\\\" \\b\\e\" | endif\n"
" 34\t  let s:cuenta = s:cuenta + 1\n"
" 35\t  echo s:cuenta . \" correcciones en este punto\"\n"
" 36\tendfunction\n"
" 37\n"
" 38\tif !exists(\":Corregir\")\n"
" 39\t  command -nargs=1  Corregir  :call s:Anadir(<q-args>, 0)\n"
" 40\tendif\n"
" 41\n"
" 42\tlet &cpo = s:save_cpo\n"

#. type: Plain text
#: original/txt/usr_41.txt:1949
msgid ""
"Line 33 wasn't explained yet.  It applies the new correction to the word "
"under the cursor.  The |:normal| command is used to use the new "
"abbreviation.  Note that mappings and abbreviations are expanded here, even "
"though the function was called from a mapping defined with \":noremap\"."
msgstr ""
"Aún no hemos explicado la línea 33. Aplica la nueva corrección a la palabra "
"bajo el cursor. La orden |:normal| se emplea para usar la nueva abreviatura. "
"Tenga en cuenta que aquí se expanden las macros y abreviaturas, a pesar de "
"que la función se ha invocado desde una macro definida con «:noremap»."

#. type: Plain text
#: original/txt/usr_41.txt:1954
msgid ""
"Using \"unix\" for the 'fileformat' option is recommended.  The Vim scripts "
"will then work everywhere.  Scripts with 'fileformat' set to \"dos\" do not "
"work on Unix.  Also see |:source_crnl|.  To be sure it is set right, do this "
"before writing the file: >"
msgstr ""
"Se recomienda usar «unix» como valor para la opción 'fileformat'. De esta "
"forma, los scripts de Vim funcionarán en cualquier sistema. Los scripts con "
"'fileformat' definido como «dos» no funcionarán en Unix. También puede "
"consultar |:source_crnl|. Para asegurar que hace lo correcto, haga lo "
"siguiente antes de escribir el archivo: >"

#. type: Plain text
#: original/txt/usr_41.txt:1956
#, no-wrap
msgid "\t:set fileformat=unix\n"
msgstr "\t:set fileformat=unix\n"

#. type: Plain text
#: original/txt/usr_41.txt:1959
#, no-wrap
msgid "DOCUMENTATION\t\t\t\t\t\t*write-local-help*\n"
msgstr "DOCUMENTACIÓN   \t\t\t\t\t*write-local-help*\n"

#. type: Plain text
#: original/txt/usr_41.txt:1963
msgid ""
"It's a good idea to also write some documentation for your plugin.  "
"Especially when its behavior can be changed by the user.  See |add-local-"
"help| for how they are installed."
msgstr ""
"Es una buena idea crear algo de documentación para su extensión, en "
"particular si el usuario puede modificar su comportamiento. Para lo referente "
"a la instalación de documentación, consulte |add-local-help|."

#. type: Plain text
#: original/txt/usr_41.txt:1965
msgid ""
"Here is a simple example for a plugin help file, called \"typecorr.txt\": >"
msgstr ""
"Aquí tiene un simple ejemplo para un archivo de ayuda de una extensión, "
"llamado «typecorr.txt»: >"

#. type: Plain text
#: original/txt/usr_41.txt:1983
#, no-wrap
msgid ""
"  1\t*typecorr.txt*\tPlugin for correcting typing mistakes\n"
"  2\n"
"  3\tIf you make typing mistakes, this plugin will have them corrected\n"
"  4\tautomatically.\n"
"  5\n"
"  6\tThere are currently only a few corrections.  Add your own if you like.\n"
"  7\n"
"  8\tMappings:\n"
"  9\t<Leader>a   or   <Plug>TypecorrAdd\n"
" 10\t\tAdd a correction for the word under the cursor.\n"
" 11\n"
" 12\tCommands:\n"
" 13\t:Correct {word}\n"
" 14\t\tAdd a correction for {word}.\n"
" 15\n"
" 16\t\t\t\t\t\t\t*typecorr-settings*\n"
" 17\tThis plugin doesn't have any settings.\n"
msgstr ""
"  1\t*correcort.txt*\tUna extensión para corregir errores ortográficos\n"
"  2\n"
"  3\tEsta extensión corrige automáticamente cualquier error ortográfico\n"
"  4\tque pueda escribir.\n"
"  5\n"
"  6\tSolo hay unas pocas correcciones. Puede añadir las suyas.\n"
"  7\n"
"  8\tMacros:\n"
"  9\t<Leader>a   o   <Plug>CorreccortAñadir\n"
" 10\t\tAñade una corrección para la palabra bajo el cursor.\n"
" 11\n"
" 12\tÓrdenes:\n"
" 13\t:Corregir {palabra}\n"
" 14\t\tAñade una corrección para {palabra}.\n"
" 15\n"
" 16\t\t\t\t\t\t\t*correcort-opciones*\n"
" 17\tEsta extensión no tiene opciones de configuración.\n"

#. type: Plain text
#: original/txt/usr_41.txt:1989
msgid ""
"The first line is actually the only one for which the format matters.  It "
"will be extracted from the help file to be put in the \"LOCAL ADDITIONS:\" "
"section of help.txt |local-additions|.  The first \"*\" must be in the first "
"column of the first line.  After adding your help file do \":help\" and "
"check that the entries line up nicely."
msgstr ""
"En realidad, la primera línea es la única en la que el formato importa. Se "
"extraerá del archivo de ayuda para su ubicación en la sección «LOCAL "
"ADDITIONS:» de help.txt |local-additions|. El primer asterisco debe estar en "
"la primera columna de la primera línea. Ejecute «:help» después de añadir su "
"archivo de ayuda y compruebe que las entradas están alineadas adecuadamente."

#. type: Plain text
#: original/txt/usr_41.txt:1993
msgid ""
"You can add more tags inside ** in your help file.  But be careful not to "
"use existing help tags.  You would probably use the name of your plugin in "
"most of them, like \"typecorr-settings\" in the example."
msgstr ""
"Puede añadir más etiquetas entre asteriscos ** en su archivo de ayuda, pero "
"tenga la precaución de no usar etiquetas de ayuda existentes. Probablemente "
"use el nombre de su extensión en la mayoría de etiquetas, como "
"«correccort-opciones» en el ejemplo."

#. type: Plain text
#: original/txt/usr_41.txt:1996
msgid ""
"Using references to other parts of the help in || is recommended.  This "
"makes it easy for the user to find associated help."
msgstr ""
"Se recomienda utilizar referencias a otras partes de archivos de ayuda "
"mediante barras, ||. Esto facilita que el usuario encuentre ayuda "
"relacionada."

# TODO bug en la sintaxis de vim/help ?
#. type: Plain text
#: original/txt/usr_41.txt:1999
#, no-wrap
msgid "FILETYPE DETECTION\t\t\t\t\t*plugin-filetype*\n"
msgstr "EXTENSIÓN DE TIPO DE ARCHIVO\t\t\t*plugin-filetype*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2004
msgid ""
"If your filetype is not already detected by Vim, you should create a "
"filetype detection snippet in a separate file.  It is usually in the form of "
"an autocommand that sets the filetype when the file name matches a pattern.  "
"Example: >"
msgstr ""
"Si Vim no detecta su tipo de archivo, debería crear un fragmento de código "
"de detección de tipo de archivo en un archivo separado. Habitualmente, tiene "
"la forma de una orden automática que define el tipo de archivo cuando su "
"nombre concuerda con un patrón. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2006
#, no-wrap
msgid "\tau BufNewFile,BufRead *.foo\t\t\tset filetype=foofoo\n"
msgstr "\tau BufNewFile,BufRead *.foo\t\t\tset filetype=foofoo\n"

#. type: Plain text
#: original/txt/usr_41.txt:2011
msgid ""
"Write this single-line file as \"ftdetect/foofoo.vim\" in the first "
"directory that appears in 'runtimepath'.  For Unix that would be \"~/.vim/"
"ftdetect/foofoo.vim\".  The convention is to use the name of the filetype "
"for the script name."
msgstr ""
"Escriba este archivo de una sola línea como «ftdetect/foofoo.vim» en el "
"primer directorio que aparece en su 'runtimepath'. En Unix, sería "
"«~/.vim/ftdetect/foofoo.vim». La convención es nombrar el script como el "
"nombre del tipo de archivo."

#. type: Plain text
#: original/txt/usr_41.txt:2014
msgid ""
"You can make more complicated checks if you like, for example to inspect the "
"contents of the file to recognize the language.  Also see |new-filetype|."
msgstr ""
"Si lo desea, puede hacer comprobaciones más complejas como inspeccionar los "
"contenidos de un archivo para reconocer el tipo del mismo. Consulte también "
"|new-filetype|."

#. type: Plain text
#: original/txt/usr_41.txt:2017
#, no-wrap
msgid "SUMMARY\t\t\t\t\t\t\t*plugin-special*\n"
msgstr "RESUMEN\t\t\t\t\t\t\t*plugin-special*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2019
msgid "Summary of special things to use in a plugin:"
msgstr "Resumen de los elementos especiales a utilizar en una extensión:"

#. type: Plain text
#: original/txt/usr_41.txt:2021
#, no-wrap
msgid "s:name\t\t\tVariables local to the script.\n"
msgstr "s:nombre\t\tVariables locales al script.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2024
#, no-wrap
msgid ""
"<SID>\t\t\tScript-ID, used for mappings and functions local to\n"
"\t\t\tthe script.\n"
msgstr ""
"<SID>\t\t\tEl identificador del script (Script-ID), utilizado en\n"
"\t\t\tmacros y funciones locales al script.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2027
#, no-wrap
msgid ""
"hasmapto()\t\tFunction to test if the user already defined a mapping\n"
"\t\t\tfor functionality the script offers.\n"
msgstr ""
"hasmapto()\t\tUna función que comprueba si el usuario ya ha definido\n"
"\t\t\tuna macro para la funcionalidad que el script ofrece.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2030
#, no-wrap
msgid ""
"<Leader>\t\tValue of \"mapleader\", which the user defines as the\n"
"\t\t\tkeys that plugin mappings start with.\n"
msgstr ""
"<Leader>\t\tEl valor de «mapleader», que el usuario define como\n"
"\t\t\tlas teclas con las que iniciar las macros de\n"
"\t\t\textensiones.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2032
#, no-wrap
msgid ":map <unique>\t\tGive a warning if a mapping already exists.\n"
msgstr "::map <unique>\t\tEmite un aviso si la macro ya existe.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2035
#, no-wrap
msgid ""
":noremap <script>\tUse only mappings local to the script, not global\n"
"\t\t\tmappings.\n"
msgstr ":noremap <script>\tSólo usa macros locales al script, no macros globales.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2037
#, no-wrap
msgid "exists(\":Cmd\")\t\tCheck if a user command already exists.\n"
msgstr "exists(\":Orden\")\tComprueba la existencia de una orden de usuario.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2040
#, no-wrap
msgid "*41.12*\tWriting a filetype plugin\t*write-filetype-plugin* *ftplugin*\n"
msgstr ""
"\t\t\t\t\t*write-filetype-plugin* *ftplugin*\n"
"*41.12*\tEscribir extensiones de tipo de archivo\n"

#. type: Plain text
#: original/txt/usr_41.txt:2044
msgid ""
"A filetype plugin is like a global plugin, except that it sets options and "
"defines mappings for the current buffer only.  See |add-filetype-plugin| for "
"how this type of plugin is used."
msgstr ""
"Una extensión de tipo de archivo («filetype plugin») es como una extensión "
"global, a diferencia de que define opciones y macros que solo afectan al "
"búfer local. Para saber más acerca del uso de este tipo de extensión, "
"consulte  |add-filetype-plugin|."

#. type: Plain text
#: original/txt/usr_41.txt:2049
msgid ""
"First read the section on global plugins above |41.11|.  All that is said "
"there also applies to filetype plugins.  There are a few extras, which are "
"explained here.  The essential thing is that a filetype plugin should only "
"have an effect on the current buffer."
msgstr ""
"En primer lugar, consulte la sección anterior sobre extensiones globales, |"
"41.11|. Todo lo detallado ahí también afecta a las extensiones de tipo de "
"archivo. Hay algunos elementos adicionales, que se explican aquí. Lo "
"esencial es que una extensión de tipo de archivo sólo debe tener efecto en "
"el búfer actual."

#. type: Plain text
#: original/txt/usr_41.txt:2052
msgid "DISABLING"
msgstr "DESACTIVAR"

#. type: Plain text
#: original/txt/usr_41.txt:2055
msgid ""
"If you are writing a filetype plugin to be used by many people, they need a "
"chance to disable loading it.  Put this at the top of the plugin: >"
msgstr ""
"Si esta escribiendo una extensión de tipo de archivo que mucha gente usará, "
"necesitarán la capacidad de desactivar su carga. Inserte lo siguiente al "
"principio de la extensión: >"

#. type: Plain text
#: original/txt/usr_41.txt:2061
#, no-wrap
msgid ""
"\t\" Only do this when not done yet for this buffer\n"
"\tif exists(\"b:did_ftplugin\")\n"
"\t  finish\n"
"\tendif\n"
"\tlet b:did_ftplugin = 1\n"
msgstr ""
"\t\" Solo hace esto cuando aún no ha finalizado con este búfer\n"
"\tif exists(\"b:did_ftplugin\")\n"
"\t  finish\n"
"\tendif\n"
"\tlet b:did_ftplugin = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:2064
msgid ""
"This also needs to be used to avoid that the same plugin is executed twice "
"for the same buffer (happens when using an \":edit\" command without "
"arguments)."
msgstr ""
"Esto también sirve para evitar la ejecución de la misma extensión por "
"duplicado en el mismo búfer (ocurre al usar la orden «:edit» sin argumentos)."

#. type: Plain text
#: original/txt/usr_41.txt:2067
msgid ""
"Now users can disable loading the default plugin completely by making a "
"filetype plugin with only this line: >"
msgstr ""
"Usando este mecanismo, los usuarios pueden evitar cargar la extensión "
"predeterminada si así lo desean, creando una extensión de tipo de archivo con "
"sólo esta línea: >"

#. type: Plain text
#: original/txt/usr_41.txt:2069
#, no-wrap
msgid "\tlet b:did_ftplugin = 1\n"
msgstr "\tlet b:did_ftplugin = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:2072
msgid ""
"This does require that the filetype plugin directory comes before "
"$VIMRUNTIME in 'runtimepath'!"
msgstr ""
"Esto requiere que el directorio de extensiones de tipo de archivo aparezca "
"antes de $VIMRUNTIME en 'runtimepath'."

#. type: Plain text
#: original/txt/usr_41.txt:2075
msgid ""
"If you do want to use the default plugin, but overrule one of the settings, "
"you can write the different setting in a script: >"
msgstr ""
"Si desea usar la extensión predeterminada, pero cambiar la configuración de "
"alguna de sus opciones, puede escribir un valor diferente para ellas en un "
"script: >"

#. type: Plain text
#: original/txt/usr_41.txt:2077
#, no-wrap
msgid "\tsetlocal textwidth=70\n"
msgstr "\tsetlocal textwidth=70\n"

#. type: Plain text
#: original/txt/usr_41.txt:2082
msgid ""
"Now write this in the \"after\" directory, so that it gets sourced after the "
"distributed \"vim.vim\" ftplugin |after-directory|.  For Unix this would be "
"\"~/.vim/after/ftplugin/vim.vim\".  Note that the default plugin will have "
"set \"b:did_ftplugin\", but it is ignored here."
msgstr ""
"Escriba esto en el directorio «after», para que se lea después de la "
"extensión de tipo de archivo predeterminado distribuido, «vim.vim» |after-"
"directory|.  En sistemas Unix, sería «~/.vim/after/ftplugin/vim.vim». Tenga "
"en cuenta que la extensión predeterminada habrá definido «b:did_ftplugin», "
"pero aquí se ignora."

#. type: Plain text
#: original/txt/usr_41.txt:2087
msgid ""
"To make sure the filetype plugin only affects the current buffer use the >"
msgstr ""
"Para asegurar que la extensión de tipo de archivo solo afecta al búfer "
"actual, use la orden >"

#. type: Plain text
#: original/txt/usr_41.txt:2089
#, no-wrap
msgid "\t:setlocal\n"
msgstr "\t:setlocal\n"

#. type: Plain text
#: original/txt/usr_41.txt:2094
msgid ""
"command to set options.  And only set options which are local to a buffer "
"(see the help for the option to check that).  When using |:setlocal| for "
"global options or options local to a window, the value will change for many "
"buffers, and that is not what a filetype plugin should do."
msgstr ""
"para definir opciones, y sólo defina opciones locales al búfer (consulte la "
"ayuda para la opción que comprueba esto). Al usar |:setlocal| con opciones "
"globales u opciones locales para una ventana, el valor cambiará para muchos "
"búfers, y una extensión de tipo de archivo no debería hacer esto."

#. type: Plain text
#: original/txt/usr_41.txt:2099
msgid ""
"When an option has a value that is a list of flags or items, consider using "
"\"+=\" and \"-=\" to keep the existing value.  Be aware that the user may "
"have changed an option value already.  First resetting to the default value "
"and then changing it often a good idea.  Example: >"
msgstr ""
"Cuando una opción tiene un valor que es una lista de opciones o elementos, "
"considere usar «+=» y «-=» para conservar el valor existente. Sea consciente "
"de que puede que el usuario ya haya cambiado el valor de una opción. Es una "
"buena idea restablecer el valor original y después cambiarlo. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2101
#, no-wrap
msgid "\t:setlocal formatoptions& formatoptions+=ro\n"
msgstr "\t:setlocal formatoptions& formatoptions+=ro\n"

#. type: Plain text
#: original/txt/usr_41.txt:2104
msgid "MAPPINGS"
msgstr "MACROS"

#. type: Plain text
#: original/txt/usr_41.txt:2106
msgid "To make sure mappings will only work in the current buffer use the >"
msgstr ""
"Para asegurar que las macros sólo funcionen en el búfer local use la orden >"

#. type: Plain text
#: original/txt/usr_41.txt:2108
#, no-wrap
msgid "\t:map <buffer>\n"
msgstr "\t:map <buffer>\n"

#. type: Plain text
#: original/txt/usr_41.txt:2111
msgid ""
"command.  This needs to be combined with the two-step mapping explained "
"above.  An example of how to define functionality in a filetype plugin: >"
msgstr ""
"Se debe usar en combinación con la macro compuesta de dos pasos explicada "
"anteriormente. A continuación una definición de ejemplo para una "
"funcionalidad en una extensión de tipo de archivo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2116
#, no-wrap
msgid ""
"\tif !hasmapto('<Plug>JavaImport')\n"
"\t  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport\n"
"\tendif\n"
"\tnoremap <buffer> <unique> <Plug>JavaImport oimport \"\"<Left><Esc>\n"
msgstr ""
"\tif !hasmapto('<Plug>JavaImport')\n"
"\t  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport\n"
"\tendif\n"
"\tnoremap <buffer> <unique> <Plug>JavaImport oimport \"\"<Left><Esc>\n"

# TODO mal ubicados los cambios de línea
#. type: Plain text
#: original/txt/usr_41.txt:2127
msgid ""
"|hasmapto()| is used to check if the user has already defined a map to "
"<Plug>JavaImport.  If not, then the filetype plugin defines the default "
"mapping.  This starts with |<LocalLeader>|, which allows the user to select "
"the key(s) he wants filetype plugin mappings to start with.  The default is "
"a backslash.  \"<unique>\" is used to give an error message if the mapping "
"already exists or overlaps with an existing mapping.  |:noremap| is used to "
"avoid that any other mappings that the user has defined interferes.  You "
"might want to use \":noremap <script>\" to allow remapping mappings defined "
"in this script that start with <SID>."
msgstr ""
"|hasmapto()| sirve para comprobar si el usuario ya ha definido una macro para "
"«<Plug>JavaImport». Si no ha sido definida, la extensión de tipo de archivo "
"define la macro actual. Esta empieza con |<LocalLeader>|, que permite al "
"usuario seleccionar una o mas teclas con las que iniciar las macros de la "
"extensión de tipo de archivo. El valor predeterminado es una barra inversa, "
"«\\». «<unique>» sirve para emitir un mensaje de error si la macro ya existe "
"o entra en conflicto con otra. |:noremap| sirve para evitar que las macros "
"definidas por el usuario interfieran. Puede que desee usar «:noremap "
"<script>» para permitir redefinir macros en el script que comienza con <SID>."

#. type: Plain text
#: original/txt/usr_41.txt:2131
msgid ""
"The user must have a chance to disable the mappings in a filetype plugin, "
"without disabling everything.  Here is an example of how this is done for a "
"plugin for the mail filetype: >"
msgstr ""
"Tiene que ofrecer al usuario la opción de desactivar macros en una extensión "
"de tipo de archivo, sin desactivar el resto. Aquí tiene un ejemplo de como "
"hacerlo con una extensión para el tipo de archivo mail: >"

#. type: Plain text
#: original/txt/usr_41.txt:2142
#, no-wrap
msgid ""
"\t\" Add mappings, unless the user didn't want this.\n"
"\tif !exists(\"no_plugin_maps\") && !exists(\"no_mail_maps\")\n"
"\t  \" Quote text by inserting \"> \"\n"
"\t  if !hasmapto('<Plug>MailQuote')\n"
"\t    vmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t    nmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t  endif\n"
"\t  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>\n"
"\t  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>\n"
"\tendif\n"
msgstr ""
"\t\" Añade macros, a menos que el usuario defina lo contrario.\n"
"\tif !exists(\"no_plugin_maps\") && !exists(\"no_mail_maps\")\n"
"\t  \" Cita el texto insertando «> »\n"
"\t  if !hasmapto('<Plug>MailQuote')\n"
"\t    vmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t    nmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t  endif\n"
"\t  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>\n"
"\t  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>\n"
"\tendif\n"

#. type: Plain text
#: original/txt/usr_41.txt:2146
#, no-wrap
msgid ""
"Two global variables are used:\n"
"no_plugin_maps\t\tdisables mappings for all filetype plugins\n"
"no_mail_maps\t\tdisables mappings for a specific filetype\n"
msgstr ""
"Se utilizan dos variables globales:\n"
"no_plugin_maps\t\tdesactiva las macros de todas las extensiones de tipo\n"
"\t\t\tde archivo\n"
"no_mail_maps\t\tdesactiva las macros para un tipo de archivo\n"
"\t\t\tparticular\n"

#. type: Plain text
#: original/txt/usr_41.txt:2149
msgid "USER COMMANDS"
msgstr "ÓRDENES DE USUARIO"

#. type: Plain text
#: original/txt/usr_41.txt:2152
msgid ""
"To add a user command for a specific file type, so that it can only be used "
"in one buffer, use the \"-buffer\" argument to |:command|.  Example: >"
msgstr ""
"El argumento «-buffer» de |:command| permite añadir una orden de usuario "
"para un tipo de archivo específico y que solo afecta al búfer local. "
"Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2154
#, no-wrap
msgid "\t:command -buffer  Make  make %:r.s\n"
msgstr "\t:command -buffer  Make  make %:r.s\n"

#. type: Plain text
#: original/txt/usr_41.txt:2157
msgid "VARIABLES"
msgstr "VARIABLES"

#. type: Plain text
#: original/txt/usr_41.txt:2161
msgid ""
"A filetype plugin will be sourced for each buffer of the type it's for.  "
"Local script variables |s:var| will be shared between all invocations.  Use "
"local buffer variables |b:var| if you want a variable specifically for one "
"buffer."
msgstr ""
"Las extensiones de tipo de archivo serán cargadas en cada búfer del tipo "
"correspondiente. Las variables de script locales |s:var| se compartirán entre "
"las diferentes llamadas a una misma extensión (o script en general.) Use las "
"variables locales al búfer |b:var| si desea usar una variable local a un "
"búfer."

#. type: Plain text
#: original/txt/usr_41.txt:2164
msgid "FUNCTIONS"
msgstr "FUNCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:2168
msgid ""
"When defining a function, this only needs to be done once.  But the filetype "
"plugin will be sourced every time a file with this filetype will be opened.  "
"This construct makes sure the function is only defined once: >"
msgstr ""
"Cada función necesita ser definida una sola vez. Pero la extensión de tipo de "
"archivo se cargará cada vez que se abra un archivo del tipo correspondiente. "
"Esta estructura asegura que la función se defina una sola vez: >"

#. type: Plain text
#: original/txt/usr_41.txt:2175
#, no-wrap
msgid ""
"\t:if !exists(\"*s:Func\")\n"
"\t:  function s:Func(arg)\n"
"\t:    ...\n"
"\t:  endfunction\n"
"\t:endif\n"
"<\n"
msgstr ""
"\t:if !exists(\"*s:Func\")\n"
"\t:  function s:Func(arg)\n"
"\t:    ...\n"
"\t:  endfunction\n"
"\t:endif\n"
"<\n"

#. type: Plain text
#: original/txt/usr_41.txt:2177
#, no-wrap
msgid "UNDO\t\t\t\t\t\t\t*undo_ftplugin*\n"
msgstr "DESHACER \t\t\t\t\t*undo_ftplugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2181
msgid ""
"When the user does \":setfiletype xyz\" the effect of the previous filetype "
"should be undone.  Set the b:undo_ftplugin variable to the commands that "
"will undo the settings in your filetype plugin.  Example: >"
msgstr ""
"Cuando el usuario hace «:setfiletype xyz», el efecto del tipo de archivo "
"anterior debería desaparecer. Defina la variable «b:undo_ftplugin» con las "
"órdenes que deshacen los cambios de configuración de su extensión de tipo de "
"archivo.  Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2184
#, no-wrap
msgid ""
"\tlet b:undo_ftplugin = \"setlocal fo< com< tw< commentstring<\"\n"
"\t\t\\ . \"| unlet b:match_ignorecase b:match_words b:match_skip\"\n"
msgstr ""
"\tlet b:undo_ftplugin = \"setlocal fo< com< tw< commentstring<\"\n"
"\t\t\\ . \"| unlet b:match_ignorecase b:match_words b:match_skip\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:2187
msgid ""
"Using \":setlocal\" with \"<\" after the option name resets the option to "
"its global value.  That is mostly the best way to reset the option value."
msgstr ""
"Usar «:setlocal» con «<» después del nombre de la opción restablece la "
"opción a su valor global. Habitualmente, es la mejor forma de restablecer el "
"valor de una opción."

#. type: Plain text
#: original/txt/usr_41.txt:2190
msgid ""
"This does require removing the \"C\" flag from 'cpoptions' to allow line "
"continuation, as mentioned above |use-cpo-save|."
msgstr ""
"Esto requiere eliminar la opción «C» de 'cpoptions' para permitir la "
"continuación de la línea, como se mencionó anteriormente |use-cpo-save|."

#. type: Plain text
#: original/txt/usr_41.txt:2193
msgid "FILE NAME"
msgstr "NOMBRE DE ARCHIVO"

#. type: Plain text
#: original/txt/usr_41.txt:2196
msgid ""
"The filetype must be included in the file name |ftplugin-name|.  Use one of "
"these three forms:"
msgstr ""
"El nombre del archivo debe incluir el tipo de archivo |ftplugin-name|. Puede "
"usar una de las tres formas a continuación:"

#. type: Plain text
#: original/txt/usr_41.txt:2200
#, no-wrap
msgid ""
"\t.../ftplugin/stuff.vim\n"
"\t.../ftplugin/stuff_foo.vim\n"
"\t.../ftplugin/stuff/bar.vim\n"
msgstr ""
"\t.../ftplugin/algo.vim\n"
"\t.../ftplugin/algo_foo.vim\n"
"\t.../ftplugin/algo/bar.vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:2202
msgid "\"stuff\" is the filetype, \"foo\" and \"bar\" are arbitrary names."
msgstr "«algo» es el tipo de archivo, «foo» y «bar» son nombres aleatorios."

#. type: Plain text
#: original/txt/usr_41.txt:2205
#, no-wrap
msgid "SUMMARY\t\t\t\t\t\t\t*ftplugin-special*\n"
msgstr "RESUMEN\t\t\t\t\t\t\t*ftplugin-special*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2207
msgid "Summary of special things to use in a filetype plugin:"
msgstr ""
"Un resumen de los aspectos a considerar cuando escriba una extensión de tipo "
"de archivo:"

#. type: Plain text
#: original/txt/usr_41.txt:2210
#, no-wrap
msgid ""
"<LocalLeader>\t\tValue of \"maplocalleader\", which the user defines as\n"
"\t\t\tthe keys that filetype plugin mappings start with.\n"
msgstr ""
"<LocalLeader>\t\tEl valor de «maplocalleader», que el usuario define\n"
"\t\t\tcomo la tecla que inicia las macros de extensión de\n"
"\t\t\ttipo de archivo.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2212
#, no-wrap
msgid ":map <buffer>\t\tDefine a mapping local to the buffer.\n"
msgstr ":map <buffer>\t\tDefine una macro local al búfer.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2215
#, no-wrap
msgid ""
":noremap <script>\tOnly remap mappings defined in this script that start\n"
"\t\t\twith <SID>.\n"
msgstr ""
":noremap <script>\tSólo modifica macros definidas en el script que\n"
"\t\t\tcomienzan con <SID>.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2217
#, no-wrap
msgid ":setlocal\t\tSet an option for the current buffer only.\n"
msgstr ":setlocal\t\tDefine una opción para el búfer actual.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2219
#, no-wrap
msgid ":command -buffer\tDefine a user command local to the buffer.\n"
msgstr ":command -buffer\tDefine una orden de usuario local al búfer.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2221
#, no-wrap
msgid "exists(\"*s:Func\")\tCheck if a function was already defined.\n"
msgstr ""
"exists(\"*s:Funcion\")\tComprueba si una función ya se ha definido\n"
"\t\t\tanteriormente.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2223
msgid "Also see |plugin-special|, the special things used for all plugins."
msgstr ""
"Consulte también |plugin-special|, las cosas especiales utilizadas por todas "
"las extensiones."

#. type: Plain text
#: original/txt/usr_41.txt:2226
#, no-wrap
msgid "*41.13*\tWriting a compiler plugin\t\t*write-compiler-plugin*\n"
msgstr "*41.13*\tEscribir extensiones para compiladores\t*write-compiler-plugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2230
msgid ""
"A compiler plugin sets options for use with a specific compiler.  The user "
"can load it with the |:compiler| command.  The main use is to set the "
"'errorformat' and 'makeprg' options."
msgstr ""
"Una extensión de compilador define opciones a usar con un compilador "
"específico. El usuario puede cargarlo con la orden |:compiler|. El uso "
"principal es definir las opciones 'errorformat' y 'makeprg'."

#. type: Plain text
#: original/txt/usr_41.txt:2233
msgid ""
"Easiest is to have a look at examples.  This command will edit all the "
"default compiler plugins: >"
msgstr ""
"Lo más sencillo es ver unos ejemplos. Esta orden editará todas las "
"extensiones de compilador predeterminadas: >"

#. type: Plain text
#: original/txt/usr_41.txt:2235
#, no-wrap
msgid "\t:next $VIMRUNTIME/compiler/*.vim\n"
msgstr "\t:next $VIMRUNTIME/compiler/*.vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:2237
msgid "Use |:next| to go to the next plugin file."
msgstr "Use |:next| para ir al siguiente archivo de extensión."

#. type: Plain text
#: original/txt/usr_41.txt:2240
msgid ""
"There are two special items about these files.  First is a mechanism to "
"allow a user to overrule or add to the default file.  The default files "
"start with: >"
msgstr ""
"Hay dos aspectos a tener en cuenta con estas extensiones. En primer lugar, "
"deben contar con un mecanismo que permita al usuario anular o añadir cambios "
"a la extensión. Las extensiones predeterminadas comienzan con: >"

#. type: Plain text
#: original/txt/usr_41.txt:2245
#, no-wrap
msgid ""
"\t:if exists(\"current_compiler\")\n"
"\t:  finish\n"
"\t:endif\n"
"\t:let current_compiler = \"mine\"\n"
msgstr ""
"\t:if exists(\"current_compiler\")\n"
"\t:  finish\n"
"\t:endif\n"
"\t:let current_compiler = \"mine\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:2254
#, no-wrap
msgid ""
"When you write a compiler file and put it in your personal runtime directory\n"
"(e.g., ~/.vim/compiler for Unix), you set the \"current_compiler\" variable to\n"
"make the default file skip the settings.\n"
"\t\t\t\t\t\t\t*:CompilerSet*\n"
"The second mechanism is to use \":set\" for \":compiler!\" and \":setlocal\" for\n"
"\":compiler\".  Vim defines the \":CompilerSet\" user command for this.  However,\n"
"older Vim versions don't, thus your plugin should define it then.  This is an\n"
"example: >\n"
msgstr ""
"Cuando escribe un archivo de compilador, y lo ubica en su directorio de\n"
"ejecución personal (esto es, «~/.vim/compiler» en sistemas Unix), debe definir\n"
"la variable «current_compiler» para que la extensión de compilador\n"
"predeterminada evite hacer cambios en la configuración.\n"
"\t\t\t\t\t\t\t*:CompilerSet*\n"
"El segundo mecanismo es usar «:set» con «:compiler!», y «:setlocal» con\n"
"«:compiler». Para ello, Vim define la orden de usuario «:CompilerSet». Por\n"
"otra parte, las versiones anteriores de Vim no cuentan de ella, y por ello su\n"
"extensión debe definirlo. Aquí tiene un ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:2260
#, no-wrap
msgid ""
"  if exists(\":CompilerSet\") != 2\n"
"    command -nargs=* CompilerSet setlocal <args>\n"
"  endif\n"
"  CompilerSet errorformat&\t\t\" use the default 'errorformat'\n"
"  CompilerSet makeprg=nmake\n"
msgstr ""
"  if exists(\":CompilerSet\") != 2\n"
"    command -nargs=* CompilerSet setlocal <args>\n"
"  endif\n"
"  CompilerSet errorformat&\t\t\" usa 'errorformat' predeterminado\n"
"  CompilerSet makeprg=nmake\n"

#. type: Plain text
#: original/txt/usr_41.txt:2264
msgid ""
"When you write a compiler plugin for the Vim distribution or for a system-"
"wide runtime directory, use the mechanism mentioned above.  When "
"\"current_compiler\" was already set by a user plugin nothing will be done."
msgstr ""
"Use el mecanismo mostrado aquí cuando escriba una extensión de "
"compilador para la distribución Vim o para un directorio de tiempo de "
"ejecución del sistema. No se hará nada si «current_compiler» ya está "
"definido por una extensión de usuario."

#. type: Plain text
#: original/txt/usr_41.txt:2269
msgid ""
"When you write a compiler plugin to overrule settings from a default plugin, "
"don't check \"current_compiler\".  This plugin is supposed to be loaded "
"last, thus it should be in a directory at the end of 'runtimepath'.  For "
"Unix that could be ~/.vim/after/compiler."
msgstr ""
"Cuando escribe una extensión de compilador para cambiar las opciones "
"definidas por una extensión predeterminada, evite comprobar "
"«current_compiler». Esta extensión se debería cargar al final, y por ello "
"debería estar en un directorio al final de 'runtimepath'. En sistemas Unix, "
"podría ser «~/.vim/after/compiler»."

#. type: Plain text
#: original/txt/usr_41.txt:2272
#, no-wrap
msgid "*41.14*\tWriting a plugin that loads quickly\t*write-plugin-quickload*\n"
msgstr "*41.14*\tEscribir extensiones que carguen rápidamente  *write-plugin-quickload*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2276
msgid ""
"A plugin may grow and become quite long.  The startup delay may become "
"noticeable, while you hardly ever use the plugin.  Then it's time for a "
"quickload plugin."
msgstr ""
"Puede que una extensión crezca, y que sea demasiado larga. Puede que el "
"tiempo de carga empiece a hacerse notorio, y además, que usted apenas use la "
"extensión. En este caso, hay que usar una extensión de carga rápida "
"(«quickload»)."

#. type: Plain text
#: original/txt/usr_41.txt:2280
msgid ""
"The basic idea is that the plugin is loaded twice.  The first time user "
"commands and mappings are defined that offer the functionality.  The second "
"time the functions that implement the functionality are defined."
msgstr ""
"La idea principal es que la extensión se carga dos veces. La primera vez, se "
"definen las órdenes de usuario y macros que ofrecen la funcionalidad de la "
"extensión. La segunda vez, se definen las funciones que implementan tales "
"funcionalidades."

#. type: Plain text
#: original/txt/usr_41.txt:2285
msgid ""
"It may sound surprising that quickload means loading a script twice.  What "
"we mean is that it loads quickly the first time, postponing the bulk of the "
"script to the second time, which only happens when you actually use it.  "
"When you always use the functionality it actually gets slower!"
msgstr ""
"Puede que sorprenda que «carga rápida» signifique cargar una extensión dos "
"veces.  Lo que queremos decir es que se carga rápidamente la primera, "
"demorando la carga de la mayoría de la extensión a la segunda vez, lo que "
"sólo ocurre cuando realmente la usa. ¡Si usa siempre la funcionalidad que "
"provee la extensión, no obtendrá ninguna ventaja!"

#. type: Plain text
#: original/txt/usr_41.txt:2288
msgid ""
"Note that since Vim 7 there is an alternative: use the |autoload| "
"functionality |41.15|."
msgstr ""
"Tenga en cuenta que hay una alternativa a partir de la versión 7 de Vim: use "
"la funcionalidad |autoload|, |41.15|."

#. type: Plain text
#: original/txt/usr_41.txt:2290
msgid "The following example shows how it's done: >"
msgstr "Los siguientes ejemplos muestran como se hace: >"

#. type: Plain text
#: original/txt/usr_41.txt:2295
#, no-wrap
msgid ""
"\t\" Vim global plugin for demonstrating quick loading\n"
"\t\" Last Change:\t2005 Feb 25\n"
"\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
"\t\" License:\tThis file is placed in the public domain.\n"
msgstr ""
"\t\" Extensión global de Vim para mostrar la carga rápida\n"
"\t\" Último cambio:\t2005 Feb 25\n"
"\t\" Desarrollador:\tBram Moolenaar <Bram@vim.org>\n"
"\t\" Licencia:\tEste archivo se encuentra en el dominio público\n"

#. type: Plain text
#: original/txt/usr_41.txt:2299
#, no-wrap
msgid ""
"\tif !exists(\"s:did_load\")\n"
"\t\tcommand -nargs=* BNRead  call BufNetRead(<f-args>)\n"
"\t\tmap <F19> :call BufNetWrite('something')<CR>\n"
msgstr ""
"\tif !exists(\"s:did_load\")\n"
"\t\tcommand -nargs=* BNRead  call BufNetRead(<f-args>)\n"
"\t\tmap <F19> :call BufNetWrite('algo')<CR>\n"

#. type: Plain text
#: original/txt/usr_41.txt:2304
#, no-wrap
msgid ""
"\t\tlet s:did_load = 1\n"
"\t\texe 'au FuncUndefined BufNet* source ' . expand('<sfile>')\n"
"\t\tfinish\n"
"\tendif\n"
msgstr ""
"\t\tlet s:did_load = 1\n"
"\t\texe 'au FuncUndefined BufNet* source ' . expand('<sfile>')\n"
"\t\tfinish\n"
"\tendif\n"

#. type: Plain text
#: original/txt/usr_41.txt:2309
#, no-wrap
msgid ""
"\tfunction BufNetRead(...)\n"
"\t\techo 'BufNetRead(' . string(a:000) . ')'\n"
"\t\t\" read functionality here\n"
"\tendfunction\n"
msgstr ""
"\tfunction BufNetRead(...)\n"
"\t\techo 'BufNetRead(' . string(a:000) . ')'\n"
"\t\t\" Funcionalidad de lectura aquí\n"
"\tendfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:2314
#, no-wrap
msgid ""
"\tfunction BufNetWrite(...)\n"
"\t\techo 'BufNetWrite(' . string(a:000) . ')'\n"
"\t\t\" write functionality here\n"
"\tendfunction\n"
msgstr ""
"\tfunction BufNetWrite(...)\n"
"\t\techo 'BufNetWrite(' . string(a:000) . ')'\n"
"\t\t\" Funcionalidad de escritura aquí\n"
"\tendfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:2318
msgid ""
"When the script is first loaded \"s:did_load\" is not set.  The commands "
"between the \"if\" and \"endif\" will be executed.  This ends in a |:finish| "
"command, thus the rest of the script is not executed."
msgstr ""
"Cuando el script se carga por primera vez, «s:did_load» no está definida, y "
"se ejecutan las órdenes entre «if» y «endif». Se termina con una orden "
"|:finish|, impidiendo ejecutar el resto del script."

#. type: Plain text
#: original/txt/usr_41.txt:2322
msgid ""
"The second time the script is loaded \"s:did_load\" exists and the commands "
"after the \"endif\" are executed.  This defines the (possible long)  "
"BufNetRead() and BufNetWrite() functions."
msgstr ""
"La segunda vez que se carga, «s:did_load» existe y se ejecutan las órdenes "
"después de «endif». Esto define las (posiblemente largas) funciones "
"BufNetRead() y BufNetWrite()."

#. type: Plain text
#: original/txt/usr_41.txt:2325
msgid ""
"If you drop this script in your plugin directory Vim will execute it on "
"startup.  This is the sequence of events that happens:"
msgstr ""
"Si ubica este script en su directorio «plugin», Vim lo ejecutará al inicio. "
"A continuación la secuencia de los eventos:"

#. type: Plain text
#: original/txt/usr_41.txt:2329
#, no-wrap
msgid ""
"1. The \"BNRead\" command is defined and the <F19> key is mapped when the script\n"
"   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The\n"
"   \":finish\" command causes the script to terminate early.\n"
msgstr ""
"1. Se define la orden «BNRead» y la tecla <F19> se asigna a una macro al cargar\n"
"el script al inicio. Se define una orden automática |FuncUndefined|. La orden\n"
"  «:finish» hace que el script finalice antes.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2332
#, no-wrap
msgid ""
"2. The user types the BNRead command or presses the <F19> key.  The\n"
"   BufNetRead() or BufNetWrite() function will be called.\n"
msgstr ""
"2. El usuario introduce la orden «BNRead» o pulsa la tecla <F19>. Se\n"
"  invoca la función «BufNetRead()» o «BufNetWrite()».\n"

#. type: Plain text
#: original/txt/usr_41.txt:2338
#, no-wrap
msgid ""
"3. Vim can't find the function and triggers the |FuncUndefined| autocommand\n"
"   event.  Since the pattern \"BufNet*\" matches the invoked function, the\n"
"   command \"source fname\" will be executed.  \"fname\" will be equal to the name\n"
"   of the script, no matter where it is located, because it comes from\n"
"   expanding \"<sfile>\" (see |expand()|).\n"
msgstr ""
"3. Vim no puede encontrar la función y ejecuta la orden automática\n"
"  |FuncUndefined|. Ya que el patrón «BufNet*» coincide con la función invocada,\n"
"  se ejecutará la orden «source nombre-archivo». «nombre-archivo» debe ser\n"
"  igual al nombre del script, sin importar su ubicación, ya que procede de\n"
"  expandir «<sfile>» (consulte |expand()|).\n"

#. type: Plain text
#: original/txt/usr_41.txt:2341
#, no-wrap
msgid ""
"4. The script is sourced again, the \"s:did_load\" variable exists and the\n"
"   functions are defined.\n"
msgstr ""
"4. El script se carga otra vez, la variable «s:did_load» existe, y se\n"
"   definen las funciones.\n"

#. type: Plain text
#: original/txt/usr_41.txt:2345
msgid ""
"Notice that the functions that are loaded afterwards match the pattern in "
"the |FuncUndefined| autocommand.  You must make sure that no other plugin "
"defines functions that match this pattern."
msgstr ""
"Tenga en cuenta que las funciones se cargan después de comparar el patrón en "
"la orden automática |FuncUndefined|. Debe comprobar que ninguna otra "
"extensión define funciones que coincidan con este patrón."

#. type: Plain text
#: original/txt/usr_41.txt:2348
#, no-wrap
msgid "*41.15*\tWriting library scripts\t\t\t*write-library-script*\n"
msgstr "*41.15*\tCrear bibliotecas\t\t\t\t*write-library-script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2352
msgid ""
"Some functionality will be required in several places.  When this becomes "
"more than a few lines you will want to put it in one script and use it from "
"many scripts.  We will call that one script a library script."
msgstr ""
"Algunas funcionalidades son necesarias en varios lugares. Cuando se trata de "
"algo más que unos pocas líneas, querrá ubicarlo en un script, y usarlo desde "
"varios otros. Vamos a denominar ese script como biblioteca."

#. type: Plain text
#: original/txt/usr_41.txt:2356
msgid ""
"Manually loading a library script is possible, so long as you avoid loading "
"it when it's already done.  You can do this with the |exists()| function.  "
"Example: >"
msgstr ""
"Cargar una biblioteca manualmente es posible, siempre que evite cargarla "
"cuando ya lo está. Puede evitarlo con la función |exists()|. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2361
#, no-wrap
msgid ""
"\tif !exists('*MyLibFunction')\n"
"\t   runtime library/mylibscript.vim\n"
"\tendif\n"
"\tcall MyLibFunction(arg)\n"
msgstr ""
"\tif !exists('*MiFuncionBiblioteca')\n"
"\t   runtime library/biblioteca.vim\n"
"\tendif\n"
"\tcall MiFuncionBiblioteca(arg)\n"

#. type: Plain text
#: original/txt/usr_41.txt:2364
msgid ""
"Here you need to know that MyLibFunction() is defined in a script \"library/"
"mylibscript.vim\" in one of the directories in 'runtimepath'."
msgstr ""
"Aquí tiene que saber que MiFunciónBiblioteca() se define en el script "
"«library/biblioteca.vim», en uno de los directorios de 'runtimepath'."

#. type: Plain text
#: original/txt/usr_41.txt:2367
msgid ""
"To make this a bit simpler Vim offers the autoload mechanism.  Then the "
"example looks like this: >"
msgstr ""
"Para hacer esto más sencillo, Vim ofrece el mecanismo «autoload» (carga "
"automática). Así, el ejemplo tendría este aspecto: >"

#. type: Plain text
#: original/txt/usr_41.txt:2369
#, no-wrap
msgid "\tcall mylib#myfunction(arg)\n"
msgstr "\tcall mibiblioteca#mifuncion(arg)\n"

#. type: Plain text
#: original/txt/usr_41.txt:2373
msgid ""
"That's a lot simpler, isn't it? Vim will recognize the function name and "
"when it's not defined search for the script \"autoload/mylib.vim\" in "
"'runtimepath'.  That script must define the \"mylib#myfunction()\" function."
msgstr ""
"Mucho más sencillo, ¿verdad? Vim reconoce el nombre de la función y, cuando "
"no esté definida, la buscará el script «autoload/mibiblioteca.vim» en "
"'runtimepath'. El script debe definir la función «mibiblioteca#mifuncion()»."

#. type: Plain text
#: original/txt/usr_41.txt:2378
msgid ""
"You can put many other functions in the mylib.vim script, you are free to "
"organize your functions in library scripts.  But you must use function names "
"where the part before the '#' matches the script name.  Otherwise Vim would "
"not know what script to load."
msgstr ""
"Puede almacenar varias funciones en el script mibiblioteca.vim, y puede "
"organizar como desee las funciones en sus bibliotecas. Pero debe usar "
"nombres de funciones en las que la parte que precede a «#» coincide con el "
"nombre del script. En caso contrario, Vim no sabrá qué script cargar."

#. type: Plain text
#: original/txt/usr_41.txt:2381
msgid ""
"If you get really enthusiastic and write lots of library scripts, you may "
"want to use subdirectories.  Example: >"
msgstr ""
"Si esto le entusiasma, y escribe muchas bibliotecas, puede que quiera usar "
"subdirectorios. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:2383
#, no-wrap
msgid "\tcall netlib#ftp#read('somefile')\n"
msgstr "\tcall netlib#ftp#read('somefile')\n"

#. type: Plain text
#: original/txt/usr_41.txt:2385
msgid "For Unix the library script used for this could be:"
msgstr "En sistemas Unix, la biblioteca a usar podría ser:"

#. type: Plain text
#: original/txt/usr_41.txt:2387
#, no-wrap
msgid "\t~/.vim/autoload/netlib/ftp.vim\n"
msgstr "\t~/.vim/autoload/netlib/ftp.vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:2389
msgid "Where the function is defined like this: >"
msgstr "Donde se define la función así: >"

#. type: Plain text
#: original/txt/usr_41.txt:2393
#, no-wrap
msgid ""
"\tfunction netlib#ftp#read(fname)\n"
"\t\t\"  Read the file fname through ftp\n"
"\tendfunction\n"
msgstr ""
"\tfunction netlib#ftp#read(nombre_archivo)\n"
"\t\t\"  Lee al archivo mediante FTP\n"
"\tendfunction\n"

#. type: Plain text
#: original/txt/usr_41.txt:2397
msgid ""
"Notice that the name the function is defined with is exactly the same as the "
"name used for calling the function.  And the part before the last '#' "
"exactly matches the subdirectory and script name."
msgstr ""
"Tenga en cuenta que el nombre con el que se define la función es idéntico al "
"utilizado para invocar la función. Y la parte a continuación del último «#» "
"coincide con el subdirectorio y el nombre del script."

#. type: Plain text
#: original/txt/usr_41.txt:2399
msgid "You can use the same mechanism for variables: >"
msgstr "Puede utilizar el mismo mecanismo con variables: >"

#. type: Plain text
#: original/txt/usr_41.txt:2401
#, no-wrap
msgid "\tlet weekdays = dutch#weekdays\n"
msgstr "\tlet dias_semana = colombia#dias_semana\n"

# revisar que caracteres no-ascii sirvan
#. type: Plain text
#: original/txt/usr_41.txt:2404
msgid ""
"This will load the script \"autoload/dutch.vim\", which should contain "
"something like: >"
msgstr ""
"Esto cargará el script «autoload/colombia.vim», que contendría algo similar "
"a lo siguiente: >"

# revisar que caracteres no-ascii sirvan
#. type: Plain text
#: original/txt/usr_41.txt:2407
#, no-wrap
msgid ""
"\tlet dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',\n"
"\t\t\\ 'donderdag', 'vrijdag', 'zaterdag']\n"
msgstr ""
"\tlet colombia#dias_semana = ['lunes', 'martes', 'miércoles', 'jueves',\n"
"\t\t\\ 'viernes', 'sábado', 'domingo']\n"

#. type: Plain text
#: original/txt/usr_41.txt:2409
msgid "Further reading: |autoload|."
msgstr "Lecturas adicionales: |autoload|."

#. type: Plain text
#: original/txt/usr_41.txt:2412
#, no-wrap
msgid "*41.16*\tDistributing Vim scripts\t\t\t*distribute-script*\n"
msgstr "*41.16*\tDistribuir scripts de Vim\t\t\t*distribute-script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2415
msgid ""
"Vim users will look for scripts on the Vim website: http://www.vim.org.  If "
"you made something that is useful for others, share it!"
msgstr ""
"Los usuarios de Vim buscarán scripts en el sitio web de Vim: http://www.vim."
"org. Si ha creado algo útil para otros, ¡compártalo!"

#. type: Plain text
#: original/txt/usr_41.txt:2419
msgid ""
"Vim scripts can be used on any system.  There might not be a tar or gzip "
"command.  If you want to pack files together and/or compress them the \"zip"
"\" utility is recommended."
msgstr ""
"Los scripts de Vim se pueden usar en cualquier sistema. Las órdenes tar o "
"gzip pueden no estar disponibles en dichos sistemas. Si desea empaquetar o "
"comprimir los archivos, se recomienda usar la herramienta «zip»."

#. type: Plain text
#: original/txt/usr_41.txt:2422
msgid ""
"For utmost portability use Vim itself to pack scripts together.  This can be "
"done with the Vimball utility.  See |vimball|."
msgstr ""
"Para obtener la máxima portabilidad use Vim para empaquetar los scripts. "
"Puede hacer esto con la herramienta Vimball. Consulte |vimball|."

#. type: Plain text
#: original/txt/usr_41.txt:2424
msgid ""
"It's good if you add a line to allow automatic updating.  See |glvs-plugins|."
msgstr ""
"Es una buena idea añadir una línea para pemitir la actualización automática. "
"Consulte |glvs-plugins|."

#. type: Plain text
#: original/txt/usr_41.txt:2428
msgid "Next chapter: |usr_42.txt| Add new menus"
msgstr "Capítulo siguiente: |usr_42.esx| Añadir menús nuevos"
