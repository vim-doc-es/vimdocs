# Spanish translations for Vim package
# Copyright (C) 2010 Free Software Foundation, Inc.
# This file is distributed under the same license as the Vim package.
# Automatically generated, 2010.
#
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.3\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2010-12-09 16:51+0100\n"
"PO-Revision-Date: 2010-12-11 17:20-0500\n"
"Last-Translator: Javier Rojas <jerojasro@devnull.li>\n"
"Language-Team: none\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: Plain text
#: original/txt/intro.txt:18 original/txt/intro.txt:79
#: original/txt/intro.txt:180 original/txt/intro.txt:290
#: original/txt/intro.txt:518 original/txt/intro.txt:596
#: original/txt/intro.txt:689 original/txt/intro.txt:817
#: original/txt/intro.txt:880 original/txt/usr_toc.txt:7
#: original/txt/usr_toc.txt:58 original/txt/usr_toc.txt:172
#: original/txt/usr_toc.txt:281 original/txt/usr_toc.txt:340
#: original/txt/usr_toc.txt:352 original/txt/usr_01.txt:19
#: original/txt/usr_01.txt:50 original/txt/usr_01.txt:100
#: original/txt/usr_01.txt:181 original/txt/usr_02.txt:25
#: original/txt/usr_02.txt:69 original/txt/usr_02.txt:130
#: original/txt/usr_02.txt:179 original/txt/usr_02.txt:239
#: original/txt/usr_02.txt:307 original/txt/usr_02.txt:369
#: original/txt/usr_02.txt:406 original/txt/usr_02.txt:560
#: original/txt/usr_03.txt:28 original/txt/usr_03.txt:74
#: original/txt/usr_03.txt:101 original/txt/usr_03.txt:147
#: original/txt/usr_03.txt:172 original/txt/usr_03.txt:223
#: original/txt/usr_03.txt:265 original/txt/usr_03.txt:320
#: original/txt/usr_03.txt:491 original/txt/usr_03.txt:552
#: original/txt/usr_03.txt:650 original/txt/usr_04.txt:27
#: original/txt/usr_04.txt:74 original/txt/usr_04.txt:160
#: original/txt/usr_04.txt:194 original/txt/usr_04.txt:269
#: original/txt/usr_04.txt:324 original/txt/usr_04.txt:360
#: original/txt/usr_04.txt:390 original/txt/usr_04.txt:446
#: original/txt/usr_04.txt:469 original/txt/usr_04.txt:510
#: original/txt/usr_05.txt:24 original/txt/usr_05.txt:63
#: original/txt/usr_05.txt:219 original/txt/usr_05.txt:266
#: original/txt/usr_05.txt:418 original/txt/usr_05.txt:467
#: original/txt/usr_05.txt:506 original/txt/usr_05.txt:621
#: original/txt/usr_06.txt:24 original/txt/usr_06.txt:50
#: original/txt/usr_06.txt:135 original/txt/usr_06.txt:189
#: original/txt/usr_06.txt:270 original/txt/usr_06.txt:276
#: original/txt/usr_07.txt:24 original/txt/usr_07.txt:63
#: original/txt/usr_07.txt:179 original/txt/usr_07.txt:266
#: original/txt/usr_07.txt:316 original/txt/usr_07.txt:404
#: original/txt/usr_07.txt:444 original/txt/usr_07.txt:475
#: original/txt/usr_08.txt:26 original/txt/usr_08.txt:82
#: original/txt/usr_08.txt:109 original/txt/usr_08.txt:161
#: original/txt/usr_08.txt:215 original/txt/usr_08.txt:278
#: original/txt/usr_08.txt:337 original/txt/usr_08.txt:477
#: original/txt/usr_08.txt:509 original/txt/usr_08.txt:597
#: original/txt/usr_09.txt:21 original/txt/usr_09.txt:124
#: original/txt/usr_09.txt:175 original/txt/usr_09.txt:259
#: original/txt/usr_09.txt:285 original/txt/usr_10.txt:27
#: original/txt/usr_10.txt:144 original/txt/usr_10.txt:221
#: original/txt/usr_10.txt:342 original/txt/usr_10.txt:378
#: original/txt/usr_10.txt:547 original/txt/usr_10.txt:621
#: original/txt/usr_10.txt:667 original/txt/usr_10.txt:692
#: original/txt/usr_10.txt:820 original/txt/usr_11.txt:22
#: original/txt/usr_11.txt:82 original/txt/usr_11.txt:144
#: original/txt/usr_11.txt:288 original/txt/usr_11.txt:303
#: original/txt/usr_12.txt:25 original/txt/usr_12.txt:90
#: original/txt/usr_12.txt:131 original/txt/usr_12.txt:177
#: original/txt/usr_12.txt:202 original/txt/usr_12.txt:231
#: original/txt/usr_12.txt:281 original/txt/usr_12.txt:309
#: original/txt/usr_12.txt:354 original/txt/usr_20.txt:22
#: original/txt/usr_20.txt:113 original/txt/usr_20.txt:158
#: original/txt/usr_20.txt:285 original/txt/usr_20.txt:327
#: original/txt/usr_20.txt:380 original/txt/usr_21.txt:24
#: original/txt/usr_21.txt:47 original/txt/usr_21.txt:87
#: original/txt/usr_21.txt:236 original/txt/usr_21.txt:385
#: original/txt/usr_21.txt:438 original/txt/usr_21.txt:495
#: original/txt/usr_22.txt:22 original/txt/usr_22.txt:148
#: original/txt/usr_22.txt:213 original/txt/usr_22.txt:272
#: original/txt/usr_22.txt:396 original/txt/usr_23.txt:23
#: original/txt/usr_23.txt:114 original/txt/usr_23.txt:156
#: original/txt/usr_23.txt:238 original/txt/usr_23.txt:324
#: original/txt/usr_23.txt:339 original/txt/usr_24.txt:28
#: original/txt/usr_24.txt:96 original/txt/usr_24.txt:119
#: original/txt/usr_24.txt:268 original/txt/usr_24.txt:305
#: original/txt/usr_24.txt:336 original/txt/usr_24.txt:369
#: original/txt/usr_24.txt:493 original/txt/usr_24.txt:537
#: original/txt/usr_24.txt:583 original/txt/usr_24.txt:602
#: original/txt/usr_25.txt:22 original/txt/usr_25.txt:132
#: original/txt/usr_25.txt:210 original/txt/usr_25.txt:287
#: original/txt/usr_25.txt:453 original/txt/usr_25.txt:574
#: original/txt/usr_26.txt:21 original/txt/usr_26.txt:46
#: original/txt/usr_26.txt:103 original/txt/usr_26.txt:136
#: original/txt/usr_26.txt:217 original/txt/usr_27.txt:26
#: original/txt/usr_27.txt:88 original/txt/usr_27.txt:136
#: original/txt/usr_27.txt:239 original/txt/usr_27.txt:320
#: original/txt/usr_27.txt:350 original/txt/usr_27.txt:427
#: original/txt/usr_27.txt:469 original/txt/usr_27.txt:510
#: original/txt/usr_27.txt:559 original/txt/usr_28.txt:27
#: original/txt/usr_28.txt:54 original/txt/usr_28.txt:121
#: original/txt/usr_28.txt:185 original/txt/usr_28.txt:211
#: original/txt/usr_28.txt:269 original/txt/usr_28.txt:315
#: original/txt/usr_28.txt:331 original/txt/usr_28.txt:375
#: original/txt/usr_28.txt:389 original/txt/usr_28.txt:422
#: original/txt/usr_29.txt:23 original/txt/usr_29.txt:273
#: original/txt/usr_29.txt:320 original/txt/usr_29.txt:441
#: original/txt/usr_29.txt:570 original/txt/usr_29.txt:609
#: original/txt/usr_30.txt:23 original/txt/usr_30.txt:202
#: original/txt/usr_30.txt:280 original/txt/usr_30.txt:336
#: original/txt/usr_30.txt:409 original/txt/usr_30.txt:515
#: original/txt/usr_30.txt:639 original/txt/usr_31.txt:22
#: original/txt/usr_31.txt:81 original/txt/usr_31.txt:133
#: original/txt/usr_31.txt:160 original/txt/usr_31.txt:208
#: original/txt/usr_31.txt:268 original/txt/usr_32.txt:21
#: original/txt/usr_32.txt:44 original/txt/usr_32.txt:92
#: original/txt/usr_32.txt:140 original/txt/usr_32.txt:176
#: original/txt/usr_40.txt:20 original/txt/usr_40.txt:279
#: original/txt/usr_40.txt:424 original/txt/usr_40.txt:653
#: original/txt/usr_41.txt:33 original/txt/usr_41.txt:133
#: original/txt/usr_41.txt:267 original/txt/usr_41.txt:345
#: original/txt/usr_41.txt:482 original/txt/usr_41.txt:532
#: original/txt/usr_41.txt:877 original/txt/usr_41.txt:1104
#: original/txt/usr_41.txt:1390 original/txt/usr_41.txt:1447
#: original/txt/usr_41.txt:1617 original/txt/usr_41.txt:2038
#: original/txt/usr_41.txt:2224 original/txt/usr_41.txt:2270
#: original/txt/usr_41.txt:2346 original/txt/usr_41.txt:2410
#: original/txt/usr_41.txt:2425 original/txt/usr_42.txt:21
#: original/txt/usr_42.txt:140 original/txt/usr_42.txt:254
#: original/txt/usr_42.txt:293 original/txt/usr_42.txt:361
#: original/txt/usr_90.txt:21 original/txt/usr_90.txt:214
#: original/txt/usr_90.txt:288 original/txt/usr_90.txt:341
#: original/txt/usr_90.txt:417 original/txt/usr_90.txt:494
#, no-wrap
msgid "==============================================================================\n"
msgstr "==============================================================================\n"

#. type: Plain text
#: original/txt/usr_toc.txt:4 original/txt/usr_01.txt:4
#: original/txt/usr_02.txt:4 original/txt/usr_03.txt:4
#: original/txt/usr_04.txt:4 original/txt/usr_05.txt:4
#: original/txt/usr_06.txt:4 original/txt/usr_07.txt:4
#: original/txt/usr_08.txt:4 original/txt/usr_09.txt:4
#: original/txt/usr_10.txt:4 original/txt/usr_11.txt:4
#: original/txt/usr_12.txt:4 original/txt/usr_20.txt:4
#: original/txt/usr_21.txt:4 original/txt/usr_22.txt:4
#: original/txt/usr_23.txt:4 original/txt/usr_24.txt:4
#: original/txt/usr_25.txt:4 original/txt/usr_26.txt:4
#: original/txt/usr_27.txt:4 original/txt/usr_28.txt:4
#: original/txt/usr_29.txt:4 original/txt/usr_30.txt:4
#: original/txt/usr_31.txt:4 original/txt/usr_32.txt:4
#: original/txt/usr_40.txt:4 original/txt/usr_41.txt:4
#: original/txt/usr_42.txt:4 original/txt/usr_90.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar\n"

#. type: Plain text
#: original/txt/usr_toc.txt:354 original/txt/usr_01.txt:185
#: original/txt/usr_02.txt:564 original/txt/usr_03.txt:654
#: original/txt/usr_04.txt:514 original/txt/usr_05.txt:625
#: original/txt/usr_06.txt:280 original/txt/usr_07.txt:479
#: original/txt/usr_08.txt:601 original/txt/usr_09.txt:289
#: original/txt/usr_10.txt:824 original/txt/usr_11.txt:307
#: original/txt/usr_12.txt:358 original/txt/usr_20.txt:384
#: original/txt/usr_21.txt:499 original/txt/usr_22.txt:400
#: original/txt/usr_23.txt:343 original/txt/usr_24.txt:606
#: original/txt/usr_25.txt:578 original/txt/usr_26.txt:221
#: original/txt/usr_27.txt:563 original/txt/usr_28.txt:426
#: original/txt/usr_29.txt:613 original/txt/usr_30.txt:643
#: original/txt/usr_31.txt:272 original/txt/usr_32.txt:180
#: original/txt/usr_40.txt:657 original/txt/usr_41.txt:2429
#: original/txt/usr_42.txt:365 original/txt/usr_90.txt:498
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: v√©ase |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"

#. type: Plain text
#: original/txt/usr_08.txt:153 original/txt/usr_24.txt:168
#: original/txt/usr_41.txt:2085
msgid "OPTIONS"
msgstr "OPCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:2
#, no-wrap
msgid "*usr_41.txt*\tFor Vim version 7.3.  Last change: 2010 Jul 20\n"
msgstr "*usr_41.esx*\tPara Vim versi√≥n 7.3.  √öltimo cambio: 20/7/2010\n"

#. type: Plain text
#: original/txt/usr_41.txt:6
#, no-wrap
msgid "\t\t\t      Write a Vim script\n"
msgstr "\t\t\t     Escribir scripts para Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:11
msgid ""
"The Vim script language is used for the startup vimrc file, syntax files, "
"and many other things.  This chapter explains the items that can be used in "
"a Vim script.  There are a lot of them, thus this is a long chapter."
msgstr ""
"El lenguaje de programaci√≥n de Vim se usa en el archivo de arranque vimrc, "
"los archivos de sintaxis, y muchas otras cosas. Este cap√≠tulo presenta y "
"explica en detalle los elementos que componen un script de Vim. Hay muchos "
"de ellos, por lo que √©ste es un cap√≠tulo largo."

#. type: Plain text
#: original/txt/usr_41.txt:28
#, no-wrap
msgid ""
"|41.1|\tIntroduction\n"
"|41.2|\tVariables\n"
"|41.3|\tExpressions\n"
"|41.4|\tConditionals\n"
"|41.5|\tExecuting an expression\n"
"|41.6|\tUsing functions\n"
"|41.7|\tDefining a function\n"
"|41.8|\tLists and Dictionaries\n"
"|41.9|\tExceptions\n"
"|41.10|\tVarious remarks\n"
"|41.11|\tWriting a plugin\n"
"|41.12|\tWriting a filetype plugin\n"
"|41.13|\tWriting a compiler plugin\n"
"|41.14|\tWriting a plugin that loads quickly\n"
"|41.15|\tWriting library scripts\n"
"|41.16|\tDistributing Vim scripts\n"
msgstr ""
"|41.1|\tIntroducci√≥n\n"
"|41.2|\tVariables\n"
"|41.3|\tExpresiones\n"
"|41.4|\tEstructuras de decisi√≥n\n"
"|41.5|\tEjecuci√≥n de expresiones\n"
"|41.6|\tFunciones\n"
"|41.7|\tDefinici√≥n de funciones\n"
"|41.8|\tListas y Diccionarios\n"
"|41.9|\tExcepciones\n"
"|41.10|\tObservaciones\n"
"|41.11|\tEscribir extensiones\n"
"|41.12|\tEscribir extensiones para tipo de archivo\n"
"|41.13|\tEscribir extensiones para compiladores\n"
"|41.14|\tEscribir extensiones que carguen r√°pidamente\n"
"|41.15|\tEscribir bibliotecas\n"
"|41.16|\tDistribuir scripts de Vim\n"

# TODO traducir nombre del cap√≠tulo destino
#. type: Plain text
#: original/txt/usr_41.txt:32
#, no-wrap
msgid ""
"     Next chapter: |usr_42.txt|  Add new menus\n"
" Previous chapter: |usr_40.txt|  Make new commands\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""
" Cap√≠tulo siguiente: |usr_42.esx|  Add new menus\n"
"  Cap√≠tulo anterior: |usr_40.esx|  Crear √≥rdenes nuevas\n"
"Tabla de contenidos: |usr_toc.txt|\n"

#. type: Plain text
#: original/txt/usr_41.txt:35
#, no-wrap
msgid "*41.1*\tIntroduction\t\t\t\t*vim-script-intro* *script*\n"
msgstr "*41.1*\tIntroducci√≥n\t\t\t\t*vim-script-intro* *script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:43
#, no-wrap
msgid ""
"Your first experience with Vim scripts is the vimrc file.  Vim reads it when\n"
"it starts up and executes the commands.  You can set options to values you\n"
"prefer.  And you can use any colon command in it (commands that start with a\n"
"\":\"; these are sometimes referred to as Ex commands or command-line commands).\n"
"   Syntax files are also Vim scripts.  As are files that set options for a\n"
"specific file type.  A complicated macro can be defined by a separate Vim\n"
"script file.  You can think of other uses yourself.\n"
msgstr ""
"Su primer acercamiento a los scripts de Vim es el archivo vimrc. Vim lo lee al\n"
"momento de arrancar y ejecuta las √≥rdenes que se encuentren ah√≠. All√≠ puede\n"
"dar el valor que prefiera a las opciones existentes. Y tambi√©n puede usar\n"
"cualquier orden (algunas veces se hace referencia a las √≥rdenes que empiezan\n"
"con ¬´:¬ª como √≥rdenes Ex, o simplemente √≥rdenes).\n"
"   Los archivos de sintaxis tambi√©n son scripts de Vim, porque son archivos en\n"
"los que se configuran opciones para un tipo de archivo particular. Es posible\n"
"definir una macro complicada en un archivo Vim separado. Usted puede tambi√©n\n"
"idear otros usos.\n"

#. type: Plain text
#: original/txt/usr_41.txt:45
msgid "Let's start with a simple example: >"
msgstr "Empecemos con un ejemplo sencillo: >"

#. type: Plain text
#: original/txt/usr_41.txt:60
#, no-wrap
msgid ""
"\t:let i = 1\n"
"\t:while i < 5\n"
"\t:  echo \"count is\" i\n"
"\t:  let i += 1\n"
"\t:endwhile\n"
"<\n"
"\tNote:\n"
"\tThe \":\" characters are not really needed here.  You only need to use\n"
"\tthem when you type a command.  In a Vim script file they can be left\n"
"\tout.  We will use them here anyway to make clear these are colon\n"
"\tcommands and make them stand out from Normal mode commands.\n"
"\tNote:\n"
"\tYou can try out the examples by yanking the lines from the text here\n"
"\tand executing them with :@\"\n"
msgstr ""
"\t:let i = 1\n"
"\t:while i < 5\n"
"\t:  echo \"cuenta es\" i\n"
"\t:  let i += 1\n"
"\t:endwhile\n"
"<\n"
"\tNota:\n"
"\tEn realidad en el ejemplo de arriba los caracteres ¬´:¬ª no son\n"
"\tnecesarios. S√≥lo es necesario digitarlos al escribir una orden. En los\n"
"\tarchivos de scripts de Vim es posible omitirlos. Aqu√≠ se muestran para\n"
"\tevidenciar que son √≥rdenes de la l√≠nea de √≥rdenes, y no √≥rdenes del\n"
"\tmodo Normal.\n"
"\tNota:\n"
"\tPuede probar los ejemplos que se muestran aqu√≠ copiando el texto\n"
"\tcorrespondiente, y ejecut√°ndolo con la orden ¬´:@\"¬ª\n"

#. type: Plain text
#: original/txt/usr_41.txt:62
msgid "The output of the example code is:"
msgstr "La salida generada por el ejemplo tiene el siguiente aspecto:"

#. type: Plain text
#: original/txt/usr_41.txt:67
#, no-wrap
msgid ""
"\tcount is 1 ~\n"
"\tcount is 2 ~\n"
"\tcount is 3 ~\n"
"\tcount is 4 ~\n"
msgstr ""
"\tcuenta es 1 ~\n"
"\tcuenta es 2 ~\n"
"\tcuenta es 3 ~\n"
"\tcuenta es 4 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:70
msgid ""
"In the first line the \":let\" command assigns a value to a variable.  The "
"generic form is: >"
msgstr ""
"En la primera l√≠nea la orden ¬´:let¬ª le asigna un valor a una variable. La "
"forma gen√©rica de hacerlo es: >"

#. type: Plain text
#: original/txt/usr_41.txt:72
#, no-wrap
msgid "\t:let {variable} = {expression}\n"
msgstr "\t:let {variable} = {expresi√≥n}\n"

#. type: Plain text
#: original/txt/usr_41.txt:76
#, no-wrap
msgid ""
"In this case the variable name is \"i\" and the expression is a simple value,\n"
"the number one.\n"
"   The \":while\" command starts a loop.  The generic form is: >\n"
msgstr ""
"En este caso el nombre de la variable es ¬´i¬ª y la expresi√≥n es simplemente un\n"
"valor, el n√∫mero uno.\n"
"   La orden ¬´:while¬ª inicia un ciclo. La forma gen√©rica de esta orden es: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:80
#, no-wrap
msgid ""
"\t:while {condition}\n"
"\t:  {statements}\n"
"\t:endwhile\n"
msgstr ""
"\t:while {condici√≥n}\n"
"\t:  {instrucciones}\n"
"\t:endwhile\n"

#. type: Plain text
#: original/txt/usr_41.txt:87
#, no-wrap
msgid ""
"The statements until the matching \":endwhile\" are executed for as long as the\n"
"condition is true.  The condition used here is the expression \"i < 5\".  This\n"
"is true when the variable i is smaller than five.\n"
"\tNote:\n"
"\tIf you happen to write a while loop that keeps on running, you can\n"
"\tinterrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).\n"
msgstr ""
"Las instrucciones hasta el ¬´:endwhile¬ª correspondiente se ejecutan mientras\n"
"que la {condici√≥n} siga cumpli√©ndose. La condici√≥n aqu√≠ es la expresi√≥n\n"
"¬´i < 5¬ª.  √âsta es verdadera cuando la variable i es menor a cinco.\n"
"\tNota:\n"
"\tSi llega a escribir un ciclo ¬´while¬ª que nunca termina de ejecutarse,\n"
"\tpuede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).\n"

#. type: Plain text
#: original/txt/usr_41.txt:90
msgid ""
"The \":echo\" command prints its arguments.  In this case the string \"count "
"is\" and the value of the variable i.  Since i is one, this will print:"
msgstr ""
"La orden ¬´:echo¬ª imprime en pantalla los argumentos que se le pasen. En este "
"caso son la cadena ¬´cuenta es¬ª y el valor de la variable i. Como i vale uno, "
"se imprimir√°:"

#. type: Plain text
#: original/txt/usr_41.txt:92
#, no-wrap
msgid "\tcount is 1 ~\n"
msgstr "\tcuenta es 1 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:96
msgid ""
"Then there is the \":let i += 1\" command.  This does the same thing as \":"
"let i = i + 1\".  This adds one to the variable i and assigns the new value "
"to the same variable."
msgstr ""
"Luego est√° la orden ¬´:let i += 1¬ª. √âsta tiene el mismo efecto que ¬´:let i = "
"i + 1¬ª. Le a√±ade uno a la variable i y asigna el resultado a la misma "
"variable."

#. type: Plain text
#: original/txt/usr_41.txt:99
msgid ""
"The example was given to explain the commands, but would you really want to "
"make such a loop it can be written much more compact: >"
msgstr ""
"El ejemplo se dio para ilustrar las √≥rdenes usadas; si se quisiera un ciclo "
"con la funcionalidad mostrada, se puede escribir algo mucho m√°s compacto: >"

#. type: Plain text
#: original/txt/usr_41.txt:103
#, no-wrap
msgid ""
"\t:for i in range(1, 4)\n"
"\t:  echo \"count is\" i\n"
"\t:endfor\n"
msgstr ""
"\t:for i in range(1, 4)\n"
"\t:  echo \"cuenta es\" i\n"
"\t:endfor\n"

#. type: Plain text
#: original/txt/usr_41.txt:106
msgid ""
"We won't explain how |:for| and |range()| work until later.  Follow the "
"links if you are impatient."
msgstr ""
"El funcionamiento de |:for| y |range()| se explicar√° despu√©s. Siga los "
"enlaces si no desea esperar."

#. type: Plain text
#: original/txt/usr_41.txt:109
msgid "THREE KINDS OF NUMBERS"
msgstr "TRES CLASES DE N√öMEROS"

#. type: Plain text
#: original/txt/usr_41.txt:115
#, no-wrap
msgid ""
"Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts\n"
"with \"0x\" or \"0X\".  For example \"0x1f\" is decimal 31.  An octal number starts\n"
"with a zero.  \"017\" is decimal 15.  Careful: don't put a zero before a decimal\n"
"number, it will be interpreted as an octal number!\n"
"   The \":echo\" command always prints decimal numbers.  Example: >\n"
msgstr ""
"Los n√∫meros pueden ser decimales, hexadecimales, u octales. Un n√∫mero\n"
"hexadecimal empieza con ¬´0x¬ª o ¬´0X¬ª. Por ejemplo, ¬´0x1f¬ª es 31 en decimal. Un\n"
"n√∫mero octal empieza con cero. ¬´017¬ª es 15 en decimal. Tenga cuidado: no ponga\n"
"ceros al comienzo de un n√∫mero decimal, ¬°ser√° interpretado como un octal!\n"
"   La orden ¬´:echo¬ª siempre muestra los n√∫meros como decimales. Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:118
#, no-wrap
msgid ""
"\t:echo 0x7f 036\n"
"<\t127 30 ~\n"
msgstr ""
"\t:echo 0x7f 036\n"
"<\t127 30 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:122
#, no-wrap
msgid ""
"A number is made negative with a minus sign.  This also works for hexadecimal\n"
"and octal numbers.   A minus sign is also used for subtraction.  Compare this\n"
"with the previous example: >\n"
msgstr ""
"Se puede obtener n√∫meros negativos a√±adi√©ndoles un signo menos. Esto funciona\n"
"tambi√©n para n√∫meros octales y hexadecimales. El signo menos tambi√©n se usa\n"
"para la substracci√≥n. Compare lo siguiente con el ejemplo anterior: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:125
#, no-wrap
msgid ""
"\t:echo 0x7f -036\n"
"<\t97 ~\n"
msgstr ""
"\t:echo 0x7f -036\n"
"<\t97 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:130
msgid ""
"White space in an expression is ignored.  However, it's recommended to use "
"it for separating items, to make the expression easier to read.  For "
"example, to avoid the confusion with a negative number above, put a space "
"between the minus sign and the following number: >"
msgstr ""
"En las expresiones se ignoran los espacios en blanco. Sin embargo, es "
"recomendable usarlo para separar elementos, para hacer que las expresiones "
"sean m√°s legibles. Por ejemplo, para evitar confundir el ejemplo anterior "
"con un n√∫mero negativo, ponga un espacio entre el signo menos y el n√∫mero "
"que lo sigue: >"

#. type: Plain text
#: original/txt/usr_41.txt:132
#, no-wrap
msgid "\t:echo 0x7f - 036\n"
msgstr "\t:echo 0x7f - 036\n"

#. type: Plain text
#: original/txt/usr_41.txt:135
#, no-wrap
msgid "*41.2*\tVariables\n"
msgstr "*41.2*\tVariables\n"

#. type: Plain text
#: original/txt/usr_41.txt:138
msgid ""
"A variable name consists of ASCII letters, digits and the underscore.  It "
"cannot start with a digit.  Valid variable names are:"
msgstr ""
"Los nombres de variables pueden consistir de las letras del c√≥digo ASCII, "
"d√≠gitos, y el gui√≥n bajo. No pueden empezar con d√≠gitos. Los siguientes son "
"nombres v√°lidos de variables:"

#. type: Plain text
#: original/txt/usr_41.txt:144
#, no-wrap
msgid ""
"\tcounter\n"
"\t_aap3\n"
"\tvery_long_variable_name_with_underscores\n"
"\tFuncLength\n"
"\tLENGTH\n"
msgstr ""
"\tcontador\n"
"\t_aap3\n"
"\tnombre_de_variable_largo_con_guion_bajo\n"
"\tFuncLongitud\n"
"\tLONGITUD\n"

#. type: Plain text
#: original/txt/usr_41.txt:148
#, no-wrap
msgid ""
"Invalid names are \"foo+bar\" and \"6var\".\n"
"   These variables are global.  To see a list of currently defined variables\n"
"use this command: >\n"
msgstr ""
"¬´foo+bar¬ª y ¬´6var¬ª son nombres inv√°lidos.\n"
"   Estas variables son globales. Para ver un listado de las variables\n"
"definidas actualmente, use la siguiente orden: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:150
#, no-wrap
msgid "\t:let\n"
msgstr "\t:let\n"

#. type: Plain text
#: original/txt/usr_41.txt:156
msgid ""
"You can use global variables everywhere.  This also means that when the "
"variable \"count\" is used in one script file, it might also be used in "
"another file.  This leads to confusion at least, and real problems at "
"worst.  To avoid this, you can use a variable local to a script file by "
"prepending \"s:\".  For example, one script contains this code: >"
msgstr ""
"Puede usar variables globales en cualquier parte. Esto implica que cuando "
"usa la variable ¬´cuenta¬ª en un archivo, √©sta tambi√©n puede ser usada en otro "
"archivo, lo que al menos crea confusi√≥n, y en el peor de los casos genera "
"problemas reales. Para evitar este problema, puede declarar variables como "
"locales respecto al archivo del script, anteponiendo ¬´s:¬ª a su nombre. Por "
"ejemplo, considere un script con las siguientes instrucciones: >"

#. type: Plain text
#: original/txt/usr_41.txt:162
#, no-wrap
msgid ""
"\t:let s:count = 1\n"
"\t:while s:count < 5\n"
"\t:  source other.vim\n"
"\t:  let s:count += 1\n"
"\t:endwhile\n"
msgstr ""
"\t:let s:cuenta = 1\n"
"\t:while s:cuenta < 5\n"
"\t:  source otro.vim\n"
"\t:  let s:cuenta += 1\n"
"\t:endwhile\n"

#. type: Plain text
#: original/txt/usr_41.txt:167
msgid ""
"Since \"s:count\" is local to this script, you can be sure that sourcing the "
"\"other.vim\" script will not change this variable.  If \"other.vim\" also "
"uses an \"s:count\" variable, it will be a different copy, local to that "
"script.  More about script-local variables here: |script-variable|."
msgstr ""
"Ya que el √°mbito de ¬´s:cuenta¬ª es local al script, puede estar seguro de que "
"cargar el archivo ¬´otro.vim¬ª no har√° cambios a dicha variable. Si ¬´otro.vim¬ª "
"tambi√©n usa una variable ¬´s:cuenta¬ª, ser√° una copia distinta, local al "
"√°mbito de ese script. Puede encontrar m√°s informaci√≥n acerca de las "
"variables locales a un script en |script-variable|."

#. type: Plain text
#: original/txt/usr_41.txt:170
msgid ""
"There are more kinds of variables, see |internal-variables|.  The most often "
"used ones are:"
msgstr ""
"Existen m√°s clases de variables, ver |internal-variables|.  Las que se usan "
"m√°s frecuentemente son:"

#. type: Plain text
#: original/txt/usr_41.txt:175
#, no-wrap
msgid ""
"\tb:name\t\tvariable local to a buffer\n"
"\tw:name\t\tvariable local to a window\n"
"\tg:name\t\tglobal variable (also in a function)\n"
"\tv:name\t\tvariable predefined by Vim\n"
msgstr ""
"\tb:nombre\t\tvariable local a un b√∫fer\n"
"\tw:nombre\t\tvariable local a una ventana\n"
"\tg:nombre\t\tvariable global (incluso dentro de funciones)\n"
"\tv:nombre\t\tvariable predefinida por Vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:178
msgid "DELETING VARIABLES"
msgstr "ELIMINAR VARIABLES"

#. type: Plain text
#: original/txt/usr_41.txt:181
msgid ""
"Variables take up memory and show up in the output of the \":let\" command.  "
"To delete a variable use the \":unlet\" command.  Example: >"
msgstr ""
"Las variables que aparecen en el listado que genera la orden ¬´:let¬ª consumen "
"recursos de memoria. Para eliminar una variable use la orden ¬´:unlet¬ª. "
"Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:183
#, no-wrap
msgid "\t:unlet s:count\n"
msgstr "\t:unlet s:cuenta\n"

#. type: Plain text
#: original/txt/usr_41.txt:187
msgid ""
"This deletes the script-local variable \"s:count\" to free up the memory it "
"uses.  If you are not sure if the variable exists, and don't want an error "
"message when it doesn't, append !: >"
msgstr ""
"Esta orden elimina la variable ¬´s:count¬ª, local al script actual, para "
"liberar la memoria que √©sta usa. Si no est√° seguro de que una variable "
"exista, y no quiere obtener mensajes de error si no existe, a√±ada ! a la "
"orden: >"

#. type: Plain text
#: original/txt/usr_41.txt:189
#, no-wrap
msgid "\t:unlet! s:count\n"
msgstr "\t:unlet! s:cuenta\n"

#. type: Plain text
#: original/txt/usr_41.txt:193
msgid ""
"When a script finishes, the local variables used there will not be "
"automatically freed.  The next time the script executes, it can still use "
"the old value.  Example: >"
msgstr ""
"Cuando la ejecuci√≥n de un script termina, no se liberan autom√°ticamente los "
"recursos usados por sus variables locales. La pr√≥xima vez que se ejecute el "
"script, los valores viejos estar√°n disponibles. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:199
#, no-wrap
msgid ""
"\t:if !exists(\"s:call_count\")\n"
"\t:  let s:call_count = 0\n"
"\t:endif\n"
"\t:let s:call_count = s:call_count + 1\n"
"\t:echo \"called\" s:call_count \"times\"\n"
msgstr ""
"\t:if !exists(\"s:cuenta_llamadas\")\n"
"\t:  let s:cuenta_llamadas = 0\n"
"\t:endif\n"
"\t:let s:cuenta_llamadas = s:cuenta_llamadas + 1\n"
"\t:echo \"llamado\" s:cuenta_llamadas \"veces\"\n"

#. type: Plain text
#: original/txt/usr_41.txt:203
msgid ""
"The \"exists()\" function checks if a variable has already been defined.  "
"Its argument is the name of the variable you want to check.  Not the "
"variable itself! If you would do this: >"
msgstr ""
"La funci√≥n ¬´exists()¬ª comprueba la existencia de una variable. Recibe como "
"argumento el nombre de la variable a comprobar. ¬°No la variable como tal! Si "
"intenta esto: >"

#. type: Plain text
#: original/txt/usr_41.txt:205
#, no-wrap
msgid "\t:if !exists(s:call_count)\n"
msgstr "\t:if !exists(s:cuenta_llamadas)\n"

#. type: Plain text
#: original/txt/usr_41.txt:218
#, no-wrap
msgid ""
"Then the value of s:call_count will be used as the name of the variable that\n"
"exists() checks.  That's not what you want.\n"
"   The exclamation mark ! negates a value.  When the value was true, it\n"
"becomes false.  When it was false, it becomes true.  You can read it as \"not\".\n"
"Thus \"if !exists()\" can be read as \"if not exists()\".\n"
"   What Vim calls true is anything that is not zero.  Zero is false.\n"
"\tNote:\n"
"\tVim automatically converts a string to a number when it is looking for\n"
"\ta number.  When using a string that doesn't start with a digit the\n"
"\tresulting number is zero.  Thus look out for this: >\n"
"\t\t:if \"true\"\n"
"<\tThe \"true\" will be interpreted as a zero, thus as false!\n"
msgstr ""
"el valor de ¬´s:cuenta_llamadas¬ª ser√° usado como el nombre de variable que\n"
"exists() revisar√°. √âse no es el efecto esperado.\n"
"   El s√≠mbolo de exclamaci√≥n ! niega un valor. Cuando un valor es verdadero,\n"
"se vuelve falso. Cuando es falso, se vuelve verdadero. Puede leer este s√≠mbolo\n"
"como ¬´not¬ª (negaci√≥n l√≥gica). As√≠, ¬´if !exists()¬ª se lee como ¬´if not\n"
"exists()¬ª.\n"
"   Vim considera como verdadero cualquier valor distinto de cero. Cero\n"
"equivale a falso.\n"
"\tNota:\n"
"\tVim convierte las cadenas de texto a n√∫meros de manera autom√°tica\n"
"\tcuando se espera un n√∫mero. Cuando se hace esta conversi√≥n con una\n"
"\tcadena que no empieza con un d√≠gito el n√∫mero resultante es cero.\n"
"\tDebido a esto, tenga cuidado con instrucciones como: >\n"
"\t\t:if \"verdadero\"\n"
"\ten este caso, la cadena ¬´verdadero¬ª ser√° interpretada como un cero, ¬°y\n"
"\tpor tanto como falso!\n"

#. type: Plain text
#: original/txt/usr_41.txt:221
msgid "STRING VARIABLES AND CONSTANTS"
msgstr "VARIABLES CADENAS DE TEXTO Y CONSTANTES CADENAS DE TEXTO"

#. type: Plain text
#: original/txt/usr_41.txt:228
#, no-wrap
msgid ""
"So far only numbers were used for the variable value.  Strings can be used as\n"
"well.  Numbers and strings are the basic types of variables that Vim supports.\n"
"The type is dynamic, it is set each time when assigning a value to the\n"
"variable with \":let\".  More about types in |41.8|.\n"
"   To assign a string value to a variable, you need to use a string constant.\n"
"There are two types of these.  First the string in double quotes: >\n"
msgstr ""
"Hasta ahora s√≥lo se han usado n√∫meros como valores de variables. Tambi√©n es\n"
"posible usar cadenas de texto. Los tipos b√°sicos de variables que Vim soporta\n"
"son n√∫meros y cadenas. El tipo de cada variable es din√°mico, y se fija cada\n"
"vez que se asigna un valor a una variable mediante ¬´:let¬ª. Refi√©rase a |41.8|\n"
"para m√°s informaci√≥n acerca de tipos.\n"
"   Para asignar un valor de tipo cadena a una variable, debe usar una\n"
"constante de cadena. Hay dos tipos de estas constantes. El primero es la\n"
"cadena con comillas dobles: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:232
#, no-wrap
msgid ""
"\t:let name = \"peter\"\n"
"\t:echo name\n"
"<\tpeter ~\n"
msgstr ""
"\t:let nombre = \"pedro\"\n"
"\t:echo nombre\n"
"<\tpedro ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:235
msgid ""
"If you want to include a double quote inside the string, put a backslash in "
"front of it: >"
msgstr ""
"Si quiere incluir una comilla doble en el contenido de la cadena, ponga una "
"barra inversa antes de la misma: > "

#. type: Plain text
#: original/txt/usr_41.txt:239
#, no-wrap
msgid ""
"\t:let name = \"\\\"peter\\\"\"\n"
"\t:echo name\n"
"<\t\"peter\" ~\n"
msgstr ""
"\t:let nombre = \"\\\"pedro\\\"\"\n"
"\t:echo nombre\n"
"<\t\"pedro\" ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:241
msgid ""
"To avoid the need for a backslash, you can use a string in single quotes: >"
msgstr ""
"Para evitar el uso de la barra inversa, puede usar una cadena con comillas "
"sencillas: >"

#. type: Plain text
#: original/txt/usr_41.txt:245
#, no-wrap
msgid ""
"\t:let name = '\"peter\"'\n"
"\t:echo name\n"
"<\t\"peter\" ~\n"
msgstr ""
"\t:let nombre = '\"pedro\"'\n"
"\t:echo nombre\n"
"<\t\"pedro\" ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:252
#, no-wrap
msgid ""
"Inside a single-quote string all the characters are as they are.  Only the\n"
"single quote itself is special: you need to use two to get one.  A backslash\n"
"is taken literally, thus you can't use it to change the meaning of the\n"
"character after it.\n"
"   In double-quote strings it is possible to use special characters.  Here are\n"
"a few useful ones:\n"
msgstr ""
"En una cadena de comillas sencillas todos los caracteres tienen solamente su\n"
"significado literal. S√≥lo la comilla sencilla es especial: debe usar dos\n"
"seguidas para obtener una dentro de una cadena. La barra inversa se considera\n"
"literalmente, por lo que no es posible usarla para cambiar el significado del\n"
"caracter despu√©s de ella.\n"
"   En las cadenas de comillas dobles es posible usar caracteres especiales. A\n"
"continuaci√≥n algunos de los m√°s usados:\n"

#. type: Plain text
#: original/txt/usr_41.txt:262
#, no-wrap
msgid ""
"\t\\t\t\t<Tab>\n"
"\t\\n\t\t<NL>, line break\n"
"\t\\r\t\t<CR>, <Enter>\n"
"\t\\e\t\t<Esc>\n"
"\t\\b\t\t<BS>, backspace\n"
"\t\\\"\t\t\"\n"
"\t\\\\\t\t\\, backslash\n"
"\t\\<Esc>\t\t<Esc>\n"
"\t\\<C-W>\t\tCTRL-W\n"
msgstr ""
"\t\\t\t\t<Tab>\n"
"\t\\n\t\t<NL>, salto de l√≠nea\n"
"\t\\r\t\t<CR>, <Enter>\n"
"\t\\e\t\t<Esc>\n"
"\t\\b\t\t<BS>, retroceso\n"
"\t\\\"\t\t\"\n"
"\t\\\\\t\t\\, barra inversa\n"
"\t\\<Esc>\t\t<Esc>\n"
"\t\\<C-W>\t\tCTRL-W\n"

#. type: Plain text
#: original/txt/usr_41.txt:266
#, no-wrap
msgid ""
"The last two are just examples.  The  \"\\<name>\" form can be used to include\n"
"the special key \"name\".\n"
"   See |expr-quote| for the full list of special items in a string.\n"
msgstr ""
"Los √∫ltimos dos s√≥lo son ejemplos. Se puede usar la forma ¬´\\<nombre>¬ª para\n"
"incluir la tecla ¬´nombre¬ª.\n"
"   Refi√©rase a |expr-quote| para ver la lista completa de elementos especiales\n"
"en una cadena de texto.\n"

#. type: Plain text
#: original/txt/usr_41.txt:269
#, no-wrap
msgid "*41.3*\tExpressions\n"
msgstr "*41.3*\tExpresiones\n"

#. type: Plain text
#: original/txt/usr_41.txt:276
#, no-wrap
msgid ""
"Vim has a rich, yet simple way to handle expressions.  You can read the\n"
"definition here: |expression-syntax|.  Here we will show the most common\n"
"items.\n"
"   The numbers, strings and variables mentioned above are expressions by\n"
"themselves.  Thus everywhere an expression is expected, you can use a number,\n"
"string or variable.  Other basic items in an expression are:\n"
msgstr ""
"Vim tiene una forma expresiva, pero sencilla, de manejar expresiones. Puede\n"
"leer la definici√≥n aqu√≠: |expression-syntax|. A continuaci√≥n mostraremos\n"
"algunos de los elementos m√°s comunes.\n"
"   Los n√∫meros, cadenas, y las variables mencionadas anteriormente son\n"
"expresiones por s√≠ mismas. As√≠ que, en donde sea que se espere una expresi√≥n,\n"
"puede usar un n√∫mero, una cadena, o una variable. Otros de los elementos\n"
"comunes en una expresi√≥n son:\n"

#. type: Plain text
#: original/txt/usr_41.txt:280
#, no-wrap
msgid ""
"\t$NAME\t\tenvironment variable\n"
"\t&name\t\toption\n"
"\t@r\t\tregister\n"
msgstr ""
"\t$NAME\t\tvariable de entorno\n"
"\t&name\t\topci√≥n\n"
"\t@r\t\tregistro\n"

#. type: Plain text
#: original/txt/usr_41.txt:282
msgid "Examples: >"
msgstr "Ejemplos: >"

#. type: Plain text
#: original/txt/usr_41.txt:286
#, no-wrap
msgid ""
"\t:echo \"The value of 'tabstop' is\" &ts\n"
"\t:echo \"Your home directory is\" $HOME\n"
"\t:if @a > 5\n"
msgstr ""
"\t:echo \"El valor de 'tabstop' es\" &ts\n"
"\t:echo \"Su directorio personal es\" $HOME\n"
"\t:if @a > 5\n"

#. type: Plain text
#: original/txt/usr_41.txt:289
msgid ""
"The &name form can be used to save an option value, set it to a new value, "
"do something and restore the old value.  Example: >"
msgstr ""
"Se puede usar la forma &name para guardar el valor de una opci√≥n, fijarla a "
"un nuevo valor, hacer algo, y restaurar el valor original. Por ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:294
#, no-wrap
msgid ""
"\t:let save_ic = &ic\n"
"\t:set noic\n"
"\t:/The Start/,$delete\n"
"\t:let &ic = save_ic\n"
msgstr ""
"\t:let ic_orig = &ic\n"
"\t:set noic\n"
"\t:/El Principio/,$delete\n"
"\t:let &ic = ic_orig\n"

#. type: Plain text
#: original/txt/usr_41.txt:298
msgid ""
"This makes sure the \"The Start\" pattern is used with the 'ignorecase' "
"option off.  Still, it keeps the value that the user had set.  (Another way "
"to do this would be to add \"\\C\" to the pattern, see |/\\C|.)"
msgstr ""
"Con esto se asegura que el patr√≥n ¬´El Principio¬ª se buscar√° con la opci√≥n "
"'ignorecase' desactivada. Sin embargo, se conserva y restaura el valor que "
"el usuario defini√≥ para la opci√≥n. (Otra forma de hacer esta b√∫squeda es "
"a√±adir ¬´\\C¬ª al patr√≥n, v√©ase |/\\C|.)"

#. type: Plain text
#: original/txt/usr_41.txt:301
msgid "MATHEMATICS"
msgstr "MATEM√ÅTICAS"

#. type: Plain text
#: original/txt/usr_41.txt:304
msgid ""
"It becomes more interesting if we combine these basic items.  Let's start "
"with mathematics on numbers:"
msgstr ""
"Las cosas se hacen m√°s interesantes si combinamos estos elementos b√°sicos. "
"Empecemos con operaciones matem√°ticas sobre n√∫meros:"

#. type: Plain text
#: original/txt/usr_41.txt:310
#, no-wrap
msgid ""
"\ta + b\t\tadd\n"
"\ta - b\t\tsubtract\n"
"\ta * b\t\tmultiply\n"
"\ta / b\t\tdivide\n"
"\ta % b\t\tmodulo\n"
msgstr ""
"\ta + b\t\tadici√≥n\n"
"\ta - b\t\tsustracci√≥n\n"
"\ta * b\t\tmultiplicaci√≥n\n"
"\ta / b\t\tdivisi√≥n\n"
"\ta % b\t\tm√≥dulo (residuo)\n"

#. type: Plain text
#: original/txt/usr_41.txt:312
msgid "The usual precedence is used.  Example: >"
msgstr "Se maneja la precendencia de operadores usual. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:315
#, no-wrap
msgid ""
"\t:echo 10 + 5 * 2\n"
"<\t20 ~\n"
msgstr ""
"\t:echo 10 + 5 * 2\n"
"<\t20 ~\n"

# TODO file bug on vim's documentation. Parentheses, not braces
#. type: Plain text
#: original/txt/usr_41.txt:317
msgid "Grouping is done with braces.  No surprises here.  Example: >"
msgstr ""
"Puede cambiar la precendencia de las operaciones usando par√©ntesis. Esto no "
"es nada nuevo.  Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:320
#, no-wrap
msgid ""
"\t:echo (10 + 5) * 2\n"
"<\t30 ~\n"
msgstr ""
"\t:echo (10 + 5) * 2\n"
"<\t30 ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:322
msgid "Strings can be concatenated with \".\".  Example: >"
msgstr "Concatene cadenas usando ¬´.¬ª. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:325
#, no-wrap
msgid ""
"\t:echo \"foo\" . \"bar\"\n"
"<\tfoobar ~\n"
msgstr ""
"\t:echo \"foo\" . \"bar\"\n"
"<\tfoobar ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:329
msgid ""
"When the \":echo\" command gets multiple arguments, it separates them with a "
"space.  In the example the argument is a single expression, thus no space is "
"inserted."
msgstr ""
"Cuando recibe varios argumentos, la orden ¬´:echo¬ª los muestra en pantalla "
"separados con espacios. En el ejemplo anterior el argumento es una √∫nica "
"expresi√≥n, por lo que no se insertan espacios."

#. type: Plain text
#: original/txt/usr_41.txt:331
msgid "Borrowed from the C language is the conditional expression:"
msgstr "Del lenguaje C se tom√≥ la expresi√≥n condicional:"

#. type: Plain text
#: original/txt/usr_41.txt:333
#, no-wrap
msgid "\ta ? b : c\n"
msgstr "\ta ? b : c\n"

#. type: Plain text
#: original/txt/usr_41.txt:335
msgid ""
"If \"a\" evaluates to true \"b\" is used, otherwise \"c\" is used.  Example: "
">"
msgstr ""
"Si ¬´a¬ª se eval√∫a verdadero, la expresi√≥n corresponder√° a ¬´b¬ª, y en otro caso "
"a ¬´c¬ª. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:339
#, no-wrap
msgid ""
"\t:let i = 4\n"
"\t:echo i > 5 ? \"i is big\" : \"i is small\"\n"
"<\ti is small ~\n"
msgstr ""
"\t:let i = 4\n"
"\t:echo i > 5 ? \"i es grande\" : \"i es peque√±o\"\n"
"<\ti es peque√±o ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:342
msgid ""
"The three parts of the constructs are always evaluated first, thus you could "
"see it work as:"
msgstr ""
"Los tres elementos de la expresi√≥n condicional siempre son evaluados; es "
"conveniente verlos de la siguiente forma:"

#. type: Plain text
#: original/txt/usr_41.txt:344
#, no-wrap
msgid "\t(a) ? (b) : (c)\n"
msgstr "\t(a) ? (b) : (c)\n"

#. type: Plain text
#: original/txt/usr_41.txt:347
#, no-wrap
msgid "*41.4*\tConditionals\n"
msgstr "*41.4*\tEstructuras de decisi√≥n\n"

#. type: Plain text
#: original/txt/usr_41.txt:350
msgid ""
"The \":if\" commands executes the following statements, until the matching "
"\":endif\", only when a condition is met.  The generic form is:"
msgstr ""
"La orden ¬´:if¬ª ejecuta los comandos a continuaci√≥n de ella, hasta el ¬´:"
"endif¬ª correspondiente, cuando se cumple la condici√≥n especificada. La forma "
"gen√©rica es:"

#. type: Plain text
#: original/txt/usr_41.txt:354
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condici√≥n}\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:359
#, no-wrap
msgid ""
"Only when the expression {condition} evaluates to true (non-zero) will the\n"
"{statements} be executed.  These must still be valid commands.  If they\n"
"contain garbage, Vim won't be able to find the \":endif\".\n"
"   You can also use \":else\".  The generic form for this is:\n"
msgstr ""
"Las {instrucciones} se ejecutan √∫nicamente cuando la expresi√≥n {condici√≥n} es\n"
"verdadera (diferente de cero). Dichas instrucciones deben ser √≥rdenes v√°lidas.\n"
"Si las √≥rdenes tienen errores de sintaxis, Vim no podr√° encontrar el ¬´:endif¬ª\n"
"correspondiente.\n"
"   Tambi√©n puede usar ¬´:else¬ª. La forma gen√©rica es:\n"

#. type: Plain text
#: original/txt/usr_41.txt:365
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:else\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condici√≥n}\n"
"\t   {instrucciones}\n"
"\t:else\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:368
#, no-wrap
msgid ""
"The second {statements} is only executed if the first one isn't.\n"
"   Finally, there is \":elseif\":\n"
msgstr ""
"El segundo grupo de {instrucciones} s√≥lo se ejecuta si el primero no lo hace.\n"
"   Finalmente, est√° ¬´:elseif¬ª\n"

#. type: Plain text
#: original/txt/usr_41.txt:374
#, no-wrap
msgid ""
"\t:if {condition}\n"
"\t   {statements}\n"
"\t:elseif {condition}\n"
"\t   {statements}\n"
"\t:endif\n"
msgstr ""
"\t:if {condici√≥n}\n"
"\t   {instrucciones}\n"
"\t:elseif {condici√≥n}\n"
"\t   {instrucciones}\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:379
#, no-wrap
msgid ""
"This works just like using \":else\" and then \"if\", but without the need for an\n"
"extra \":endif\".\n"
"   A useful example for your vimrc file is checking the 'term' option and\n"
"doing something depending upon its value: >\n"
msgstr ""
"Esta orden funciona como ¬´:else¬ª seguido de ¬´:if¬ª, pero tiene la ventaja de no\n"
"requerir un ¬´:endif¬ª extra.\n"
"   Un ejemplo √∫til para ser usado en el archivo vimrc es revisar la opci√≥n\n"
"'term' y ejecutar √≥rdenes diferentes de acuerdo a su valor: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:387
#, no-wrap
msgid ""
"\t:if &term == \"xterm\"\n"
"\t:  \" Do stuff for xterm\n"
"\t:elseif &term == \"vt100\"\n"
"\t:  \" Do stuff for a vt100 terminal\n"
"\t:else\n"
"\t:  \" Do something for other terminals\n"
"\t:endif\n"
msgstr ""
"\t:if &term == \"xterm\"\n"
"\t:  \" Configuraci√≥n para xterm\n"
"\t:elseif &term == \"vt100\"\n"
"\t:  \" Configuraci√≥n para la terminal vt100\n"
"\t:else\n"
"\t:  \" Configuraci√≥n para otras terminales\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:390
msgid "LOGIC OPERATIONS"
msgstr "OPERACIONES L√ìGICAS"

#. type: Plain text
#: original/txt/usr_41.txt:393
msgid ""
"We already used some of them in the examples.  These are the most often used "
"ones:"
msgstr ""
"Ya hemos usado algunas de ellas en los ejemplos anteriores. A continuaci√≥n "
"listamos las m√°s utilizadas:"

#. type: Plain text
#: original/txt/usr_41.txt:400
#, no-wrap
msgid ""
"\ta == b\t\tequal to\n"
"\ta != b\t\tnot equal to\n"
"\ta >  b\t\tgreater than\n"
"\ta >= b\t\tgreater than or equal to\n"
"\ta <  b\t\tless than\n"
"\ta <= b\t\tless than or equal to\n"
msgstr ""
"\ta == b\t\tigual a\n"
"\ta != b\t\tdiferente de\n"
"\ta >  b\t\tmayor que\n"
"\ta >= b\t\tmayor o igual a\n"
"\ta <  b\t\tmenor que\n"
"\ta <= b\t\tmenor o igual a\n"

#. type: Plain text
#: original/txt/usr_41.txt:402
msgid ""
"The result is one if the condition is met and zero otherwise.  An example: >"
msgstr ""
"El resultado es uno si la condici√≥n se cumple, y cero en otro caso. Ejemplo: "
">"

#. type: Plain text
#: original/txt/usr_41.txt:408
#, no-wrap
msgid ""
"\t:if v:version >= 700\n"
"\t:  echo \"congratulations\"\n"
"\t:else\n"
"\t:  echo \"you are using an old version, upgrade!\"\n"
"\t:endif\n"
msgstr ""
"\t:if v:version >= 700\n"
"\t:  echo \"felicitaciones\"\n"
"\t:else\n"
"\t:  echo \"¬°est√° usando una versi√≥n vieja, actual√≠cese!\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:413
msgid ""
"Here \"v:version\" is a variable defined by Vim, which has the value of the "
"Vim version.  600 is for version 6.0.  Version 6.1 has the value 601.  This "
"is very useful to write a script that works with multiple versions of Vim.  |"
"v:version|"
msgstr ""
"La variable ¬´v:version¬ª es definida por Vim, y contiene el n√∫mero de versi√≥n "
"de Vim. 600 corresponde a la versi√≥n 6.0. La versi√≥n 6.1 tiene el valor 601. "
"Esta variable es √∫til para escribir scripts que funcionen con distintas "
"versiones de Vim. |v:version|"

# TODO revisar qu√© se quiere decir con languages? idiomas? paradigmas de
# lenguajes de programaci√≥n?
#. type: Plain text
#: original/txt/usr_41.txt:420
#, no-wrap
msgid ""
"The logic operators work both for numbers and strings.  When comparing two\n"
"strings, the mathematical difference is used.  This compares byte values,\n"
"which may not be right for some languages.\n"
"   When comparing a string with a number, the string is first converted to a\n"
"number.  This is a bit tricky, because when a string doesn't look like a\n"
"number, the number zero is used.  Example: >\n"
msgstr ""
"Los operadores l√≥gicos funcionan con n√∫meros y con cadenas de texto. Al\n"
"comparar dos cadenas, se trabaja con la diferencia matem√°tica de las mismas.\n"
"Esto compara valores de bytes, lo que para algunos idiomas puede no entregar\n"
"resultados correctos.\n"
"   Al comparar cadenas con n√∫meros, la cadena es convertida a un n√∫mero antes\n"
"de hacer la comparaci√≥n. Debe tener en cuenta que, cuando el contenido de una\n"
"cadena no se asemeja a un n√∫mero, se usa el n√∫mero cero. Ejemplo: >\n"

#. type: Plain text
#: original/txt/usr_41.txt:424
#, no-wrap
msgid ""
"\t:if 0 == \"one\"\n"
"\t:  echo \"yes\"\n"
"\t:endif\n"
msgstr ""
"\t:if 0 == \"uno\"\n"
"\t:  echo \"s√≠\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:427
msgid ""
"This will echo \"yes\", because \"one\" doesn't look like a number, thus it "
"is converted to the number zero."
msgstr ""
"El ejemplo mostrar√° ¬´s√≠¬ª, porque ¬´uno¬ª no puede ser convertido a un n√∫mero, "
"por lo que se lo convierte al n√∫mero cero."

#. type: Plain text
#: original/txt/usr_41.txt:429
msgid "For strings there are two more items:"
msgstr "Hay dos operadores m√°s para cadenas de texto:"

#. type: Plain text
#: original/txt/usr_41.txt:432
#, no-wrap
msgid ""
"\ta =~ b\t\tmatches with\n"
"\ta !~ b\t\tdoes not match with\n"
msgstr ""
"\ta =~ b\t\tcoincide con\n"
"\ta !~ b\t\tno coincide con\n"

#. type: Plain text
#: original/txt/usr_41.txt:435
msgid ""
"The left item \"a\" is used as a string.  The right item \"b\" is used as a "
"pattern, like what's used for searching.  Example: >"
msgstr ""
"El operando de la izquierda, ¬´a¬ª, se trata como una cadena. El operador de la "
"derecha, ¬´b¬ª, se trata como un patr√≥n para una b√∫squeda de texto. Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:442
#, no-wrap
msgid ""
"\t:if str =~ \" \"\n"
"\t:  echo \"str contains a space\"\n"
"\t:endif\n"
"\t:if str !~ '\\.$'\n"
"\t:  echo \"str does not end in a full stop\"\n"
"\t:endif\n"
msgstr ""
"\t:if str =~ \" \"\n"
"\t:  echo \"str contiene un espacio\"\n"
"\t:endif\n"
"\t:if str !~ '\\.$'\n"
"\t:  echo \"str no termina con punto final\"\n"
"\t:endif\n"

#. type: Plain text
#: original/txt/usr_41.txt:446
msgid ""
"Notice the use of a single-quote string for the pattern.  This is useful, "
"because backslashes would need to be doubled in a double-quote string and "
"patterns tend to contain many backslashes."
msgstr ""
"Es de resaltar el uso de una cadena de comillas sencillas como patr√≥n de "
"b√∫squeda. En este caso es √∫til porque las barras inversas tendr√≠an que "
"digitarse dos veces en una cadena de comillas dobles, y los patrones de "
"b√∫squeda suelen contener muchas barras inversas."

# TODO incompleto
#. type: Plain text
#: original/txt/usr_41.txt:452
msgid ""
"The 'ignorecase' option is used when comparing strings.  When you don't want "
"that, append \"#\" to match case and \"?\" to ignore case.  Thus \"==?\" "
"compares two strings to be equal while ignoring case.  And \"!~#\" checks if "
"a pattern doesn't match, also checking the case of letters.  For the full "
"table see |expr-==|."
msgstr ""
"Al comparar cadenas se tiene en cuenta la opci√≥n 'ignorecase'. Si no desea "
"este comportamiento, a√±ada un ¬´#¬ª para diferenciar may√∫sculas de min√∫sculas, "
"o ¬´?¬ª para ignorar dicha diferencia. As√≠, ¬´==?¬ª compara dos cadenas sin "
"diferenciar may√∫sculas de min√∫sculas. ¬´!~#¬ª revisa la no coincidencia de un "
"patr√≥n, teniendo en cuenta diferencias de may√∫sculas y min√∫sculas. Puede "
"consultar la tabla completa de operadores de comparaci√≥n en |expr-==|."

#. type: Plain text
#: original/txt/usr_41.txt:455
msgid "MORE LOOPING"
msgstr "M√ÅS SOBRE CICLOS"

#. type: Plain text
#: original/txt/usr_41.txt:458
msgid ""
"The \":while\" command was already mentioned.  Two more statements can be "
"used in between the \":while\" and the \":endwhile\":"
msgstr ""
"Ya hemos mencionado la orden ¬´:while¬ª. Hay dos instrucciones adicionales que "
"pueden usarse entre ¬´:while¬ª y el ¬´:endwhile¬ª correspondiente:"

# TODO revisar como queda formateada la cosa
#. type: Plain text
#: original/txt/usr_41.txt:463
#, no-wrap
msgid ""
"\t:continue\t\tJump back to the start of the while loop; the\n"
"\t\t\t\tloop continues.\n"
"\t:break\t\t\tJump forward to the \":endwhile\"; the loop is\n"
"\t\t\t\tdiscontinued.\n"
msgstr ""
"\t:continue\t\tsaltar hasta el inicio del ciclo ¬´while¬ª; el ciclo\n"
"\t\t\t\tcontin√∫a.\n"
"\t:break\t\t\tSaltar hasta despu√©s del ¬´:endwhile¬ª; provoca la\n"
"\t\t\t\tterminaci√≥n del ciclo.\n"

#. type: Plain text
#: original/txt/usr_41.txt:465
msgid "Example: >"
msgstr "Ejemplo: >"

#. type: Plain text
#: original/txt/usr_41.txt:476
#, no-wrap
msgid ""
"\t:while counter < 40\n"
"\t:  call do_something()\n"
"\t:  if skip_flag\n"
"\t:    continue\n"
"\t:  endif\n"
"\t:  if finished_flag\n"
"\t:    break\n"
"\t:  endif\n"
"\t:  sleep 50m\n"
"\t:endwhile\n"
msgstr ""
"\t:while contador < 40\n"
"\t:  call hacer_algo()\n"
"\t:  if bandera_saltar\n"
"\t:    continue\n"
"\t:  endif\n"
"\t:  if bandera_terminado\n"
"\t:    break\n"
"\t:  endif\n"
"\t:  sleep 50m\n"
"\t:endwhile\n"

# TODO incompleto
#. type: Plain text
#: original/txt/usr_41.txt:479
msgid ""
"The \":sleep\" command makes Vim take a nap.  The \"50m\" specifies fifty "
"milliseconds.  Another example is \":sleep 4\", which sleeps for four "
"seconds."
msgstr ""
"La orden ¬´:sleep¬ª hace que Vim tome una pausa. El argumento ¬´50m¬ª especifica "
"una duraci√≥n de 50 milisegundos. "

#. type: Plain text
#: original/txt/usr_41.txt:481
#, fuzzy
#| msgid ""
#| "Other subjects can be found with the \":help\" command, see |help.txt|."
msgid ""
"Even more looping can be done with the \":for\" command, see below in |41.8|."
msgstr "Puede encontrar otros temas con la orden ¬´:help¬ª, v√©ase |help.esx|."

#. type: Plain text
#: original/txt/usr_41.txt:484
#, no-wrap
msgid "*41.5*\tExecuting an expression\n"
msgstr "*41.5*\tEjecuci√≥n de expresiones\n"

#. type: Plain text
#: original/txt/usr_41.txt:489
#, no-wrap
msgid ""
"So far the commands in the script were executed by Vim directly.  The\n"
"\":execute\" command allows executing the result of an expression.  This is a\n"
"very powerful way to build commands and execute them.\n"
"   An example is to jump to a tag, which is contained in a variable: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:491
#, fuzzy, no-wrap
#| msgid "\t:tselect tagname\n"
msgid "\t:execute \"tag \" . tag_name\n"
msgstr "\t:tselect etiqueta\n"

#. type: Plain text
#: original/txt/usr_41.txt:495
msgid ""
"The \".\" is used to concatenate the string \"tag \" with the value of "
"variable \"tag_name\".  Suppose \"tag_name\" has the value \"get_cmd\", then "
"the command that will be executed is: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:497
#, fuzzy, no-wrap
#| msgid "\t:ptag write_char\n"
msgid "\t:tag get_cmd\n"
msgstr "\t:ptag write_char\n"

#. type: Plain text
#: original/txt/usr_41.txt:501
msgid ""
"The \":execute\" command can only execute colon commands.  The \":normal\" "
"command executes Normal mode commands.  However, its argument is not an "
"expression but the literal command characters.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:503
#, no-wrap
msgid "\t:normal gg=G\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:507
#, no-wrap
msgid ""
"This jumps to the first line and formats all lines with the \"=\" operator.\n"
"   To make \":normal\" work with an expression, combine \":execute\" with it.\n"
"Example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:509
#, no-wrap
msgid "\t:execute \"normal \" . normal_commands\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:514
#, no-wrap
msgid ""
"The variable \"normal_commands\" must contain the Normal mode commands.\n"
"   Make sure that the argument for \":normal\" is a complete command.  Otherwise\n"
"Vim will run into the end of the argument and abort the command.  For example,\n"
"if you start Insert mode, you must leave Insert mode as well.  This works: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:516
#, no-wrap
msgid "\t:execute \"normal Inew text \\<Esc>\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:520
msgid ""
"This inserts \"new text \" in the current line.  Notice the use of the "
"special key \"\\<Esc>\".  This avoids having to enter a real <Esc> character "
"in your script."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:523
msgid ""
"If you don't want to execute a string but evaluate it to get its expression "
"value, you can use the eval() function: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:526
#, no-wrap
msgid ""
"\t:let optname = \"path\"\n"
"\t:let optval = eval('&' . optname)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:531
#, no-wrap
msgid ""
"A \"&\" character is prepended to \"path\", thus the argument to eval() is\n"
"\"&path\".  The result will then be the value of the 'path' option.\n"
"   The same thing can be done with: >\n"
"\t:exe 'let optval = &' . optname\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:534
#, no-wrap
msgid "*41.6*\tUsing functions\n"
msgstr "*24.1*\tFunciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:538
msgid ""
"Vim defines many functions and provides a large amount of functionality that "
"way.  A few examples will be given in this section.  You can find the whole "
"list here: |functions|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:541
msgid ""
"A function is called with the \":call\" command.  The parameters are passed "
"in between braces, separated by commas.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:543
#, no-wrap
msgid "\t:call search(\"Date: \", \"W\")\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:548
msgid ""
"This calls the search() function, with arguments \"Date: \" and \"W\".  The "
"search() function uses its first argument as a search pattern and the second "
"one as flags.  The \"W\" flag means the search doesn't wrap around the end "
"of the file."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:550
msgid "A function can be called in an expression.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:554
#, no-wrap
msgid ""
"\t:let line = getline(\".\")\n"
"\t:let repl = substitute(line, '\\a', \"*\", \"g\")\n"
"\t:call setline(\".\", repl)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:566
#, no-wrap
msgid ""
"The getline() function obtains a line from the current buffer.  Its argument\n"
"is a specification of the line number.  In this case \".\" is used, which means\n"
"the line where the cursor is.\n"
"   The substitute() function does something similar to the \":substitute\"\n"
"command.  The first argument is the string on which to perform the\n"
"substitution.  The second argument is the pattern, the third the replacement\n"
"string.  Finally, the last arguments are the flags.\n"
"   The setline() function sets the line, specified by the first argument, to a\n"
"new string, the second argument.  In this example the line under the cursor is\n"
"replaced with the result of the substitute().  Thus the effect of the three\n"
"statements is equal to: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:568
#, fuzzy, no-wrap
#| msgid "\t:s[ubstitute]\n"
msgid "\t:substitute/\\a/*/g\n"
msgstr "\t:s[ubstitute]\n"

#. type: Plain text
#: original/txt/usr_41.txt:571
msgid ""
"Using the functions becomes more interesting when you do more work before "
"and after the substitute() call."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:574
#, no-wrap
msgid "FUNCTIONS\t\t\t\t\t\t*function-list*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:578
msgid ""
"There are many functions.  We will mention them here, grouped by what they "
"are used for.  You can find an alphabetical list here: |functions|.  Use "
"CTRL-] on the function name to jump to detailed help on it."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:607
#, no-wrap
msgid ""
"String manipulation:\t\t\t\t\t*string-functions*\n"
"\tnr2char()\t\tget a character by its ASCII value\n"
"\tchar2nr()\t\tget ASCII value of a character\n"
"\tstr2nr()\t\tconvert a string to a Number\n"
"\tstr2float()\t\tconvert a string to a Float\n"
"\tprintf()\t\tformat a string according to % items\n"
"\tescape()\t\tescape characters in a string with a '\\'\n"
"\tshellescape()\t\tescape a string for use with a shell command\n"
"\tfnameescape()\t\tescape a file name for use with a Vim command\n"
"\ttr()\t\t\ttranslate characters from one set to another\n"
"\tstrtrans()\t\ttranslate a string to make it printable\n"
"\ttolower()\t\tturn a string to lowercase\n"
"\ttoupper()\t\tturn a string to uppercase\n"
"\tmatch()\t\t\tposition where a pattern matches in a string\n"
"\tmatchend()\t\tposition where a pattern match ends in a string\n"
"\tmatchstr()\t\tmatch of a pattern in a string\n"
"\tmatchlist()\t\tlike matchstr() and also return submatches\n"
"\tstridx()\t\tfirst index of a short string in a long string\n"
"\tstrridx()\t\tlast index of a short string in a long string\n"
"\tstrlen()\t\tlength of a string\n"
"\tsubstitute()\t\tsubstitute a pattern match with a string\n"
"\tsubmatch()\t\tget a specific match in a \":substitute\"\n"
"\tstrpart()\t\tget part of a string\n"
"\texpand()\t\texpand special keywords\n"
"\ticonv()\t\t\tconvert text from one encoding to another\n"
"\tbyteidx()\t\tbyte index of a character in a string\n"
"\trepeat()\t\trepeat a string multiple times\n"
"\teval()\t\t\tevaluate a string expression\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:632
#, no-wrap
msgid ""
"List manipulation:\t\t\t\t\t*list-functions*\n"
"\tget()\t\t\tget an item without error for wrong index\n"
"\tlen()\t\t\tnumber of items in a List\n"
"\tempty()\t\t\tcheck if List is empty\n"
"\tinsert()\t\tinsert an item somewhere in a List\n"
"\tadd()\t\t\tappend an item to a List\n"
"\textend()\t\tappend a List to a List\n"
"\tremove()\t\tremove one or more items from a List\n"
"\tcopy()\t\t\tmake a shallow copy of a List\n"
"\tdeepcopy()\t\tmake a full copy of a List\n"
"\tfilter()\t\tremove selected items from a List\n"
"\tmap()\t\t\tchange each List item\n"
"\tsort()\t\t\tsort a List\n"
"\treverse()\t\treverse the order of a List\n"
"\tsplit()\t\t\tsplit a String into a List\n"
"\tjoin()\t\t\tjoin List items into a String\n"
"\trange()\t\t\treturn a List with a sequence of numbers\n"
"\tstring()\t\tString representation of a List\n"
"\tcall()\t\t\tcall a function with List as arguments\n"
"\tindex()\t\t\tindex of a value in a List\n"
"\tmax()\t\t\tmaximum value in a List\n"
"\tmin()\t\t\tminimum value in a List\n"
"\tcount()\t\t\tcount number of times a value appears in a List\n"
"\trepeat()\t\trepeat a List multiple times\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:651
#, no-wrap
msgid ""
"Dictionary manipulation:\t\t\t\t*dict-functions*\n"
"\tget()\t\t\tget an entry without an error for a wrong key\n"
"\tlen()\t\t\tnumber of entries in a Dictionary\n"
"\thas_key()\t\tcheck whether a key appears in a Dictionary\n"
"\tempty()\t\t\tcheck if Dictionary is empty\n"
"\tremove()\t\tremove an entry from a Dictionary\n"
"\textend()\t\tadd entries from one Dictionary to another\n"
"\tfilter()\t\tremove selected entries from a Dictionary\n"
"\tmap()\t\t\tchange each Dictionary entry\n"
"\tkeys()\t\t\tget List of Dictionary keys\n"
"\tvalues()\t\tget List of Dictionary values\n"
"\titems()\t\t\tget List of Dictionary key-value pairs\n"
"\tcopy()\t\t\tmake a shallow copy of a Dictionary\n"
"\tdeepcopy()\t\tmake a full copy of a Dictionary\n"
"\tstring()\t\tString representation of a Dictionary\n"
"\tmax()\t\t\tmaximum value in a Dictionary\n"
"\tmin()\t\t\tminimum value in a Dictionary\n"
"\tcount()\t\t\tcount number of times a value appears\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:665
#, no-wrap
msgid ""
"Floating point computation:\t\t\t\t*float-functions*\n"
"\tfloat2nr()\t\tconvert Float to Number\n"
"\tabs()\t\t\tabsolute value (also works for Number)\n"
"\tround()\t\t\tround off\n"
"\tceil()\t\t\tround up\n"
"\tfloor()\t\t\tround down\n"
"\ttrunc()\t\t\tremove value after decimal point\n"
"\tlog10()\t\t\tlogarithm to base 10\n"
"\tpow()\t\t\tvalue of x to the exponent y\n"
"\tsqrt()\t\t\tsquare root\n"
"\tsin()\t\t\tsine\n"
"\tcos()\t\t\tcosine\n"
"\tatan()\t\t\tarc tangent\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:679
#, no-wrap
msgid ""
"Variables:\t\t\t\t\t\t*var-functions*\n"
"\ttype()\t\t\ttype of a variable\n"
"\tislocked()\t\tcheck if a variable is locked\n"
"\tfunction()\t\tget a Funcref for a function name\n"
"\tgetbufvar()\t\tget a variable value from a specific buffer\n"
"\tsetbufvar()\t\tset a variable in a specific buffer\n"
"\tgetwinvar()\t\tget a variable from specific window\n"
"\tgettabvar()\t\tget a variable from specific tab page\n"
"\tgettabwinvar()\t\tget a variable from specific window & tab page\n"
"\tsetwinvar()\t\tset a variable in a specific window\n"
"\tsettabvar()\t\tset a variable in a specific tab page\n"
"\tsettabwinvar()\t\tset a variable in a specific window & tab page\n"
"\tgarbagecollect()\tpossibly free memory\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:692
#, no-wrap
msgid ""
"Cursor and mark position:\t\t*cursor-functions* *mark-functions*\n"
"\tcol()\t\t\tcolumn number of the cursor or a mark\n"
"\tvirtcol()\t\tscreen column of the cursor or a mark\n"
"\tline()\t\t\tline number of the cursor or mark\n"
"\twincol()\t\twindow column number of the cursor\n"
"\twinline()\t\twindow line number of the cursor\n"
"\tcursor()\t\tposition the cursor at a line/column\n"
"\tgetpos()\t\tget position of cursor, mark, etc.\n"
"\tsetpos()\t\tset position of cursor, mark, etc.\n"
"\tbyte2line()\t\tget line number at a specific byte count\n"
"\tline2byte()\t\tbyte count at a specific line\n"
"\tdiff_filler()\t\tget the number of filler lines above a line\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:707
#, no-wrap
msgid ""
"Working with text in the current buffer:\t\t*text-functions*\n"
"\tgetline()\t\tget a line or list of lines from the buffer\n"
"\tsetline()\t\treplace a line in the buffer\n"
"\tappend()\t\tappend line or list of lines in the buffer\n"
"\tindent()\t\tindent of a specific line\n"
"\tcindent()\t\tindent according to C indenting\n"
"\tlispindent()\t\tindent according to Lisp indenting\n"
"\tnextnonblank()\t\tfind next non-blank line\n"
"\tprevnonblank()\t\tfind previous non-blank line\n"
"\tsearch()\t\tfind a match for a pattern\n"
"\tsearchpos()\t\tfind a match for a pattern\n"
"\tsearchpair()\t\tfind the other end of a start/skip/end\n"
"\tsearchpairpos()\t\tfind the other end of a start/skip/end\n"
"\tsearchdecl()\t\tsearch for the declaration of a name\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:735
#, no-wrap
msgid ""
"\t\t\t\t\t*system-functions* *file-functions*\n"
"System functions and manipulation of files:\n"
"\tglob()\t\t\texpand wildcards\n"
"\tglobpath()\t\texpand wildcards in a number of directories\n"
"\tfindfile()\t\tfind a file in a list of directories\n"
"\tfinddir()\t\tfind a directory in a list of directories\n"
"\tresolve()\t\tfind out where a shortcut points to\n"
"\tfnamemodify()\t\tmodify a file name\n"
"\tpathshorten()\t\tshorten directory names in a path\n"
"\tsimplify()\t\tsimplify a path without changing its meaning\n"
"\texecutable()\t\tcheck if an executable program exists\n"
"\tfilereadable()\t\tcheck if a file can be read\n"
"\tfilewritable()\t\tcheck if a file can be written to\n"
"\tgetfperm()\t\tget the permissions of a file\n"
"\tgetftype()\t\tget the kind of a file\n"
"\tisdirectory()\t\tcheck if a directory exists\n"
"\tgetfsize()\t\tget the size of a file\n"
"\tgetcwd()\t\tget the current working directory\n"
"\thaslocaldir()\t\tcheck if current window used |:lcd|\n"
"\ttempname()\t\tget the name of a temporary file\n"
"\tmkdir()\t\t\tcreate a new directory\n"
"\tdelete()\t\tdelete a file\n"
"\trename()\t\trename a file\n"
"\tsystem()\t\tget the result of a shell command\n"
"\thostname()\t\tname of the system\n"
"\treadfile()\t\tread a file into a List of lines\n"
"\twritefile()\t\twrite a List of lines into a file\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:742
#, no-wrap
msgid ""
"Date and Time:\t\t\t\t*date-functions* *time-functions*\n"
"\tgetftime()\t\tget last modification time of a file\n"
"\tlocaltime()\t\tget current time in seconds\n"
"\tstrftime()\t\tconvert time to a string\n"
"\treltime()\t\tget the current or elapsed time accurately\n"
"\treltimestr()\t\tconvert reltime() result to a string\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:760
#, no-wrap
msgid ""
"\t\t\t*buffer-functions* *window-functions* *arg-functions*\n"
"Buffers, windows and the argument list:\n"
"\targc()\t\t\tnumber of entries in the argument list\n"
"\targidx()\t\tcurrent position in the argument list\n"
"\targv()\t\t\tget one entry from the argument list\n"
"\tbufexists()\t\tcheck if a buffer exists\n"
"\tbuflisted()\t\tcheck if a buffer exists and is listed\n"
"\tbufloaded()\t\tcheck if a buffer exists and is loaded\n"
"\tbufname()\t\tget the name of a specific buffer\n"
"\tbufnr()\t\t\tget the buffer number of a specific buffer\n"
"\ttabpagebuflist()\treturn List of buffers in a tab page\n"
"\ttabpagenr()\t\tget the number of a tab page\n"
"\ttabpagewinnr()\t\tlike winnr() for a specified tab page\n"
"\twinnr()\t\t\tget the window number for the current window\n"
"\tbufwinnr()\t\tget the window number of a specific buffer\n"
"\twinbufnr()\t\tget the buffer number of a specific window\n"
"\tgetbufline()\t\tget a list of lines from the specified buffer\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:766
#, no-wrap
msgid ""
"Command line:\t\t\t\t\t*command-line-functions*\n"
"\tgetcmdline()\t\tget the current command line\n"
"\tgetcmdpos()\t\tget position of the cursor in the command line\n"
"\tsetcmdpos()\t\tset position of the cursor in the command line\n"
"\tgetcmdtype()\t\treturn the current command-line type\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:772
#, no-wrap
msgid ""
"Quickfix and location lists:\t\t\t*quickfix-functions*\n"
"\tgetqflist()\t\tlist of quickfix errors\n"
"\tsetqflist()\t\tmodify a quickfix list\n"
"\tgetloclist()\t\tlist of location list items\n"
"\tsetloclist()\t\tmodify a location list\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:778
#, no-wrap
msgid ""
"Insert mode completion:\t\t\t\t*completion-functions*\n"
"\tcomplete()\t\tset found matches\n"
"\tcomplete_add()\t\tadd to found matches\n"
"\tcomplete_check()\tcheck if completion should be aborted\n"
"\tpumvisible()\t\tcheck if the popup menu is displayed\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:785
#, no-wrap
msgid ""
"Folding:\t\t\t\t\t*folding-functions*\n"
"\tfoldclosed()\t\tcheck for a closed fold at a specific line\n"
"\tfoldclosedend()\t\tlike foldclosed() but return the last line\n"
"\tfoldlevel()\t\tcheck for the fold level at a specific line\n"
"\tfoldtext()\t\tgenerate the line displayed for a closed fold\n"
"\tfoldtextresult()\tget the text displayed for a closed fold\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:803
#, no-wrap
msgid ""
"Syntax and highlighting:\t  *syntax-functions* *highlighting-functions*\n"
"\tclearmatches()\t\tclear all matches defined by |matchadd()| and\n"
"\t\t\t\tthe |:match| commands\n"
"\tgetmatches()\t\tget all matches defined by |matchadd()| and\n"
"\t\t\t\tthe |:match| commands\n"
"\thlexists()\t\tcheck if a highlight group exists\n"
"\thlID()\t\t\tget ID of a highlight group\n"
"\tsynID()\t\t\tget syntax ID at a specific position\n"
"\tsynIDattr()\t\tget a specific attribute of a syntax ID\n"
"\tsynIDtrans()\t\tget translated syntax ID\n"
"\tdiff_hlID()\t\tget highlight ID for diff mode at a position\n"
"\tmatchadd()\t\tdefine a pattern to highlight (a \"match\")\n"
"\tmatcharg()\t\tget info about |:match| arguments\n"
"\tmatchdelete()\t\tdelete a match defined by |matchadd()| or a\n"
"\t\t\t\t|:match| command\n"
"\tsetmatches()\t\trestore a list of matches saved by\n"
"\t\t\t\t|getmatches()|\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:808
#, no-wrap
msgid ""
"Spelling:\t\t\t\t\t*spell-functions*\n"
"\tspellbadword()\t\tlocate badly spelled word at or after cursor\n"
"\tspellsuggest()\t\treturn suggested spelling corrections\n"
"\tsoundfold()\t\treturn the sound-a-like equivalent of a word\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:814
#, no-wrap
msgid ""
"History:\t\t\t\t\t*history-functions*\n"
"\thistadd()\t\tadd an item to a history\n"
"\thistdel()\t\tdelete an item from a history\n"
"\thistget()\t\tget an item from a history\n"
"\thistnr()\t\tget highest index of a history list\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:828
#, no-wrap
msgid ""
"Interactive:\t\t\t\t\t*interactive-functions*\n"
"\tbrowse()\t\tput up a file requester\n"
"\tbrowsedir()\t\tput up a directory requester\n"
"\tconfirm()\t\tlet the user make a choice\n"
"\tgetchar()\t\tget a character from the user\n"
"\tgetcharmod()\t\tget modifiers for the last typed character\n"
"\tfeedkeys()\t\tput characters in the typeahead queue\n"
"\tinput()\t\t\tget a line from the user\n"
"\tinputlist()\t\tlet the user pick an entry from a list\n"
"\tinputsecret()\t\tget a line from the user without showing it\n"
"\tinputdialog()\t\tget a line from the user in a dialog\n"
"\tinputsave()\t\tsave and clear typeahead\n"
"\tinputrestore()\t\trestore typeahead\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:833
#, no-wrap
msgid ""
"GUI:\t\t\t\t\t\t*gui-functions*\n"
"\tgetfontname()\t\tget name of current font being used\n"
"\tgetwinposx()\t\tX position of the GUI Vim window\n"
"\tgetwinposy()\t\tY position of the GUI Vim window\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:843
#, no-wrap
msgid ""
"Vim server:\t\t\t\t\t*server-functions*\n"
"\tserverlist()\t\treturn the list of server names\n"
"\tremote_send()\t\tsend command characters to a Vim server\n"
"\tremote_expr()\t\tevaluate an expression in a Vim server\n"
"\tserver2client()\t\tsend a reply to a client of a Vim server\n"
"\tremote_peek()\t\tcheck if there is a reply from a Vim server\n"
"\tremote_read()\t\tread a reply from a Vim server\n"
"\tforeground()\t\tmove the Vim window to the foreground\n"
"\tremote_foreground()\tmove the Vim server window to the foreground\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:850
#, no-wrap
msgid ""
"Window size and position:\t\t\t*window-size-functions*\n"
"\twinheight()\t\tget height of a specific window\n"
"\twinwidth()\t\tget width of a specific window\n"
"\twinrestcmd()\t\treturn command to restore window sizes\n"
"\twinsaveview()\t\tget view of current window\n"
"\twinrestview()\t\trestore saved view of current window\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:864
#, no-wrap
msgid ""
"Various:\t\t\t\t\t*various-functions*\n"
"\tmode()\t\t\tget current editing mode\n"
"\tvisualmode()\t\tlast visual mode used\n"
"\thasmapto()\t\tcheck if a mapping exists\n"
"\tmapcheck()\t\tcheck if a matching mapping exists\n"
"\tmaparg()\t\tget rhs of a mapping\n"
"\texists()\t\tcheck if a variable, function, etc. exists\n"
"\thas()\t\t\tcheck if a feature is supported in Vim\n"
"\tchangenr()\t\treturn number of most recent change\n"
"\tcscope_connection()\tcheck if a cscope connection exists\n"
"\tdid_filetype()\t\tcheck if a FileType autocommand was used\n"
"\teventhandler()\t\tcheck if invoked by an event handler\n"
"\tgetpid()\t\tget process ID of Vim\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:867
#, no-wrap
msgid ""
"\tlibcall()\t\tcall a function in an external library\n"
"\tlibcallnr()\t\tidem, returning a number\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:871
#, no-wrap
msgid ""
"\tgetreg()\t\tget contents of a register\n"
"\tgetregtype()\t\tget type of a register\n"
"\tsetreg()\t\tset contents and type of a register\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:874
#, no-wrap
msgid ""
"\ttaglist()\t\tget list of matching tags\n"
"\ttagfiles()\t\tget a list of tags files\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:876
#, no-wrap
msgid "\tmzeval()\t\tevaluate |MzScheme| expression\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:879
#, fuzzy, no-wrap
#| msgid "*22.3*\tFinding a file\n"
msgid "*41.7*\tDefining a function\n"
msgstr "*22.3*\tEncontrar un archivo\n"

#. type: Plain text
#: original/txt/usr_41.txt:882
msgid ""
"Vim enables you to define your own functions.  The basic function "
"declaration begins as follows: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:889
#, no-wrap
msgid ""
"\t:function {name}({var1}, {var2}, ...)\n"
"\t:  {body}\n"
"\t:endfunction\n"
"<\n"
"\tNote:\n"
"\tFunction names must begin with a capital letter.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:892
msgid ""
"Let's define a short function to return the smaller of two numbers.  It "
"starts with this line: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:894
#, no-wrap
msgid "\t:function Min(num1, num2)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:900
#, no-wrap
msgid ""
"This tells Vim that the function is named \"Min\" and it takes two arguments:\n"
"\"num1\" and \"num2\".\n"
"   The first thing you need to do is to check to see which number is smaller:\n"
"   >\n"
"\t:  if a:num1 < a:num2\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:903
msgid ""
"The special prefix \"a:\" tells Vim that the variable is a function "
"argument.  Let's assign the variable \"smaller\" the value of the smallest "
"number: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:909
#, no-wrap
msgid ""
"\t:  if a:num1 < a:num2\n"
"\t:    let smaller = a:num1\n"
"\t:  else\n"
"\t:    let smaller = a:num2\n"
"\t:  endif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:912
msgid ""
"The variable \"smaller\" is a local variable.  Variables used inside a "
"function are local unless prefixed by something like \"g:\", \"a:\", or \"s:"
"\"."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:918
#, no-wrap
msgid ""
"\tNote:\n"
"\tTo access a global variable from inside a function you must prepend\n"
"\t\"g:\" to it.  Thus \"g:today\" inside a function is used for the global\n"
"\tvariable \"today\", and \"today\" is another variable, local to the\n"
"\tfunction.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:921
msgid ""
"You now use the \":return\" statement to return the smallest number to the "
"user.  Finally, you end the function: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:924
#, no-wrap
msgid ""
"\t:  return smaller\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:926
#, fuzzy
#| msgid "Now the command executed is as follows: >"
msgid "The complete function definition is as follows: >"
msgstr "Ahora, la orden se ejecuta de la siguiente manera: >"

#. type: Plain text
#: original/txt/usr_41.txt:935
#, no-wrap
msgid ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    let smaller = a:num1\n"
"\t:  else\n"
"\t:    let smaller = a:num2\n"
"\t:  endif\n"
"\t:  return smaller\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:937
msgid "For people who like short functions, this does the same thing: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:944
#, no-wrap
msgid ""
"\t:function Min(num1, num2)\n"
"\t:  if a:num1 < a:num2\n"
"\t:    return a:num1\n"
"\t:  endif\n"
"\t:  return a:num2\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:948
msgid ""
"A user defined function is called in exactly the same way as a built-in "
"function.  Only the name is different.  The Min function can be used like "
"this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:950
#, fuzzy, no-wrap
#| msgid "\t:echo undotree()\n"
msgid "\t:echo Min(5, 8)\n"
msgstr "\t:echo undotree()\n"

#. type: Plain text
#: original/txt/usr_41.txt:955
msgid ""
"Only now will the function be executed and the lines be interpreted by Vim.  "
"If there are mistakes, like using an undefined variable or function, you "
"will now get an error message.  When defining the function these errors are "
"not detected."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:958
msgid ""
"When a function reaches \":endfunction\" or \":return\" is used without an "
"argument, the function returns zero."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:961
msgid ""
"To redefine a function that already exists, use the ! for the \":function\" "
"command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:963
#, no-wrap
msgid "\t:function!  Min(num1, num2, num3)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:966
#, fuzzy
#| msgid "USING A COUNT"
msgid "USING A RANGE"
msgstr "USAR UN MULTIPLICADOR"

#. type: Plain text
#: original/txt/usr_41.txt:973
#, no-wrap
msgid ""
"The \":call\" command can be given a line range.  This can have one of two\n"
"meanings.  When a function has been defined with the \"range\" keyword, it will\n"
"take care of the line range itself.\n"
"  The function will be passed the variables \"a:firstline\" and \"a:lastline\".\n"
"These will have the line numbers from the range the function was called with.\n"
"Example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:983
#, no-wrap
msgid ""
"\t:function Count_words() range\n"
"\t:  let lnum = a:firstline\n"
"\t:  let n = 0\n"
"\t:  while lnum <= a:lastline\n"
"\t:    let n = n + len(split(getline(lnum)))\n"
"\t:    let lnum = lnum + 1\n"
"\t:  endwhile\n"
"\t:  echo \"found \" . n . \" words\"\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:985
#, fuzzy
#| msgid "And you can close the fold again with: >"
msgid "You can call this function with: >"
msgstr "Y puede cerrar el pliegue otra vez con: >"

#. type: Plain text
#: original/txt/usr_41.txt:987
#, no-wrap
msgid "\t:10,30call Count_words()\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:992
#, no-wrap
msgid ""
"It will be executed once and echo the number of words.\n"
"   The other way to use a line range is by defining a function without the\n"
"\"range\" keyword.  The function will be called once for every line in the\n"
"range, with the cursor in that line.  Example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:996
#, no-wrap
msgid ""
"\t:function  Number()\n"
"\t:  echo \"line \" . line(\".\") . \" contains: \" . getline(\".\")\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:998
#, fuzzy
#| msgid "And you can close the fold again with: >"
msgid "If you call this function with: >"
msgstr "Y puede cerrar el pliegue otra vez con: >"

#. type: Plain text
#: original/txt/usr_41.txt:1000
#, no-wrap
msgid "\t:10,15call Number()\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1002
msgid "The function will be called six times."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1005
#, fuzzy
#| msgid "A NUMBER OF LINES"
msgid "VARIABLE NUMBER OF ARGUMENTS"
msgstr "UN N√öMERO DE L√çNEAS"

#. type: Plain text
#: original/txt/usr_41.txt:1009
msgid ""
"Vim enables you to define functions that have a variable number of "
"arguments.  The following command, for instance, defines a function that "
"must have 1 argument (start) and can have up to 20 additional arguments: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1011
#, no-wrap
msgid "\t:function Show(start, ...)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1015
#, no-wrap
msgid ""
"The variable \"a:1\" contains the first optional argument, \"a:2\" the second, and\n"
"so on.  The variable \"a:0\" contains the number of extra arguments.\n"
"   For example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1027
#, no-wrap
msgid ""
"\t:function Show(start, ...)\n"
"\t:  echohl Title\n"
"\t:  echo \"Show is \" . a:start\n"
"\t:  echohl None\n"
"\t:  let index = 1\n"
"\t:  while index <= a:0\n"
"\t:    echo \"  Arg \" . index . \" is \" . a:{index}\n"
"\t:    let index = index + 1\n"
"\t:  endwhile\n"
"\t:  echo \"\"\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1031
msgid ""
"This uses the \":echohl\" command to specify the highlighting used for the "
"following \":echo\" command.  \":echohl None\" stops it again.  The \":echon"
"\" command works like \":echo\", but doesn't output a line break."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1034
msgid ""
"You can also use the a:000 variable, it is a List of all the \"...\" "
"arguments.  See |a:000|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1037
#, fuzzy
#| msgid "LISTING ABBREVIATIONS"
msgid "LISTING FUNCTIONS"
msgstr "LISTAR ABREVIATURAS"

#. type: Plain text
#: original/txt/usr_41.txt:1040
msgid ""
"The \":function\" command lists the names and arguments of all user-defined "
"functions: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1045
#, no-wrap
msgid ""
"\t:function\n"
"<\tfunction Show(start, ...) ~\n"
"\tfunction GetVimIndent() ~\n"
"\tfunction SetSyn(name) ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1047
msgid ""
"To see what a function does, use its name as an argument for \":function\": >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1053
#, no-wrap
msgid ""
"\t:function SetSyn\n"
"<\t1     if &syntax == '' ~\n"
"\t2       let &syntax = a:name ~\n"
"\t3     endif ~\n"
"\t   endfunction ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1056
msgid "DEBUGGING"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1061
#, no-wrap
msgid ""
"The line number is useful for when you get an error message or when debugging.\n"
"See |debug-scripts| about debugging mode.\n"
"   You can also set the 'verbose' option to 12 or higher to see all function\n"
"calls.  Set it to 15 or higher to see every executed line.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1064
#, fuzzy
#| msgid "DELETING A LINE"
msgid "DELETING A FUNCTION"
msgstr "ELIMINAR UNA L√çNEA"

#. type: Plain text
#: original/txt/usr_41.txt:1066
msgid "To delete the Show() function: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1068
#, no-wrap
msgid "\t:delfunction Show\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1070
msgid "You get an error when the function doesn't exist."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1073
msgid "FUNCTION REFERENCES"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1077
msgid ""
"Sometimes it can be useful to have a variable point to one function or "
"another.  You can do it with the function() function.  It turns the name of "
"a function into a reference: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1093
#, no-wrap
msgid ""
"\t:let result = 0\t\t\" or 1\n"
"\t:function! Right()\n"
"\t:  return 'Right!'\n"
"\t:endfunc\n"
"\t:function! Wrong()\n"
"\t:  return 'Wrong!'\n"
"\t:endfunc\n"
"\t:\n"
"\t:if result == 1\n"
"\t:  let Afunc = function('Right')\n"
"\t:else\n"
"\t:  let Afunc = function('Wrong')\n"
"\t:endif\n"
"\t:echo call(Afunc, [])\n"
"<\tWrong! ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1100
#, no-wrap
msgid ""
"Note that the name of a variable that holds a function reference must start\n"
"with a capital.  Otherwise it could be confused with the name of a builtin\n"
"function.\n"
"   The way to invoke a function that a variable refers to is with the call()\n"
"function.  Its first argument is the function reference, the second argument\n"
"is a List with arguments.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1103
msgid ""
"Function references are most useful in combination with a Dictionary, as is "
"explained in the next section."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1106
#, no-wrap
msgid "*41.8*\tLists and Dictionaries\n"
msgstr "*41.8*\tListas y Diccionarios\n"

#. type: Plain text
#: original/txt/usr_41.txt:1109
msgid ""
"So far we have used the basic types String and Number.  Vim also supports "
"two composite types: List and Dictionary."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1113
msgid ""
"A List is an ordered sequence of things.  The things can be any kind of "
"value, thus you can make a List of numbers, a List of Lists and even a List "
"of mixed items.  To create a List with three strings: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1115
#, no-wrap
msgid "\t:let alist = ['aap', 'mies', 'noot']\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1118
msgid ""
"The List items are enclosed in square brackets and separated by commas.  To "
"create an empty List: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1120
#, fuzzy, no-wrap
#| msgid "\t:set list\n"
msgid "\t:let alist = []\n"
msgstr "\t:set list\n"

#. type: Plain text
#: original/txt/usr_41.txt:1122
#, fuzzy
#| msgid "You can remove it with this command: >"
msgid "You can add items to a List with the add() function: >"
msgstr "Puede eliminarla con esta orden: >"

#. type: Plain text
#: original/txt/usr_41.txt:1128
#, no-wrap
msgid ""
"\t:let alist = []\n"
"\t:call add(alist, 'foo')\n"
"\t:call add(alist, 'bar')\n"
"\t:echo alist\n"
"<\t['foo', 'bar'] ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1130
msgid "List concatenation is done with +: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1133
#, no-wrap
msgid ""
"\t:echo alist + ['foo', 'bar']\n"
"<\t['foo', 'bar', 'foo', 'bar'] ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1135
msgid "Or, if you want to extend a List directly: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1140
#, no-wrap
msgid ""
"\t:let alist = ['one']\n"
"\t:call extend(alist, ['two', 'three'])\n"
"\t:echo alist\n"
"<\t['one', 'two', 'three'] ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1142
msgid "Notice that using add() will have a different effect: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1147
#, no-wrap
msgid ""
"\t:let alist = ['one']\n"
"\t:call add(alist, ['two', 'three'])\n"
"\t:echo alist\n"
"<\t['one', ['two', 'three']] ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1149
msgid "The second argument of add() is added as a single item."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1152
msgid "FOR LOOP"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1154
#, fuzzy
#| msgid "A few more things you can do with tab pages:"
msgid "One of the nice things you can do with a List is iterate over it: >"
msgstr "Un par de cosas m√°s que puede hacer con las pesta√±as:"

#. type: Plain text
#: original/txt/usr_41.txt:1162
#, no-wrap
msgid ""
"\t:let alist = ['one', 'two', 'three']\n"
"\t:for n in alist\n"
"\t:  echo n\n"
"\t:endfor\n"
"<\tone ~\n"
"\ttwo ~\n"
"\tthree ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1165
msgid ""
"This will loop over each element in List \"alist\", assigning the value to "
"variable \"n\".  The generic form of a for loop is: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1169
#, no-wrap
msgid ""
"\t:for {varname} in {listexpression}\n"
"\t:  {commands}\n"
"\t:endfor\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1172
msgid ""
"To loop a certain number of times you need a List of a specific length.  The "
"range() function creates one for you: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1179
#, no-wrap
msgid ""
"\t:for a in range(3)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t0 ~\n"
"\t1 ~\n"
"\t2 ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1183
#, no-wrap
msgid ""
"Notice that the first item of the List that range() produces is zero, thus the\n"
"last item is one less than the length of the list.\n"
"   You can also specify the maximum value, the stride and even go backwards: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1190
#, no-wrap
msgid ""
"\t:for a in range(8, 4, -2)\n"
"\t:  echo a\n"
"\t:endfor\n"
"<\t8 ~\n"
"\t6 ~\n"
"\t4 ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1192
msgid "A more useful example, looping over lines in the buffer: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1198
#, no-wrap
msgid ""
"\t:for line in getline(1, 20)\n"
"\t:  if line =~ \"Date: \"\n"
"\t:    echo matchstr(line, 'Date: \\zs.*')\n"
"\t:  endif\n"
"\t:endfor\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1200
msgid ""
"This looks into lines 1 to 20 (inclusive) and echoes any date found in there."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1203
msgid "DICTIONARIES"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1206
msgid ""
"A Dictionary stores key-value pairs.  You can quickly lookup a value if you "
"know the key.  A Dictionary is created with curly braces: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1208
#, no-wrap
msgid "\t:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1210
msgid "Now you can lookup words by putting the key in square brackets: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1213
#, no-wrap
msgid ""
"\t:echo uk2nl['two']\n"
"<\ttwee ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1215
msgid "The generic form for defining a Dictionary is: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1217
#, no-wrap
msgid "\t{<key> : <value>, ...}\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1219
msgid "An empty Dictionary is one without any keys: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1221
#, no-wrap
msgid "\t{}\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1225
msgid ""
"The possibilities with Dictionaries are numerous.  There are various "
"functions for them as well.  For example, you can obtain a list of the keys "
"and loop over them: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1232
#, no-wrap
msgid ""
"\t:for key in keys(uk2nl)\n"
"\t:  echo key\n"
"\t:endfor\n"
"<\tthree ~\n"
"\tone ~\n"
"\ttwo ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1235
msgid ""
"You will notice the keys are not ordered.  You can sort the list to get a "
"specific order: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1242
#, no-wrap
msgid ""
"\t:for key in sort(keys(uk2nl))\n"
"\t:  echo key\n"
"\t:endfor\n"
"<\tone ~\n"
"\tthree ~\n"
"\ttwo ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1245
msgid ""
"But you can never get back the order in which items are defined.  For that "
"you need to use a List, it stores items in an ordered sequence."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1248
msgid "DICTIONARY FUNCTIONS"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1251
msgid ""
"The items in a Dictionary can normally be obtained with an index in square "
"brackets: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1254
#, no-wrap
msgid ""
"\t:echo uk2nl['one']\n"
"<\teen ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1256
msgid ""
"A method that does the same, but without so many punctuation characters: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1259
#, fuzzy, no-wrap
#| msgid "\t:echo undotree()\n"
msgid ""
"\t:echo uk2nl.one\n"
"<\teen ~\n"
msgstr "\t:echo undotree()\n"

#. type: Plain text
#: original/txt/usr_41.txt:1262
msgid ""
"This only works for a key that is made of ASCII letters, digits and the "
"underscore.  You can also assign a new value this way: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1266
#, no-wrap
msgid ""
"\t:let uk2nl.four = 'vier'\n"
"\t:echo uk2nl\n"
"<\t{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1269
msgid ""
"And now for something special: you can directly define a function and store "
"a reference to it in the dictionary: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1273
#, no-wrap
msgid ""
"\t:function uk2nl.translate(line) dict\n"
"\t:  return join(map(split(a:line), 'get(self, v:val, \"???\")'))\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1275
msgid "Let's first try it out: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1278
#, no-wrap
msgid ""
"\t:echo uk2nl.translate('three two five one')\n"
"<\tdrie twee ??? een ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1283
#, no-wrap
msgid ""
"The first special thing you notice is the \"dict\" at the end of the \":function\"\n"
"line.  This marks the function as being used from a Dictionary.  The \"self\"\n"
"local variable will then refer to that Dictionary.\n"
"   Now let's break up the complicated return command: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1285
#, fuzzy, no-wrap
#| msgid "\t:split\n"
msgid "\tsplit(a:line)\n"
msgstr "\t:split\n"

#. type: Plain text
#: original/txt/usr_41.txt:1288
msgid ""
"The split() function takes a string, chops it into white separated words and "
"returns a list with these words.  Thus in the example it returns: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1291
#, no-wrap
msgid ""
"\t:echo split('three two five one')\n"
"<\t['three', 'two', 'five', 'one'] ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1295
msgid ""
"This list is the first argument to the map() function.  This will go through "
"the list, evaluating its second argument with \"v:val\" set to the value of "
"each item.  This is a shortcut to using a for loop.  This command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1297
#, no-wrap
msgid "\t:let alist = map(split(a:line), 'get(self, v:val, \"???\")')\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1299
#, fuzzy
#| msgid "Is equal to: >"
msgid "Is equivalent to: >"
msgstr "Equivale a: >"

#. type: Plain text
#: original/txt/usr_41.txt:1304
#, no-wrap
msgid ""
"\t:let alist = split(a:line)\n"
"\t:for idx in range(len(alist))\n"
"\t:  let alist[idx] = get(self, alist[idx], \"???\")\n"
"\t:endfor\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1309
msgid ""
"The get() function checks if a key is present in a Dictionary.  If it is, "
"then the value is retrieved.  If it isn't, then the default value is "
"returned, in the example it's '???'.  This is a convenient way to handle "
"situations where a key may not be present and you don't want an error "
"message."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1314
#, no-wrap
msgid ""
"The join() function does the opposite of split(): it joins together a list of\n"
"words, putting a space in between.\n"
"  This combination of split(), map() and join() is a nice way to filter a line\n"
"of words in a very compact way.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1317
msgid "OBJECT ORIENTED PROGRAMMING"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1323
#, no-wrap
msgid ""
"Now that you can put both values and functions in a Dictionary, you can\n"
"actually use a Dictionary like an object.\n"
"   Above we used a Dictionary for translating Dutch to English.  We might want\n"
"to do the same for other languages.  Let's first make an object (aka\n"
"Dictionary) that has the translate function, but no words to translate: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1328
#, no-wrap
msgid ""
"\t:let transdict = {}\n"
"\t:function transdict.translate(line) dict\n"
"\t:  return join(map(split(a:line), 'get(self.words, v:val, \"???\")'))\n"
"\t:endfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1332
msgid ""
"It's slightly different from the function above, using 'self.words' to "
"lookup word translations.  But we don't have a self.words.  Thus you could "
"call this an abstract class."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1334
msgid "Now we can instantiate a Dutch translation object: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1339
#, no-wrap
msgid ""
"\t:let uk2nl = copy(transdict)\n"
"\t:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}\n"
"\t:echo uk2nl.translate('three one')\n"
"<\tdrie een ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1341
msgid "And a German translator: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1346
#, no-wrap
msgid ""
"\t:let uk2de = copy(transdict)\n"
"\t:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}\n"
"\t:echo uk2de.translate('three one')\n"
"<\tdrei ein ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1350
msgid ""
"You see that the copy() function is used to make a copy of the \"transdict\" "
"Dictionary and then the copy is changed to add the words.  The original "
"remains the same, of course."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1352
msgid "Now you can go one step further, and use your preferred translator: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1360
#, no-wrap
msgid ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trans = uk2de\n"
"\t:else\n"
"\t:  let trans = uk2nl\n"
"\t:endif\n"
"\t:echo trans.translate('one two three')\n"
"<\teen twee drie ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1364
msgid ""
"Here \"trans\" refers to one of the two objects (Dictionaries).  No copy is "
"made.  More about List and Dictionary identity can be found at |list-"
"identity| and |dict-identity|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1367
msgid ""
"Now you might use a language that isn't supported.  You can overrule the "
"translate() function to do nothing: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1374
#, no-wrap
msgid ""
"\t:let uk2uk = copy(transdict)\n"
"\t:function! uk2uk.translate(line)\n"
"\t:  return a:line\n"
"\t:endfunction\n"
"\t:echo uk2uk.translate('three one wladiwostok')\n"
"<\tthree one wladiwostok ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1377
msgid ""
"Notice that a ! was used to overwrite the existing function reference.  Now "
"use \"uk2uk\" when no recognized language is found: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1387
#, no-wrap
msgid ""
"\t:if $LANG =~ \"de\"\n"
"\t:  let trans = uk2de\n"
"\t:elseif $LANG =~ \"nl\"\n"
"\t:  let trans = uk2nl\n"
"\t:else\n"
"\t:  let trans = uk2uk\n"
"\t:endif\n"
"\t:echo trans.translate('one two three')\n"
"<\tone two three ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1389
msgid "For further reading see |Lists| and |Dictionaries|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1392
#, no-wrap
msgid "*41.9*\tExceptions\n"
msgstr "*41.9*\tExcepciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:1394
#, fuzzy
#| msgid "It all starts with one simple command: >"
msgid "Let's start with an example: >"
msgstr "Comencemos con una simple orden: >"

#. type: Plain text
#: original/txt/usr_41.txt:1400
#, no-wrap
msgid ""
"\t:try\n"
"\t:   read ~/templates/pascal.tmpl\n"
"\t:catch /E484:/\n"
"\t:   echo \"Sorry, the Pascal template file cannot be found.\"\n"
"\t:endtry\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1404
msgid ""
"The \":read\" command will fail if the file does not exist.  Instead of "
"generating an error message, this code catches the error and gives the user "
"a nice message instead."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1410
msgid ""
"For the commands in between \":try\" and \":endtry\" errors are turned into "
"exceptions.  An exception is a string.  In the case of an error the string "
"contains the error message.  And every error message has a number.  In this "
"case, the error we catch contains \"E484:\".  This number is guaranteed to "
"stay the same (the text may change, e.g., it may be translated)."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1414
msgid ""
"When the \":read\" command causes another error, the pattern \"E484:\" will "
"not match in it.  Thus this exception will not be caught and result in the "
"usual error message."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1416
#, fuzzy
#| msgid "Another way to do this: >"
msgid "You might be tempted to do this: >"
msgstr "Existe otra manera de hacer esto: >"

#. type: Plain text
#: original/txt/usr_41.txt:1422
#, no-wrap
msgid ""
"\t:try\n"
"\t:   read ~/templates/pascal.tmpl\n"
"\t:catch\n"
"\t:   echo \"Sorry, the Pascal template file cannot be found.\"\n"
"\t:endtry\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1425
msgid ""
"This means all errors are caught.  But then you will not see errors that are "
"useful, such as \"E21: Cannot make changes, 'modifiable' is off\"."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1427
msgid "Another useful mechanism is the \":finally\" command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1437
#, no-wrap
msgid ""
"\t:let tmp = tempname()\n"
"\t:try\n"
"\t:   exe \".,$write \" . tmp\n"
"\t:   exe \"!filter \" . tmp\n"
"\t:   .,$delete\n"
"\t:   exe \"$read \" . tmp\n"
"\t:finally\n"
"\t:   call delete(tmp)\n"
"\t:endtry\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1443
msgid ""
"This filters the lines from the cursor until the end of the file through the "
"\"filter\" command, which takes a file name argument.  No matter if the "
"filtering works, something goes wrong in between \":try\" and \":finally\" "
"or the user cancels the filtering by pressing CTRL-C, the \"call delete"
"(tmp)\" is always executed.  This makes sure you don't leave the temporary "
"file behind."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1446
#, fuzzy
#| msgid "More about folding by indent in the reference manual: |fold-indent|"
msgid ""
"More information about exception handling can be found in the reference "
"manual: |exception-handling|."
msgstr ""
"Puede ver m√°s acerca de plegar por sangrado en el manual de referencia: |"
"fold-indent|"

#. type: Plain text
#: original/txt/usr_41.txt:1449
#, no-wrap
msgid "*41.10*\tVarious remarks\n"
msgstr "*41.10*\tObservaciones\n"

#. type: Plain text
#: original/txt/usr_41.txt:1452
msgid ""
"Here is a summary of items that apply to Vim scripts.  They are also "
"mentioned elsewhere, but form a nice checklist."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1456
msgid ""
"The end-of-line character depends on the system.  For Unix a single <NL> "
"character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is "
"used.  This is important when using mappings that end in a <CR>.  See |:"
"source_crnl|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1459
#, fuzzy
#| msgid "JUST SPACES"
msgid "WHITE SPACE"
msgstr "S√ìLO ESPACIOS"

#. type: Plain text
#: original/txt/usr_41.txt:1461
msgid "Blank lines are allowed and ignored."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1467
msgid ""
"Leading whitespace characters (blanks and TABs) are always ignored.  The "
"whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' "
"in the example below) are reduced to one blank character and plays the role "
"of a separator, the whitespaces after the last (visible) character may or "
"may not be ignored depending on the situation, see below."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1469
msgid "For a \":set\" command involving the \"=\" (equal) sign, such as in: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1471
#, fuzzy, no-wrap
#| msgid "\t:set cinoptions+={2\n"
msgid "\t:set cpoptions    =aABceFst\n"
msgstr "\t:set cinoptions+={2\n"

#. type: Plain text
#: original/txt/usr_41.txt:1474
msgid ""
"the whitespace immediately before the \"=\" sign is ignored.  But there can "
"be no whitespace after the \"=\" sign!"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1477
msgid ""
"To include a whitespace character in the value of an option, it must be "
"escaped by a \"\\\" (backslash)  as in the following example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1479
#, no-wrap
msgid "\t:set tags=my\\ nice\\ file\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1481
msgid "The same example written as >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1483
#, no-wrap
msgid "\t:set tags=my nice file\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1485
msgid "will issue an error, because it is interpreted as: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1489
#, fuzzy, no-wrap
#| msgid ""
#| "\t:set autoindent\n"
#| "\t:set ai\n"
msgid ""
"\t:set tags=my\n"
"\t:set nice\n"
"\t:set file\n"
msgstr ""
"\t:set autoindent\n"
"\t:set ai\n"

#. type: Plain text
#: original/txt/usr_41.txt:1492
#, fuzzy
#| msgid "MOVING IN COMMENTS"
msgid "COMMENTS"
msgstr "MOVERSE EN COMENTARIOS\t"

#. type: Plain text
#: original/txt/usr_41.txt:1497
msgid ""
"The character \" (the double quote mark) starts a comment.  Everything after "
"and including this character until the end-of-line is considered a comment "
"and is ignored, except for commands that don't consider comments, as shown "
"in examples below.  A comment can start on any character position on the "
"line."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1499
msgid ""
"There is a little \"catch\" with comments for some commands.  Examples: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1504
#, no-wrap
msgid ""
"\t:abbrev dev development\t\t\" shorthand\n"
"\t:map <F3> o#include\t\t\" insert include\n"
"\t:execute cmd\t\t\t\" do it\n"
"\t:!ls *.c\t\t\t\" list C files\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1513
#, no-wrap
msgid ""
"The abbreviation 'dev' will be expanded to 'development     \" shorthand'.  The\n"
"mapping of <F3> will actually be the whole line after the 'o# ....' including\n"
"the '\" insert include'.  The \"execute\" command will give an error.  The \"!\"\n"
"command will send everything after it to the shell, causing an error for an\n"
"unmatched '\"' character.\n"
"   There can be no comment after \":map\", \":abbreviate\", \":execute\" and \"!\"\n"
"commands (there are a few more commands with this restriction).  For the\n"
"\":map\", \":abbreviate\" and \":execute\" commands there is a trick: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1517
#, no-wrap
msgid ""
"\t:abbrev dev development|\" shorthand\n"
"\t:map <F3> o#include|\" insert include\n"
"\t:execute cmd\t\t\t|\" do it\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1522
#, no-wrap
msgid ""
"With the '|' character the command is separated from the next one.  And that\n"
"next command is only a comment.  For the last command you need to do two\n"
"things: |:execute| and use '|': >\n"
"\t:exe '!ls *.c'\t\t\t|\" list C files\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1527
msgid ""
"Notice that there is no white space before the '|' in the abbreviation and "
"mapping.  For these commands, any character until the end-of-line or '|' is "
"included.  As a consequence of this behavior, you don't always see that "
"trailing whitespace is included: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1529
#, no-wrap
msgid "\t:map <F4> o#include  \n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1532
msgid ""
"To spot these problems, you can set the 'list' option when editing vimrc "
"files."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1538
#, no-wrap
msgid ""
"For Unix there is one special way to comment a line, that allows making a Vim\n"
"script executable: >\n"
"\t#!/usr/bin/env vim -S\n"
"\techo \"this is a Vim script\"\n"
"\tquit\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1542
msgid ""
"The \"#\" command by itself lists a line with the line number.  Adding an "
"exclamation mark changes it into doing nothing, so that you can add the "
"shell command to execute the rest of the file. |:#!| |-S|"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1545
msgid "PITFALLS"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1547
msgid "Even bigger problem arises in the following example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1550
#, no-wrap
msgid ""
"\t:map ,ab o#include\n"
"\t:unmap ,ab \n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1555
msgid ""
"Here the unmap command will not work, because it tries to unmap \",ab \".  "
"This does not exist as a mapped sequence.  An error will be issued, which is "
"very hard to identify, because the ending whitespace character in \":unmap ,"
"ab \" is not visible."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1558
msgid ""
"And this is the same as what happens when one uses a comment after an "
"'unmap' command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1560
#, no-wrap
msgid "\t:unmap ,ab     \" comment\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1563
#, no-wrap
msgid ""
"Here the comment part will be ignored.  However, Vim will try to unmap\n"
"',ab     ', which does not exist.  Rewrite it as: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1565
#, no-wrap
msgid "\t:unmap ,ab|    \" comment\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1568
#, fuzzy
#| msgid "REDRAWING THE SCREEN"
msgid "RESTORING THE VIEW"
msgstr "REDIBUJAR LA PANTALLA"

#. type: Plain text
#: original/txt/usr_41.txt:1574
#, no-wrap
msgid ""
"Sometimes you want to make a change and go back to where cursor was.\n"
"Restoring the relative position would also be nice, so that the same line\n"
"appears at the top of the window.\n"
"   This example yanks the current line, puts it above the first line in the\n"
"file and then restores the view: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1576
#, no-wrap
msgid "\tmap ,p ma\"aYHmbgg\"aP`bzt`a\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1587
#, no-wrap
msgid ""
"What this does: >\n"
"\tma\"aYHmbgg\"aP`bzt`a\n"
"<\tma\t\t\tset mark a at cursor position\n"
"\t  \"aY\t\t\tyank current line into register a\n"
"\t     Hmb\t\tgo to top line in window and set mark b there\n"
"\t\tgg\t\tgo to first line in file\n"
"\t\t  \"aP\t\tput the yanked line above it\n"
"\t\t     `b\t\tgo back to top line in display\n"
"\t\t       zt\tposition the text in the window as before\n"
"\t\t\t `a\tgo back to saved cursor position\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1590
msgid "PACKAGING"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1599
#, no-wrap
msgid ""
"To avoid your function names to interfere with functions that you get from\n"
"others, use this scheme:\n"
"- Prepend a unique string before each function name.  I often use an\n"
"  abbreviation.  For example, \"OW_\" is used for the option window functions.\n"
"- Put the definition of your functions together in a file.  Set a global\n"
"  variable to indicate that the functions have been loaded.  When sourcing the\n"
"  file again, first unload the functions.\n"
"Example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1601
#, no-wrap
msgid "\t\" This is the XXX package\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1606
#, no-wrap
msgid ""
"\tif exists(\"XXX_loaded\")\n"
"\t  delfun XXX_one\n"
"\t  delfun XXX_two\n"
"\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1610
#, no-wrap
msgid ""
"\tfunction XXX_one(a)\n"
"\t\t... body of function ...\n"
"\tendfun\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1614
#, no-wrap
msgid ""
"\tfunction XXX_two(b)\n"
"\t\t... body of function ...\n"
"\tendfun\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1616
#, fuzzy, no-wrap
#| msgid "\t:let b:did_indent = 1\n"
msgid "\tlet XXX_loaded = 1\n"
msgstr "\t:let b:did_indent = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:1619
#, no-wrap
msgid "*41.11*\tWriting a plugin\t\t\t\t*write-plugin*\n"
msgstr "*41.11*\tEscribir extensiones\t\t\t\t*write-plugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:1623
msgid ""
"You can write a Vim script in such a way that many people can use it.  This "
"is called a plugin.  Vim users can drop your script in their plugin "
"directory and use its features right away |add-plugin|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1625
#, fuzzy
#| msgid "There are two types of plugins:"
msgid "There are actually two types of plugins:"
msgstr "Hay dos tipos de extensiones:"

#. type: Plain text
#: original/txt/usr_41.txt:1628
#, fuzzy, no-wrap
#| msgid ""
#| "    global plugin: Used for all kinds of files\n"
#| "  filetype plugin: Only used for a specific type of file\n"
msgid ""
"  global plugins: For all types of files.\n"
"filetype plugins: Only for files of a specific type.\n"
msgstr ""
"               Extensi√≥n global: Empleado para todos los tipos de archivo\n"
"   Extensi√≥n de tipo de archivo: Empleado para un tipo de archivo espec√≠fico\n"

#. type: Plain text
#: original/txt/usr_41.txt:1632
msgid ""
"In this section the first type is explained.  Most items are also relevant "
"for writing filetype plugins.  The specifics for filetype plugins are in the "
"next section |write-filetype-plugin|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1635
msgid "NAME"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1641
msgid ""
"First of all you must choose a name for your plugin.  The features provided "
"by the plugin should be clear from its name.  And it should be unlikely that "
"someone else writes a plugin with the same name but which does something "
"different.  And please limit the name to 8 characters, to avoid problems on "
"old Windows systems."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1644
msgid ""
"A script that corrects typing mistakes could be called \"typecorr.vim\".  We "
"will use it here as an example."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1647
msgid ""
"For the plugin to work for everybody, it should follow a few guidelines.  "
"This will be explained step-by-step.  The complete example plugin is at the "
"end."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1650
msgid "BODY"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1652
msgid ""
"Let's start with the body of the plugin, the lines that do the actual work: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1659
#, no-wrap
msgid ""
" 14\tiabbrev teh the\n"
" 15\tiabbrev otehr other\n"
" 16\tiabbrev wnat want\n"
" 17\tiabbrev synchronisation\n"
" 18\t\t\\ synchronization\n"
" 19\tlet s:count = 4\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1661
msgid "The actual list should be much longer, of course."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1664
msgid ""
"The line numbers have only been added to explain a few things, don't put "
"them in your plugin file!"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1667
msgid "HEADER"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1672
msgid ""
"You will probably add new corrections to the plugin and soon have several "
"versions laying around.  And when distributing this file, people will want "
"to know who wrote this wonderful plugin and where they can send remarks.  "
"Therefore, put a header at the top of your plugin: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1676
#, no-wrap
msgid ""
"  1\t\" Vim global plugin for correcting typing mistakes\n"
"  2\t\" Last Change:\t2000 Oct 15\n"
"  3\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1681
msgid ""
"About copyright and licensing: Since plugins are very useful and it's hardly "
"worth restricting their distribution, please consider making your plugin "
"either public domain or use the Vim |license|.  A short note about this near "
"the top of the plugin should be sufficient.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1683
#, no-wrap
msgid "  4\t\" License:\tThis file is placed in the public domain.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1686
#, no-wrap
msgid "LINE CONTINUATION, AVOIDING SIDE EFFECTS\t\t*use-cpo-save*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1693
msgid ""
"In line 18 above, the line-continuation mechanism is used |line-"
"continuation|.  Users with 'compatible' set will run into trouble here, they "
"will get an error message.  We can't just reset 'compatible', because that "
"has a lot of side effects.  To avoid this, we will set the 'cpoptions' "
"option to its Vim default value and restore it later.  That will allow the "
"use of line-continuation and make the script work for most people.  It is "
"done like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1698
#, no-wrap
msgid ""
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" ..\n"
" 42\tlet &cpo = s:save_cpo\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1701
msgid ""
"We first store the old value of 'cpoptions' in the s:save_cpo variable.  At "
"the end of the plugin this value is restored."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1705
msgid ""
"Notice that a script-local variable is used |s:var|.  A global variable "
"could already be in use for something else.  Always use script-local "
"variables for things that are only used in the script."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1708
#, fuzzy
#| msgid "NOT WRAPPING"
msgid "NOT LOADING"
msgstr "B√öSQUEDA ¬´NOWRAP¬ª"

#. type: Plain text
#: original/txt/usr_41.txt:1713
msgid ""
"It's possible that a user doesn't always want to load this plugin.  Or the "
"system administrator has dropped it in the system-wide plugin directory, but "
"a user has his own plugin he wants to use.  Then the user must have a chance "
"to disable loading this specific plugin.  This will make it possible: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1718
#, no-wrap
msgid ""
"  6\tif exists(\"g:loaded_typecorr\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_typecorr = 1\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1722
msgid ""
"This also avoids that when the script is loaded twice it would cause error "
"messages for redefining functions and cause trouble for autocommands that "
"are added twice."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1727
msgid ""
"The name is recommended to start with \"loaded_\" and then the file name of "
"the plugin, literally.  The \"g:\" is prepended just to avoid mistakes when "
"using the variable in a function (without \"g:\" it would be a variable "
"local to the function)."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1730
msgid ""
"Using \"finish\" stops Vim from reading the rest of the file, it's much "
"quicker than using if-endif around the whole file."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1733
#, fuzzy
#| msgid "NOT WRAPPING"
msgid "MAPPING"
msgstr "B√öSQUEDA ¬´NOWRAP¬ª"

#. type: Plain text
#: original/txt/usr_41.txt:1739
msgid ""
"Now let's make the plugin more interesting: We will add a mapping that adds "
"a correction for the word under the cursor.  We could just pick a key "
"sequence for this mapping, but the user might already use it for something "
"else.  To allow the user to define which keys a mapping in a plugin uses, "
"the <Leader> item can be used: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1741
#, no-wrap
msgid " 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1743
msgid ""
"The \"<Plug>TypecorrAdd\" thing will do the work, more about that further on."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1746
msgid ""
"The user can set the \"mapleader\" variable to the key sequence that he "
"wants this mapping to start with.  Thus if the user has done: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1748
#, no-wrap
msgid "\tlet mapleader = \"_\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1751
msgid ""
"the mapping will define \"_a\".  If the user didn't do this, the default "
"value will be used, which is a backslash.  Then a map for \"\\a\" will be "
"defined."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1754
msgid ""
"Note that <unique> is used, this will cause an error message if the mapping "
"already happened to exist. |:map-<unique>|"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1757
msgid ""
"But what if the user wants to define his own key sequence? We can allow that "
"with this mechanism: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1761
#, no-wrap
msgid ""
" 21\tif !hasmapto('<Plug>TypecorrAdd')\n"
" 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
" 23\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1765
msgid ""
"This checks if a mapping to \"<Plug>TypecorrAdd\" already exists, and only "
"defines the mapping from \"<Leader>a\" if it doesn't.  The user then has a "
"chance of putting this in his vimrc file: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1767
#, no-wrap
msgid "\tmap ,c  <Plug>TypecorrAdd\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1769
msgid ""
"Then the mapped key sequence will be \",c\" instead of \"_a\" or \"\\a\"."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1772
msgid "PIECES"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1779
msgid ""
"If a script gets longer, you often want to break up the work in pieces.  You "
"can use functions or mappings for this.  But you don't want these functions "
"and mappings to interfere with the ones from other scripts.  For example, "
"you could define a function Add(), but another script could try to define "
"the same function.  To avoid this, we define the function local to the "
"script by prepending it with \"s:\"."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1781
msgid "We will define a function that adds a new typing correction: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1787
#, no-wrap
msgid ""
" 30\tfunction s:Add(from, correct)\n"
" 31\t  let to = input(\"type the correction for \" . a:from . \": \")\n"
" 32\t  exe \":iabbrev \" . a:from . \" \" . to\n"
" ..\n"
" 36\tendfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1792
msgid ""
"Now we can call the function s:Add() from within this script.  If another "
"script also defines s:Add(), it will be local to that script and can only be "
"called from the script it was defined in.  There can also be a global Add()  "
"function (without the \"s:\"), which is again another function."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1795
msgid ""
"<SID> can be used with mappings.  It generates a script ID, which identifies "
"the current script.  In our typing correction plugin we use it like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1799
#, no-wrap
msgid ""
" 24\tnoremap <unique> <script> <Plug>TypecorrAdd  <SID>Add\n"
" ..\n"
" 28\tnoremap <SID>Add  :call <SID>Add(expand(\"<cword>\"), 1)<CR>\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1801
msgid "Thus when a user types \"\\a\", this sequence is invoked: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1803
#, no-wrap
msgid "\t\\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1806
msgid ""
"If another script would also map <SID>Add, it would get another script ID "
"and thus define another mapping."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1811
msgid ""
"Note that instead of s:Add() we use <SID>Add() here.  That is because the "
"mapping is typed by the user, thus outside of the script.  The <SID> is "
"translated to the script ID, so that Vim knows in which script to look for "
"the Add() function."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1815
msgid ""
"This is a bit complicated, but it's required for the plugin to work together "
"with other plugins.  The basic rule is that you use <SID>Add() in mappings "
"and s:Add() in other places (the script itself, autocommands, user commands)."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1817
msgid "We can also add a menu entry to do the same as the mapping: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1819
#, no-wrap
msgid " 26\tnoremenu <script> Plugin.Add\\ Correction      <SID>Add\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1824
msgid ""
"The \"Plugin\" menu is recommended for adding menu items for plugins.  In "
"this case only one item is used.  When adding more items, creating a submenu "
"is recommended.  For example, \"Plugin.CVS\" could be used for a plugin that "
"offers CVS operations \"Plugin.CVS.checkin\", \"Plugin.CVS.checkout\", etc."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1831
msgid ""
"Note that in line 28 \":noremap\" is used to avoid that any other mappings "
"cause trouble.  Someone may have remapped \":call\", for example.  In line "
"24 we also use \":noremap\", but we do want \"<SID>Add\" to be remapped.  "
"This is why \"<script>\" is used here.  This only allows mappings which are "
"local to the script. |:map-<script>| The same is done in line 26 for \":"
"noremenu\".  |:menu-<script>|"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1834
#, no-wrap
msgid "<SID> AND <Plug>\t\t\t\t\t*using-<Plug>*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1838
msgid ""
"Both <SID> and <Plug> are used to avoid that mappings of typed keys "
"interfere with mappings that are only to be used from other mappings.  Note "
"the difference between using <SID> and <Plug>:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1848
#, no-wrap
msgid ""
"<Plug>\tis visible outside of the script.  It is used for mappings which the\n"
"\tuser might want to map a key sequence to.  <Plug> is a special code\n"
"\tthat a typed key will never produce.\n"
"\tTo make it very unlikely that other plugins use the same sequence of\n"
"\tcharacters, use this structure: <Plug> scriptname mapname\n"
"\tIn our example the scriptname is \"Typecorr\" and the mapname is \"Add\".\n"
"\tThis results in \"<Plug>TypecorrAdd\".  Only the first character of\n"
"\tscriptname and mapname is uppercase, so that we can see where mapname\n"
"\tstarts.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1856
#, no-wrap
msgid ""
"<SID>\tis the script ID, a unique identifier for a script.\n"
"\tInternally Vim translates <SID> to \"<SNR>123_\", where \"123\" can be any\n"
"\tnumber.  Thus a function \"<SID>Add()\" will have a name \"<SNR>11_Add()\"\n"
"\tin one script, and \"<SNR>22_Add()\" in another.  You can see this if\n"
"\tyou use the \":function\" command to get a list of functions.  The\n"
"\ttranslation of <SID> in mappings is exactly the same, that's how you\n"
"\tcan call a script-local function from a mapping.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1859
#, fuzzy
#| msgid "THE VIM COMMAND"
msgid "USER COMMAND"
msgstr "LA ORDEN VIM"

#. type: Plain text
#: original/txt/usr_41.txt:1861
msgid "Now let's add a user command to add a correction: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1865
#, no-wrap
msgid ""
" 38\tif !exists(\":Correct\")\n"
" 39\t  command -nargs=1  Correct  :call s:Add(<q-args>, 0)\n"
" 40\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1870
msgid ""
"The user command is defined only if no command with the same name already "
"exists.  Otherwise we would get an error here.  Overriding the existing user "
"command with \":command!\" is not a good idea, this would probably make the "
"user wonder why the command he defined himself doesn't work.  |:command|"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1873
msgid "SCRIPT VARIABLES"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1879
msgid ""
"When a variable starts with \"s:\" it is a script variable.  It can only be "
"used inside a script.  Outside the script it's not visible.  This avoids "
"trouble with using the same variable name in different scripts.  The "
"variables will be kept as long as Vim is running.  And the same variables "
"are used when sourcing the same script again. |s:var|"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1883
msgid ""
"The fun is that these variables can also be used in functions, autocommands "
"and user commands that are defined in the script.  In our example we can add "
"a few lines to count the number of corrections: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1891
#, no-wrap
msgid ""
" 19\tlet s:count = 4\n"
" ..\n"
" 30\tfunction s:Add(from, correct)\n"
" ..\n"
" 34\t  let s:count = s:count + 1\n"
" 35\t  echo s:count . \" corrections now\"\n"
" 36\tendfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1896
msgid ""
"First s:count is initialized to 4 in the script itself.  When later the s:Add"
"() function is called, it increments s:count.  It doesn't matter from where "
"the function was called, since it has been defined in the script, it will "
"use the local variables from this script."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1899
msgid "THE RESULT"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1901
msgid "Here is the resulting complete example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1944
#, no-wrap
msgid ""
"  1\t\" Vim global plugin for correcting typing mistakes\n"
"  2\t\" Last Change:\t2000 Oct 15\n"
"  3\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
"  4\t\" License:\tThis file is placed in the public domain.\n"
"  5\n"
"  6\tif exists(\"g:loaded_typecorr\")\n"
"  7\t  finish\n"
"  8\tendif\n"
"  9\tlet g:loaded_typecorr = 1\n"
" 10\n"
" 11\tlet s:save_cpo = &cpo\n"
" 12\tset cpo&vim\n"
" 13\n"
" 14\tiabbrev teh the\n"
" 15\tiabbrev otehr other\n"
" 16\tiabbrev wnat want\n"
" 17\tiabbrev synchronisation\n"
" 18\t\t\\ synchronization\n"
" 19\tlet s:count = 4\n"
" 20\n"
" 21\tif !hasmapto('<Plug>TypecorrAdd')\n"
" 22\t  map <unique> <Leader>a  <Plug>TypecorrAdd\n"
" 23\tendif\n"
" 24\tnoremap <unique> <script> <Plug>TypecorrAdd  <SID>Add\n"
" 25\n"
" 26\tnoremenu <script> Plugin.Add\\ Correction      <SID>Add\n"
" 27\n"
" 28\tnoremap <SID>Add  :call <SID>Add(expand(\"<cword>\"), 1)<CR>\n"
" 29\n"
" 30\tfunction s:Add(from, correct)\n"
" 31\t  let to = input(\"type the correction for \" . a:from . \": \")\n"
" 32\t  exe \":iabbrev \" . a:from . \" \" . to\n"
" 33\t  if a:correct | exe \"normal viws\\<C-R>\\\" \\b\\e\" | endif\n"
" 34\t  let s:count = s:count + 1\n"
" 35\t  echo s:count . \" corrections now\"\n"
" 36\tendfunction\n"
" 37\n"
" 38\tif !exists(\":Correct\")\n"
" 39\t  command -nargs=1  Correct  :call s:Add(<q-args>, 0)\n"
" 40\tendif\n"
" 41\n"
" 42\tlet &cpo = s:save_cpo\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1949
msgid ""
"Line 33 wasn't explained yet.  It applies the new correction to the word "
"under the cursor.  The |:normal| command is used to use the new "
"abbreviation.  Note that mappings and abbreviations are expanded here, even "
"though the function was called from a mapping defined with \":noremap\"."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1954
msgid ""
"Using \"unix\" for the 'fileformat' option is recommended.  The Vim scripts "
"will then work everywhere.  Scripts with 'fileformat' set to \"dos\" do not "
"work on Unix.  Also see |:source_crnl|.  To be sure it is set right, do this "
"before writing the file: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1956
#, fuzzy, no-wrap
#| msgid "\t:set fileformats=unix,dos\n"
msgid "\t:set fileformat=unix\n"
msgstr "\t:set fileformats=unix,dos\n"

#. type: Plain text
#: original/txt/usr_41.txt:1959
#, no-wrap
msgid "DOCUMENTATION\t\t\t\t\t\t*write-local-help*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1963
msgid ""
"It's a good idea to also write some documentation for your plugin.  "
"Especially when its behavior can be changed by the user.  See |add-local-"
"help| for how they are installed."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1965
msgid ""
"Here is a simple example for a plugin help file, called \"typecorr.txt\": >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1983
#, no-wrap
msgid ""
"  1\t*typecorr.txt*\tPlugin for correcting typing mistakes\n"
"  2\n"
"  3\tIf you make typing mistakes, this plugin will have them corrected\n"
"  4\tautomatically.\n"
"  5\n"
"  6\tThere are currently only a few corrections.  Add your own if you like.\n"
"  7\n"
"  8\tMappings:\n"
"  9\t<Leader>a   or   <Plug>TypecorrAdd\n"
" 10\t\tAdd a correction for the word under the cursor.\n"
" 11\n"
" 12\tCommands:\n"
" 13\t:Correct {word}\n"
" 14\t\tAdd a correction for {word}.\n"
" 15\n"
" 16\t\t\t\t\t\t\t*typecorr-settings*\n"
" 17\tThis plugin doesn't have any settings.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1989
msgid ""
"The first line is actually the only one for which the format matters.  It "
"will be extracted from the help file to be put in the \"LOCAL ADDITIONS:\" "
"section of help.txt |local-additions|.  The first \"*\" must be in the first "
"column of the first line.  After adding your help file do \":help\" and "
"check that the entries line up nicely."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1993
msgid ""
"You can add more tags inside ** in your help file.  But be careful not to "
"use existing help tags.  You would probably use the name of your plugin in "
"most of them, like \"typecorr-settings\" in the example."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1996
msgid ""
"Using references to other parts of the help in || is recommended.  This "
"makes it easy for the user to find associated help."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:1999
#, fuzzy, no-wrap
#| msgid "USING A FILETYPE PLUGIN\t\t\t\t\t*ftplugin-name*\n"
msgid "FILETYPE DETECTION\t\t\t\t\t*plugin-filetype*\n"
msgstr "USAR UNA EXTENSI√ìN DE TIPO DE ARCHIVO\t\t\t*ftplugin-name*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2004
msgid ""
"If your filetype is not already detected by Vim, you should create a "
"filetype detection snippet in a separate file.  It is usually in the form of "
"an autocommand that sets the filetype when the file name matches a pattern.  "
"Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2006
#, no-wrap
msgid "\tau BufNewFile,BufRead *.foo\t\t\tset filetype=foofoo\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2011
msgid ""
"Write this single-line file as \"ftdetect/foofoo.vim\" in the first "
"directory that appears in 'runtimepath'.  For Unix that would be \"~/.vim/"
"ftdetect/foofoo.vim\".  The convention is to use the name of the filetype "
"for the script name."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2014
msgid ""
"You can make more complicated checks if you like, for example to inspect the "
"contents of the file to recognize the language.  Also see |new-filetype|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2017
#, no-wrap
msgid "SUMMARY\t\t\t\t\t\t\t*plugin-special*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2019
msgid "Summary of special things to use in a plugin:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2021
#, no-wrap
msgid "s:name\t\t\tVariables local to the script.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2024
#, no-wrap
msgid ""
"<SID>\t\t\tScript-ID, used for mappings and functions local to\n"
"\t\t\tthe script.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2027
#, no-wrap
msgid ""
"hasmapto()\t\tFunction to test if the user already defined a mapping\n"
"\t\t\tfor functionality the script offers.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2030
#, no-wrap
msgid ""
"<Leader>\t\tValue of \"mapleader\", which the user defines as the\n"
"\t\t\tkeys that plugin mappings start with.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2032
#, no-wrap
msgid ":map <unique>\t\tGive a warning if a mapping already exists.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2035
#, no-wrap
msgid ""
":noremap <script>\tUse only mappings local to the script, not global\n"
"\t\t\tmappings.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2037
#, no-wrap
msgid "exists(\":Cmd\")\t\tCheck if a user command already exists.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2040
#, no-wrap
msgid "*41.12*\tWriting a filetype plugin\t*write-filetype-plugin* *ftplugin*\n"
msgstr "*41.12*\tEscribir extensiones para tipo de archivo\t*write-filetype-plugin* *ftplugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2044
msgid ""
"A filetype plugin is like a global plugin, except that it sets options and "
"defines mappings for the current buffer only.  See |add-filetype-plugin| for "
"how this type of plugin is used."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2049
msgid ""
"First read the section on global plugins above |41.11|.  All that is said "
"there also applies to filetype plugins.  There are a few extras, which are "
"explained here.  The essential thing is that a filetype plugin should only "
"have an effect on the current buffer."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2052
msgid "DISABLING"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2055
msgid ""
"If you are writing a filetype plugin to be used by many people, they need a "
"chance to disable loading it.  Put this at the top of the plugin: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2061
#, no-wrap
msgid ""
"\t\" Only do this when not done yet for this buffer\n"
"\tif exists(\"b:did_ftplugin\")\n"
"\t  finish\n"
"\tendif\n"
"\tlet b:did_ftplugin = 1\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2064
msgid ""
"This also needs to be used to avoid that the same plugin is executed twice "
"for the same buffer (happens when using an \":edit\" command without "
"arguments)."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2067
msgid ""
"Now users can disable loading the default plugin completely by making a "
"filetype plugin with only this line: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2069
#, fuzzy, no-wrap
#| msgid "\t:let b:did_indent = 1\n"
msgid "\tlet b:did_ftplugin = 1\n"
msgstr "\t:let b:did_indent = 1\n"

#. type: Plain text
#: original/txt/usr_41.txt:2072
msgid ""
"This does require that the filetype plugin directory comes before "
"$VIMRUNTIME in 'runtimepath'!"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2075
msgid ""
"If you do want to use the default plugin, but overrule one of the settings, "
"you can write the different setting in a script: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2077
#, fuzzy, no-wrap
#| msgid "\t:set textwidth=72\n"
msgid "\tsetlocal textwidth=70\n"
msgstr "\t:set textwidth=72\n"

#. type: Plain text
#: original/txt/usr_41.txt:2082
msgid ""
"Now write this in the \"after\" directory, so that it gets sourced after the "
"distributed \"vim.vim\" ftplugin |after-directory|.  For Unix this would be "
"\"~/.vim/after/ftplugin/vim.vim\".  Note that the default plugin will have "
"set \"b:did_ftplugin\", but it is ignored here."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2087
msgid ""
"To make sure the filetype plugin only affects the current buffer use the >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2089
#, fuzzy, no-wrap
#| msgid "\t:setlocal noswapfile\n"
msgid "\t:setlocal\n"
msgstr "\t:setlocal noswapfile\n"

#. type: Plain text
#: original/txt/usr_41.txt:2094
msgid ""
"command to set options.  And only set options which are local to a buffer "
"(see the help for the option to check that).  When using |:setlocal| for "
"global options or options local to a window, the value will change for many "
"buffers, and that is not what a filetype plugin should do."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2099
msgid ""
"When an option has a value that is a list of flags or items, consider using "
"\"+=\" and \"-=\" to keep the existing value.  Be aware that the user may "
"have changed an option value already.  First resetting to the default value "
"and then changing it often a good idea.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2101
#, no-wrap
msgid "\t:setlocal formatoptions& formatoptions+=ro\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2104
#, fuzzy
#| msgid "NOT WRAPPING"
msgid "MAPPINGS"
msgstr "B√öSQUEDA ¬´NOWRAP¬ª"

#. type: Plain text
#: original/txt/usr_41.txt:2106
msgid "To make sure mappings will only work in the current buffer use the >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2108
#, fuzzy, no-wrap
#| msgid "\t:buffers\n"
msgid "\t:map <buffer>\n"
msgstr "\t:buffers\n"

#. type: Plain text
#: original/txt/usr_41.txt:2111
msgid ""
"command.  This needs to be combined with the two-step mapping explained "
"above.  An example of how to define functionality in a filetype plugin: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2116
#, no-wrap
msgid ""
"\tif !hasmapto('<Plug>JavaImport')\n"
"\t  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport\n"
"\tendif\n"
"\tnoremap <buffer> <unique> <Plug>JavaImport oimport \"\"<Left><Esc>\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2127
msgid ""
"|hasmapto()| is used to check if the user has already defined a map to "
"<Plug>JavaImport.  If not, then the filetype plugin defines the default "
"mapping.  This starts with |<LocalLeader>|, which allows the user to select "
"the key(s) he wants filetype plugin mappings to start with.  The default is "
"a backslash.  \"<unique>\" is used to give an error message if the mapping "
"already exists or overlaps with an existing mapping.  |:noremap| is used to "
"avoid that any other mappings that the user has defined interferes.  You "
"might want to use \":noremap <script>\" to allow remapping mappings defined "
"in this script that start with <SID>."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2131
msgid ""
"The user must have a chance to disable the mappings in a filetype plugin, "
"without disabling everything.  Here is an example of how this is done for a "
"plugin for the mail filetype: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2142
#, no-wrap
msgid ""
"\t\" Add mappings, unless the user didn't want this.\n"
"\tif !exists(\"no_plugin_maps\") && !exists(\"no_mail_maps\")\n"
"\t  \" Quote text by inserting \"> \"\n"
"\t  if !hasmapto('<Plug>MailQuote')\n"
"\t    vmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t    nmap <buffer> <LocalLeader>q <Plug>MailQuote\n"
"\t  endif\n"
"\t  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>\n"
"\t  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>\n"
"\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2146
#, no-wrap
msgid ""
"Two global variables are used:\n"
"no_plugin_maps\t\tdisables mappings for all filetype plugins\n"
"no_mail_maps\t\tdisables mappings for a specific filetype\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2149
#, fuzzy
#| msgid "RELATED COMMANDS"
msgid "USER COMMANDS"
msgstr "√ìRDENES RELACIONADAS"

#. type: Plain text
#: original/txt/usr_41.txt:2152
msgid ""
"To add a user command for a specific file type, so that it can only be used "
"in one buffer, use the \"-buffer\" argument to |:command|.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2154
#, no-wrap
msgid "\t:command -buffer  Make  make %:r.s\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2157
msgid "VARIABLES"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2161
msgid ""
"A filetype plugin will be sourced for each buffer of the type it's for.  "
"Local script variables |s:var| will be shared between all invocations.  Use "
"local buffer variables |b:var| if you want a variable specifically for one "
"buffer."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2164
#, fuzzy
#| msgid "OPTIONS"
msgid "FUNCTIONS"
msgstr "OPCIONES"

#. type: Plain text
#: original/txt/usr_41.txt:2168
msgid ""
"When defining a function, this only needs to be done once.  But the filetype "
"plugin will be sourced every time a file with this filetype will be opened.  "
"This construct makes sure the function is only defined once: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2175
#, no-wrap
msgid ""
"\t:if !exists(\"*s:Func\")\n"
"\t:  function s:Func(arg)\n"
"\t:    ...\n"
"\t:  endfunction\n"
"\t:endif\n"
"<\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2177
#, no-wrap
msgid "UNDO\t\t\t\t\t\t\t*undo_ftplugin*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2181
msgid ""
"When the user does \":setfiletype xyz\" the effect of the previous filetype "
"should be undone.  Set the b:undo_ftplugin variable to the commands that "
"will undo the settings in your filetype plugin.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2184
#, no-wrap
msgid ""
"\tlet b:undo_ftplugin = \"setlocal fo< com< tw< commentstring<\"\n"
"\t\t\\ . \"| unlet b:match_ignorecase b:match_words b:match_skip\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2187
msgid ""
"Using \":setlocal\" with \"<\" after the option name resets the option to "
"its global value.  That is mostly the best way to reset the option value."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2190
msgid ""
"This does require removing the \"C\" flag from 'cpoptions' to allow line "
"continuation, as mentioned above |use-cpo-save|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2193
#, fuzzy
#| msgid "FILE MARKS"
msgid "FILE NAME"
msgstr "MARCAS DE ARCHIVO"

#. type: Plain text
#: original/txt/usr_41.txt:2196
msgid ""
"The filetype must be included in the file name |ftplugin-name|.  Use one of "
"these three forms:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2200
#, fuzzy, no-wrap
#| msgid ""
#| "\t~/.vim/ftplugin/stuff.vim\n"
#| "\t~/.vim/ftplugin/stuff_def.vim\n"
#| "\t~/.vim/ftplugin/stuff/header.vim\n"
msgid ""
"\t.../ftplugin/stuff.vim\n"
"\t.../ftplugin/stuff_foo.vim\n"
"\t.../ftplugin/stuff/bar.vim\n"
msgstr ""
"\t~/.vim/ftplugin/cosas.vim\n"
"\t~/.vim/ftplugin/cosas_def.vim\n"
"\t~/.vim/ftplugin/cosas/header.vim\n"

#. type: Plain text
#: original/txt/usr_41.txt:2202
msgid "\"stuff\" is the filetype, \"foo\" and \"bar\" are arbitrary names."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2205
#, no-wrap
msgid "SUMMARY\t\t\t\t\t\t\t*ftplugin-special*\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2207
msgid "Summary of special things to use in a filetype plugin:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2210
#, no-wrap
msgid ""
"<LocalLeader>\t\tValue of \"maplocalleader\", which the user defines as\n"
"\t\t\tthe keys that filetype plugin mappings start with.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2212
#, no-wrap
msgid ":map <buffer>\t\tDefine a mapping local to the buffer.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2215
#, no-wrap
msgid ""
":noremap <script>\tOnly remap mappings defined in this script that start\n"
"\t\t\twith <SID>.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2217
#, no-wrap
msgid ":setlocal\t\tSet an option for the current buffer only.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2219
#, no-wrap
msgid ":command -buffer\tDefine a user command local to the buffer.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2221
#, no-wrap
msgid "exists(\"*s:Func\")\tCheck if a function was already defined.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2223
msgid "Also see |plugin-special|, the special things used for all plugins."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2226
#, no-wrap
msgid "*41.13*\tWriting a compiler plugin\t\t*write-compiler-plugin*\n"
msgstr "*41.13*\tEscribir extensiones para compiladores\t\t*write-compiler-plugin*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2230
msgid ""
"A compiler plugin sets options for use with a specific compiler.  The user "
"can load it with the |:compiler| command.  The main use is to set the "
"'errorformat' and 'makeprg' options."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2233
msgid ""
"Easiest is to have a look at examples.  This command will edit all the "
"default compiler plugins: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2235
#, fuzzy, no-wrap
#| msgid "\t$VIMRUNTIME/vimrc_example.vim ~\n"
msgid "\t:next $VIMRUNTIME/compiler/*.vim\n"
msgstr "\t$VIMRUNTIME/vimrc_example.vim ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:2237
msgid "Use |:next| to go to the next plugin file."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2240
msgid ""
"There are two special items about these files.  First is a mechanism to "
"allow a user to overrule or add to the default file.  The default files "
"start with: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2245
#, no-wrap
msgid ""
"\t:if exists(\"current_compiler\")\n"
"\t:  finish\n"
"\t:endif\n"
"\t:let current_compiler = \"mine\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2254
#, no-wrap
msgid ""
"When you write a compiler file and put it in your personal runtime directory\n"
"(e.g., ~/.vim/compiler for Unix), you set the \"current_compiler\" variable to\n"
"make the default file skip the settings.\n"
"\t\t\t\t\t\t\t*:CompilerSet*\n"
"The second mechanism is to use \":set\" for \":compiler!\" and \":setlocal\" for\n"
"\":compiler\".  Vim defines the \":CompilerSet\" user command for this.  However,\n"
"older Vim versions don't, thus your plugin should define it then.  This is an\n"
"example: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2260
#, no-wrap
msgid ""
"  if exists(\":CompilerSet\") != 2\n"
"    command -nargs=* CompilerSet setlocal <args>\n"
"  endif\n"
"  CompilerSet errorformat&\t\t\" use the default 'errorformat'\n"
"  CompilerSet makeprg=nmake\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2264
msgid ""
"When you write a compiler plugin for the Vim distribution or for a system-"
"wide runtime directory, use the mechanism mentioned above.  When "
"\"current_compiler\" was already set by a user plugin nothing will be done."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2269
msgid ""
"When you write a compiler plugin to overrule settings from a default plugin, "
"don't check \"current_compiler\".  This plugin is supposed to be loaded "
"last, thus it should be in a directory at the end of 'runtimepath'.  For "
"Unix that could be ~/.vim/after/compiler."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2272
#, no-wrap
msgid "*41.14*\tWriting a plugin that loads quickly\t*write-plugin-quickload*\n"
msgstr "*41.14*\tEscribir extensiones que carguen r√°pidamente\t*write-plugin-quickload*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2276
msgid ""
"A plugin may grow and become quite long.  The startup delay may become "
"noticeable, while you hardly ever use the plugin.  Then it's time for a "
"quickload plugin."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2280
msgid ""
"The basic idea is that the plugin is loaded twice.  The first time user "
"commands and mappings are defined that offer the functionality.  The second "
"time the functions that implement the functionality are defined."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2285
msgid ""
"It may sound surprising that quickload means loading a script twice.  What "
"we mean is that it loads quickly the first time, postponing the bulk of the "
"script to the second time, which only happens when you actually use it.  "
"When you always use the functionality it actually gets slower!"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2288
msgid ""
"Note that since Vim 7 there is an alternative: use the |autoload| "
"functionality |41.15|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2290
msgid "The following example shows how it's done: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2295
#, no-wrap
msgid ""
"\t\" Vim global plugin for demonstrating quick loading\n"
"\t\" Last Change:\t2005 Feb 25\n"
"\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
"\t\" License:\tThis file is placed in the public domain.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2299
#, no-wrap
msgid ""
"\tif !exists(\"s:did_load\")\n"
"\t\tcommand -nargs=* BNRead  call BufNetRead(<f-args>)\n"
"\t\tmap <F19> :call BufNetWrite('something')<CR>\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2304
#, no-wrap
msgid ""
"\t\tlet s:did_load = 1\n"
"\t\texe 'au FuncUndefined BufNet* source ' . expand('<sfile>')\n"
"\t\tfinish\n"
"\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2309
#, no-wrap
msgid ""
"\tfunction BufNetRead(...)\n"
"\t\techo 'BufNetRead(' . string(a:000) . ')'\n"
"\t\t\" read functionality here\n"
"\tendfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2314
#, no-wrap
msgid ""
"\tfunction BufNetWrite(...)\n"
"\t\techo 'BufNetWrite(' . string(a:000) . ')'\n"
"\t\t\" write functionality here\n"
"\tendfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2318
msgid ""
"When the script is first loaded \"s:did_load\" is not set.  The commands "
"between the \"if\" and \"endif\" will be executed.  This ends in a |:finish| "
"command, thus the rest of the script is not executed."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2322
msgid ""
"The second time the script is loaded \"s:did_load\" exists and the commands "
"after the \"endif\" are executed.  This defines the (possible long)  "
"BufNetRead() and BufNetWrite() functions."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2325
msgid ""
"If you drop this script in your plugin directory Vim will execute it on "
"startup.  This is the sequence of events that happens:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2329
#, no-wrap
msgid ""
"1. The \"BNRead\" command is defined and the <F19> key is mapped when the script\n"
"   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The\n"
"   \":finish\" command causes the script to terminate early.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2332
#, no-wrap
msgid ""
"2. The user types the BNRead command or presses the <F19> key.  The\n"
"   BufNetRead() or BufNetWrite() function will be called.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2338
#, no-wrap
msgid ""
"3. Vim can't find the function and triggers the |FuncUndefined| autocommand\n"
"   event.  Since the pattern \"BufNet*\" matches the invoked function, the\n"
"   command \"source fname\" will be executed.  \"fname\" will be equal to the name\n"
"   of the script, no matter where it is located, because it comes from\n"
"   expanding \"<sfile>\" (see |expand()|).\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2341
#, no-wrap
msgid ""
"4. The script is sourced again, the \"s:did_load\" variable exists and the\n"
"   functions are defined.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2345
msgid ""
"Notice that the functions that are loaded afterwards match the pattern in "
"the |FuncUndefined| autocommand.  You must make sure that no other plugin "
"defines functions that match this pattern."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2348
#, no-wrap
msgid "*41.15*\tWriting library scripts\t\t\t*write-library-script*\n"
msgstr "*41.15*\tEscribir bibliotecas\t\t\t*write-library-script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2352
msgid ""
"Some functionality will be required in several places.  When this becomes "
"more than a few lines you will want to put it in one script and use it from "
"many scripts.  We will call that one script a library script."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2356
msgid ""
"Manually loading a library script is possible, so long as you avoid loading "
"it when it's already done.  You can do this with the |exists()| function.  "
"Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2361
#, no-wrap
msgid ""
"\tif !exists('*MyLibFunction')\n"
"\t   runtime library/mylibscript.vim\n"
"\tendif\n"
"\tcall MyLibFunction(arg)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2364
msgid ""
"Here you need to know that MyLibFunction() is defined in a script \"library/"
"mylibscript.vim\" in one of the directories in 'runtimepath'."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2367
msgid ""
"To make this a bit simpler Vim offers the autoload mechanism.  Then the "
"example looks like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2369
#, no-wrap
msgid "\tcall mylib#myfunction(arg)\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2373
msgid ""
"That's a lot simpler, isn't it? Vim will recognize the function name and "
"when it's not defined search for the script \"autoload/mylib.vim\" in "
"'runtimepath'.  That script must define the \"mylib#myfunction()\" function."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2378
msgid ""
"You can put many other functions in the mylib.vim script, you are free to "
"organize your functions in library scripts.  But you must use function names "
"where the part before the '#' matches the script name.  Otherwise Vim would "
"not know what script to load."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2381
msgid ""
"If you get really enthusiastic and write lots of library scripts, you may "
"want to use subdirectories.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2383
#, no-wrap
msgid "\tcall netlib#ftp#read('somefile')\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2385
msgid "For Unix the library script used for this could be:"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2387
#, fuzzy, no-wrap
#| msgid "\t~/.vim/indent/help.vim ~\n"
msgid "\t~/.vim/autoload/netlib/ftp.vim\n"
msgstr "\t~/.vim/indent/help.vim ~\n"

#. type: Plain text
#: original/txt/usr_41.txt:2389
msgid "Where the function is defined like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2393
#, no-wrap
msgid ""
"\tfunction netlib#ftp#read(fname)\n"
"\t\t\"  Read the file fname through ftp\n"
"\tendfunction\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2397
msgid ""
"Notice that the name the function is defined with is exactly the same as the "
"name used for calling the function.  And the part before the last '#' "
"exactly matches the subdirectory and script name."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2399
#, fuzzy
#| msgid "You can use this command to get a list of marks: >"
msgid "You can use the same mechanism for variables: >"
msgstr "Puedes usar esta orden para obtener una lista de marcadores: >"

#. type: Plain text
#: original/txt/usr_41.txt:2401
#, no-wrap
msgid "\tlet weekdays = dutch#weekdays\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2404
msgid ""
"This will load the script \"autoload/dutch.vim\", which should contain "
"something like: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2407
#, no-wrap
msgid ""
"\tlet dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',\n"
"\t\t\\ 'donderdag', 'vrijdag', 'zaterdag']\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2409
msgid "Further reading: |autoload|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2412
#, no-wrap
msgid "*41.16*\tDistributing Vim scripts\t\t\t*distribute-script*\n"
msgstr "*41.16*\tDistribuir scripts de Vim\t\t\t*distribute-script*\n"

#. type: Plain text
#: original/txt/usr_41.txt:2415
msgid ""
"Vim users will look for scripts on the Vim website: http://www.vim.org.  If "
"you made something that is useful for others, share it!"
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2419
msgid ""
"Vim scripts can be used on any system.  There might not be a tar or gzip "
"command.  If you want to pack files together and/or compress them the \"zip"
"\" utility is recommended."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2422
msgid ""
"For utmost portability use Vim itself to pack scripts together.  This can be "
"done with the Vimball utility.  See |vimball|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2424
msgid ""
"It's good if you add a line to allow automatic updating.  See |glvs-plugins|."
msgstr ""

#. type: Plain text
#: original/txt/usr_41.txt:2428
#, fuzzy
#| msgid "Next chapter: |usr_40.txt| Make new commands"
msgid "Next chapter: |usr_42.txt| Add new menus"
msgstr "Cap√≠tulo siguiente: |usr_40.esx| Crear √≥rdenes nuevas"
