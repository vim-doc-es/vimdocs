# Spanish translations for Vim package
# Copyright (C) 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the Vim package.
# Automatically generated, 2011.
#
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.3\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2011-05-14 19:11+0300\n"
"PO-Revision-Date: 2011-05-14 19:11+0300\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: Plain text
#: original/txt/intro.txt:18 original/txt/intro.txt:79
#: original/txt/intro.txt:180 original/txt/intro.txt:290
#: original/txt/intro.txt:518 original/txt/intro.txt:596
#: original/txt/intro.txt:689 original/txt/intro.txt:817
#: original/txt/intro.txt:880 original/txt/usr_toc.txt:7
#: original/txt/usr_toc.txt:58 original/txt/usr_toc.txt:172
#: original/txt/usr_toc.txt:281 original/txt/usr_toc.txt:340
#: original/txt/usr_toc.txt:352 original/txt/usr_01.txt:19
#: original/txt/usr_01.txt:50 original/txt/usr_01.txt:100
#: original/txt/usr_01.txt:181 original/txt/usr_02.txt:25
#: original/txt/usr_02.txt:69 original/txt/usr_02.txt:130
#: original/txt/usr_02.txt:179 original/txt/usr_02.txt:239
#: original/txt/usr_02.txt:307 original/txt/usr_02.txt:369
#: original/txt/usr_02.txt:406 original/txt/usr_02.txt:560
#: original/txt/usr_03.txt:28 original/txt/usr_03.txt:74
#: original/txt/usr_03.txt:101 original/txt/usr_03.txt:147
#: original/txt/usr_03.txt:172 original/txt/usr_03.txt:223
#: original/txt/usr_03.txt:265 original/txt/usr_03.txt:320
#: original/txt/usr_03.txt:491 original/txt/usr_03.txt:552
#: original/txt/usr_03.txt:650 original/txt/usr_04.txt:27
#: original/txt/usr_04.txt:74 original/txt/usr_04.txt:160
#: original/txt/usr_04.txt:194 original/txt/usr_04.txt:269
#: original/txt/usr_04.txt:324 original/txt/usr_04.txt:360
#: original/txt/usr_04.txt:390 original/txt/usr_04.txt:446
#: original/txt/usr_04.txt:469 original/txt/usr_04.txt:510
#: original/txt/usr_05.txt:24 original/txt/usr_05.txt:63
#: original/txt/usr_05.txt:219 original/txt/usr_05.txt:266
#: original/txt/usr_05.txt:418 original/txt/usr_05.txt:467
#: original/txt/usr_05.txt:506 original/txt/usr_05.txt:621
#: original/txt/usr_06.txt:24 original/txt/usr_06.txt:50
#: original/txt/usr_06.txt:135 original/txt/usr_06.txt:189
#: original/txt/usr_06.txt:270 original/txt/usr_06.txt:276
#: original/txt/usr_07.txt:24 original/txt/usr_07.txt:63
#: original/txt/usr_07.txt:179 original/txt/usr_07.txt:266
#: original/txt/usr_07.txt:316 original/txt/usr_07.txt:404
#: original/txt/usr_07.txt:444 original/txt/usr_07.txt:475
#: original/txt/usr_08.txt:26 original/txt/usr_08.txt:82
#: original/txt/usr_08.txt:109 original/txt/usr_08.txt:161
#: original/txt/usr_08.txt:215 original/txt/usr_08.txt:278
#: original/txt/usr_08.txt:337 original/txt/usr_08.txt:477
#: original/txt/usr_08.txt:509 original/txt/usr_08.txt:597
#: original/txt/usr_09.txt:21 original/txt/usr_09.txt:124
#: original/txt/usr_09.txt:175 original/txt/usr_09.txt:259
#: original/txt/usr_09.txt:285 original/txt/usr_10.txt:27
#: original/txt/usr_10.txt:144 original/txt/usr_10.txt:221
#: original/txt/usr_10.txt:342 original/txt/usr_10.txt:378
#: original/txt/usr_10.txt:547 original/txt/usr_10.txt:621
#: original/txt/usr_10.txt:667 original/txt/usr_10.txt:692
#: original/txt/usr_10.txt:820 original/txt/usr_11.txt:22
#: original/txt/usr_11.txt:82 original/txt/usr_11.txt:144
#: original/txt/usr_11.txt:288 original/txt/usr_11.txt:303
#: original/txt/usr_12.txt:25 original/txt/usr_12.txt:90
#: original/txt/usr_12.txt:131 original/txt/usr_12.txt:177
#: original/txt/usr_12.txt:202 original/txt/usr_12.txt:231
#: original/txt/usr_12.txt:281 original/txt/usr_12.txt:309
#: original/txt/usr_12.txt:354 original/txt/usr_20.txt:22
#: original/txt/usr_20.txt:113 original/txt/usr_20.txt:158
#: original/txt/usr_20.txt:285 original/txt/usr_20.txt:327
#: original/txt/usr_20.txt:380 original/txt/usr_21.txt:24
#: original/txt/usr_21.txt:47 original/txt/usr_21.txt:87
#: original/txt/usr_21.txt:236 original/txt/usr_21.txt:385
#: original/txt/usr_21.txt:438 original/txt/usr_21.txt:495
#: original/txt/usr_22.txt:22 original/txt/usr_22.txt:148
#: original/txt/usr_22.txt:213 original/txt/usr_22.txt:272
#: original/txt/usr_22.txt:396 original/txt/usr_23.txt:23
#: original/txt/usr_23.txt:114 original/txt/usr_23.txt:156
#: original/txt/usr_23.txt:238 original/txt/usr_23.txt:324
#: original/txt/usr_23.txt:339 original/txt/usr_24.txt:28
#: original/txt/usr_24.txt:96 original/txt/usr_24.txt:119
#: original/txt/usr_24.txt:268 original/txt/usr_24.txt:305
#: original/txt/usr_24.txt:336 original/txt/usr_24.txt:369
#: original/txt/usr_24.txt:493 original/txt/usr_24.txt:537
#: original/txt/usr_24.txt:583 original/txt/usr_24.txt:602
#: original/txt/usr_25.txt:22 original/txt/usr_25.txt:132
#: original/txt/usr_25.txt:210 original/txt/usr_25.txt:287
#: original/txt/usr_25.txt:453 original/txt/usr_25.txt:574
#: original/txt/usr_26.txt:21 original/txt/usr_26.txt:46
#: original/txt/usr_26.txt:103 original/txt/usr_26.txt:136
#: original/txt/usr_26.txt:217 original/txt/usr_27.txt:26
#: original/txt/usr_27.txt:88 original/txt/usr_27.txt:136
#: original/txt/usr_27.txt:239 original/txt/usr_27.txt:320
#: original/txt/usr_27.txt:350 original/txt/usr_27.txt:427
#: original/txt/usr_27.txt:469 original/txt/usr_27.txt:510
#: original/txt/usr_27.txt:559 original/txt/usr_28.txt:27
#: original/txt/usr_28.txt:54 original/txt/usr_28.txt:121
#: original/txt/usr_28.txt:185 original/txt/usr_28.txt:211
#: original/txt/usr_28.txt:269 original/txt/usr_28.txt:315
#: original/txt/usr_28.txt:331 original/txt/usr_28.txt:375
#: original/txt/usr_28.txt:389 original/txt/usr_28.txt:422
#: original/txt/usr_29.txt:23 original/txt/usr_29.txt:273
#: original/txt/usr_29.txt:320 original/txt/usr_29.txt:441
#: original/txt/usr_29.txt:570 original/txt/usr_29.txt:609
#: original/txt/usr_30.txt:23 original/txt/usr_30.txt:202
#: original/txt/usr_30.txt:280 original/txt/usr_30.txt:336
#: original/txt/usr_30.txt:409 original/txt/usr_30.txt:515
#: original/txt/usr_30.txt:639 original/txt/usr_31.txt:22
#: original/txt/usr_31.txt:81 original/txt/usr_31.txt:133
#: original/txt/usr_31.txt:160 original/txt/usr_31.txt:208
#: original/txt/usr_31.txt:268 original/txt/usr_32.txt:21
#: original/txt/usr_32.txt:44 original/txt/usr_32.txt:92
#: original/txt/usr_32.txt:140 original/txt/usr_32.txt:176
#: original/txt/usr_40.txt:20 original/txt/usr_40.txt:279
#: original/txt/usr_40.txt:424 original/txt/usr_40.txt:653
#: original/txt/usr_41.txt:33 original/txt/usr_41.txt:133
#: original/txt/usr_41.txt:267 original/txt/usr_41.txt:345
#: original/txt/usr_41.txt:482 original/txt/usr_41.txt:532
#: original/txt/usr_41.txt:877 original/txt/usr_41.txt:1104
#: original/txt/usr_41.txt:1390 original/txt/usr_41.txt:1447
#: original/txt/usr_41.txt:1617 original/txt/usr_41.txt:2038
#: original/txt/usr_41.txt:2224 original/txt/usr_41.txt:2270
#: original/txt/usr_41.txt:2346 original/txt/usr_41.txt:2410
#: original/txt/usr_41.txt:2425 original/txt/usr_42.txt:21
#: original/txt/usr_42.txt:140 original/txt/usr_42.txt:254
#: original/txt/usr_42.txt:293 original/txt/usr_42.txt:361
#: original/txt/usr_43.txt:20 original/txt/usr_43.txt:70
#: original/txt/usr_43.txt:169 original/txt/usr_44.txt:30
#: original/txt/usr_44.txt:85 original/txt/usr_44.txt:139
#: original/txt/usr_44.txt:166 original/txt/usr_44.txt:196
#: original/txt/usr_44.txt:291 original/txt/usr_44.txt:321
#: original/txt/usr_44.txt:448 original/txt/usr_44.txt:486
#: original/txt/usr_44.txt:530 original/txt/usr_44.txt:609
#: original/txt/usr_44.txt:645 original/txt/usr_44.txt:715
#: original/txt/usr_45.txt:22 original/txt/usr_45.txt:85
#: original/txt/usr_45.txt:137 original/txt/usr_45.txt:263
#: original/txt/usr_45.txt:327 original/txt/usr_45.txt:415
#: original/txt/usr_90.txt:21 original/txt/usr_90.txt:214
#: original/txt/usr_90.txt:288 original/txt/usr_90.txt:341
#: original/txt/usr_90.txt:417 original/txt/usr_90.txt:494
#, no-wrap
msgid "==============================================================================\n"
msgstr "==============================================================================\n"

#. type: Plain text
#: original/txt/usr_toc.txt:4 original/txt/usr_01.txt:4
#: original/txt/usr_02.txt:4 original/txt/usr_03.txt:4
#: original/txt/usr_04.txt:4 original/txt/usr_05.txt:4
#: original/txt/usr_06.txt:4 original/txt/usr_07.txt:4
#: original/txt/usr_08.txt:4 original/txt/usr_09.txt:4
#: original/txt/usr_10.txt:4 original/txt/usr_11.txt:4
#: original/txt/usr_12.txt:4 original/txt/usr_20.txt:4
#: original/txt/usr_21.txt:4 original/txt/usr_22.txt:4
#: original/txt/usr_23.txt:4 original/txt/usr_24.txt:4
#: original/txt/usr_25.txt:4 original/txt/usr_26.txt:4
#: original/txt/usr_27.txt:4 original/txt/usr_28.txt:4
#: original/txt/usr_29.txt:4 original/txt/usr_30.txt:4
#: original/txt/usr_31.txt:4 original/txt/usr_32.txt:4
#: original/txt/usr_40.txt:4 original/txt/usr_41.txt:4
#: original/txt/usr_42.txt:4 original/txt/usr_43.txt:4
#: original/txt/usr_44.txt:4 original/txt/usr_45.txt:4
#: original/txt/usr_90.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar\n"

#. type: Plain text
#: original/txt/usr_toc.txt:354 original/txt/usr_01.txt:185
#: original/txt/usr_02.txt:564 original/txt/usr_03.txt:654
#: original/txt/usr_04.txt:514 original/txt/usr_05.txt:625
#: original/txt/usr_06.txt:280 original/txt/usr_07.txt:479
#: original/txt/usr_08.txt:601 original/txt/usr_09.txt:289
#: original/txt/usr_10.txt:824 original/txt/usr_11.txt:307
#: original/txt/usr_12.txt:358 original/txt/usr_20.txt:384
#: original/txt/usr_21.txt:499 original/txt/usr_22.txt:400
#: original/txt/usr_23.txt:343 original/txt/usr_24.txt:606
#: original/txt/usr_25.txt:578 original/txt/usr_26.txt:221
#: original/txt/usr_27.txt:563 original/txt/usr_28.txt:426
#: original/txt/usr_29.txt:613 original/txt/usr_30.txt:643
#: original/txt/usr_31.txt:272 original/txt/usr_32.txt:180
#: original/txt/usr_40.txt:657 original/txt/usr_41.txt:2429
#: original/txt/usr_42.txt:365 original/txt/usr_43.txt:173
#: original/txt/usr_44.txt:719 original/txt/usr_45.txt:419
#: original/txt/usr_90.txt:498
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: consulte |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"

#. type: Plain text
#: original/txt/usr_06.txt:196 original/txt/usr_44.txt:42
#, no-wrap
msgid "\t:syntax clear\n"
msgstr "\t:syntax clear\n"

#. type: Plain text
#: original/txt/usr_44.txt:2
#, fuzzy, no-wrap
#| msgid "*usr_29.txt*\tFor Vim version 7.3.  Last change: 2008 Jun 28\n"
msgid "*usr_44.txt*\tFor Vim version 7.3.  Last change: 2008 Dec 28\n"
msgstr "*usr_29.esx*\tPara Vim versión 7.3.  Último cambio: 8/6/2008\n"

#. type: Plain text
#: original/txt/usr_44.txt:6
#, fuzzy, no-wrap
#| msgid "\t\t\t  Using syntax highlighting\n"
msgid "\t\t\t Your own syntax highlighted\n"
msgstr "\t\t\t Uso del resaltado de sintaxis\n"

#. type: Plain text
#: original/txt/usr_44.txt:12
msgid ""
"Vim comes with highlighting for a couple of hundred different file types.  "
"If the file you are editing isn't included, read this chapter to find out "
"how to get this type of file highlighted.  Also see |:syn-define| in the "
"reference manual."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:25
#, fuzzy, no-wrap
msgid ""
"|44.1|\tBasic syntax commands\n"
"|44.2|\tKeywords\n"
"|44.3|\tMatches\n"
"|44.4|\tRegions\n"
"|44.5|\tNested items\n"
"|44.6|\tFollowing groups\n"
"|44.7|\tOther arguments\n"
"|44.8|\tClusters\n"
"|44.9|\tIncluding another syntax file\n"
"|44.10|\tSynchronizing\n"
"|44.11|\tInstalling a syntax file\n"
"|44.12|\tPortable syntax file layout\n"
msgstr ""
"|usr_44.txt|  Your own syntax highlighted\n"
"\t\t|44.1|\tBasic syntax commands\n"
"\t\t|44.2|\tKeywords\n"
"\t\t|44.3|\tMatches\n"
"\t\t|44.4|\tRegions\n"
"\t\t|44.5|\tNested items\n"
"\t\t|44.6|\tFollowing groups\n"
"\t\t|44.7|\tOther arguments\n"
"\t\t|44.8|\tClusters\n"
"\t\t|44.9|\tIncluding another syntax file\n"
"\t\t|44.10|\tSynchronizing\n"
"\t\t|44.11|\tInstalling a syntax file\n"
"\t\t|44.12|\tPortable syntax file layout\n"

#. type: Plain text
#: original/txt/usr_44.txt:29
#, fuzzy, no-wrap
#| msgid ""
#| "     Next chapter: |usr_05.txt|  Set your settings\n"
#| " Previous chapter: |usr_03.txt|  Moving around\n"
#| "Table of contents: |usr_toc.txt|\n"
msgid ""
"     Next chapter: |usr_45.txt|  Select your language\n"
" Previous chapter: |usr_43.txt|  Using filetypes\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""
" Capítulo siguiente: |usr_05.esx|  Configuración\n"
"  Capítulo anterior: |usr_03.esx|  Desplazamiento\n"
"Tabla de contenidos: |usr_toc.esx|\n"

#. type: Plain text
#: original/txt/usr_44.txt:32
#, fuzzy, no-wrap
#| msgid "*42.2*\tMenu commands\n"
msgid "*44.1*\tBasic syntax commands\n"
msgstr "*42.2*\tÓrdenes de menú\n"

#. type: Plain text
#: original/txt/usr_44.txt:37
msgid ""
"Using an existing syntax file to start with will save you a lot of time.  "
"Try finding a syntax file in $VIMRUNTIME/syntax for a language that is "
"similar.  These files will also show you the normal layout of a syntax "
"file.  To understand it, you need to read the following."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:40
msgid ""
"Let's start with the basic arguments.  Before we start defining any new "
"syntax, we need to clear out any old definitions: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:45
msgid ""
"This isn't required in the final syntax file, but very useful when "
"experimenting."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:49
msgid ""
"There are more simplifications in this chapter.  If you are writing a syntax "
"file to be used by others, read all the way through the end to find out the "
"details."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:52
#, fuzzy
#| msgid "FINDING DEFINED IDENTIFIERS"
msgid "LISTING DEFINED ITEMS"
msgstr "ENCONTRAR UN IDENTIFICADOR DEFINIDO"

#. type: Plain text
#: original/txt/usr_44.txt:54
#, fuzzy
#| msgid "To see on which byte you are in the file use this command: >"
msgid "To check which syntax items are currently defined, use this command: >"
msgstr ""
"Use esta orden para ver en que byte se encuentra dentro de un archivo: >"

#. type: Plain text
#: original/txt/usr_44.txt:56
#, fuzzy, no-wrap
#| msgid "\t:syntax off\n"
msgid "\t:syntax\n"
msgstr "\t:syntax off\n"

#. type: Plain text
#: original/txt/usr_44.txt:61
#, no-wrap
msgid ""
"You can use this to check which items have actually been defined.  Quite\n"
"useful when you are experimenting with a new syntax file.  It also shows the\n"
"colors used for each item, which helps to find out what is what.\n"
"   To list the items in a specific syntax group use: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:63
#, fuzzy, no-wrap
#| msgid "\t:syntax enable\n"
msgid "\t:syntax list {group-name}\n"
msgstr "\t:syntax enable\n"

#. type: Plain text
#: original/txt/usr_44.txt:66
msgid ""
"This also can be used to list clusters (explained in |44.8|).  Just include "
"the @ in the name."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:69
#, fuzzy
#| msgid "SEARCHING BACKWARDS"
msgid "MATCHING CASE"
msgstr "BUSCAR EN SENTIDO INVERSO"

#. type: Plain text
#: original/txt/usr_44.txt:75
#, no-wrap
msgid ""
"Some languages are not case sensitive, such as Pascal.  Others, such as C, are\n"
"case sensitive.  You need to tell which type you have with the following\n"
"commands: >\n"
"\t:syntax case match\n"
"\t:syntax case ignore\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:84
#, no-wrap
msgid ""
"The \"match\" argument means that Vim will match the case of syntax elements.\n"
"Therefore, \"int\" differs from \"Int\" and \"INT\".  If the \"ignore\" argument is\n"
"used, the following are equivalent: \"Procedure\", \"PROCEDURE\" and \"procedure\".\n"
"   The \":syntax case\" commands can appear anywhere in a syntax file and affect\n"
"the syntax definitions that follow.  In most cases, you have only one \":syntax\n"
"case\" command in your syntax file; if you work with an unusual language that\n"
"contains both case-sensitive and non-case-sensitive elements, however, you can\n"
"scatter the \":syntax case\" command throughout the file.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:87
#, no-wrap
msgid "*44.2*\tKeywords\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:90
msgid ""
"The most basic syntax elements are keywords.  To define a keyword, use the "
"following form: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:92
#, no-wrap
msgid "\t:syntax keyword {group} {keyword} ...\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:96
msgid ""
"The {group} is the name of a syntax group.  With the \":highlight\" command "
"you can assign colors to a {group}.  The {keyword} argument is an actual "
"keyword.  Here are a few examples: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:99
#, no-wrap
msgid ""
"\t:syntax keyword xType int long char\n"
"\t:syntax keyword xStatement if then else endif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:109
#, no-wrap
msgid ""
"This example uses the group names \"xType\" and \"xStatement\".  By convention,\n"
"each group name is prefixed by the filetype for the language being defined.\n"
"This example defines syntax for the x language (eXample language without an\n"
"interesting name).  In a syntax file for \"csh\" scripts the name \"cshType\"\n"
"would be used.  Thus the prefix is equal to the value of 'filetype'.\n"
"   These commands cause the words \"int\", \"long\" and \"char\" to be highlighted\n"
"one way and the words \"if\", \"then\", \"else\" and \"endif\" to be highlighted\n"
"another way.  Now you need to connect the x group names to standard Vim\n"
"names.  You do this with the following commands: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:112
#, no-wrap
msgid ""
"\t:highlight link xType Type\n"
"\t:highlight link xStatement Statement\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:115
msgid ""
"This tells Vim to highlight \"xType\" like \"Type\" and \"xStatement\" like "
"\"Statement\".  See |group-name| for the standard names."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:118
#, fuzzy
#| msgid "KEYWORDS"
msgid "UNUSUAL KEYWORDS"
msgstr "PALABRAS CLAVES"

#. type: Plain text
#: original/txt/usr_44.txt:126
#, no-wrap
msgid ""
"The characters used in a keyword must be in the 'iskeyword' option.  If you\n"
"use another character, the word will never match.  Vim doesn't give a warning\n"
"message for this.\n"
"   The x language uses the '-' character in keywords.  This is how it's done:\n"
">\n"
"\t:setlocal iskeyword+=-\n"
"\t:syntax keyword xStatement when-not\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:131
msgid ""
"The \":setlocal\" command is used to change 'iskeyword' only for the current "
"buffer.  Still it does change the behavior of commands like \"w\" and \"*"
"\".  If that is not wanted, don't define a keyword but use a match "
"(explained in the next section)."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:136
#, no-wrap
msgid ""
"The x language allows for abbreviations.  For example, \"next\" can be\n"
"abbreviated to \"n\", \"ne\" or \"nex\".  You can define them by using this command:\n"
">\n"
"\t:syntax keyword xStatement n[ext]\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:138
msgid "This doesn't match \"nextone\", keywords always match whole words only."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:141
#, fuzzy, no-wrap
#| msgid "*24.2*\tShowing matches\n"
msgid "*44.3*\tMatches\n"
msgstr "*24.2*\tMostrar coincidencias\n"

#. type: Plain text
#: original/txt/usr_44.txt:145
msgid ""
"Consider defining something a bit more complex.  You want to match ordinary "
"identifiers.  To do this, you define a match syntax item.  This one matches "
"any word consisting of only lowercase letters: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:153
#, no-wrap
msgid ""
"\t:syntax match xIdentifier /\\<\\l\\+\\>/\n"
"<\n"
"\tNote:\n"
"\tKeywords overrule any other syntax item.  Thus the keywords \"if\",\n"
"\t\"then\", etc., will be keywords, as defined with the \":syntax keyword\"\n"
"\tcommands above, even though they also match the pattern for\n"
"\txIdentifier.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:157
msgid ""
"The part at the end is a pattern, like it's used for searching.  The // is "
"used to surround the pattern (like how it's done in a \":substitute\" "
"command).  You can use any other character, like a plus or a quote."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:160
msgid ""
"Now define a match for a comment.  In the x language it is anything from # "
"to the end of a line: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:162
#, fuzzy, no-wrap
#| msgid "\t:set comments=://\n"
msgid "\t:syntax match xComment /#.*/\n"
msgstr "\t:set comments=://\n"

#. type: Plain text
#: original/txt/usr_44.txt:165
msgid ""
"Since you can use any search pattern, you can highlight very complex things "
"with a match item.  See |pattern| for help on search patterns."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:168
#, fuzzy, no-wrap
#| msgid "*21.4*\tSessions\n"
msgid "*44.4*\tRegions\n"
msgstr "*21.4*\tSesiones\n"

#. type: Plain text
#: original/txt/usr_44.txt:172
msgid ""
"In the example x language, strings are enclosed in double quotation marks "
"(\").  To highlight strings you define a region.  You need a region start "
"(double quote) and a region end (double quote).  The definition is as "
"follows: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:174
#, no-wrap
msgid "\t:syntax region xString start=/\"/ end=/\"/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:177
msgid ""
"The \"start\" and \"end\" directives define the patterns used to find the "
"start and end of the region.  But what about strings that look like this?"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:179
#, no-wrap
msgid "\t\"A string with a double quote (\\\") in it\" ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:183
msgid ""
"This creates a problem: The double quotation marks in the middle of the "
"string will end the region.  You need to tell Vim to skip over any escaped "
"double quotes in the string.  Do this with the skip keyword: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:185
#, no-wrap
msgid "\t:syntax region xString start=/\"/ skip=/\\\\\"/ end=/\"/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:188
msgid ""
"The double backslash matches a single backslash, since the backslash is a "
"special character in search patterns."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:195
msgid ""
"When to use a region instead of a match? The main difference is that a match "
"item is a single pattern, which must match as a whole.  A region starts as "
"soon as the \"start\" pattern matches.  Whether the \"end\" pattern is found "
"or not doesn't matter.  Thus when the item depends on the \"end\" pattern to "
"match, you cannot use a region.  Otherwise, regions are often simpler to "
"define.  And it is easier to use nested items, as is explained in the next "
"section."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:198
#, fuzzy, no-wrap
#| msgid "*23.5*\tCompressed files\n"
msgid "*44.5*\tNested items\n"
msgstr "*23.5*\tArchivos comprimidos\n"

#. type: Plain text
#: original/txt/usr_44.txt:200
msgid "Take a look at this comment:"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:202
#, no-wrap
msgid "\t%Get input  TODO: Skip white space ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:206
msgid ""
"You want to highlight TODO in big yellow letters, even though it is in a "
"comment that is highlighted blue.  To let Vim know about this, you define "
"the following syntax groups: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:209
#, no-wrap
msgid ""
"\t:syntax keyword xTodo TODO contained\n"
"\t:syntax match xComment /%.*/ contains=xTodo\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:216
msgid ""
"In the first line, the \"contained\" argument tells Vim that this keyword "
"can exist only inside another syntax item.  The next line has "
"\"contains=xTodo\".  This indicates that the xTodo syntax element is inside "
"it.  The result is that the comment line as a whole is matched with "
"\"xComment\" and made blue.  The word TODO inside it is matched by xTodo and "
"highlighted yellow (highlighting for xTodo was setup for this)."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:219
#, fuzzy
#| msgid "RECURSIVE MAPPING"
msgid "RECURSIVE NESTING"
msgstr "MACROS RECURSIVAS"

#. type: Plain text
#: original/txt/usr_44.txt:222
msgid ""
"The x language defines code blocks in curly braces.  And a code block may "
"contain other code blocks.  This can be defined this way: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:224
#, no-wrap
msgid "\t:syntax region xBlock start=/{/ end=/}/ contains=xBlock\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:226
#, fuzzy
#| msgid "Suppose you do three searches: >"
msgid "Suppose you have this text:"
msgstr "Suponga que realiza tres búsquedas: >"

#. type: Plain text
#: original/txt/usr_44.txt:232
#, no-wrap
msgid ""
"\twhile i < b { ~\n"
"\t\tif a { ~\n"
"\t\t\tb = c; ~\n"
"\t\t} ~\n"
"\t} ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:240
msgid ""
"First a xBlock starts at the { in the first line.  In the second line "
"another { is found.  Since we are inside a xBlock item, and it contains "
"itself, a nested xBlock item will start here.  Thus the \"b = c\" line is "
"inside the second level xBlock region.  Then a } is found in the next line, "
"which matches with the end pattern of the region.  This ends the nested "
"xBlock.  Because the } is included in the nested region, it is hidden from "
"the first xBlock region.  Then at the last } the first xBlock region ends."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:243
#, fuzzy
#| msgid "KEEPING THE ORIGINAL FILE"
msgid "KEEPING THE END"
msgstr "MANTENER EL ARCHIVO ORIGINAL"

#. type: Plain text
#: original/txt/usr_44.txt:245
msgid "Consider the following two syntax items: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:248
#, no-wrap
msgid ""
"\t:syntax region xComment start=/%/ end=/$/ contained\n"
"\t:syntax region xPreProc start=/#/ end=/$/ contains=xComment\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:254
msgid ""
"You define a comment as anything from % to the end of the line.  A "
"preprocessor directive is anything from # to the end of the line.  Because "
"you can have a comment on a preprocessor line, the preprocessor definition "
"includes a \"contains=xComment\" argument.  Now look what happens with this "
"text:"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:257
#, no-wrap
msgid ""
"\t#define X = Y  % Comment text ~\n"
"\tint foo = 1; ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:268
#, no-wrap
msgid ""
"What you see is that the second line is also highlighted as xPreProc.  The\n"
"preprocessor directive should end at the end of the line.  That is why\n"
"you have used \"end=/$/\".  So what is going wrong?\n"
"   The problem is the contained comment.  The comment starts with % and ends\n"
"at the end of the line.  After the comment ends, the preprocessor syntax\n"
"continues.  This is after the end of the line has been seen, so the next\n"
"line is included as well.\n"
"   To avoid this problem and to avoid a contained syntax item eating a needed\n"
"end of line, use the \"keepend\" argument.  This takes care of\n"
"the double end-of-line matching: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:271
#, no-wrap
msgid ""
"\t:syntax region xComment start=/%/ end=/$/ contained\n"
"\t:syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:274
msgid "CONTAINING MANY ITEMS"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:277
#, fuzzy
#| msgid "You can start Vim to edit a sequence of files.  For example: >"
msgid ""
"You can use the contains argument to specify that everything can be "
"contained.  For example: >"
msgstr ""
"Puede iniciar Vim para editar una secuencia de archivos. Por ejemplo: >"

#. type: Plain text
#: original/txt/usr_44.txt:279
#, no-wrap
msgid "\t:syntax region xList start=/\\[/ end=/\\]/ contains=ALL\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:286
#, no-wrap
msgid ""
"All syntax items will be contained in this one.  It also contains itself, but\n"
"not at the same position (that would cause an endless loop).\n"
"   You can specify that some groups are not contained.  Thus contain all\n"
"groups but the ones that are listed:\n"
">\n"
"\t:syntax region xList start=/\\[/ end=/\\]/ contains=ALLBUT,xString\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:290
msgid ""
"With the \"TOP\" item you can include all items that don't have a \"contained"
"\" argument.  \"CONTAINED\" is used to only include items with a \"contained"
"\" argument.  See |:syn-contains| for the details."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:293
#, fuzzy, no-wrap
#| msgid "*03.7*\tScrolling around\n"
msgid "*44.6*\tFollowing groups\n"
msgstr "*03.7*\tDesplazar el texto\n"

#. type: Plain text
#: original/txt/usr_44.txt:295
#, fuzzy
#| msgid "You have a list of names in this form:"
msgid "The x language has statements in this form:"
msgstr "Tiene una lista de nombre de la siguiente forma:"

#. type: Plain text
#: original/txt/usr_44.txt:297
#, no-wrap
msgid "\tif (condition) then ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:301
msgid ""
"You want to highlight the three items differently.  But \"(condition)\" and "
"\"then\" might also appear in other places, where they get different "
"highlighting.  This is how you can do this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:305
#, no-wrap
msgid ""
"\t:syntax match xIf /if/ nextgroup=xIfCondition skipwhite\n"
"\t:syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite\n"
"\t:syntax match xThen /then/ contained\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:309
msgid ""
"The \"nextgroup\" argument specifies which item can come next.  This is not "
"required.  If none of the items that are specified are found, nothing "
"happens.  For example, in this text:"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:311
#, no-wrap
msgid "\tif not (condition) then ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:314
msgid ""
"The \"if\" is matched by xIf.  \"not\" doesn't match the specified nextgroup "
"xIfCondition, thus only the \"if\" is highlighted."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:320
msgid ""
"The \"skipwhite\" argument tells Vim that white space (spaces and tabs) may "
"appear in between the items.  Similar arguments are \"skipnl\", which allows "
"a line break in between the items, and \"skipempty\", which allows empty "
"lines.  Notice that \"skipnl\" doesn't skip an empty line, something must "
"match after the line break."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:323
#, fuzzy, no-wrap
#| msgid "\t:make {arguments}\n"
msgid "*44.7*\tOther arguments\n"
msgstr "\t:make {arguments}\n"

#. type: Plain text
#: original/txt/usr_44.txt:325
#, fuzzy
#| msgid "GROUPS"
msgid "MATCHGROUP"
msgstr "GRUPOS"

#. type: Plain text
#: original/txt/usr_44.txt:329
msgid ""
"When you define a region, the entire region is highlighted according to the "
"group name specified.  To highlight the text enclosed in parentheses () with "
"the group xInside, for example, use the following command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:331
#, no-wrap
msgid "\t:syntax region xInside start=/(/ end=/)/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:336
msgid ""
"Suppose, that you want to highlight the parentheses differently.  You can do "
"this with a lot of convoluted region statements, or you can use the "
"\"matchgroup\" argument.  This tells Vim to highlight the start and end of a "
"region with a different highlight group (in this case, the xParen group): >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:338
#, no-wrap
msgid "\t:syntax region xInside matchgroup=xParen start=/(/ end=/)/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:342
msgid ""
"The \"matchgroup\" argument applies to the start or end match that comes "
"after it.  In the previous example both start and end are highlighted with "
"xParen.  To highlight the end with xParenEnd: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:345
#, no-wrap
msgid ""
"\t:syntax region xInside matchgroup=xParen start=/(/\n"
"\t\t\\ matchgroup=xParenEnd end=/)/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:348
msgid ""
"A side effect of using \"matchgroup\" is that contained items will not match "
"in the start or end of the region.  The example for \"transparent\" uses "
"this."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:351
msgid "TRANSPARENT"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:362
#, no-wrap
msgid ""
"In a C language file you would like to highlight the () text after a \"while\"\n"
"differently from the () text after a \"for\".  In both of these there can be\n"
"nested () items, which should be highlighted in the same way.  You must make\n"
"sure the () highlighting stops at the matching ).  This is one way to do this:\n"
">\n"
"\t:syntax region cWhile matchgroup=cWhile start=/while\\s*(/ end=/)/\n"
"\t\t\\ contains=cCondNest\n"
"\t:syntax region cFor matchgroup=cFor start=/for\\s*(/ end=/)/\n"
"\t\t\\ contains=cCondNest\n"
"\t:syntax region cCondNest start=/(/ end=/)/ contained transparent\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:373
#, no-wrap
msgid ""
"Now you can give cWhile and cFor different highlighting.  The cCondNest item\n"
"can appear in either of them, but take over the highlighting of the item it is\n"
"contained in.  The \"transparent\" argument causes this.\n"
"   Notice that the \"matchgroup\" argument has the same group as the item\n"
"itself.  Why define it then?  Well, the side effect of using a matchgroup is\n"
"that contained items are not found in the match with the start item then.\n"
"This avoids that the cCondNest group matches the ( just after the \"while\" or\n"
"\"for\".  If this would happen, it would span the whole text until the matching\n"
") and the region would continue after it.  Now cCondNest only matches after\n"
"the match with the start pattern, thus after the first (.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:376
msgid "OFFSETS"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:380
msgid ""
"Suppose you want to define a region for the text between ( and ) after an "
"\"if\".  But you don't want to include the \"if\" or the ( and ).  You can "
"do this by specifying offsets for the patterns.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:382
#, no-wrap
msgid "\t:syntax region xCond start=/if\\s*(/ms=e+1 end=/)/me=s-1\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:390
#, no-wrap
msgid ""
"The offset for the start pattern is \"ms=e+1\".  \"ms\" stands for Match Start.\n"
"This defines an offset for the start of the match.  Normally the match starts\n"
"where the pattern matches.  \"e+1\" means that the match now starts at the end\n"
"of the pattern match, and then one character further.\n"
"   The offset for the end pattern is \"me=s-1\".  \"me\" stands for Match End.\n"
"\"s-1\" means the start of the pattern match and then one character back.  The\n"
"result is that in this text:\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:392
#, no-wrap
msgid "\tif (foo == bar) ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:394
msgid "Only the text \"foo == bar\" will be highlighted as xCond."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:396
#, fuzzy
#| msgid "More about these modifiers here: |filename-modifiers|."
msgid "More about offsets here: |:syn-pattern-offset|."
msgstr ""
"Para más información acerca de los modificadores, consulte: |filename-"
"modifiers|."

#. type: Plain text
#: original/txt/usr_44.txt:399
#, fuzzy
#| msgid "JOINING LINES"
msgid "ONELINE"
msgstr "UNIR LÍNEAS"

#. type: Plain text
#: original/txt/usr_44.txt:402
msgid ""
"The \"oneline\" argument indicates that the region does not cross a line "
"boundary.  For example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:404
#, no-wrap
msgid "\t:syntax region xIfThen start=/if/ end=/then/ oneline\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:407
msgid ""
"This defines a region that starts at \"if\" and ends at \"then\".  But if "
"there is no \"then\" after the \"if\", the region doesn't match."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:413
#, no-wrap
msgid ""
"\tNote:\n"
"\tWhen using \"oneline\" the region doesn't start if the end pattern\n"
"\tdoesn't match in the same line.  Without \"oneline\" Vim does _not_\n"
"\tcheck if there is a match for the end pattern.  The region starts even\n"
"\twhen the end pattern doesn't match in the rest of the file.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:416
msgid "CONTINUATION LINES AND AVOIDING THEM"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:422
msgid ""
"Things now become a little more complex.  Let's define a preprocessor line.  "
"This starts with a # in the first column and continues until the end of the "
"line.  A line that ends with \\ makes the next line a continuation line.  "
"The way you handle this is to allow the syntax item to contain a "
"continuation pattern: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:425
#, no-wrap
msgid ""
"\t:syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue\n"
"\t:syntax match xLineContinue \"\\\\$\" contained\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:429
msgid ""
"In this case, although xPreProc normally matches a single line, the group "
"contained in it (namely xLineContinue) lets it go on for more than one "
"line.  For example, it would match both of these lines:"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:432
#, no-wrap
msgid ""
"\t#define SPAM  spam spam spam \\ ~\n"
"\t\t\tbacon and spam ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:438
msgid ""
"In this case, this is what you want.  If it is not what you want, you can "
"call for the region to be on a single line by adding \"excludenl\" to the "
"contained pattern.  For example, you want to highlight \"end\" in xPreProc, "
"but only at the end of the line.  To avoid making the xPreProc continue on "
"the next line, like xLineContinue does, use \"excludenl\" like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:443
#, no-wrap
msgid ""
"\t:syntax region xPreProc start=/^#/ end=/$/\n"
"\t\t\\ contains=xLineContinue,xPreProcEnd\n"
"\t:syntax match xPreProcEnd excludenl /end$/ contained\n"
"\t:syntax match xLineContinue \"\\\\$\" contained\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:447
msgid ""
"\"excludenl\" must be placed before the pattern.  Since \"xLineContinue\" "
"doesn't have \"excludenl\", a match with it will extend xPreProc to the next "
"line as before."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:450
#, no-wrap
msgid "*44.8*\tClusters\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:457
#, no-wrap
msgid ""
"One of the things you will notice as you start to write a syntax file is that\n"
"you wind up generating a lot of syntax groups.  Vim enables you to define a\n"
"collection of syntax groups called a cluster.\n"
"   Suppose you have a language that contains for loops, if statements, while\n"
"loops, and functions.  Each of them contains the same syntax elements: numbers\n"
"and identifiers.  You define them like this: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:461
#, no-wrap
msgid ""
"\t:syntax match xFor /^for.*/ contains=xNumber,xIdent\n"
"\t:syntax match xIf /^if.*/ contains=xNumber,xIdent\n"
"\t:syntax match xWhile /^while.*/ contains=xNumber,xIdent\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:468
#, no-wrap
msgid ""
"You have to repeat the same \"contains=\" every time.  If you want to add\n"
"another contained item, you have to add it three times.  Syntax clusters\n"
"simplify these definitions by enabling you to have one cluster stand for\n"
"several syntax groups.\n"
"   To define a cluster for the two items that the three groups contain, use\n"
"the following command: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:470
#, no-wrap
msgid "\t:syntax cluster xState contains=xNumber,xIdent\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:473
msgid ""
"Clusters are used inside other syntax items just like any syntax group.  "
"Their names start with @.  Thus, you can define the three groups like this: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:477
#, no-wrap
msgid ""
"\t:syntax match xFor /^for.*/ contains=@xState\n"
"\t:syntax match xIf /^if.*/ contains=@xState\n"
"\t:syntax match xWhile /^while.*/ contains=@xState\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:479
#, fuzzy
#| msgid "You can add items to a List with the add() function: >"
msgid ""
"You can add new group names to this cluster with the \"add\" argument: >"
msgstr "Puede añadir elementos a una lista mediante la función add(): >"

#. type: Plain text
#: original/txt/usr_44.txt:481
#, no-wrap
msgid "\t:syntax cluster xState add=xString\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:483
msgid "You can remove syntax groups from this list as well: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:485
#, no-wrap
msgid "\t:syntax cluster xState remove=xNumber\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:488
#, fuzzy, no-wrap
#| msgid "*07.1*\tEdit another file\n"
msgid "*44.9*\tIncluding another syntax file\n"
msgstr "*07.1*\tEditar otro archivo\n"

#. type: Plain text
#: original/txt/usr_44.txt:492
msgid ""
"The C++ language syntax is a superset of the C language.  Because you do not "
"want to write two syntax files, you can have the C++ syntax file read in the "
"one for C by using the following command: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:494
#, fuzzy, no-wrap
#| msgid "\t:runtime syntax/colortest.vim\n"
msgid "\t:runtime! syntax/c.vim\n"
msgstr "\t:runtime syntax/colortest.vim\n"

#. type: Plain text
#: original/txt/usr_44.txt:501
#, no-wrap
msgid ""
"The \":runtime!\" command searches 'runtimepath' for all \"syntax/c.vim\" files.\n"
"This makes the C parts of the C++ syntax be defined like for C files.  If you\n"
"have replaced the c.vim syntax file, or added items with an extra file, these\n"
"will be loaded as well.\n"
"   After loading the C syntax items the specific C++ items can be defined.\n"
"For example, add keywords that are not used in C: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:503
#, no-wrap
msgid "\t:syntax keyword cppStatement\tnew delete this friend using\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:505
msgid "This works just like in any other syntax file."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:513
#, no-wrap
msgid ""
"Now consider the Perl language.  A Perl script consists of two distinct parts:\n"
"a documentation section in POD format, and a program written in Perl itself.\n"
"The POD section starts with \"=head\" and ends with \"=cut\".\n"
"   You want to define the POD syntax in one file, and use it from the Perl\n"
"syntax file.  The \":syntax include\" command reads in a syntax file and stores\n"
"the elements it defined in a syntax cluster.  For Perl, the statements are as\n"
"follows: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:516
#, no-wrap
msgid ""
"\t:syntax include @Pod <sfile>:p:h/pod.vim\n"
"\t:syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:529
#, no-wrap
msgid ""
"When \"=head\" is found in a Perl file, the perlPOD region starts.  In this\n"
"region the @Pod cluster is contained.  All the items defined as top-level\n"
"items in the pod.vim syntax files will match here.  When \"=cut\" is found, the\n"
"region ends and we go back to the items defined in the Perl file.\n"
"   The \":syntax include\" command is clever enough to ignore a \":syntax clear\"\n"
"command in the included file.  And an argument such as \"contains=ALL\" will\n"
"only contain items defined in the included file, not in the file that includes\n"
"it.\n"
"   The \"<sfile>:p:h/\" part uses the name of the current file (<sfile>),\n"
"expands it to a full path (:p) and then takes the head (:h).  This results in\n"
"the directory name of the file.  This causes the pod.vim file in the same\n"
"directory to be included.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:532
#, no-wrap
msgid "*44.10*\tSynchronizing\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:540
#, no-wrap
msgid ""
"Compilers have it easy.  They start at the beginning of a file and parse it\n"
"straight through.  Vim does not have it so easy.  It must start in the middle,\n"
"where the editing is being done.  So how does it tell where it is?\n"
"   The secret is the \":syntax sync\" command.  This tells Vim how to figure out\n"
"where it is.  For example, the following command tells Vim to scan backward\n"
"for the beginning or end of a C-style comment and begin syntax coloring from\n"
"there: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:542
#, fuzzy, no-wrap
#| msgid "\t:syntax clear\n"
msgid "\t:syntax sync ccomment\n"
msgstr "\t:syntax clear\n"

#. type: Plain text
#: original/txt/usr_44.txt:548
#, no-wrap
msgid ""
"You can tune this processing with some arguments.  The \"minlines\" argument\n"
"tells Vim the minimum number of lines to look backward, and \"maxlines\" tells\n"
"the editor the maximum number of lines to scan.\n"
"   For example, the following command tells Vim to look at least 10 lines\n"
"before the top of the screen: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:550
#, no-wrap
msgid "\t:syntax sync ccomment minlines=10 maxlines=500\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:561
#, no-wrap
msgid ""
"If it cannot figure out where it is in that space, it starts looking farther\n"
"and farther back until it figures out what to do.  But it looks no farther\n"
"back than 500 lines.  (A large \"maxlines\" slows down processing.  A small one\n"
"might cause synchronization to fail.)\n"
"   To make synchronizing go a bit faster, tell Vim which syntax items can be\n"
"skipped.  Every match and region that only needs to be used when actually\n"
"displaying text can be given the \"display\" argument.\n"
"   By default, the comment to be found will be colored as part of the Comment\n"
"syntax group.  If you want to color things another way, you can specify a\n"
"different syntax group: >\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:563
#, no-wrap
msgid "\t:syntax sync ccomment xAltComment\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:568
msgid ""
"If your programming language does not have C-style comments in it, you can "
"try another method of synchronization.  The simplest way is to tell Vim to "
"space back a number of lines and try to figure out things from there.  The "
"following command tells Vim to go back 150 lines and start parsing from "
"there: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:570
#, fuzzy, no-wrap
#| msgid "\t:set modelines=10\n"
msgid "\t:syntax sync minlines=150\n"
msgstr "\t:set modelines=10\n"

#. type: Plain text
#: original/txt/usr_44.txt:577
#, no-wrap
msgid ""
"A large \"minlines\" value can make Vim slower, especially when scrolling\n"
"backwards in the file.\n"
"   Finally, you can specify a syntax group to look for by using this command:\n"
">\n"
"\t:syntax sync match {sync-group-name}\n"
"\t\t\\ grouphere {group-name} {pattern}\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:582
msgid ""
"This tells Vim that when it sees {pattern} the syntax group named {group-"
"name} begins just after the pattern given.  The {sync-group-name} is used to "
"give a name to this synchronization specification.  For example, the sh "
"scripting language begins an if statement with \"if\" and ends it with \"fi"
"\":"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:586
#, no-wrap
msgid ""
"\tif [ --f file.txt ] ; then ~\n"
"\t\techo \"File exists\" ~\n"
"\tfi ~\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:589
#, fuzzy
#| msgid "To center a range of lines, use the following command: >"
msgid ""
"To define a \"grouphere\" directive for this syntax, you use the following "
"command: >"
msgstr "Use la siguiente orden para centrar un rango de líneas: >"

#. type: Plain text
#: original/txt/usr_44.txt:591
#, no-wrap
msgid "\t:syntax sync match shIfSync grouphere shIf \"\\<if\\>\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:594
msgid ""
"The \"groupthere\" argument tells Vim that the pattern ends a group.  For "
"example, the end of the if/fi group is as follows: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:596
#, no-wrap
msgid "\t:syntax sync match shIfSync groupthere NONE \"\\<fi\\>\"\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:599
msgid ""
"In this example, the NONE tells Vim that you are not in any special syntax "
"region.  In particular, you are not inside an if block."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:604
msgid ""
"You also can define matches and regions that are with no \"grouphere\" or "
"\"groupthere\" arguments.  These groups are for syntax groups skipped during "
"synchronization.  For example, the following skips over anything inside {}, "
"even if it would normally match another synchronization method: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:606
#, no-wrap
msgid "\t:syntax sync match xSpecial /{.*}/\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:608
#, fuzzy
#| msgid "More about manual folding in the reference manual: |fold-manual|"
msgid "More about synchronizing in the reference manual: |:syn-sync|."
msgstr ""
"Para más información acerca del plegado manual, consulte la siguiente "
"sección en el manual de referencia: |fold-manual|."

#. type: Plain text
#: original/txt/usr_44.txt:611
#, fuzzy, no-wrap
#| msgid "*24.6*\tInserting a register\n"
msgid "*44.11*\tInstalling a syntax file\n"
msgstr "*24.6*\tInsertar un registro\n"

#. type: Plain text
#: original/txt/usr_44.txt:616
#, no-wrap
msgid ""
"When your new syntax file is ready to be used, drop it in a \"syntax\" directory\n"
"in 'runtimepath'.  For Unix that would be \"~/.vim/syntax\".\n"
"  The name of the syntax file must be equal to the file type, with \".vim\"\n"
"added.  Thus for the x language, the full path of the file would be:\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:618
#, fuzzy, no-wrap
#| msgid "\t~/.vim/indent/help.vim ~\n"
msgid "\t~/.vim/syntax/x.vim ~\n"
msgstr "\t~/.vim/indent/help.vim ~\n"

#. type: Plain text
#: original/txt/usr_44.txt:620
msgid "You must also make the file type be recognized.  See |43.2|."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:626
msgid ""
"If your file works well, you might want to make it available to other Vim "
"users.  First read the next section to make sure your file works well for "
"others.  Then e-mail it to the Vim maintainer: <maintainer@vim.org>.  Also "
"explain how the filetype can be detected.  With a bit of luck your file will "
"be included in the next Vim version!"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:629
msgid "ADDING TO AN EXISTING SYNTAX FILE"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:638
#, no-wrap
msgid ""
"We were assuming you were adding a completely new syntax file.  When an existing\n"
"syntax file works, but is missing some items, you can add items in a separate\n"
"file.  That avoids changing the distributed syntax file, which will be lost\n"
"when installing a new version of Vim.\n"
"   Write syntax commands in your file, possibly using group names from the\n"
"existing syntax.  For example, to add new variable types to the C syntax file:\n"
">\n"
"\t:syntax keyword cType off_t uint\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:642
msgid ""
"Write the file with the same name as the original syntax file.  In this case "
"\"c.vim\".  Place it in a directory near the end of 'runtimepath'.  This "
"makes it loaded after the original syntax file.  For Unix this would be:"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:644
#, fuzzy, no-wrap
#| msgid "\t~/.vim/indent/help.vim ~\n"
msgid "\t~/.vim/after/syntax/c.vim ~\n"
msgstr "\t~/.vim/indent/help.vim ~\n"

#. type: Plain text
#: original/txt/usr_44.txt:647
#, no-wrap
msgid "*44.12*\tPortable syntax file layout\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:650
msgid ""
"Wouldn't it be nice if all Vim users exchange syntax files? To make this "
"possible, the syntax file must follow a few guidelines."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:654
msgid ""
"Start with a header that explains what the syntax file is for, who maintains "
"it and when it was last updated.  Don't include too much information about "
"changes history, not many people will read it.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:660
#, no-wrap
msgid ""
"\t\" Vim syntax file\n"
"\t\" Language:\tC\n"
"\t\" Maintainer:\tBram Moolenaar <Bram@vim.org>\n"
"\t\" Last Change:\t2001 Jun 18\n"
"\t\" Remark:\tIncluded by the C++ syntax.\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:663
msgid ""
"Use the same layout as the other syntax files.  Using an existing syntax "
"file as an example will save you a lot of time."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:668
msgid ""
"Choose a good, descriptive name for your syntax file.  Use lowercase letters "
"and digits.  Don't make it too long, it is used in many places: The name of "
"the syntax file \"name.vim\", 'filetype', b:current_syntax and the start of "
"each syntax group (nameType, nameStatement, nameString, etc)."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:671
msgid ""
"Start with a check for \"b:current_syntax\".  If it is defined, some other "
"syntax file, earlier in 'runtimepath' was already loaded: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:675
#, fuzzy, no-wrap
#| msgid ""
#| "\t:if exists(\"current_compiler\")\n"
#| "\t:  finish\n"
#| "\t:endif\n"
#| "\t:let current_compiler = \"mine\"\n"
msgid ""
"\tif exists(\"b:current_syntax\")\n"
"\t  finish\n"
"\tendif\n"
msgstr ""
"\t:if exists(\"current_compiler\")\n"
"\t:  finish\n"
"\t:endif\n"
"\t:let current_compiler = \"mine\"\n"

#. type: Plain text
#: original/txt/usr_44.txt:677
msgid "To be compatible with Vim 5.8 use: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:683
#, no-wrap
msgid ""
"\tif version < 600\n"
"\t  syntax clear\n"
"\telseif exists(\"b:current_syntax\")\n"
"\t  finish\n"
"\tendif\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:687
msgid ""
"Set \"b:current_syntax\" to the name of the syntax at the end.  Don't forget "
"that included files do this too, you might have to reset \"b:current_syntax"
"\" if you include two files."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:690
msgid ""
"If you want your syntax file to work with Vim 5.x, add a check for v:"
"version.  See yacc.vim for an example."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:693
msgid ""
"Do not include anything that is a user preference.  Don't set 'tabstop', "
"'expandtab', etc.  These belong in a filetype plugin."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:696
msgid ""
"Do not include mappings or abbreviations.  Only include setting 'iskeyword' "
"if it is really necessary for recognizing keywords."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:703
msgid ""
"To allow users select their own preferred colors, make a different group "
"name for every kind of highlighted item.  Then link each of them to one of "
"the standard highlight groups.  That will make it work with every color "
"scheme.  If you select specific colors it will look bad with some color "
"schemes.  And don't forget that some people use a different background "
"color, or have only eight colors available."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:706
msgid ""
"For the linking use \"hi def link\", so that the user can select different "
"highlighting before your syntax file is loaded.  Example: >"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:711
#, no-wrap
msgid ""
"\t  hi def link nameString\tString\n"
"\t  hi def link nameNumber\tNumber\n"
"\t  hi def link nameCommand\tStatement\n"
"\t  ... etc ...\n"
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:714
msgid ""
"Add the \"display\" argument to items that are not used when syncing, to "
"speed up scrolling backwards and CTRL-L."
msgstr ""

#. type: Plain text
#: original/txt/usr_44.txt:718
#, fuzzy
#| msgid "Next chapter: |usr_05.txt| Set your settings"
msgid "Next chapter: |usr_45.txt| Select your language"
msgstr "Capítulo siguiente: |usr_05.esx| Configuración"
