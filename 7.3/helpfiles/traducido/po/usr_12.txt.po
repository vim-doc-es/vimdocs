# vim-doc-es https://www.assembla.com/wiki/show/vim-doc-es
#
# Copyright (C) AÑOS 
# This file is distributed under the same license as the Vim 7.2 package.
#
# Translators credits:
#   - Initial translation
#       Álvaro Castro Castillo <alvaro.castro.castilla@gmail.com>
#
#   - Updates
#       TRADUCTOR <CORREO>, AÑO 
#
#
#
# Debido al formato (txt) y al máximo de 80 columnas que pueden tener 
# los textos de ayuda en Vim, así como el formato PO, por favor, leete los
# apuntes concernientes a la edición de los archivos PO relativos a la
# aplicación que desees usar.
# También encontrarás información acerca del uso de herramientas gettext en el 
# proyecto de localización (l10n) de Vim.
#
# - http://www.assembla.com/wiki/show/vim-doc-es
#
# No somos parte del proyecto de traducción en Debian. Sin embargo, creemos que
# este enlace puede ser de interés. A pesar de no formar parte, nuestra 
# intención es homologarnos con su terminología y uso de la lengua 
# en la medida de lo útil y posible.
#
#  - El proyecto de traducción de Debian al español
#     http://www.debian.org/intl/spanish/notas
#
# La R.A.E. no es un inmenso referente en cuanto a términos tecnológicos,
# pero también puede servir de referencia para otros términos no técnicos.
# No pretendemos hacer es_ES, es_CO, es_AR, etc..., sino que la misma
# traducción sea comprensible independientemente de la nacionalidad del
# usuario. Si crees que alguna traducción puede llevar a confusión, consulta
# la R.A.E., o el diccionario de Maria Moliner, y escribe un correo.
#
#  - www.rae.es 
#  - http://www.diclib.com/cgi-bin/d1.cgi?base=moliner&page=showpages   
#
# Disponemos también de un archivo «terminology.po» en «/recursos_de..» que
# se puede consultar con un simple grep, pogrep o cargado en Virtaal.
#
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.2\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2010-09-23 20:27+0300\n"
"PO-Revision-Date: 2011-02-03 17:45+0100\n"
"Last-Translator: Álvaro Castro Castillo <alvaro.castro.castilla@gmail.com>\n"
"Language-Team: vim-doc-es <vim-doc-es@freelists.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: original/TXT/intro.txt:18 original/TXT/intro.txt:79
#: original/TXT/intro.txt:180 original/TXT/intro.txt:290
#: original/TXT/intro.txt:518 original/TXT/intro.txt:596
#: original/TXT/intro.txt:689 original/TXT/intro.txt:817
#: original/TXT/intro.txt:880 original/TXT/usr_toc.txt:7
#: original/TXT/usr_toc.txt:58 original/TXT/usr_toc.txt:172
#: original/TXT/usr_toc.txt:281 original/TXT/usr_toc.txt:340
#: original/TXT/usr_toc.txt:352 original/TXT/usr_01.txt:19
#: original/TXT/usr_01.txt:50 original/TXT/usr_01.txt:100
#: original/TXT/usr_01.txt:181 original/TXT/usr_02.txt:25
#: original/TXT/usr_02.txt:69 original/TXT/usr_02.txt:130
#: original/TXT/usr_02.txt:179 original/TXT/usr_02.txt:239
#: original/TXT/usr_02.txt:307 original/TXT/usr_02.txt:369
#: original/TXT/usr_02.txt:406 original/TXT/usr_02.txt:560
#: original/TXT/usr_03.txt:28 original/TXT/usr_03.txt:74
#: original/TXT/usr_03.txt:101 original/TXT/usr_03.txt:147
#: original/TXT/usr_03.txt:172 original/TXT/usr_03.txt:223
#: original/TXT/usr_03.txt:265 original/TXT/usr_03.txt:320
#: original/TXT/usr_03.txt:491 original/TXT/usr_03.txt:552
#: original/TXT/usr_03.txt:650 original/TXT/usr_04.txt:27
#: original/TXT/usr_04.txt:74 original/TXT/usr_04.txt:160
#: original/TXT/usr_04.txt:194 original/TXT/usr_04.txt:269
#: original/TXT/usr_04.txt:324 original/TXT/usr_04.txt:360
#: original/TXT/usr_04.txt:390 original/TXT/usr_04.txt:446
#: original/TXT/usr_04.txt:469 original/TXT/usr_04.txt:510
#: original/TXT/usr_05.txt:24 original/TXT/usr_05.txt:63
#: original/TXT/usr_05.txt:219 original/TXT/usr_05.txt:266
#: original/TXT/usr_05.txt:418 original/TXT/usr_05.txt:467
#: original/TXT/usr_05.txt:506 original/TXT/usr_05.txt:621
#: original/TXT/usr_06.txt:24 original/TXT/usr_06.txt:50
#: original/TXT/usr_06.txt:135 original/TXT/usr_06.txt:189
#: original/TXT/usr_06.txt:270 original/TXT/usr_06.txt:276
#: original/TXT/usr_07.txt:24 original/TXT/usr_07.txt:63
#: original/TXT/usr_07.txt:179 original/TXT/usr_07.txt:266
#: original/TXT/usr_07.txt:316 original/TXT/usr_07.txt:404
#: original/TXT/usr_07.txt:444 original/TXT/usr_07.txt:475
#: original/TXT/usr_08.txt:26 original/TXT/usr_08.txt:82
#: original/TXT/usr_08.txt:109 original/TXT/usr_08.txt:161
#: original/TXT/usr_08.txt:215 original/TXT/usr_08.txt:278
#: original/TXT/usr_08.txt:337 original/TXT/usr_08.txt:477
#: original/TXT/usr_08.txt:509 original/TXT/usr_08.txt:597
#: original/TXT/usr_09.txt:21 original/TXT/usr_09.txt:124
#: original/TXT/usr_09.txt:175 original/TXT/usr_09.txt:259
#: original/TXT/usr_09.txt:285 original/TXT/usr_10.txt:27
#: original/TXT/usr_10.txt:144 original/TXT/usr_10.txt:221
#: original/TXT/usr_10.txt:342 original/TXT/usr_10.txt:378
#: original/TXT/usr_10.txt:547 original/TXT/usr_10.txt:621
#: original/TXT/usr_10.txt:667 original/TXT/usr_10.txt:692
#: original/TXT/usr_10.txt:820 original/TXT/usr_11.txt:22
#: original/TXT/usr_11.txt:82 original/TXT/usr_11.txt:144
#: original/TXT/usr_11.txt:288 original/TXT/usr_11.txt:303
#: original/TXT/usr_12.txt:25 original/TXT/usr_12.txt:90
#: original/TXT/usr_12.txt:131 original/TXT/usr_12.txt:177
#: original/TXT/usr_12.txt:202 original/TXT/usr_12.txt:231
#: original/TXT/usr_12.txt:281 original/TXT/usr_12.txt:309
#: original/TXT/usr_12.txt:354 original/TXT/usr_20.txt:22
#: original/TXT/usr_20.txt:113 original/TXT/usr_20.txt:158
#: original/TXT/usr_20.txt:285 original/TXT/usr_20.txt:327
#: original/TXT/usr_20.txt:380 original/TXT/usr_21.txt:24
#: original/TXT/usr_21.txt:47 original/TXT/usr_21.txt:87
#: original/TXT/usr_21.txt:236 original/TXT/usr_21.txt:385
#: original/TXT/usr_21.txt:438 original/TXT/usr_21.txt:495
#: original/TXT/usr_22.txt:22 original/TXT/usr_22.txt:148
#: original/TXT/usr_22.txt:213 original/TXT/usr_22.txt:272
#: original/TXT/usr_22.txt:396 original/TXT/usr_23.txt:23
#: original/TXT/usr_23.txt:114 original/TXT/usr_23.txt:156
#: original/TXT/usr_23.txt:238 original/TXT/usr_23.txt:324
#: original/TXT/usr_23.txt:339 original/TXT/usr_24.txt:28
#: original/TXT/usr_24.txt:96 original/TXT/usr_24.txt:119
#: original/TXT/usr_24.txt:268 original/TXT/usr_24.txt:305
#: original/TXT/usr_24.txt:336 original/TXT/usr_24.txt:369
#: original/TXT/usr_24.txt:493 original/TXT/usr_24.txt:537
#: original/TXT/usr_24.txt:583 original/TXT/usr_24.txt:602
#: original/TXT/usr_25.txt:22 original/TXT/usr_25.txt:132
#: original/TXT/usr_25.txt:210 original/TXT/usr_25.txt:287
#: original/TXT/usr_25.txt:453 original/TXT/usr_25.txt:574
#: original/TXT/usr_26.txt:21 original/TXT/usr_26.txt:46
#: original/TXT/usr_26.txt:103 original/TXT/usr_26.txt:136
#: original/TXT/usr_26.txt:217 original/TXT/usr_27.txt:26
#: original/TXT/usr_27.txt:88 original/TXT/usr_27.txt:136
#: original/TXT/usr_27.txt:239 original/TXT/usr_27.txt:320
#: original/TXT/usr_27.txt:350 original/TXT/usr_27.txt:427
#: original/TXT/usr_27.txt:469 original/TXT/usr_27.txt:510
#: original/TXT/usr_27.txt:559 original/TXT/usr_28.txt:27
#: original/TXT/usr_28.txt:54 original/TXT/usr_28.txt:121
#: original/TXT/usr_28.txt:185 original/TXT/usr_28.txt:211
#: original/TXT/usr_28.txt:269 original/TXT/usr_28.txt:315
#: original/TXT/usr_28.txt:331 original/TXT/usr_28.txt:375
#: original/TXT/usr_28.txt:389 original/TXT/usr_28.txt:422
#: original/TXT/usr_29.txt:23 original/TXT/usr_29.txt:273
#: original/TXT/usr_29.txt:320 original/TXT/usr_29.txt:441
#: original/TXT/usr_29.txt:570 original/TXT/usr_29.txt:609
#: original/TXT/usr_30.txt:23 original/TXT/usr_30.txt:202
#: original/TXT/usr_30.txt:280 original/TXT/usr_30.txt:336
#: original/TXT/usr_30.txt:409 original/TXT/usr_30.txt:515
#: original/TXT/usr_30.txt:639 original/TXT/usr_31.txt:22
#: original/TXT/usr_31.txt:81 original/TXT/usr_31.txt:133
#: original/TXT/usr_31.txt:160 original/TXT/usr_31.txt:208
#: original/TXT/usr_31.txt:268
#, no-wrap
msgid "==============================================================================\n"
msgstr "==============================================================================\n"

#. type: Plain text
#: original/TXT/usr_toc.txt:4 original/TXT/usr_01.txt:4
#: original/TXT/usr_02.txt:4 original/TXT/usr_03.txt:4
#: original/TXT/usr_04.txt:4 original/TXT/usr_05.txt:4
#: original/TXT/usr_06.txt:4 original/TXT/usr_07.txt:4
#: original/TXT/usr_08.txt:4 original/TXT/usr_09.txt:4
#: original/TXT/usr_10.txt:4 original/TXT/usr_11.txt:4
#: original/TXT/usr_12.txt:4 original/TXT/usr_20.txt:4
#: original/TXT/usr_21.txt:4 original/TXT/usr_22.txt:4
#: original/TXT/usr_23.txt:4 original/TXT/usr_24.txt:4
#: original/TXT/usr_25.txt:4 original/TXT/usr_26.txt:4
#: original/TXT/usr_27.txt:4 original/TXT/usr_28.txt:4
#: original/TXT/usr_29.txt:4 original/TXT/usr_30.txt:4
#: original/TXT/usr_31.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar\n"

#. type: Plain text
#: original/TXT/usr_toc.txt:354 original/TXT/usr_01.txt:185
#: original/TXT/usr_02.txt:564 original/TXT/usr_03.txt:654
#: original/TXT/usr_04.txt:514 original/TXT/usr_05.txt:625
#: original/TXT/usr_06.txt:280 original/TXT/usr_07.txt:479
#: original/TXT/usr_08.txt:601 original/TXT/usr_09.txt:289
#: original/TXT/usr_10.txt:824 original/TXT/usr_11.txt:307
#: original/TXT/usr_12.txt:358 original/TXT/usr_20.txt:384
#: original/TXT/usr_21.txt:499 original/TXT/usr_22.txt:400
#: original/TXT/usr_23.txt:343 original/TXT/usr_24.txt:606
#: original/TXT/usr_25.txt:578 original/TXT/usr_26.txt:221
#: original/TXT/usr_27.txt:563 original/TXT/usr_28.txt:426
#: original/TXT/usr_29.txt:613 original/TXT/usr_30.txt:643
#: original/TXT/usr_31.txt:272
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: consulte |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"

#. type: Plain text
#: original/TXT/usr_12.txt:2
#, no-wrap
msgid "*usr_12.txt*\tFor Vim version 7.3.  Last change: 2007 May 11\n"
msgstr "*usr_12.esx*\tPara Vim versión 7.3.  Último cambio: 11/6/2007\n"

#. type: Plain text
#: original/TXT/usr_12.txt:6
#, no-wrap
msgid "\t\t\t\tClever tricks\n"
msgstr "\t\t\t\tTrucos\n"

#. type: Plain text
#: original/TXT/usr_12.txt:11
msgid ""
"By combining several commands you can make Vim do nearly everything.  In "
"this chapter a number of useful combinations will be presented.  This uses "
"the commands introduced in the previous chapters and a few more."
msgstr ""
"Puedes conseguir que Vim haga casi cualquier cosa,.mediante la combinación "
"varias órdenes. En este capítulo, presentaremos una serie de combinaciones "
"útiles. Esto emplea las órdenes introducidos en capítulos anteriores y "
"algunos más."

#. type: Plain text
#: original/TXT/usr_12.txt:20
#, no-wrap
msgid ""
"|12.1|\tReplace a word\n"
"|12.2|\tChange \"Last, First\" to \"First Last\"\n"
"|12.3|\tSort a list\n"
"|12.4|\tReverse line order\n"
"|12.5|\tCount words\n"
"|12.6|\tFind a man page\n"
"|12.7|\tTrim blanks\n"
"|12.8|\tFind where a word is used\n"
msgstr ""
"|12.1|\tReemplazar una palabra\n"
"|12.2|\tCambiar «Último, Primero» a «Primero Último»\n"
"|12.3|\tOrdenar una lista\n"
"|12.4|\tInvertir el orden de las líneas\n"
"|12.5|\tContar palabras\n"
"|12.6|\tEncontrar una página de manual\n"
"|12.7|\tEliminar espacios en blanco sobrantes\n"
"|12.8|\tBuscar dónde se emplea una palabra\n"

#. type: Plain text
#: original/TXT/usr_12.txt:24
#, no-wrap
msgid ""
"     Next chapter: |usr_20.txt|  Typing command-line commands quickly\n"
" Previous chapter: |usr_11.txt|  Recovering from a crash\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""
" Capítulo siguiente: |usr_20.esx|  Ser eficaz con la línea de órdenes\n"
"  Capítulo anterior: |usr_11.esx|  Recuperarse de un fallo\n"
"Tabla de contenidos: |usr_toc.esx|\n"

#. type: Plain text
#: original/TXT/usr_12.txt:27
#, no-wrap
msgid "*12.1*\tReplace a word\n"
msgstr "*12.1*  Reemplazar una palabra\n"

#. type: Plain text
#: original/TXT/usr_12.txt:30
msgid ""
"The substitute command can be used to replace all occurrences of a word with "
"another word: >"
msgstr ""
"La orden sustituir se puede emplear para reemplazar todas las apariciones de "
"una palabra con otra: >"

#. type: Plain text
#: original/TXT/usr_12.txt:32
#, no-wrap
msgid "\t:%s/four/4/g\n"
msgstr "\t:%s/cuatro/4/g\n"

#. type: Plain text
#: original/TXT/usr_12.txt:38
#, no-wrap
msgid ""
"The \"%\" range means to replace in all lines.  The \"g\" flag at the end causes\n"
"all words in a line to be replaced.\n"
"   This will not do the right thing if your file also contains \"thirtyfour\".\n"
"It would be replaced with \"thirty4\".  To avoid this, use the \"\\<\" item to\n"
"match the start of a word: >\n"
msgstr ""
"El rango «%» significa reemplazar en todas las líneas. La marca «g» al final\n"
"hace que todas las palabras de una línea sean sustituidas.\n"
"   Esto no hará lo que desea si su archivo también contiene «veinticuatro».\n"
"Será reemplazado por «veinti4». Para evitar que esto ocurra, use el «\\<»\n"
"para concordar con el comienzo de una palabra. >\n"

#. type: Plain text
#: original/TXT/usr_12.txt:40
#, no-wrap
msgid "\t:%s/\\<four/4/g\n"
msgstr "\t:%s/\\<cuatro/4/g\n"

#. type: Plain text
#: original/TXT/usr_12.txt:43
msgid ""
"Obviously, this still goes wrong on \"fourteen\".  Use \"\\>\" to match the "
"end of a word: >"
msgstr ""
"Obviamente, esto también funcionará mal con «cuatrocientos». Use «\\>» para "
"concordar el final de una palabra: >"

#. type: Plain text
#: original/TXT/usr_12.txt:45
#, no-wrap
msgid "\t:%s/\\<four\\>/4/g\n"
msgstr "\t:%s/\\<cuatro\\>/4/g\n"

#. type: Plain text
#: original/TXT/usr_12.txt:49
msgid ""
"If you are programming, you might want to replace \"four\" in comments, but "
"not in the code.  Since this is difficult to specify, add the \"c\" flag to "
"have the substitute command prompt you for each replacement: >"
msgstr ""
"Si está programando, quizá desee reemplazar «cuatro» en los comentarios, "
"pero no en el código. Ya que es difícil de especificar, añada la marca «c» "
"para que se le pida una confirmación cada vez que se vaya a reemplazar la "
"palabra: >"

#. type: Plain text
#: original/TXT/usr_12.txt:52
#, no-wrap
msgid "\t:%s/\\<four\\>/4/gc\n"
msgstr "\t:%s/\\<cuatro\\>/4/gc\n"

#. type: Plain text
#: original/TXT/usr_12.txt:55
msgid "REPLACING IN SEVERAL FILES"
msgstr "REEMPLAZAR EN VARIOS ARCHIVOS"

#. type: Plain text
#: original/TXT/usr_12.txt:61
#, no-wrap
msgid ""
"Suppose you want to replace a word in more than one file.  You could edit each\n"
"file and type the command manually.  It's a lot faster to use record and\n"
"playback.\n"
"   Let's assume you have a directory with C++ files, all ending in \".cpp\".\n"
"There is a function called \"GetResp\" that you want to rename to \"GetAnswer\".\n"
msgstr ""
"Suponga que quiere reemplazar una palabra en más de un archivo. Puede\n"
"editar cada archivo y escribir la orden manualmente. Es mucho más fácil\n"
"usar la grabación y reproducción.\n"
"   Vamos a suponer que tiene un directorio con archivos C++ en el que todos\n"
"terminan en «.cpp». Quiere renombrar la función «GetResp» a «GetAnswer».\n"

#. type: Plain text
#: original/TXT/usr_12.txt:74
#, no-wrap
msgid ""
"\tvim *.cpp\t\tStart Vim, defining the argument list to\n"
"\t\t\t\tcontain all the C++ files.  You are now in the\n"
"\t\t\t\tfirst file.\n"
"\tqq\t\t\tStart recording into the q register\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tDo the replacements in the first file.\n"
"\t:wnext\t\t\tWrite this file and move to the next one.\n"
"\tq\t\t\tStop recording.\n"
"\t@q\t\t\tExecute the q register.  This will replay the\n"
"\t\t\t\tsubstitution and \":wnext\".  You can verify\n"
"\t\t\t\tthat this doesn't produce an error message.\n"
"\t999@q\t\t\tExecute the q register on the remaining files.\n"
msgstr ""
"\tvim *.cpp\t\tInicie Vim definiendo la lista de argumentos\n"
"\t\t\t\tconteniendo todos los archivos C++. Estará\n"
"\t\t\t\tahora en el primer archivo.\n"
"\tqq\t\t\tComience a grabar en el registro «q».\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tReemplace en el primer archivo.\n"
"\t:wnext\t\t\tGrabe este archivo y vaya al siguiente.\n"
"\tq\t\t\tDetiene la grabación.\n"
"\t@q\t\t\tEjecute el registro «q». Esto ejecutará la\n"
"\t\t\t\tsustitución y la orden «:wnext». Puede\n"
"\t\t\t\tcomprobar que esto no produzca ningún error.\n"
"\t999@q\t\t\tEjecute el registro «q» en el resto de archivos.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:77
msgid ""
"At the last file you will get an error message, because \":wnext\" cannot "
"move to the next file.  This stops the execution, and everything is done."
msgstr ""
"En el último archivo obtendrá un mensaje de error, porque «wnext» no puede "
"ir a un archivo siguiente. Esto parará la ejecución y todo terminará."

#. type: Plain text
#: original/TXT/usr_12.txt:81
#, no-wrap
msgid ""
"\tNote:\n"
"\tWhen playing back a recorded sequence, an error stops the execution.\n"
"\tTherefore, make sure you don't get an error message when recording.\n"
msgstr ""
"\tNota:\n"
"\tCuando vuelva a reproducir una secuencia grabada, un error detendrá la\n"
"\tejecución. Cuide de no producir errores cuando grabes.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:85
msgid ""
"There is one catch: If one of the .cpp files does not contain the word "
"\"GetResp\", you will get an error and replacing will stop.  To avoid this, "
"add the \"e\" flag to the substitute command: >"
msgstr ""
"Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra "
"«GetResp», obtendrá un error y la ejecución se detendrá. Para evitar esto, "
"añada la marca «e» a la orden de sustituir: >"

#. type: Plain text
#: original/TXT/usr_12.txt:87
#, no-wrap
msgid "\t:%s/\\<GetResp\\>/GetAnswer/ge\n"
msgstr "\t:%s/\\<GetResp\\>/GetAnswer/ge\n"

#. type: Plain text
#: original/TXT/usr_12.txt:89
msgid ""
"The \"e\" flag tells \":substitute\" that not finding a match is not an "
"error."
msgstr ""
"La marca «e» le dice a «:substitute» que ninguna coincidencia no es un error."

#. type: Plain text
#: original/TXT/usr_12.txt:92
#, no-wrap
msgid "*12.2*\tChange \"Last, First\" to \"First Last\"\n"
msgstr "*12.2*\tCambiar «Último, Primero» a «Primero Último»\n"

#. type: Plain text
#: original/TXT/usr_12.txt:94
msgid "You have a list of names in this form:"
msgstr "Tiene una lista de nombre de la siguiente forma:"

#. type: Plain text
#: original/TXT/usr_12.txt:97
#, no-wrap
msgid ""
"\tDoe, John ~\n"
"\tSmith, Peter ~\n"
msgstr ""
"\tPepe, Juan ~\n"
"\tAmancio, Pedro ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:99
msgid "You want to change that to:"
msgstr "Quiere cambiarlo a:"

#. type: Plain text
#: original/TXT/usr_12.txt:102
#, no-wrap
msgid ""
"\tJohn Doe ~\n"
"\tPeter Smith ~\n"
msgstr ""
"\tJuan Pepe ~\n"
"\tPedro Amancio ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:104
msgid "This can be done with just one command: >"
msgstr "Esto se puede hacer con una sola orden: >"

#. type: Plain text
#: original/TXT/usr_12.txt:106
#, no-wrap
msgid "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/\n"
msgstr "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/\n"

#. type: Plain text
#: original/TXT/usr_12.txt:114
#, no-wrap
msgid ""
"Let's break this down in parts.  Obviously it starts with a substitute\n"
"command.  The \"%\" is the line range, which stands for the whole file.  Thus\n"
"the substitution is done in every line in the file.\n"
"   The arguments for the substitute command are \"/from/to/\".  The slashes\n"
"separate the \"from\" pattern and the \"to\" string.  This is what the \"from\"\n"
"pattern contains:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~\n"
msgstr ""
"Veámoslo por partes. Obviamente comienza con la orden «substitute».\n"
"El «%» es el rango de líneas, que se refiere al archivo completo. Por lo\n"
"tanto la sustitución se producirá en cada línea del archivo.\n"
"   Los argumentos para la orden sustituir son «/desde/a/». Las barras\n"
"separan el patrón «desde» y la cadena \"hacia\". Esto es lo que el patrón\n"
"«desde» contiene:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:122
#, no-wrap
msgid ""
"\tThe first part between \\( \\) matches \"Last\"\t\\(     \\)\n"
"\t    match anything but a comma\t\t\t  [^,]\n"
"\t    any number of times\t\t\t\t      *\n"
"\tmatches \", \" literally\t\t\t\t\t ,\n"
"\tThe second part between \\( \\) matches \"First\"\t\t   \\(  \\)\n"
"\t    any character\t\t\t\t\t     .\n"
"\t    any number of times\t\t\t\t\t      *\n"
msgstr ""
"\tLa primera parte entre \\( \\) concuerda «Último» \\(     \\)\n"
"\t    concordar cualquier cosa excepto una coma     [^,]\n"
"\t    cualquier número de veces                         *\n"
"\tconcuerda literalmente \", \"                              ,\n"
"\tLa segunda parte entre \\(  \\) concuerda «Primero»\t   \\(  \\)\n"
"\t    cualquier carácter                                       .\n"
"\t    cualquier número de veces \t\t\t\t\t     *\n"

#. type: Plain text
#: original/TXT/usr_12.txt:130
#, no-wrap
msgid ""
"In the \"to\" part we have \"\\2\" and \"\\1\".  These are called backreferences.\n"
"They refer to the text matched by the \"\\( \\)\" parts in the pattern.  \"\\2\"\n"
"refers to the text matched by the second \"\\( \\)\", which is the \"First\" name.\n"
"\"\\1\" refers to the first \"\\( \\)\", which is the \"Last\" name.\n"
"   You can use up to nine backreferences in the \"to\" part of a substitute\n"
"command.  \"\\0\" stands for the whole matched pattern.  There are a few more\n"
"special items in a substitute command, see |sub-replace-special|.\n"
msgstr ""
"En la parte «a» tenemos «\\2» y «\\1». A esto se le llaman referencias\n"
"«inversas». Se refieren al texto encontrado por los «\\( \\)» del patrón. «\\2» "
"se\n"
"refiere al texto del segundo «\\( \\)», que es el nombre «Primero». «\\1» se\n"
"refiere al primer «\\( \\)», que es el nombre «Último».\n"
"   Puede usar hasta nueve referencias «inversas» en la parte «a» de una\n"
"orden de sustitución. «\\0x se refiere a la cadena coincidente completa. Hay\n"
"otros elementos especiales en una orden sustituir,\n"
"consulte |sub-replace-special|.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:133
#, no-wrap
msgid "*12.3*\tSort a list\n"
msgstr "*12.3*\tOrdenar una lista\n"

#. type: Plain text
#: original/TXT/usr_12.txt:135
msgid "In a Makefile you often have a list of files.  For example:"
msgstr ""
"A menudo, en un archivo Makefile tiene una lista de archivos. Por ejemplo:"

#. type: Plain text
#: original/TXT/usr_12.txt:145
#, no-wrap
msgid ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~\n"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:147
msgid "To sort this list, filter the text through the external sort command: >"
msgstr ""
"Para ordenar esta lista, filtre el texto a través de la orden externa "
"«sort»: >"

#. type: Plain text
#: original/TXT/usr_12.txt:151
#, no-wrap
msgid ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort\n"
msgstr ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort\n"

#. type: Plain text
#: original/TXT/usr_12.txt:157
#, no-wrap
msgid ""
"This goes to the first line, where \"OBJS\" is the first thing in the line.\n"
"Then it goes one line down and filters the lines until the next empty line.\n"
"You could also select the lines in Visual mode and then use \"!sort\".  That's\n"
"easier to type, but more work when there are many lines.\n"
"   The result is this:\n"
msgstr ""
"Esto va a la primera línea, donde «OBJS» es lo primero que se encuentra en una\n"
"línea. Luego baja una línea y filtra las líneas hasta encontrar una línea\n"
"vacía. También podría seleccionar las líneas en modo Visual y escribir\n"
"«!sort». Es más fácil pero conlleva más trabajo cuando hay muchas líneas.\n"
"   El resultado es el siguiente:\n"

#. type: Plain text
#: original/TXT/usr_12.txt:167
#, no-wrap
msgid ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~\n"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:176
#, no-wrap
msgid ""
"Notice that a backslash at the end of each line is used to indicate the line\n"
"continues.  After sorting, this is wrong!  The \"backup.o\" line that was at\n"
"the end didn't have a backslash.  Now that it sorts to another place, it\n"
"must have a backslash.\n"
"   The simplest solution is to add the backslash with \"A \\<Esc>\".  You can\n"
"keep the backslash in the last line, if you make sure an empty line comes\n"
"after it.  That way you don't have this problem again.\n"
msgstr ""
"Observe que una barra inversa al final de cada línea se usa para indicar\n"
"que la línea continúa. Tras ordenar, está mal puesto. La línea de «backup.o»\n"
"que estaba al final no tenía una barra inversa. Ahora que se sitúa en otro\n"
"lugar debe tener una barra inversa.\n"
"   La solución más sencilla es añadirla con «A \\<Esc>». Puede mantener la\n"
"barra en la última línea si se asegura de que una línea en blanco viene justo\n"
"después. De este modo no tendrá este problema de nuevo.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:179
#, no-wrap
msgid "*12.4*\tReverse line order\n"
msgstr "*12.4*\tInvertir el orden de las líneas\n"

#. type: Plain text
#: original/TXT/usr_12.txt:182
msgid ""
"The |:global| command can be combined with the |:move| command to move all "
"the lines before the first line, resulting in a reversed file.  The command "
"is: >"
msgstr ""
"La orden «|:global|» se debe combinar con la orden «|:move|» para mover "
"todas las líneas antes de la primera línea, invirtiendo el archivo.  La "
"orden es: >"

#. type: Plain text
#: original/TXT/usr_12.txt:184
#, no-wrap
msgid "\t:global/^/m 0\n"
msgstr "\t:global/^/m 0\n"

#. type: Plain text
#: original/TXT/usr_12.txt:186
msgid "Abbreviated: >"
msgstr "Abreviado: >"

#. type: Plain text
#: original/TXT/usr_12.txt:188
#, no-wrap
msgid "\t:g/^/m 0\n"
msgstr "\t:g/^/m 0\n"

#. type: Plain text
#: original/TXT/usr_12.txt:195
msgid ""
"The \"^\" regular expression matches the beginning of the line (even if the "
"line is blank).  The |:move| command moves the matching line to after the "
"mythical zeroth line, so the current matching line becomes the first line of "
"the file.  As the |:global| command is not confused by the changing line "
"numbering, |:global| proceeds to match all remaining lines of the file and "
"puts each as the first."
msgstr ""
"La expresión regular «^» coincide con el comienzo de línea (incluso si la "
"línea está en blanco). La orden «|:move|» mueve la línea justo después de la "
"mítica «línea cero», de forma que se convierte en la primera línea. Como la "
"orden «|:global|» no se confunde al cambiar la numeración de las líneas, «|:"
"global|» procede a concordar el resto de líneas del archivo y pone cada una "
"como la primera."

#. type: Plain text
#: original/TXT/usr_12.txt:199
msgid ""
"This also works on a range of lines.  First move to above the first line and "
"mark it with \"mt\".  Then move the cursor to the last line in the range and "
"type: >"
msgstr ""
"Esto también funciona sobre un rango de líneas. Vaya primero a la línea de "
"encima de la primera y márcala con \"mt\".  Luego pon el cursor en la última "
"línea del rango y escribe: >"

#. type: Plain text
#: original/TXT/usr_12.txt:201
#, no-wrap
msgid "\t:'t+1,.g/^/m 't\n"
msgstr "\t:'t+1,.g/^/m 't\n"

#. type: Plain text
#: original/TXT/usr_12.txt:204
#, no-wrap
msgid "*12.5*\tCount words\n"
msgstr "*12.5*\tContar palabras\n"

#. type: Plain text
#: original/TXT/usr_12.txt:209
#, no-wrap
msgid ""
"Sometimes you have to write a text with a maximum number of words.  Vim can\n"
"count the words for you.\n"
"   When the whole file is what you want to count the words in, use this\n"
"command: >\n"
msgstr ""
"A veces puede escribir un texto con un número máximo de palabras. Vim\n"
"puede contar las palabras por Ud.\n"
"   Cuando quiera usar el archivo completo para contar las palabras, use la\n"
"siguiente orden: >\n"

#. type: Plain text
#: original/TXT/usr_12.txt:211 original/TXT/usr_23.txt:279
#, no-wrap
msgid "\tg CTRL-G\n"
msgstr "\tg CTRL-G\n"

#. type: Plain text
#: original/TXT/usr_12.txt:215
#, no-wrap
msgid ""
"Do not type a space after the g, this is just used here to make the command\n"
"easy to read.\n"
"   The output looks like this:\n"
msgstr ""
"No teclee un espacio tras la «g», esto está aquí para hacer que la orden sea\n"
"fácil de leer.\n"
"   La salida tendrá este aspecto:\n"

#. type: Plain text
#: original/TXT/usr_12.txt:217
#, no-wrap
msgid "\tCol 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~\n"
msgstr "\tCol 1 of 0; Línea 141 of 157; Palabra 748 of 774; Carácter 4489 of 4976 ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:220
msgid ""
"You can see on which word you are (748), and the total number of words in "
"the file (774)."
msgstr ""
"Puede ver en qué palabra está (748), y el número total de palabras en el "
"archivo (774)."

#. type: Plain text
#: original/TXT/usr_12.txt:226
msgid ""
"When the text is only part of a file, you could move to the start of the "
"text, type \"g CTRL-G\", move to the end of the text, type \"g CTRL-G\" "
"again, and then use your brain to compute the difference in the word "
"position.  That's a good exercise, but there is an easier way.  With Visual "
"mode, select the text you want to count words in.  Then type g CTRL-G.  The "
"result:"
msgstr ""
"Cuando el texto sea sólo una parte del archivo, puede ir al comienzo del "
"texto, pulsar «g CTRL-G», ir al final del texto y volver a escribir «g CTRL-"
"G» y usar la cabeza para calcular la diferencia. Es un buen ejercicio, pero "
"hay un modo más sencillo. En el modo Visual, seleccione el texto sobre el "
"que quiera contar las palabras. Escriba «g CTRL-G». El resultado será:"

#. type: Plain text
#: original/TXT/usr_12.txt:228
#, no-wrap
msgid "\tSelected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~\n"
msgstr "\tSelección 5 of 293 Líneas; 70 of 1884 Palabras; 359 of 10928 Bytes ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:230
msgid ""
"For other ways to count words, lines and other items, see |count-items|."
msgstr ""
"Para otras formas de contar las palabras, líneas y otros, consulte |count-"
"items|."

#. type: Plain text
#: original/TXT/usr_12.txt:233
#, no-wrap
msgid "*12.6*\tFind a man page\t\t\t\t\t*find-manpage*\n"
msgstr "*12.6*\tEncontrar una página de manual\t\t*find-manpage*\n"

#. type: Plain text
#: original/TXT/usr_12.txt:237
msgid ""
"While editing a shell script or C program, you are using a command or "
"function that you want to find the man page for (this is on Unix).  Let's "
"first use a simple way: Move the cursor to the word you want to find help on "
"and press >"
msgstr ""
"Mientras edita un script de consola o un programa C, está usando una orden o "
"función para el que quiera encontrar una página de manual (en Unix). Vamos a "
"usar la forma sencilla. Ponga el cursor sobre la palabra y pulse: >"

#. type: Plain text
#: original/TXT/usr_12.txt:239
#, no-wrap
msgid "\tK\n"
msgstr "\tK\n"

#. type: Plain text
#: original/TXT/usr_12.txt:244
msgid ""
"Vim will run the external \"man\" program on the word.  If the man page is "
"found, it is displayed.  This uses the normal pager to scroll through the "
"text (mostly the \"more\" program).  When you get to the end pressing "
"<Enter> will get you back into Vim."
msgstr ""
"Vim ejecutará el programa externo «man» sobre la palabra. Si se encuentra la "
"página de manual, se mostrará. Esto usa el paginador normal para desplazarse "
"por el texto (con el programa «more»). Cuando llegue al final, presionando "
"<Intro> le devolverá a Vim."

#. type: Plain text
#: original/TXT/usr_12.txt:248
msgid ""
"A disadvantage is that you can't see the man page and the text you are "
"working on at the same time.  There is a trick to make the man page appear "
"in a Vim window.  First, load the man filetype plugin: >"
msgstr ""
"Una desventaja es que no puede ver la página de manual y el texto en el que "
"trabaja al mismo tiempo. Hay un truco para hacer que la página de manual "
"aparezca en una ventana de Vim. Primero cargue la extensión del tipo de "
"archivo man: >"

#. type: Plain text
#: original/TXT/usr_12.txt:250
#, no-wrap
msgid "\t:runtime! ftplugin/man.vim\n"
msgstr "\t:runtime! ftplugin/man.vim\n"

#. type: Plain text
#: original/TXT/usr_12.txt:253
msgid ""
"Put this command in your vimrc file if you intend to do this often.  Now you "
"can use the \":Man\" command to open a window on a man page: >"
msgstr ""
"Ponga esta orden en su archivo «vimrc» si tiene la intención de hacer esto a "
"menudo. Ahora puede usar «:Man» para ver una página man en una ventana: >"

#. type: Plain text
#: original/TXT/usr_12.txt:255
#, no-wrap
msgid "\t:Man csh\n"
msgstr "\t:Man csh\n"

#. type: Plain text
#: original/TXT/usr_12.txt:261
#, no-wrap
msgid ""
"You can scroll around and the text is highlighted.  This allows you to find\n"
"the help you were looking for.  Use CTRL-W w to jump to the window with the\n"
"text you were working on.\n"
"   To find a man page in a specific section, put the section number first.\n"
"For example, to look in section 3 for \"echo\": >\n"
msgstr ""
"Puede desplazarse alrededor y el texto se resaltará. Esto le permite\n"
"encontrar la ayuda que estaba buscando. Use «CTRL-W w» para saltar a la\n"
"ventana con el texto en el que trabajaba.\n"
"   Para encontrar la página de manua en una sección específica, ponga el\n"
"número de sección primero. Por ejemplo, para ver «echo» en la sección 3: >\n"

#. type: Plain text
#: original/TXT/usr_12.txt:263
#, no-wrap
msgid "\t:Man 3 echo\n"
msgstr "\t:Man 3 echo\n"

#. type: Plain text
#: original/TXT/usr_12.txt:267
msgid ""
"To jump to another man page, which is in the text with the typical form "
"\"word(1)\", press CTRL-] on it.  Further \":Man\" commands will use the "
"same window."
msgstr ""
"Para saltar a otra página de manual, la cuál está en el texto con la forma "
"típica «word(1)», pulse «CTRL-]» sobre ella. Otras llamadas a «:Man» "
"emplearán la misma ventana."

#. type: Plain text
#: original/TXT/usr_12.txt:269
msgid "To display a man page for the word under the cursor, use this: >"
msgstr ""
"Para mostrar una página de manual para la palabra bajo el cursor use lo "
"siguiente: >"

#. type: Plain text
#: original/TXT/usr_12.txt:271
#, no-wrap
msgid "\t\\K\n"
msgstr "\t\\K\n"

#. type: Plain text
#: original/TXT/usr_12.txt:275
msgid ""
"(If you redefined the <Leader>, use it instead of the backslash).  For "
"example, you want to know the return value of \"strstr()\" while editing "
"this line:"
msgstr ""
"(Si ha redefinido <Leader>, úselo en lugar de la barra inversa). Por "
"ejemplo, puede que quiera saber el valor que le devuelve «strstr()» mientras "
"edita esta línea:"

#. type: Plain text
#: original/TXT/usr_12.txt:277
#, no-wrap
msgid "\tif ( strstr (input, \"aap\") == ) ~\n"
msgstr "\tif ( strstr (input, \"aap\") == ) ~\n"

#. type: Plain text
#: original/TXT/usr_12.txt:280
msgid ""
"Move the cursor to somewhere on \"strstr\" and type \"\\K\".  A window will "
"open to display the man page for strstr()."
msgstr ""
"Ponga el cursor en alguna parte de «strstr» y escriba «\\K». Una ventana se "
"abrirá a continuación para mostrar la página de manual de «strstr()»."

#. type: Plain text
#: original/TXT/usr_12.txt:283
#, no-wrap
msgid "*12.7*\tTrim blanks\n"
msgstr "*12.7*\tEliminar espacios en blanco sobrantes\n"

#. type: Plain text
#: original/TXT/usr_12.txt:287
msgid ""
"Some people find spaces and tabs at the end of a line useless, wasteful, and "
"ugly.  To remove whitespace at the end of every line, execute the following "
"command: >"
msgstr ""
"Algunas personas encuentran los espacios y los tabuladores al final de línea "
"inútiles y feos. Para eliminar el espacio en blanco al final de cada línea, "
"ejecute la siguiente orden: >"

#. type: Plain text
#: original/TXT/usr_12.txt:289
#, no-wrap
msgid "\t:%s/\\s\\+$//\n"
msgstr "\t:%s/\\s\\+$//\n"

#. type: Plain text
#: original/TXT/usr_12.txt:296
#, no-wrap
msgid ""
"The line range \"%\" is used, thus this works on the whole file.  The pattern\n"
"that the \":substitute\" command matches with is \"\\s\\+$\".  This finds white\n"
"space characters (\\s), 1 or more of them (\\+), before the end-of-line ($).\n"
"Later will be explained how you write patterns like this |usr_27.txt|.\n"
"   The \"to\" part of the substitute command is empty: \"//\".  Thus it replaces\n"
"with nothing, effectively deleting the matched white space.\n"
msgstr ""
"El rango de línea «%» es empleado, funcionando sobre todo en el archivo\n"
"completo. El patrón que la orden «:substitute» concuerda es el «\\s\\+$».\n"
"Esto encuentra los caracteres en blanco (\\s), 1 o más (\\+), antes del final\n"
"de línea ($).\n"
"Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.\n"
"   La parte «hacia» de la orden de sustituxión está vacía: «//». Por lo tanto\n"
"reemplaza con nada, lo que de hecho elimina el espacio en blanco.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:300
msgid ""
"Another wasteful use of spaces is placing them before a tab.  Often these "
"can be deleted without changing the amount of white space.  But not always! "
"Therefore, you can best do this manually.  Use this search command: >"
msgstr ""
"Otro uso desafortunado de los espacios es colocarlos antes de un tabulador. "
"A menudo, se pueden eliminar sin cambiar la cantidad de espacio en blanco.  "
"¡Pero no siempre! Por lo tanto, lo mejor es que lo haga a mano. Use esta "
"orden de búsqueda: >"

#. type: Plain text
#: original/TXT/usr_12.txt:302
#, no-wrap
msgid "\t/ \t\n"
msgstr "\t/\t\n"

#. type: Plain text
#: original/TXT/usr_12.txt:308
#, no-wrap
msgid ""
"You cannot see it, but there is a space before a tab in this command.  Thus\n"
"it's \"/<Space><Tab>\".   Now use \"x\" to delete the space and check that the\n"
"amount of white space doesn't change.  You might have to insert a tab if it\n"
"does change.  Type \"n\" to find the next match.  Repeat this until no more\n"
"matches can be found.\n"
msgstr ""
"No puede verlo, pero hay un espacio antes de un tabulador en esta orden. De\n"
"hecho, es «/<Espacio><Tabulador>». Use ahora «x» para eliminar el espacio\n"
"y comprobar que la cantidad de espacio en blanco no cambia. Puede que\n"
"tenga que insertar un tabulador si cambia. Teclee «n» para encontrar la\n"
"próxima coincidencia. Repita esto hasta que no se encuentren más\n"
"concordancias.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:311
#, no-wrap
msgid "*12.8*\tFind where a word is used\n"
msgstr "*12.8*\tBuscar donde se emplea una palabra\n"

#. type: Plain text
#: original/TXT/usr_12.txt:318
#, no-wrap
msgid ""
"If you are a UNIX user, you can use a combination of Vim and the grep command\n"
"to edit all the files that contain a given word.  This is extremely useful if\n"
"you are working on a program and want to view or edit all the files that\n"
"contain a specific variable.\n"
"   For example, suppose you want to edit all the C program files that contain\n"
"the word \"frame_counter\".  To do this you use the command: >\n"
msgstr ""
"Si eres un usuario de sistemas UNIX, puede usar una combinación de Vim\n"
"y «grep» para editar todos los archivos que contengan la palabra dada.\n"
"Esto es extremadamente útil si está trabajando en un programa y quiere\n"
"ver o editar todos los archivos que contienen una variable específica.\n"
"   Por ejemplo, suponga que desea editar todos los archivos C que contengan\n"
"la palabra «frame_counter». Para hacer esto, use la orden: >\n"

#. type: Plain text
#: original/TXT/usr_12.txt:320
#, no-wrap
msgid "\tvim `grep -l frame_counter *.c`\n"
msgstr "\tvim `grep -l frame_counter *.c`\n"

#. type: Plain text
#: original/TXT/usr_12.txt:333
#, no-wrap
msgid ""
"Let's look at this command in detail.  The grep command searches through a set\n"
"of files for a given word.  Because the -l argument is specified, the command\n"
"will only list the files containing the word and not print the matching lines.\n"
"The word it is searching for is \"frame_counter\".  Actually, this can be any\n"
"regular expression.  (Note: What grep uses for regular expressions is not\n"
"exactly the same as what Vim uses.)\n"
"   The entire command is enclosed in backticks (`).  This tells the UNIX shell\n"
"to run this command and pretend that the results were typed on the command\n"
"line.  So what happens is that the grep command is run and produces a list of\n"
"files, these files are put on the Vim command line.  This results in Vim\n"
"editing the file list that is the output of grep.  You can then use commands\n"
"like \":next\" and \":first\" to browse through the files.\n"
msgstr ""
"Veamos esta orden en detalle. La orden «grep» busca a través de un\n"
"conjunto de archivos una palabra dada. Ya que especificamos el argumento\n"
"«-l», la orden sólo listará archivos que contengan la palabra y no impriman\n"
"las líneas coincidentes. La palabra que está buscando es «frame_counter».\n"
"De hecho, esto puede ser cualquier expresión regular. (Nota: las expresiones\n"
"regulares en Vim y «grep» no siguen las mismas convenciones.)\n"
"   La orden está arropada por acentos invertidos (`). Esto le dice a la consola\n"
"de UNIX que ejecute la orden y haga como si el resultado se hubiese\n"
"escrito en la línea de órdenes. Por lo tanto la orden «grep» se ejecutará\n"
"y producirá una lista de archivos, estos archivos serán puestos en la línea\n"
"de órdenes de Vim. Podrá usar las órdenes «:next» y «:first» para navegar\n"
"entre los archivos.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:336
msgid "FINDING EACH LINE"
msgstr "ENCONTRAR CADA LÍNEA"

#. type: Plain text
#: original/TXT/usr_12.txt:342
#, no-wrap
msgid ""
"The above command only finds the files in which the word is found.  You still\n"
"have to find the word within the files.\n"
"   Vim has a built-in command that you can use to search a set of files for a\n"
"given string.  If you want to find all occurrences of \"error_string\" in all C\n"
"program files, for example, enter the following command: >\n"
msgstr ""
"La orden anterior sólo dice los archivos en los cuáles se encuentra la\n"
"palabra. Todavía tendrás que encontrar la palabra entre los archivos.\n"
"   Vim tiene una orden integrada que puede usar para buscar una cadena\n"
"en un conjunto de archivos. Si desea encontrar todas las coincidencias de\n"
"«error_string» en todos los archivos C, por ejemplo, introduzca lo siguiente: >\n"

#. type: Plain text
#: original/TXT/usr_12.txt:344
#, no-wrap
msgid "\t:grep error_string *.c\n"
msgstr "\t:grep error_string *.c\n"

#. type: Plain text
#: original/TXT/usr_12.txt:353
#, no-wrap
msgid ""
"This causes Vim to search for the string \"error_string\" in all the specified\n"
"files (*.c).  The editor will now open the first file where a match is found\n"
"and position the cursor on the first matching line.  To go to the next\n"
"matching line (no matter in what file it is), use the \":cnext\" command.  To go\n"
"to the previous match, use the \":cprev\" command.  Use \":clist\" to see all the\n"
"matches and where they are.\n"
"   The \":grep\" command uses the external commands grep (on Unix) or findstr\n"
"(on Windows).  You can change this by setting the option 'grepprg'.\n"
msgstr ""
"Esto hace que Vim busque la cadena «error_string» en cada uno de los\n"
"archivos especificados (*.c). El editor abrirá el primer archivo donde se\n"
"produzca una concordancia y posicionará el cursor en la primera línea\n"
"coincidente.\n"
"Para ir a la siguiente línea (no importa en que archivo se encuentre), use la\n"
"orden «:cnext». Para ir a la anterior, use «:cprev». Use «:clist» para ver\n"
"todas las coincidencias y dónde están.\n"
"  La orden «:grep\"» usa la orden externa «grep» en Unix y «findstr» en\n"
"Windows.\n"
"Puedes cambiar esto modificando la opción 'grepprg'.\n"

#. type: Plain text
#: original/TXT/usr_12.txt:357
msgid "Next chapter: |usr_20.txt| Typing command-line commands quickly"
msgstr "Capítulo siguiente: |usr_20.esx| Ser eficaz con la línea de órdenes"
