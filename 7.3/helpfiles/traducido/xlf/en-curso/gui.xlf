<?xml version='1.0' encoding='utf-8'?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.1" version="1.1">
  <file original="po/en-curso/gui.po" source-language="en-US" datatype="plaintext">
    <body>
      <trans-unit xml:space="preserve" id="1" approved="no" restype="x-gettext-domain-header">
        <source>Project-Id-Version: Vim 7.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2009-08-06 14:46+0200
PO-Revision-Date: 2009-11-24 02:38+0100
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: Documentación de Vim en español
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.4.0-rc2
</source>
        <target state="translated">Project-Id-Version: Vim 7.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2009-08-06 14:46+0200
PO-Revision-Date: 2009-11-24 02:38+0100
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: Documentación de Vim en español
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.4.0-rc2
</target>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">Omar Campagne &lt;&lt;ocampagne@gmail.com&gt;&gt;, 2009.</context>
        </context-group>
        <note from="po-translator">Omar Campagne &lt;&lt;ocampagne@gmail.com&gt;&gt;, 2009.</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="2" approved="yes">
        <source>*gui.txt*       For Vim version 7.2.  Last change: 2008 Jun 14</source>
        <target state="translated">*gui.txt*	Para Vim version 7.2.  Último cambio: 2008 Jun 14</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">1</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="3" approved="yes">
        <source>		  VIM REFERENCE MANUAL    by Bram Moolenaar</source>
        <target state="translated">		 MANUAL DE USUARIO DE VIM   por Bram Moolenaar</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="4" approved="yes">
        <source>Vim's Graphical User Interface				*gui* *GUI*</source>
        <target state="translated">Interfaz gráfica de usuario de Vim			*gui* *GUI*</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">7</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="5" approved="yes">
        <source>1. Starting the GUI		|gui-start|
2. Scrollbars			|gui-scrollbars|
3. Mouse Control		|gui-mouse|
4. Making GUI Selections	|gui-selections|
5. Menus			|menus|
6. Extras			|gui-extras|
7. Shell Commands		|gui-shell|</source>
        <target state="translated">1. Iniciar la GUI		|gui-start|
2. Barras de desplazamiento	|gui-scrollbars|
3. Control del ratón		|gui-mouse|
4. Seleccionar en la GUI	|gui-selections|
5. Menús		 	|menus|
6. Extras			|gui-extras|
7. Órdenes de consola		|gui-shell|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">9</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="6" approved="yes">
        <source>Other GUI documentation:
|gui_x11.txt|	For specific items of the X11 GUI.
|gui_w32.txt|	For specific items of the Win32 GUI.</source>
        <target state="translated">Más documentación de la GUI:
|gui_x11.txt|	Para elementos específicos de la GUI bajo X11.
|gui_w32.txt|	Para elementos específicos de la GUI bajo Win32.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">17</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="7" approved="yes">
        <source>{Vi does not have any of these commands}</source>
        <target state="translated">{Ninguna de estas órdenes está presente en Vi}</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="8" approved="yes">
        <source>==============================================================================
1. Starting the GUI				*gui-start* *E229* *E233*</source>
        <target state="translated">==============================================================================
1. Iniciar la GUI				*gui-start* *E229* *E233*</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="9" approved="yes">
        <source>First you must make sure you actually have a version of Vim with the GUI code
included.  You can check this with the ":version" command, it says "with xxx
GUI", where "xxx" is X11-Motif, X11-Athena, Photon, GTK, GTK2, etc., or
"MS-Windows 32 bit GUI version".</source>
        <target state="translated">Asegúrese primero de que realmente tiene una versión de Vim con el código de
la GUI integrado. Puede revisar esto con la orden :version, el cual
devuelve
«con GUI xxx», donde «xxx» puede ser X11-Motif, X11-Athena, Photon, GTK, GTK2,
etc... o «versión GUI MS-Windows 32 bit».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">26</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="10" approved="yes">
        <source>How to start the GUI depends on the system used.  Mostly you can run the
GUI version of Vim with:
    gvim [options] [files...]</source>
        <target state="translated">Como iniciar la interfaz gráfica depende del sistema que se usa.
Generalmente, puede iniciar la versión GUI de Vim con:
    gvim [opciones] [archivos...]</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">31</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="11" approved="yes">
        <source>The X11 version of Vim can run both in GUI and in non-GUI mode.  See
|gui-x11-start|.</source>
        <target state="translated">La versión X11 de Vim puede ejecutarse en modo gráfico o no. Véase
|gui-x11-start|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">35</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="12" approved="yes">
        <source>					*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
The gvimrc file is where GUI-specific startup commands should be placed.  It
is always sourced after the |vimrc| file.  If you have one then the $MYGVIMRC
environment variable has its name.</source>
        <target state="translated">					*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
El archivo gvimrc es donde debe escribir las órdenes de inicio específicos de
la GUI.
Siempre se lee después del archivo |vimrc|. Si tiene uno, la variable
de entorno $MYGVIMRC llevará su tal nombre.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">38</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="13" approved="yes">
        <source>When the GUI starts up initializations are carried out, in this order:
- The 'term' option is set to "builgin_gui" and terminal options are reset to
  their default value for the GUI |terminal-options|.
- If the system menu file exists, it is sourced.  The name of this file is
  normally "$VIMRUNTIME/menu.vim".  You can check this with ":version".  Also
  see |$VIMRUNTIME|.  To skip loading the system menu include 'M' in
  'guioptions'.				*buffers-menu* *no_buffers_menu*
  The system menu file includes a "Buffers" menu.  If you don't want this, set
  the "no_buffers_menu" variable in your .vimrc (not .gvimrc!): &gt;
	:let no_buffers_menu = 1
&lt; NOTE: Switching on syntax highlighting also loads the menu file, thus
  disabling the Buffers menu must be done before ":syntax on".
  The path names are truncated to 35 characters.  You can truncate them at a
  different length, for example 50, like this: &gt;
	:let bmenu_max_pathlen = 50
- If the "-U {gvimrc}" command-line option has been used when starting Vim,
  the {gvimrc} file will be read for initializations.  The following
  initializations are skipped.  When {gvimrc} is "NONE" no file will be read
  for initializations.
- For Unix and MS-Windows, if the system gvimrc exists, it is sourced.  The
  name of this file is normally "$VIM/gvimrc".  You can check this with
  ":version".  Also see |$VIM|.
- The following are tried, and only the first one that exists is used:
  - If the GVIMINIT environment variable exists and is not empty, it is
    executed as an Ex command.
  - If the user gvimrc file exists, it is sourced.  The name of this file is
    normally "$HOME/.gvimrc".  You can check this with ":version".
  - For Win32, when $HOME is not set, "$VIM\_gvimrc" is used.
  - When a "_gvimrc" file is not found, ".gvimrc" is tried too.  And vice
    versa.
  The name of the first file found is stored in $MYGVIMRC, unless it was
  already set.
- If the 'exrc' option is set (which is NOT the default) the file ./.gvimrc
  is sourced, if it exists and isn't the same file as the system or user
  gvimrc file.  If this file is not owned by you, some security restrictions
  apply.  When ".gvimrc" is not found, "_gvimrc" is tried too.  For Macintosh
  and DOS/Win32 "_gvimrc" is tried first.</source>
        <target state="translated">Al ejecutar la GUI, las órdenes de inicio se llevan a cabo en este orden:
- La opción 'term' está definida como «builgin_gui» y las opciones de
  terminal se devuleven a sus valores predeterminados |terminal-options|.
- Si existe un archivo de menú del sistema, se lee. Generalmente, el nombre
  de este archivo es «$VIMRUNTIME/menu.vim». Puede cerciorarse con
  la orden «:version». Véase también |$VIMRUNTIME|. Para evitar cargar el
  menú del sistema, incluya 'M' en 'guioptions'.
					*buffers-menu* *no_buffers_menu*
  </target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">43</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="14" approved="yes">
        <source>NOTE: All but the first one are not carried out if Vim was started with
"-u NONE" and no "-U" argument was given, or when started with "-U NONE".</source>
        <target state="translated">NOTA: Todas excepto la primera no se ejecutarán si inicia Vim con
«-u NONE» y si no se introdujo ningún argumento «-U», o si se inicia con
«-U NONE».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">81</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="15" approved="yes">
        <source>All this happens AFTER the normal Vim initializations, like reading your
.vimrc file.  See |initialization|.
But the GUI window is only opened after all the initializations have been
carried out.  If you want some commands to be executed just after opening the
GUI window, use the |GUIEnter| autocommand event.  Example: &gt;
	:autocmd GUIEnter * winpos 100 50</source>
        <target state="translated">Todo esto ocurre despues de las órdenes de inicio de Vim, como si
leyese el archivo «.vimrc». Véase |initialization|.
La ventana de la interfaz gráfica solo se abre después de llevar a cabo
todas las órdenes de inicio. Si desea que alguna orden se ejecute justo
después de abrir la ventana de la interfaz gráfica, use el evento de
autorden |GUIEvent|. Ejemplo: &gt;
	:autocmd GUIEnter * winpos 100 50</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">84</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="16" approved="yes">
        <source>You can use the gvimrc files to set up your own customized menus (see |:menu|)
and initialize other things that you may want to set up differently from the
terminal version.</source>
        <target state="translated">Puede usar los archivos gvimrc para crear sus propios menús
personalizados (véase |:menu|).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">91</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="17">
        <source>Recommended place for your personal GUI initializations:
	Unix		    $HOME/.gvimrc
	OS/2		    $HOME/.gvimrc or $VIM/.gvimrc
	MS-DOS and Win32    $HOME/_gvimrc or $VIM/_gvimrc
	Amiga		    s:.gvimrc or $VIM/.gvimrc</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">95</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="18" approved="yes">
        <source>There are a number of options which only have meaning in the GUI version of
Vim.  These are 'guicursor', 'guifont', 'guipty' and 'guioptions'.  They are
documented in |options.txt| with all the other options.</source>
        <target state="translated">Hay un número de opciones que solo tienen efecto en la versión GUI
de Vim. Estos son 'guicursor', 'guifont', 'guipty' y 'guioptions'.
Están documentadas en |options.txt|, junto con el resto de opciones.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">101</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="19">
        <source>If using the Motif or Athena version of the GUI (but not for the GTK+ or
Win32 version), a number of X resources are available.  See |gui-resources|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">105</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="20">
        <source>Another way to set the colors for different occasions is with highlight
groups.  The "Normal" group is used to set the background and foreground
colors.  Example (which looks nice): &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">108</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="21" approved="yes">
        <source>	:highlight Normal guibg=grey90</source>
        <target state="translated">	:highlight Normal guibg=grey90</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">112</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="22">
        <source>The "guibg" and "guifg" settings override the normal background and
foreground settings.  The other settings for the Normal highlight group are
not used.  Use the 'guifont' option to set the font.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">114</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="23">
        <source>Also check out the 'guicursor' option, to set the colors for the cursor in
various modes.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">118</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="24">
        <source>Vim tries to make the window fit on the screen when it starts up.  This avoids
that you can't see part of it.  On the X Window System this requires a bit of
guesswork.  You can change the height that is used for the window title and a
task bar with the 'guiheadroom' option.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">121</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="25">
        <source>						*:winp* *:winpos* *E188*
:winp[os]
		Display current position of the top left corner of the GUI vim
		window in pixels.  Does not work in all versions.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">126</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="26">
        <source>:winp[os] {X} {Y}							*E466*
		Put the GUI vim window at the given {X} and {Y} coordinates.
		The coordinates should specify the position in pixels of the
		top left corner of the window.  Does not work in all versions.
		Does work in an (new) xterm |xterm-color|.
		When the GUI window has not been opened yet, the values are
		remembered until the window is opened.  The position is
		adjusted to make the window fit on the screen (if possible).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">131</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="27">
        <source>						    *:win* *:winsize* *E465*
:win[size] {width} {height}
		Set the window height to {width} by {height} characters.
		Obsolete, use ":set lines=11 columns=22".
		If you get less lines than expected, check the 'guiheadroom'
		option.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">140</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="28">
        <source>If you are running the X Window System, you can get information about the
window Vim is running in with this command: &gt;
	:!xwininfo -id $WINDOWID</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">147</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="29">
        <source>==============================================================================
2. Scrollbars						*gui-scrollbars*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">151</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="30">
        <source>There are vertical scrollbars and a horizontal scrollbar.  You may
configure which ones appear with the 'guioptions' option.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">154</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="31">
        <source>The interface looks like this (with ":set guioptions=mlrb"):</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">157</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="32">
        <source>		       +------------------------------+
		       | File  Edit		 Help | &lt;- Menu bar (m)
		       +-+--------------------------+-+
		       |^|			    |^|
		       |#| Text area.		    |#|
		       | |			    | |
		       |v|__________________________|v|
 Normal status line -&gt; |-+ File.c	       5,2  +-|
 between Vim windows   |^|""""""""""""""""""""""""""|^|
		       | |			    | |
		       | | Another file buffer.     | |
		       | |			    | |
		       |#|			    |#|
 Left scrollbar (l) -&gt; |#|			    |#| &lt;- Right
		       |#|			    |#|    scrollbar (r)
		       | |			    | |
		       |v|			    |v|
		       +-+--------------------------+-+
		       | |&lt; ####		   &gt;| | &lt;- Bottom
		       +-+--------------------------+-+    scrollbar (b)</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">159</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="33">
        <source>Any of the scrollbar or menu components may be turned off by not putting the
appropriate letter in the 'guioptions' string.  The bottom scrollbar is
only useful when 'nowrap' is set.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">180</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="34">
        <source>VERTICAL SCROLLBARS					*gui-vert-scroll*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">185</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="35">
        <source>Each Vim window has a scrollbar next to it which may be scrolled up and down
to move through the text in that buffer.  The size of the scrollbar-thumb
indicates the fraction of the buffer which can be seen in the window.
When the scrollbar is dragged all the way down, the last line of the file
will appear in the top of the window.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">187</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="36">
        <source>If a window is shrunk to zero height (by the growth of another window) its
scrollbar disappears.  It reappears when the window is restored.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">193</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="37">
        <source>If a window is vertically split, it will get a scrollbar when it is the
current window and when, taking the middle of the current window and drawing a
vertical line, this line goes through the window.
When there are scrollbars on both sides, and the middle of the current window
is on the left half, the right scrollbar column will contain scrollbars for
the rightmost windows.  The same happens on the other side.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">196</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="38">
        <source>HORIZONTAL SCROLLBARS					*gui-horiz-scroll*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">204</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="39">
        <source>The horizontal scrollbar (at the bottom of the Vim GUI) may be used to
scroll text sideways when the 'wrap' option is turned off.  The
scrollbar-thumb size is such that the text of the longest visible line may be
scrolled as far as possible left and right.  The cursor is moved when
necessary, it must remain on a visible character (unless 'virtualedit' is
set).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">206</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="40">
        <source>Computing the length of the longest visible line takes quite a bit of
computation, and it has to be done every time something changes.  If this
takes too much time or you don't like the cursor jumping to another line,
include the 'h' flag in 'guioptions'.  Then the scrolling is limited by the
text of the current cursor line.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">213</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="41">
        <source>							*athena-intellimouse*
If you have an Intellimouse and an X server that supports using the wheel,
then you can use the wheel to scroll the text up and down in gvim.  This works
with XFree86 4.0 and later, and with some older versions when you add patches.
See |scroll-mouse-wheel|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">219</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="42">
        <source>For older versions of XFree86 you must patch your X server.  The following
page has a bit of information about using the Intellimouse on Linux as well as
links to the patches and X server binaries (may not have the one you need
though):
    http://www.inria.fr/koala/colas/mouse-wheel-scroll/</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">225</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="43">
        <source>==============================================================================
3. Mouse Control					*gui-mouse*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">231</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="44">
        <source>The mouse only works if the appropriate flag in the 'mouse' option is set.
When the GUI is switched on, and 'mouse' wasn't set yet, the 'mouse' option is
automatically set to "a", enabling it for all modes except for the
|hit-enter| prompt.  If you don't want this, a good place to change the
'mouse' option is the "gvimrc" file.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">234</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="45">
        <source>Other options that are relevant:
'mousefocus'	window focus follows mouse pointer |gui-mouse-focus|
'mousemodel'	what mouse button does which action
'mousehide'	hide mouse pointer while typing text
'selectmode'	whether to start Select mode or Visual mode</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">240</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="46">
        <source>A quick way to set these is with the ":behave" command.
							*:behave* *:be*
:be[have] {model}	Set behavior for mouse and selection.  Valid
			arguments are:
			   mswin	MS-Windows behavior
			   xterm	Xterm behavior</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">246</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="47">
        <source>			Using ":behave" changes these options:
			option		mswin			xterm	~
			'selectmode'	"mouse,key"		""
			'mousemodel'	"popup"			"extend"
			'keymodel'	"startsel,stopsel"	""
			'selection'	"exclusive"		"inclusive"</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">253</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="48">
        <source>In the $VIMRUNTIME directory, there is a script called |mswin.vim|, which will
also map a few keys to the MS-Windows cut/copy/paste commands.  This is NOT
compatible, since it uses the CTRL-V, CTRL-X and CTRL-C keys.  If you don't
mind, use this command: &gt;
	:so $VIMRUNTIME/mswin.vim</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">260</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="49">
        <source>For scrolling with a wheel on a mouse, see |scroll-mouse-wheel|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="50">
        <source>3.1 Moving Cursor with Mouse				*gui-mouse-move*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="51">
        <source>Click the left mouse button somewhere in a text buffer where you want the
cursor to go, and it does!
This works in	    when 'mouse' contains ~
Normal mode	    'n' or 'a'
Visual mode	    'v' or 'a'
Insert mode	    'i' or 'a'</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">271</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="52">
        <source>Select mode is handled like Visual mode.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">278</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="53">
        <source>You may use this with an operator such as 'd' to delete text from the current
cursor position to the position you point to with the mouse.  That is, you hit
'd' and then click the mouse somewhere.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="54">
        <source>							*gui-mouse-focus*
The 'mousefocus' option can be set to make the keyboard focus follow the
mouse pointer.  This means that the window where the mouse pointer is, is the
active window.  Warning: this doesn't work very well when using a menu,
because the menu command will always be applied to the top window.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">284</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="55">
        <source>If you are on the ':' line (or '/' or '?'), then clicking the left or right
mouse button will position the cursor on the ':' line (if 'mouse' contains
'c', 'a' or 'A').</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">290</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="56">
        <source>In any situation the middle mouse button may be clicked to paste the current
selection.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">294</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="57">
        <source>3.2 Selection with Mouse				*gui-mouse-select*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">298</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="58">
        <source>The mouse can be used to start a selection.  How depends on the 'mousemodel'
option:
'mousemodel' is "extend": use the right mouse button
'mousemodel' is "popup":  use the left mouse button, while keeping the Shift
key pressed.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">300</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="59">
        <source>If there was no selection yet, this starts a selection from the old cursor
position to the position pointed to with the mouse.  If there already is a
selection then the closest end will be extended.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">306</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="60">
        <source>If 'selectmode' contains "mouse", then the selection will be in Select mode.
This means that typing normal text will replace the selection.  See
|Select-mode|.  Otherwise, the selection will be in Visual mode.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">310</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="61">
        <source>Double clicking may be done to make the selection word-wise, triple clicking
makes it line-wise, and quadruple clicking makes it rectangular block-wise.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">314</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="62">
        <source>See |gui-selections| on how the selection is used.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">317</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="63">
        <source>3.3 Other Text Selection with Mouse		*gui-mouse-modeless*
						*modeless-selection*
A different kind of selection is used when:
- in Command-line mode
- in the Command-line window and pointing in another window
- at the |hit-enter| prompt
- whenever the current mode is not in the 'mouse' option
- when holding the CTRL and SHIFT keys in the GUI</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="64">
        <source>Since Vim continues like the selection isn't there, and there is no mode
associated with the selection, this is called modeless selection.  Any text in
the Vim window can be selected.  Select the text by pressing the left mouse
button at the start, drag to the end and release.  To extend the selection,
use the right mouse button when 'mousemodel' is "extend", or the left mouse
button with the shift key pressed when 'mousemodel' is "popup".
The selection is removed when the selected text is scrolled or changed.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">329</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="65">
        <source>On the command line CTRL-Y can be used to copy the selection into the
clipboard.  To do this from Insert mode, use CTRL-O : CTRL-Y &lt;CR&gt;.  When
'guioptions' contains a or A (default on X11), the selection is automatically
copied to the "* register.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">337</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="66">
        <source>The middle mouse button can then paste the text.  On non-X11 systems, you can
use CTRL-R +.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">342</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="67">
        <source>3.4 Using Mouse on Status Lines				*gui-mouse-status*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">346</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="68">
        <source>Clicking the left or right mouse button on the status line below a Vim
window makes that window the current window.  This actually happens on button
release (to be able to distinguish a click from a drag action).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">348</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="69">
        <source>With the left mouse button a status line can be dragged up and down, thus
resizing the windows above and below it.  This does not change window focus.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">352</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="70">
        <source>The same can be used on the vertical separator: click to give the window left
of it focus, drag left and right to make windows wider and narrower.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">355</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="71">
        <source>3.5 Various Mouse Clicks				*gui-mouse-various*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">359</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="72">
        <source>    &lt;S-LeftMouse&gt;	Search forward for the word under the mouse click.
			When 'mousemodel' is "popup" this starts or extends a
			selection.
    &lt;S-RightMouse&gt;	Search backward for the word under the mouse click.
    &lt;C-LeftMouse&gt;	Jump to the tag name under the mouse click.
    &lt;C-RightMouse&gt;	Jump back to position before the previous tag jump
			(same as "CTRL-T")</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">361</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="73">
        <source>3.6 Mouse Mappings					*gui-mouse-mapping*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">370</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="74">
        <source>The mouse events, complete with modifiers, may be mapped.  Eg: &gt;
   :map &lt;S-LeftMouse&gt;     &lt;RightMouse&gt;
   :map &lt;S-LeftDrag&gt;      &lt;RightDrag&gt;
   :map &lt;S-LeftRelease&gt;   &lt;RightRelease&gt;
   :map &lt;2-S-LeftMouse&gt;   &lt;2-RightMouse&gt;
   :map &lt;2-S-LeftDrag&gt;    &lt;2-RightDrag&gt;
   :map &lt;2-S-LeftRelease&gt; &lt;2-RightRelease&gt;
   :map &lt;3-S-LeftMouse&gt;   &lt;3-RightMouse&gt;
   :map &lt;3-S-LeftDrag&gt;    &lt;3-RightDrag&gt;
   :map &lt;3-S-LeftRelease&gt; &lt;3-RightRelease&gt;
   :map &lt;4-S-LeftMouse&gt;   &lt;4-RightMouse&gt;
   :map &lt;4-S-LeftDrag&gt;    &lt;4-RightDrag&gt;
   :map &lt;4-S-LeftRelease&gt; &lt;4-RightRelease&gt;
These mappings make selection work the way it probably should in a Motif
application, with shift-left mouse allowing for extending the visual area
rather than the right mouse button.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">372</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="75">
        <source>Mouse mapping with modifiers does not work for modeless selection.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">389</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="76">
        <source>3.7 Drag and drop						*drag-n-drop*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">392</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="77">
        <source>You can drag and drop one or more files into the Vim window, where they will
be opened as if a |:drop| command was used.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">394</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="78">
        <source>If you hold down Shift while doing this, Vim changes to the first dropped
file's directory.  If you hold Ctrl Vim will always split a new window for the
file.  Otherwise it's only done if the current buffer has been changed.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">397</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="79">
        <source>You can also drop a directory on Vim.  This starts the explorer plugin for
that directory (assuming it was enabled, otherwise you'll get an error
message).  Keep Shift pressed to change to the directory instead.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">401</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="80">
        <source>If Vim happens to be editing a command line, the names of the dropped files
and directories will be inserted at the cursor.  This allows you to use these
names with any Ex command.  Special characters (space, tab, double quote and
'|'; backslash on non-MS-Windows systems) will be escaped.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">405</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="81">
        <source>==============================================================================
4. Making GUI Selections				*gui-selections*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">410</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="82">
        <source>							*quotestar*
You may make selections with the mouse (see |gui-mouse-select|), or by using
Vim's Visual mode (see |v|).  If 'a' is present in 'guioptions', then
whenever a selection is started (Visual or Select mode), or when the selection
is changed, Vim becomes the owner of the windowing system's primary selection
(on MS-Windows the |gui-clipboard| is used; under X11, the |x11-selection| is
used - you should read whichever of these is appropriate now).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">413</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="83">
        <source>							*clipboard*
There is a special register for storing this selection, it is the "*
register.  Nothing is put in here unless the information about what text is
selected is about to change (e.g. with a left mouse click somewhere), or when
another application wants to paste the selected text.  Then the text is put
in the "* register.  For example, to cut a line and make it the current
selection/put it on the clipboard: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">421</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="84">
        <source>	"*dd</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">429</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="85">
        <source>Similarly, when you want to paste a selection from another application, e.g.,
by clicking the middle mouse button, the selection is put in the "* register
first, and then 'put' like any other register.  For example, to put the
selection (contents of the clipboard): &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">431</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="86">
        <source>	"*p</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">436</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="87">
        <source>When using this register under X11, also see |x11-selection|.  This also
explains the related "+ register.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">438</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="88">
        <source>Note that when pasting text from one Vim into another separate Vim, the type
of selection (character, line, or block) will also be copied.  For other
applications the type is always character.  However, if the text gets
transferred via the |x11-cut-buffer|, the selection type is ALWAYS lost.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">441</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="89">
        <source>When the "unnamed" string is included in the 'clipboard' option, the unnamed
register is the same as the "* register.  Thus you can yank to and paste the
selection without prepending "* to commands.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">446</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="90">
        <source>==============================================================================
5. Menus						*menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">450</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="91">
        <source>For an introduction see |usr_42.txt| in the user manual.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">453</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="92">
        <source>5.1 Using Menus						*using-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">456</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="93">
        <source>Basically, menus can be used just like mappings.  You can define your own
menus, as many as you like.
Long-time Vim users won't use menus much.  But the power is in adding your own
menus and menu items.  They are most useful for things that you can't remember
what the key sequence was.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">458</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="94">
        <source>For creating menus in a different language, see |:menutrans|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">464</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="95">
        <source>							*menu.vim*
The default menus are read from the file "$VIMRUNTIME/menu.vim".  See
|$VIMRUNTIME| for where the path comes from.  You can set up your own menus.
Starting off with the default set is a good idea.  You can add more items, or,
if you don't like the defaults at all, start with removing all menus
|:unmenu-all|.  You can also avoid the default menus being loaded by adding
this line to your .vimrc file (NOT your .gvimrc file!): &gt;
	:let did_install_default_menus = 1
If you also want to avoid the Syntax menu: &gt;
	:let did_install_syntax_menu = 1
If you do want the Syntax menu but not all the entries for each available
syntax file (which take quite a bit of time to load): &gt;
	:let skip_syntax_sel_menu = 1
&lt;
							*console-menus*
Although this documentation is in the GUI section, you can actually use menus
in console mode too.  You will have to load |menu.vim| explicitly then, it is
not done by default.  You can use the |:emenu| command and command-line
completion with 'wildmenu' to access the menu entries almost like a real menu
system.  To do this, put these commands in your .vimrc file: &gt;
	:source $VIMRUNTIME/menu.vim
	:set wildmenu
	:set cpo-=&lt;
	:set wcm=&lt;C-Z&gt;
	:map &lt;F4&gt; :emenu &lt;C-Z&gt;
Pressing &lt;F4&gt; will start the menu.  You can now use the cursor keys to select
a menu entry.  Hit &lt;Enter&gt; to execute it.  Hit &lt;Esc&gt; if you want to cancel.
This does require the |+menu| feature enabled at compile time.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">466</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="96">
        <source>							*tear-off-menus*
GTK+ and Motif support Tear-off menus.  These are sort of sticky menus or
pop-up menus that are present all the time.  If the resizing does not work
correctly, this may be caused by using something like "Vim*geometry" in the
defaults.  Use "Vim.geometry" instead.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">495</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="97">
        <source>The Win32 GUI version emulates Motif's tear-off menus.  Actually, a Motif user
will spot the differences easily, but hopefully they're just as useful.  You
can also use the |:tearoff| command together with |hidden-menus| to create
floating menus that do not appear on the main menu bar.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">501</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="98">
        <source>5.2 Creating New Menus					*creating-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">507</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="99">
        <source>				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
To create a new menu item, use the ":menu" commands.  They are mostly like
the ":map" set of commands but the first argument is a menu item name, given
as a path of menus and submenus with a '.' between them, e.g.: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">509</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="100">
        <source>   :menu File.Save  :w&lt;CR&gt;
   :inoremenu File.Save  &lt;C-O&gt;:w&lt;CR&gt;
   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g&lt;CR&gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">524</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="101">
        <source>This last one will create a new item in the menu bar called "Edit", holding
the mouse button down on this will pop up a menu containing the item
"Big Changes", which is a sub-menu containing the item "Delete All Spaces",
which when selected, performs the operation.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">528</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="102">
        <source>Special characters in a menu name:</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">533</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="103">
        <source>	&amp;	The next character is the shortcut key.  Make sure each
		shortcut key is only used once in a (sub)menu.  If you want to
		insert a literal "&amp;" in the menu name use "&amp;&amp;".
	&lt;Tab&gt;	Separates the menu name from right-aligned text.  This can be
		used to show the equivalent typed command.  The text "&lt;Tab&gt;"
		can be used here for convenience.  If you are using a real
		tab, don't forget to put a backslash before it!
Example: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">535</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="104">
        <source>   :amenu &amp;File.&amp;Open&lt;Tab&gt;:e  :browse e&lt;CR&gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">544</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="105">
        <source>[typed literally]
With the shortcut "F" (while keeping the &lt;Alt&gt; key pressed), and then "O",
this menu can be used.  The second part is shown as "Open     :e".  The ":e"
is right aligned, and the "O" is underlined, to indicate it is the shortcut.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">546</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="106">
        <source>The ":amenu" command can be used to define menu entries for all modes at once.
To make the command work correctly, a character is automatically inserted for
some modes:
	mode		inserted	appended	~
	Normal		nothing		nothing
	Visual		&lt;C-C&gt;		&lt;C-\&gt;&lt;C-G&gt;
	Insert		&lt;C-O&gt;
	Cmdline		&lt;C-C&gt;		&lt;C-\&gt;&lt;C-G&gt;
	Op-pending	&lt;C-C&gt;		&lt;C-\&gt;&lt;C-G&gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">551</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="107">
        <source>Appending CTRL-\ CTRL-G is for going back to insert mode when 'insertmode' is
set. |CTRL-\_CTRL-G|</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">561</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="108">
        <source>Example: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">564</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="109">
        <source>   :amenu File.Next	:next^M</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">566</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="110">
        <source>is equal to: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">568</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="111">
        <source>   :nmenu File.Next	:next^M
   :vmenu File.Next	^C:next^M^\^G
   :imenu File.Next	^O:next^M
   :cmenu File.Next	^C:next^M^\^G
   :omenu File.Next	^C:next^M^\^G</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">570</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="112">
        <source>Careful: In Insert mode this only works for a SINGLE Normal mode command,
because of the CTRL-O.  If you have two or more commands, you will need to use
the ":imenu" command.  For inserting text in any mode, you can use the
expression register: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">576</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="113">
        <source>   :amenu Insert.foobar   "='foobar'&lt;CR&gt;P</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">581</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="114">
        <source>Note that the '&lt;' and 'k' flags in 'cpoptions' also apply here (when
included they make the &lt;&gt; form and raw key codes not being recognized).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">583</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="115">
        <source>Note that &lt;Esc&gt; in Cmdline mode executes the command, like in a mapping.  This
is Vi compatible.  Use CTRL-C to quit Cmdline mode.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">586</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="116">
        <source>						*:menu-&lt;silent&gt;* *:menu-silent*
To define a menu which will not be echoed on the command line, add
"&lt;silent&gt;" as the first argument.  Example: &gt;
	:menu &lt;silent&gt; Settings.Ignore\ case  :set ic&lt;CR&gt;
The ":set ic" will not be echoed when using this menu.  Messages from the
executed command are still given though.  To shut them up too, add a ":silent"
in the executed command: &gt;
	:menu &lt;silent&gt; Search.Header :exe ":silent normal /Header\r"&lt;CR&gt;
"&lt;silent&gt;" may also appear just after "&lt;special&gt;" or "&lt;script&gt;".</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">589</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="117">
        <source>					*:menu-&lt;special&gt;* *:menu-special*
Define a menu with &lt;&gt; notation for special keys, even though the "&lt;" flag
may appear in 'cpoptions'.  This is useful if the side effect of setting
'cpoptions' is not desired.  Example: &gt;
	:menu &lt;special&gt; Search.Header /Header&lt;CR&gt;
"&lt;special&gt;" must appear as the very first argument to the ":menu" command or
just after "&lt;silent&gt;" or "&lt;script&gt;".</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">599</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="118">
        <source>						*:menu-&lt;script&gt;* *:menu-script*
The "to" part of the menu will be inspected for mappings.  If you don't want
this, use the ":noremenu" command (or the similar one for a specific mode).
If you do want to use script-local mappings, add "&lt;script&gt;" as the very first
argument to the ":menu" command or just after "&lt;silent&gt;" or "&lt;special&gt;".</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">607</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="119">
        <source>							*menu-priority*
You can give a priority to a menu.  Menus with a higher priority go more to
the right.  The priority is given as a number before the ":menu" command.
Example: &gt;
	:80menu Buffer.next :bn&lt;CR&gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">613</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="120">
        <source>The default menus have these priorities:
	File		10
	Edit		20
	Tools		40
	Syntax		50
	Buffers		60
	Window		70
	Help		9999</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">619</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="121">
        <source>When no or zero priority is given, 500 is used.
The priority for the PopUp menu is not used.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">628</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="122">
        <source>The Help menu will be placed on the far right side of the menu bar on systems
which support this (Motif and GTK+).  For GTK+ 2, this is not done anymore
because right-aligning the Help menu is now discouraged UI design.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">631</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="123">
        <source>You can use a priority higher than 9999, to make it go after the Help menu,
but that is non-standard and is discouraged.  The highest possible priority is
about 32000.  The lowest is 1.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">635</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="124">
        <source>							*sub-menu-priority*
The same mechanism can be used to position a sub-menu.  The priority is then
given as a dot-separated list of priorities, before the menu name: &gt;
	:menu 80.500 Buffer.next :bn&lt;CR&gt;
Giving the sub-menu priority is only needed when the item is not to be put
in a normal position.  For example, to put a sub-menu before the other items: &gt;
	:menu 80.100 Buffer.first :brew&lt;CR&gt;
Or to put a sub-menu after the other items, and further items with default
priority will be put before it: &gt;
	:menu 80.900 Buffer.last :blast&lt;CR&gt;
When a number is missing, the default value 500 will be used: &gt;
	:menu .900 myMenu.test :echo "text"&lt;CR&gt;
The menu priority is only used when creating a new menu.  When it already
existed, e.g., in another mode, the priority will not change.  Thus, the
priority only needs to be given the first time a menu is used.
An exception is the PopUp menu.  There is a separate menu for each mode
(Normal, Op-pending, Visual, Insert, Cmdline).  The order in each of these
menus can be different.  This is different from menu-bar menus, which have
the same order for all modes.
NOTE: sub-menu priorities currently don't work for all versions of the GUI.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">639</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="125">
        <source>							*menu-separator* *E332*
Menu items can be separated by a special item that inserts some space between
items.  Depending on the system this is displayed as a line or a dotted line.
These items must start with a '-' and end in a '-'.  The part in between is
used to give it a unique name.  Priorities can be used as with normal items.
Example: &gt;
	:menu Example.item1	:do something
	:menu Example.-Sep-	:
	:menu Example.item2	:do something different
Note that the separator also requires a rhs.  It doesn't matter what it is,
because the item will never be selected.  Use a single colon to keep it
simple.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">660</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="126">
        <source>							*gui-toolbar*
The toolbar is currently available in the Win32, Athena, Motif, GTK+ (X11),
and Photon GUI.  It should turn up in other GUIs in due course.  The
default toolbar is setup in menu.vim.
The display of the toolbar is controlled by the 'guioptions' letter 'T'.  You
can thus have menu &amp; toolbar together, or either on its own, or neither.
The appearance is controlled by the 'toolbar' option.  You can chose between
an image, text or both.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">673</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="127">
        <source>							*toolbar-icon*
The toolbar is defined as a special menu called ToolBar, which only has one
level.  Vim interprets the items in this menu as follows:
1)  If an "icon=" argument was specified, the file with this name is used.
    The file can either be specified with the full path or with the base name.
    In the last case it is searched for in the "bitmaps" directory in
    'runtimepath', like in point 3.  Examples: &gt;
	:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"&lt;CR&gt;
	:amenu icon=FooIcon ToolBar.Foo :echo "Foo"&lt;CR&gt;
&lt;   Note that in the first case the extension is included, while in the second
    case it is omitted.
    If the file cannot be opened the next points are tried.
    A space in the file name must be escaped with a backslash.
    A menu priority must come _after_ the icon argument: &gt;
	:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"&lt;CR&gt;
2)  An item called 'BuiltIn##', where ## is a number, is taken as number ## of
    the built-in bitmaps available in Vim.  Currently there are 31 numbered
    from 0 to 30 which cover most common editing operations |builtin-tools|. &gt;
	:amenu ToolBar.BuiltIn22 :call SearchNext("back")&lt;CR&gt;
3)  An item with another name is first searched for in the directory
    "bitmaps" in 'runtimepath'.  If found, the bitmap file is used as the
    toolbar button image.  Note that the exact filename is OS-specific: For
    example, under Win32 the command &gt;
	:amenu ToolBar.Hello :echo "hello"&lt;CR&gt;
&lt;   would find the file 'hello.bmp'.  Under GTK+/X11 it is 'Hello.xpm'.  With
    GTK+ 2 the files 'Hello.png', 'Hello.xpm' and 'Hello.bmp' are checked for
    existence, and the first one found would be used.
    For MS-Windows and GTK+ 2 the bitmap is scaled to fit the button.  For
    MS-Windows a size of 18 by 18 pixels works best.
    For MS-Windows the bitmap should have 16 colors with the standard palette.
    The light grey pixels will be changed to the Window frame color and the
    dark grey pixels to the window shadow color.  More colors might also work,
    depending on your system.
4)  If the bitmap is still not found, Vim checks for a match against its list
    of built-in names.  Each built-in button image has a name.
    So the command &gt;
	:amenu ToolBar.Open :e
&lt;   will show the built-in "open a file" button image if no open.bmp exists.
    All the built-in names can be seen used in menu.vim.
5)  If all else fails, a blank, but functioning, button is displayed.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">682</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="128">
        <source>							*builtin-tools*
nr  Name		Normal action  ~
00  New			open new window
01  Open		browse for file to open in current window
02  Save		write buffer to file
03  Undo		undo last change
04  Redo		redo last undone change
05  Cut			delete selected text to clipboard
06  Copy		copy selected text to clipboard
07  Paste		paste text from clipboard
08  Print		print current buffer
09  Help		open a buffer on Vim's builtin help
10  Find		start a search command
11  SaveAll		write all modified buffers to file
12  SaveSesn		write session file for current situation
13  NewSesn		write new session file
14  LoadSesn		load session file
15  RunScript		browse for file to run as a Vim script
16  Replace		prompt for substitute command
17  WinClose		close current window
18  WinMax		make current window use many lines
19  WinMin		make current window use few lines
20  WinSplit		split current window
21  Shell		start a shell
22  FindPrev		search again, backward
23  FindNext		search again, forward
24  FindHelp		prompt for word to search help for
25  Make		run make and jump to first error
26  TagJump		jump to tag under the cursor
27  RunCtags		build tags for files in current directory
28  WinVSplit		split current window vertically
29  WinMaxWidth		make current window use many columns
30  WinMinWidth		make current window use few columns</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">723</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="129">
        <source>					*hidden-menus* *win32-hidden-menus*
In the Win32 and GTK+ GUI, starting a menu name with ']' excludes that menu
from the main menu bar.  You must then use the |:popup| or |:tearoff| command
to display it.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">757</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="130">
        <source>							*popup-menu*
In the Win32, GTK+, Motif, Athena and Photon GUI, you can define the
special menu "PopUp".  This is the menu that is displayed when the right mouse
button is pressed, if 'mousemodel' is set to popup or popup_setpos.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">762</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="131">
        <source>5.3 Showing What Menus Are Mapped To			*showing-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">768</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="132">
        <source>To see what an existing menu is mapped to, use just one argument after the
menu commands (just like you would with the ":map" commands).  If the menu
specified is a submenu, then all menus under that hierarchy will be shown.
If no argument is given after :menu at all, then ALL menu items are shown
for the appropriate mode (e.g., Command-line mode for :cmenu).</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">770</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="133">
        <source>Special characters in the list, just before the rhs:
*	The menu was defined with "nore" to disallow remapping.
&amp;	The menu was defined with "&lt;script&gt;" to allow remapping script-local
	mappings only.
-	The menu was disabled.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">776</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="134">
        <source>Note that hitting &lt;Tab&gt; while entering a menu name after a menu command may
be used to complete the name of the menu item.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">782</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="135">
        <source>5.4 Executing Menus					*execute-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">786</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="136">
        <source>						*:em*  *:emenu* *E334* *E335*
:[range]em[enu] {menu}		Execute {menu} from the command line.
				The default is to execute the Normal mode
				menu.  If a range is specified, it executes
				the Visual mode menu.
				If used from &lt;c-o&gt;, it executes the
				insert-mode menu Eg: &gt;
	:emenu File.Exit</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">788</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="137">
        <source>If the console-mode vim has been compiled with WANT_MENU defined, you can
use :emenu to access useful menu items you may have got used to from GUI
mode.  See 'wildmenu' for an option that works well with this.  See
|console-menus| for an example.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">797</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="138">
        <source>When using a range, if the lines match with '&lt;,'&gt;, then the menu is executed
using the last visual selection.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">802</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="139">
        <source>5.5 Deleting Menus					*delete-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">806</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="140">
        <source>						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
To delete a menu item or a whole submenu, use the unmenu commands, which are
analogous to the unmap commands.  Eg: &gt;
    :unmenu! Edit.Paste</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">808</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="141">
        <source>This will remove the Paste item from the Edit menu for Insert and
Command-line modes.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">821</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="142">
        <source>Note that hitting &lt;Tab&gt; while entering a menu name after an umenu command
may be used to complete the name of the menu item for the appropriate mode.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">824</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="143">
        <source>To remove all menus use:			*:unmenu-all*  &gt;
	:unmenu *	" remove all menus in Normal and visual mode
	:unmenu! *	" remove all menus in Insert and Command-line mode
	:aunmenu *	" remove all menus in all modes</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">827</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="144">
        <source>If you want to get rid of the menu bar: &gt;
	:set guioptions-=m</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">832</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="145">
        <source>5.6 Disabling Menus					*disable-menus*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">836</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="146">
        <source>						*:menu-disable* *:menu-enable*
If you do not want to remove a menu, but disable it for a moment, this can be
done by adding the "enable" or "disable" keyword to a ":menu" command.
Examples: &gt;
	:menu disable &amp;File.&amp;Open\.\.\.
	:amenu enable *
	:amenu disable &amp;Tools.*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">838</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="147">
        <source>The command applies to the modes as used with all menu commands.  Note that
characters like "&amp;" need to be included for translated names to be found.
When the argument is "*", all menus are affected.  Otherwise the given menu
name and all existing submenus below it are affected.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">846</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="148">
        <source>5.7 Examples for Menus					*menu-examples*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">852</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="149">
        <source>Here is an example on how to add menu items with menu's!  You can add a menu
item for the keyword under the cursor.  The register "z" is used. &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">854</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="150">
        <source>  :nmenu Words.Add\ Var		wb"zye:menu! Words.&lt;C-R&gt;z &lt;C-R&gt;z&lt;CR&gt;
  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.&lt;C-R&gt;z&lt;CR&gt;
  :vmenu Words.Add\ Var		"zy:menu! Words.&lt;C-R&gt;z &lt;C-R&gt;z &lt;CR&gt;
  :vmenu Words.Remove\ Var	"zy:unmenu! Words.&lt;C-R&gt;z&lt;CR&gt;
  :imenu Words.Add\ Var		&lt;Esc&gt;wb"zye:menu! Words.&lt;C-R&gt;z &lt;C-R&gt;z&lt;CR&gt;a
  :imenu Words.Remove\ Var	&lt;Esc&gt;wb"zye:unmenu! Words.&lt;C-R&gt;z&lt;CR&gt;a</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">857</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="151">
        <source>(the rhs is in &lt;&gt; notation, you can copy/paste this text to try out the
mappings, or put these lines in your gvimrc; "&lt;C-R&gt;" is CTRL-R, "&lt;CR&gt;" is
the &lt;CR&gt; key.  |&lt;&gt;|)</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">864</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="152">
        <source>5.8 Tooltips &amp; Menu tips</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">869</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="153">
        <source>See section |42.4| in the user manual.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">871</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="154">
        <source>							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	Define a tip for a menu or tool.  {only in
				X11 and Win32 GUI}</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">873</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="155">
        <source>:tm[enu] [menupath]		List menu tips. {only in X11 and Win32 GUI}</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">877</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="156">
        <source>							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		Remove a tip for a menu or tool.
				{only in X11 and Win32 GUI}</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">879</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="157">
        <source>When a tip is defined for a menu item, it appears in the command-line area
when the mouse is over that item, much like a standard Windows menu hint in
the status bar.  (Except when Vim is in Command-line mode, when of course
nothing is displayed.)
When a tip is defined for a ToolBar item, it appears as a tooltip when the
mouse pauses over that button, in the usual fashion.  Use the |hl-Tooltip|
highlight group to change its colors.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">883</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="158">
        <source>A "tip" can be defined for each menu item.  For example, when defining a menu
item like this: &gt;
	:amenu MyMenu.Hello :echo "Hello"&lt;CR&gt;
The tip is defined like this: &gt;
	:tmenu MyMenu.Hello Displays a greeting.
And delete it with: &gt;
	:tunmenu MyMenu.Hello</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">891</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="159">
        <source>Tooltips are currently only supported for the X11 and Win32 GUI.  However, they
should appear for the other gui platforms in the not too distant future.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">899</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="160">
        <source>The ":tmenu" command works just like other menu commands, it uses the same
arguments.  ":tunmenu" deletes an existing menu tip, in the same way as the
other unmenu commands.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">902</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="161">
        <source>If a menu item becomes invalid (i.e. its actions in all modes are deleted) Vim
deletes the menu tip (and the item) for you.  This means that :aunmenu deletes
a menu item - you don't need to do a :tunmenu as well.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">906</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="162">
        <source>5.9 Popup Menus</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">911</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="163">
        <source>In the Win32 and GTK+ GUI, you can cause a menu to popup at the cursor.
This behaves similarly to the PopUp menus except that any menu tree can
be popped up.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">913</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="164">
        <source>This command is for backwards compatibility, using it is discouraged, because
it behaves in a strange way.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">917</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="165">
        <source>							*:popup* *:popu*
:popu[p] {name}			Popup the menu {name}.  The menu named must
				have at least one subentry, but need not
				appear on the menu-bar (see |hidden-menus|).
				{only available for Win32 and GTK GUI}</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">920</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="166">
        <source>:popu[p]! {name}		Like above, but use the position of the mouse
				pointer instead of the cursor.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">926</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="167">
        <source>Example: &gt;
	:popup File
will make the "File" menu (if there is one) appear at the text cursor (mouse
pointer if ! was used). &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">929</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="168">
        <source>	:amenu ]Toolbar.Make	:make&lt;CR&gt;
	:popup ]Toolbar
This creates a popup menu that doesn't exist on the main menu-bar.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">934</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="169">
        <source>Note that a menu that starts with ']' will not be displayed.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">938</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="170">
        <source>==============================================================================
6. Extras						*gui-extras*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">940</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="171">
        <source>This section describes other features which are related to the GUI.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">943</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="172">
        <source>- With the GUI, there is no wait for one second after hitting escape, because
  the key codes don't start with &lt;Esc&gt;.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">945</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="173">
        <source>- Typing ^V followed by a special key in the GUI will insert "&lt;Key&gt;", since
  the internal string used is meaningless.  Modifiers may also be held down to
  get "&lt;Modifiers-Key&gt;".</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">948</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="174">
        <source>- In the GUI, the modifiers SHIFT, CTRL, and ALT (or META) may be used within
  mappings of special keys and mouse events.  E.g.: :map &lt;M-LeftDrag&gt; &lt;LeftDrag&gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">952</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="175">
        <source>- In the GUI, several normal keys may have modifiers in mappings etc, these
  are &lt;Space&gt;, &lt;Tab&gt;, &lt;NL&gt;, &lt;CR&gt;, &lt;Esc&gt;.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">955</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="176">
        <source>- To check in a Vim script if the GUI is being used, you can use something
  like this: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">958</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="177">
        <source>	if has("gui_running")
	   echo "yes, we have a GUI"
	else
	   echo "Boring old console"
	endif
&lt;							*setting-guifont*
- When you use the same vimrc file on various systems, you can use something
  like this to set options specifically for each type of GUI: &gt;</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">961</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="178">
        <source>	if has("gui_running")
	    if has("gui_gtk2")
		:set guifont=Luxi\ Mono\ 12
	    elseif has("x11")
		" Also for GTK 1
		:set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
	    elseif has("gui_win32")
		:set guifont=Luxi_Mono:h12:cANSI
	    endif
	endif</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">970</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="179">
        <source>A recommended Japanese font is MS Mincho.  You can find info here:
http://www.lexikan.com/mincho.htm</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">981</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="180">
        <source>==============================================================================
7. Shell Commands					*gui-shell*</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">984</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="181">
        <source>For the X11 GUI the external commands are executed inside the gvim window.
See |gui-pty|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">987</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="182">
        <source>WARNING: Executing an external command from the X11 GUI will not always
work.  "normal" commands like "ls", "grep" and "make" mostly work fine.
Commands that require an intelligent terminal like "less" and "ispell" won't
work.  Some may even hang and need to be killed from another terminal.  So be
careful!</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">990</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="183">
        <source>For the Win32 GUI the external commands are executed in a separate window.
See |gui-shell-win32|.</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">996</context>
        </context-group>
      </trans-unit>
      <trans-unit xml:space="preserve" id="184">
        <source> vim:tw=78:sw=4:ts=8:ft=help:norl:</source>
        <target></target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">gui.txt</context>
          <context context-type="linenumber">999</context>
        </context-group>
      </trans-unit>
    </body>
  </file>
</xliff>
