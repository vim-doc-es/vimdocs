<?xml version='1.0' encoding='utf-8'?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.1" version="1.1">
  <file original="po/usr_41.txt.po" source-language="en-US" datatype="plaintext">
    <body>
      <trans-unit xml:space="preserve" id="1" approved="no" restype="x-gettext-domain-header">
        <source>Project-Id-Version: Vim 7.3
Report-Msgid-Bugs-To: vim@bugs.org
POT-Creation-Date: 2010-12-09 16:51+0100
PO-Revision-Date: 2011-02-26 19:16+0200
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: vim-doc-es
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.7.0-beta4
X-Project-Style: default
</source>
        <target state="translated">Project-Id-Version: Vim 7.3
Report-Msgid-Bugs-To: vim@bugs.org
POT-Creation-Date: 2010-12-09 16:51+0100
PO-Revision-Date: 2011-02-26 19:16+0200
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: vim-doc-es
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.7.0-beta4
X-Project-Style: default
</target>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">Spanish translations for Vim package
Copyright (C) 2010 Free Software Foundation, Inc.
This file is distributed under the same license as the Vim package.
Automatically generated, 2010.
Omar Campagne &lt;ocampagne@gmail.com&gt;, 2011.</context>
        </context-group>
        <note from="po-translator">Spanish translations for Vim package
Copyright (C) 2010 Free Software Foundation, Inc.
This file is distributed under the same license as the Vim package.
Automatically generated, 2010.
Omar Campagne &lt;ocampagne@gmail.com&gt;, 2011.</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="2" approved="yes">
        <source>==============================================================================
</source>
        <target state="translated">==============================================================================
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">18</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">79</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">180</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">290</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">518</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">596</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">689</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">817</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">880</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">7</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">58</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">172</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">281</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">340</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">352</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">19</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">50</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">100</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">181</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">25</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">69</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">130</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">179</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">307</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">369</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">406</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">560</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">74</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">101</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">147</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">172</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">223</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">265</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">491</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">552</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">650</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">74</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">160</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">194</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">324</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">360</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">390</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">446</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">469</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">510</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">63</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">219</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">418</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">467</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">506</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">621</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">50</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">135</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">189</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">270</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">276</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">63</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">179</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">316</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">404</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">444</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">475</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">26</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">82</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">109</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">161</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">215</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">278</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">337</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">477</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">509</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">597</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">124</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">175</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">259</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">285</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">342</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">378</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">547</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">621</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">667</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">692</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">820</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">82</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">288</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">303</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">25</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">90</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">131</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">177</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">202</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">231</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">281</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">309</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">113</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">158</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">285</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">327</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">380</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">47</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">87</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">236</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">385</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">438</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">495</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">148</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">213</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">272</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">396</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">114</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">156</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">238</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">324</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">339</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">96</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">119</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">268</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">305</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">336</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">369</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">493</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">537</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">583</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">602</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">132</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">210</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">287</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">453</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">574</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">46</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">103</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">136</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">217</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">26</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">88</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">136</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">350</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">427</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">469</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">510</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">559</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">54</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">121</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">185</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">211</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">315</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">331</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">375</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">389</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">422</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">273</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">441</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">570</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">609</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">202</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">336</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">409</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">515</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">639</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">81</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">133</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">160</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">208</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">268</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">44</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">92</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">140</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">176</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">20</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">279</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">424</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">653</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">33</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">133</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">267</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">345</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">482</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">532</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">877</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1104</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1390</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1447</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1617</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2038</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2224</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2270</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2346</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2410</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2425</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">140</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">254</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">293</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">361</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">214</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">288</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">341</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">417</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">494</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="3" approved="yes">
        <source>		     VIM USER MANUAL - by Bram Moolenaar
</source>
        <target state="translated">		MANUAL DE USUARIO DE VIM - por Bram Moolenaar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="4" approved="yes">
        <source>Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:</source>
        <target state="translated">Copyright: consulte |manual-copyright| vim:tw=78:ts=8:ft=help:norl:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">185</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">564</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">654</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">514</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">625</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">479</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">601</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">289</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">824</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">307</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">358</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">384</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">499</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">400</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">343</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">606</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">578</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">563</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">426</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">613</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">643</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">272</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">180</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">657</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2429</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">365</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">498</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="5" approved="yes">
        <source>OPTIONS</source>
        <target state="translated">OPCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">153</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">168</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2085</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="6" approved="yes">
        <source>*usr_41.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</source>
        <target state="translated">*usr_41.esx*	Para Vim versión 7.3.  Último cambio: 20/7/2010
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="7" approved="yes">
        <source>			      Write a Vim script
</source>
        <target state="translated">			     Escribir scripts para Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">6</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="8" approved="yes">
        <source>The Vim script language is used for the startup vimrc file, syntax files, and many other things.  This chapter explains the items that can be used in a Vim script.  There are a lot of them, thus this is a long chapter.</source>
        <target state="translated">El lenguaje de programación de Vim se usa en el archivo de arranque vimrc, los archivos de sintaxis, y muchas otras cosas. Este capítulo presenta y explica en detalle los elementos que componen un script de Vim. Hay muchos de ellos, por lo que éste es un capítulo largo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">11</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="9" approved="yes">
        <source>|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts
</source>
        <target state="translated">|41.1|	Introducción
|41.2|	Variables
|41.3|	Expresiones
|41.4|	Estructuras de decisión
|41.5|	Ejecución de expresiones
|41.6|	Funciones
|41.7|	Definición de funciones
|41.8|	Listas y Diccionarios
|41.9|	Excepciones
|41.10|	Observaciones
|41.11|	Escribir extensiones
|41.12|	Escribir extensiones para tipo de archivo
|41.13|	Escribir extensiones para compiladores
|41.14|	Escribir extensiones que carguen rápidamente
|41.15|	Escribir bibliotecas
|41.16|	Distribuir scripts de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="10" approved="yes">
        <source>     Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|
</source>
        <target state="translated"> Capítulo siguiente: |usr_42.esx|  Añadir menús nuevos
  Capítulo anterior: |usr_40.esx|  Crear órdenes nuevas
Tabla de contenidos: |usr_toc.txt|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">32</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="11" approved="yes">
        <source>*41.1*	Introduction				*vim-script-intro* *script*
</source>
        <target state="translated">*41.1*	Introducción				*vim-script-intro* *script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">35</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="12" approved="yes">
        <source>Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
":"; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.
</source>
        <target state="translated">Su primer acercamiento a los scripts de Vim es el archivo vimrc. Vim lo lee en
el arranque y ejecuta las órdenes que se encuentren ahí. En este archivo puede
dar el valor que prefiera a las opciones existentes, así como usar
cualquier orden (algunas veces se hace referencia a las órdenes que empiezan
con «:» como órdenes Ex, o simplemente órdenes).
   Los archivos de sintaxis también son scripts de Vim, porque son archivos en
los que se configuran opciones para un tipo de archivo particular. Es posible
definir una macro complicada en un archivo Vim separado. También puede
idear otros usos.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">43</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="13" approved="yes">
        <source>Let's start with a simple example: &gt;</source>
        <target state="translated">Empecemos con un ejemplo sencillo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">45</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="14" approved="yes">
        <source>	:let i = 1
	:while i &lt; 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
&lt;
	Note:
	The ":" characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim script file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"
</source>
        <target state="translated">	:let i = 1
	:while i &lt; 5
	:  echo "cuenta es" i
	:  let i += 1
	:endwhile
&lt;
	Nota:
	En realidad en el ejemplo de arriba los caracteres «:» no son
	necesarios. Sólo es necesario su uso al escribir una orden. En los
	archivos de script de Vim es posible omitirlos. Aquí se muestran para
	evidenciar que son órdenes de la línea de órdenes, y no órdenes del
	modo Normal.
	Nota:
	Puede probar los ejemplos que se muestran aquí copiando el texto
	correspondiente, y ejecutándolo con la orden «:@"»
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">60</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="15" approved="yes">
        <source>The output of the example code is:</source>
        <target state="translated">La salida generada por el ejemplo tiene el siguiente aspecto:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">62</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="16" approved="yes">
        <source>	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~
</source>
        <target state="translated">	cuenta es 1 ~
	cuenta es 2 ~
	cuenta es 3 ~
	cuenta es 4 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">67</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="17" approved="yes">
        <source>In the first line the ":let" command assigns a value to a variable.  The generic form is: &gt;</source>
        <target state="translated">En la primera línea la orden «:let» le asigna un valor a una variable. La forma genérica de hacerlo es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">70</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="18" approved="yes">
        <source>	:let {variable} = {expression}
</source>
        <target state="translated">	:let {variable} = {expresión}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">72</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="19" approved="yes">
        <source>In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is: &gt;
</source>
        <target state="translated">En este caso el nombre de la variable es «i» y la expresión es simplemente un
valor, el número uno.
   La orden «:while» inicia un ciclo. La forma genérica de esta orden es: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">76</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="20" approved="yes">
        <source>	:while {condition}
	:  {statements}
	:endwhile
</source>
        <target state="translated">	:while {condicion}
	:  {instrucciones}
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">80</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="21" approved="yes">
        <source>The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i &lt; 5".  This
is true when the variable i is smaller than five.
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
</source>
        <target state="translated">Las instrucciones hasta el «:endwhile» correspondiente se ejecutan mientras
que la {condicion} se siga cumpliendo. La condición aquí es la expresión
«i &lt; 5».  Ésta es verdadera cuando la variable i es menor a cinco.
	Nota:
	Si llega a escribir un ciclo «while» que nunca termina de ejecutarse,
	puede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">87</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="22" approved="yes">
        <source>The ":echo" command prints its arguments.  In this case the string "count is" and the value of the variable i.  Since i is one, this will print:</source>
        <target state="translated">La orden «:echo» imprime en pantalla los argumentos que se le introduzcan. En este caso son la cadena «cuenta es» y el valor de la variable i. Como i vale uno, se imprimirá:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">90</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="23" approved="yes">
        <source>	count is 1 ~
</source>
        <target state="translated">	cuenta es 1 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">92</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="24" approved="yes">
        <source>Then there is the ":let i += 1" command.  This does the same thing as ":let i = i + 1".  This adds one to the variable i and assigns the new value to the same variable.</source>
        <target state="translated">Luego está la orden «:let i += 1». Ésta tiene el mismo efecto que «:let i = i + 1». Le añade uno a la variable i y asigna el resultado a la misma variable.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">96</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="25" approved="yes">
        <source>The example was given to explain the commands, but would you really want to make such a loop it can be written much more compact: &gt;</source>
        <target state="translated">El ejemplo se dio para ilustrar las órdenes usadas; si se quisiera un ciclo con la funcionalidad mostrada, se puede escribir algo mucho más compacto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">99</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="26" approved="yes">
        <source>	:for i in range(1, 4)
	:  echo "count is" i
	:endfor
</source>
        <target state="translated">	:for i in range(1, 4)
	:  echo "cuenta es" i
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">103</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="27" approved="yes">
        <source>We won't explain how |:for| and |range()| work until later.  Follow the links if you are impatient.</source>
        <target state="translated">El funcionamiento de |:for| y |range()| se explicará después. Siga los enlaces si no desea esperar.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="28" approved="yes">
        <source>THREE KINDS OF NUMBERS</source>
        <target state="translated">TRES CLASES DE NÚMEROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">109</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="29" approved="yes">
        <source>Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
number, it will be interpreted as an octal number!
   The ":echo" command always prints decimal numbers.  Example: &gt;
</source>
        <target state="translated">Los números pueden ser decimales, hexadecimales, u octales. Un número
hexadecimal empieza con «0x» o «0X». Por ejemplo, «0x1f» es 31 en decimal. Un
número octal empieza con cero. «017» es 15 en decimal. Tenga cuidado: no ponga
ceros al comienzo de un número decimal, ¡será interpretado como un octal!
   La orden «:echo» siempre muestra los números como decimales. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">115</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="30" approved="yes">
        <source>	:echo 0x7f 036
&lt;	127 30 ~
</source>
        <target state="translated">	:echo 0x7f 036
&lt;	127 30 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">118</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="31" approved="yes">
        <source>A number is made negative with a minus sign.  This also works for hexadecimal
and octal numbers.   A minus sign is also used for subtraction.  Compare this
with the previous example: &gt;
</source>
        <target state="translated">Se pueden obtener números negativos añadiéndoles un signo de resta. Esto funciona
también para números octales y hexadecimales. El signo menos también se usa
para la substracción. Compare lo siguiente con el ejemplo anterior: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">122</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="32" approved="yes">
        <source>	:echo 0x7f -036
&lt;	97 ~
</source>
        <target state="translated">	:echo 0x7f -036
&lt;	97 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">125</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="33" approved="yes">
        <source>White space in an expression is ignored.  However, it's recommended to use it for separating items, to make the expression easier to read.  For example, to avoid the confusion with a negative number above, put a space between the minus sign and the following number: &gt;</source>
        <target state="translated">En las expresiones se ignoran los espacios en blanco. Sin embargo, es recomendable usarlo para separar elementos, para hacer que las expresiones sean más legibles. Por ejemplo, para evitar confundir el ejemplo anterior con un número negativo, ponga un espacio entre el signo de resta y el número que lo sigue: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">130</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="34" approved="yes">
        <source>	:echo 0x7f - 036
</source>
        <target state="translated">	:echo 0x7f - 036
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">132</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="35" approved="yes">
        <source>*41.2*	Variables
</source>
        <target state="translated">*41.2*	Variables
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">135</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="36" approved="yes">
        <source>A variable name consists of ASCII letters, digits and the underscore.  It cannot start with a digit.  Valid variable names are:</source>
        <target state="translated">Los nombres de variables pueden consistir de las letras del código ASCII, dígitos, y el guión bajo. No pueden empezar con dígitos. Los siguientes son nombres válidos de variables:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">138</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="37" approved="yes">
        <source>	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH
</source>
        <target state="translated">	contador
	_aap3
	nombre_de_variable_largo_con_guion_bajo
	FuncLongitud
	LONGITUD
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="38" approved="yes">
        <source>Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command: &gt;
</source>
        <target state="translated">«foo+bar» y «6var» no son nombres válidos.
   Estas variables son globales. Para ver un listado de las variables
definidas actualmente, use la siguiente orden: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">148</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="39" approved="yes">
        <source>	:let
</source>
        <target state="translated">	:let
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">150</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="40" approved="yes">
        <source>You can use global variables everywhere.  This also means that when the variable "count" is used in one script file, it might also be used in another file.  This leads to confusion at least, and real problems at worst.  To avoid this, you can use a variable local to a script file by prepending "s:".  For example, one script contains this code: &gt;</source>
        <target state="translated">Puede usar variables globales en cualquier parte. Esto implica que cuando usa la variable «cuenta» en un archivo, ésta también puede ser usada en otro archivo, lo que al menos crea confusión, y en el peor de los casos genera problemas reales. Para evitar este problema, puede declarar variables como locales respecto al archivo del script, anteponiendo «s:» a su nombre. Por ejemplo, considere un script con las siguientes instrucciones: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">156</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="41" approved="yes">
        <source>	:let s:count = 1
	:while s:count &lt; 5
	:  source other.vim
	:  let s:count += 1
	:endwhile
</source>
        <target state="translated">	:let s:cuenta = 1
	:while s:cuenta &lt; 5
	:  source otro.vim
	:  let s:cuenta += 1
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">162</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="42" approved="yes">
        <source>Since "s:count" is local to this script, you can be sure that sourcing the "other.vim" script will not change this variable.  If "other.vim" also uses an "s:count" variable, it will be a different copy, local to that script.  More about script-local variables here: |script-variable|.</source>
        <target state="translated">Ya que el ámbito de «s:cuenta» es local al script, puede estar seguro de que cargar el archivo «otro.vim» no hará cambios a dicha variable. Si «otro.vim» también usa una variable «s:cuenta», será una copia distinta, local al ámbito de ese script. Puede encontrar más información acerca de las variables locales a un script en |script-variable|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">167</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="43" approved="yes">
        <source>There are more kinds of variables, see |internal-variables|.  The most often used ones are:</source>
        <target state="translated">Existen más clases de variables, consulte |internal-variables|. Las que se usan más frecuentemente son:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">170</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="44" approved="yes">
        <source>	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim
</source>
        <target state="translated">	b:nombre		variable local a un búfer
	w:nombre		variable local a una ventana
	g:nombre		variable global (incluso dentro de funciones)
	v:nombre		variable predeterminada por Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">175</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="45" approved="yes">
        <source>DELETING VARIABLES</source>
        <target state="translated">ELIMINAR VARIABLES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">178</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="46" approved="yes">
        <source>Variables take up memory and show up in the output of the ":let" command.  To delete a variable use the ":unlet" command.  Example: &gt;</source>
        <target state="translated">Las variables que aparecen en el listado que genera la orden «:let» consumen recursos de memoria. Para eliminar una variable use la orden «:unlet». Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">181</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="47" approved="yes">
        <source>	:unlet s:count
</source>
        <target state="translated">	:unlet s:cuenta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">183</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="48" approved="yes">
        <source>This deletes the script-local variable "s:count" to free up the memory it uses.  If you are not sure if the variable exists, and don't want an error message when it doesn't, append !: &gt;</source>
        <target state="translated">Esta orden elimina la variable «s:count», local al script actual, para liberar la memoria que ésta usa. Si no está seguro de que una variable exista, y no quiere obtener mensajes de error si no existe, añada ! a la orden: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">187</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="49" approved="yes">
        <source>	:unlet! s:count
</source>
        <target state="translated">	:unlet! s:cuenta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">189</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="50" approved="yes">
        <source>When a script finishes, the local variables used there will not be automatically freed.  The next time the script executes, it can still use the old value.  Example: &gt;</source>
        <target state="translated">Cuando la ejecución de un script termina, no se liberan automáticamente los recursos usados por sus variables locales. La próxima vez que se ejecute el script, los valores antiguos estarán disponibles. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">193</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="51" approved="yes">
        <source>	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"
</source>
        <target state="translated">	:if !exists("s:cuenta_llamadas")
	:  let s:cuenta_llamadas = 0
	:endif
	:let s:cuenta_llamadas = s:cuenta_llamadas + 1
	:echo "llamado" s:cuenta_llamadas "veces"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">199</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="52" approved="yes">
        <source>The "exists()" function checks if a variable has already been defined.  Its argument is the name of the variable you want to check.  Not the variable itself! If you would do this: &gt;</source>
        <target state="translated">La función «exists()» comprueba la existencia de una variable. Recibe como argumento el nombre de la variable a comprobar. ¡No la variable como tal! Si intenta esto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">203</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="53" approved="yes">
        <source>	:if !exists(s:call_count)
</source>
        <target state="translated">	:if !exists(s:cuenta_llamadas)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">205</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="54" approved="yes">
        <source>Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
	Note:
	Vim automatically converts a string to a number when it is looking for
	a number.  When using a string that doesn't start with a digit the
	resulting number is zero.  Thus look out for this: &gt;
		:if "true"
&lt;	The "true" will be interpreted as a zero, thus as false!
</source>
        <target state="translated">El valor de «s:cuenta_llamadas» se usará como el nombre de variable que
exists() revisará. Ése no es el efecto esperado.
   El símbolo de exclamación ! niega un valor. Cuando un valor es verdadero,
se vuelve falso. Cuando es falso, se vuelve verdadero. Puede leer este símbolo
como «not» (negación lógica). Así, «if !exists()» se lee como «if not
exists()».
   Vim considera como verdadero cualquier valor distinto de cero. Cero
equivale a falso.
	Nota:
	Vim convierte las cadenas de texto a números de manera automática
	cuando se espera un número. Cuando se hace esta conversión con una
	cadena que no empieza con un dígito el número resultante es cero.
	Debido a esto, tenga cuidado con instrucciones como: &gt;
		:if "verdadero"
&lt;	en este caso, la cadena «verdadero» será interpretada como un cero, ¡y
	por tanto como falso!
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">218</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="55" approved="yes">
        <source>STRING VARIABLES AND CONSTANTS</source>
        <target state="translated">VARIABLES CADENAS DE TEXTO Y CONSTANTES CADENAS DE TEXTO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="56" approved="yes">
        <source>So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes: &gt;
</source>
        <target state="translated">Hasta ahora sólo se han usado números como valores de variables. También es
posible usar cadenas de texto. Los tipos básicos de variables que Vim soporta
son números y cadenas. El tipo de cada variable es dinámico, y se fija cada
vez que se asigna un valor a una variable mediante «:let». Refiérase a |41.8|
para más información acerca de tipos.
   Para asignar un valor de tipo cadena a una variable, debe usar una
constante de cadena. Hay dos tipos de estas constantes. El primero es la
cadena con comillas dobles: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">228</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="57" approved="yes">
        <source>	:let name = "peter"
	:echo name
&lt;	peter ~
</source>
        <target state="translated">	:let nombre = "pedro"
	:echo nombre
&lt;	pedro ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">232</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="58" approved="yes">
        <source>If you want to include a double quote inside the string, put a backslash in front of it: &gt;</source>
        <target state="translated">Si quiere incluir una comilla doble en el contenido de la cadena, ponga una barra inversa antes de la misma: &gt; </target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="59" approved="yes">
        <source>	:let name = "\"peter\""
	:echo name
&lt;	"peter" ~
</source>
        <target state="translated">	:let nombre = "\"pedro\""
	:echo nombre
&lt;	"pedro" ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="60" approved="yes">
        <source>To avoid the need for a backslash, you can use a string in single quotes: &gt;</source>
        <target state="translated">Para evitar el uso de la barra inversa, puede usar una cadena con comillas sencillas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">241</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="61" approved="yes">
        <source>	:let name = '"peter"'
	:echo name
&lt;	"peter" ~
</source>
        <target state="translated">	:let nombre = '"pedro"'
	:echo nombre
&lt;	"pedro" ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="62" approved="yes">
        <source>Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:
</source>
        <target state="translated">En una cadena de comillas sencillas todos los caracteres tienen solamente su
significado literal. Sólo la comilla sencilla es especial: debe usar dos
seguidas para obtener una dentro de una cadena. La barra inversa se considera
literalmente, por lo que no es posible usarla para cambiar el significado del
carácter después de ella.
   En las cadenas de comillas dobles es posible usar caracteres especiales. A
continuación algunos de los más usados:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">252</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="63" approved="yes">
        <source>	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, line break
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, backspace
	\"		"
	\\		\, backslash
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</source>
        <target state="translated">	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, salto de línea
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, retroceso
	\"		"
	\\		\, barra inversa
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">262</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="64" approved="yes">
        <source>The last two are just examples.  The  "\&lt;name&gt;" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.
</source>
        <target state="translated">Los últimos dos sólo son ejemplos. Se puede usar la forma «\&lt;nombre&gt;» para
incluir la tecla «nombre».
   Consulte |expr-quote| para ver la lista completa de elementos especiales
en una cadena de texto.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="65" approved="yes">
        <source>*41.3*	Expressions
</source>
        <target state="translated">*41.3*	Expresiones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="66" approved="yes">
        <source>Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:
</source>
        <target state="translated">Vim tiene una forma expresiva, pero sencilla, de manejar expresiones. Puede
leer la definición aquí: |expression-syntax|. A continuación mostraremos
algunos de los elementos más comunes.
   Los números, cadenas, y las variables mencionadas anteriormente son
expresiones por sí mismas. Así que, en donde sea que se espere una expresión,
puede usar un número, una cadena, o una variable. Otros de los elementos
comunes en una expresión son:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">276</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="67" approved="yes">
        <source>	$NAME		environment variable
	&amp;name		option
	@r		register
</source>
        <target state="translated">	$NOMBRE		variable de entorno
	&amp;nombre		opción
	@r		registro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="68" approved="yes">
        <source>Examples: &gt;</source>
        <target state="translated">Ejemplos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">282</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="69" approved="yes">
        <source>	:echo "The value of 'tabstop' is" &amp;ts
	:echo "Your home directory is" $HOME
	:if @a &gt; 5
</source>
        <target state="translated">	:echo "El valor de 'tabstop' es" &amp;ts
	:echo "Su directorio personal es" $HOME
	:if @a &gt; 5
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">286</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="70" approved="yes">
        <source>The &amp;name form can be used to save an option value, set it to a new value, do something and restore the old value.  Example: &gt;</source>
        <target state="translated">Puede usar la forma «&amp;nombre» para guardar el valor de una opción, fijarla a un nuevo valor, hacer algo, y restaurar el valor original. Por ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">289</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="71" approved="yes">
        <source>	:let save_ic = &amp;ic
	:set noic
	:/The Start/,$delete
	:let &amp;ic = save_ic
</source>
        <target state="translated">	:let ic_orig = &amp;ic
	:set noic
	:/El Principio/,$delete
	:let &amp;ic = ic_orig
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">294</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="72" approved="yes">
        <source>This makes sure the "The Start" pattern is used with the 'ignorecase' option off.  Still, it keeps the value that the user had set.  (Another way to do this would be to add "\C" to the pattern, see |/\C|.)</source>
        <target state="translated">Con esto se asegura que el patrón «El Principio» se buscará con la opción 'ignorecase' desactivada. Sin embargo, se conserva y restaura el valor que el usuario definió para la opción. (Otra forma de hacer esta búsqueda es añadir «\C» al patrón, consulte |/\C|.)</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">298</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="73" approved="yes">
        <source>MATHEMATICS</source>
        <target state="translated">MATEMÁTICAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">301</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="74" approved="yes">
        <source>It becomes more interesting if we combine these basic items.  Let's start with mathematics on numbers:</source>
        <target state="translated">Las cosas se hacen más interesantes si combinamos estos elementos básicos. Empecemos con operaciones matemáticas sobre números:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="75" approved="yes">
        <source>	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo
</source>
        <target state="translated">	a + b		adición
	a - b		sustracción
	a * b		multiplicación
	a / b		división
	a % b		módulo (residuo)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">310</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="76" approved="yes">
        <source>The usual precedence is used.  Example: &gt;</source>
        <target state="translated">Se maneja la precendencia de operadores usual. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">312</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="77" approved="yes">
        <source>	:echo 10 + 5 * 2
&lt;	20 ~
</source>
        <target state="translated">	:echo 10 + 5 * 2
&lt;	20 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">315</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="78" approved="yes">
        <source>Grouping is done with braces.  No surprises here.  Example: &gt;</source>
        <target state="translated">Puede cambiar la precendencia de las operaciones usando paréntesis. Esto no es nada nuevo.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">317</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO file bug on vim's documentation. Parentheses, not braces</context>
        </context-group>
        <note from="po-translator">TODO file bug on vim's documentation. Parentheses, not braces</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="79" approved="yes">
        <source>	:echo (10 + 5) * 2
&lt;	30 ~
</source>
        <target state="translated">	:echo (10 + 5) * 2
&lt;	30 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="80" approved="yes">
        <source>Strings can be concatenated with ".".  Example: &gt;</source>
        <target state="translated">Puede unir cadenas usando «.». Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">322</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="81" approved="yes">
        <source>	:echo "foo" . "bar"
&lt;	foobar ~
</source>
        <target state="translated">	:echo "foo" . "bar"
&lt;	foobar ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">325</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="82" approved="yes">
        <source>When the ":echo" command gets multiple arguments, it separates them with a space.  In the example the argument is a single expression, thus no space is inserted.</source>
        <target state="translated">Cuando recibe varios argumentos, la orden «:echo» los muestra en pantalla separados con espacios. En el ejemplo anterior el argumento es una única expresión, por lo que no se insertan espacios.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">329</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="83" approved="yes">
        <source>Borrowed from the C language is the conditional expression:</source>
        <target state="translated">Del lenguaje C se tomó la expresión condicional:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">331</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="84" approved="yes">
        <source>	a ? b : c
</source>
        <target state="translated">	a ? b : c
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">333</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="85" approved="yes">
        <source>If "a" evaluates to true "b" is used, otherwise "c" is used.  Example: &gt;</source>
        <target state="translated">Si «a» se evalúa como verdadero, la expresión corresponderá a «b», y en caso contrario a «c». Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">335</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="86" approved="yes">
        <source>	:let i = 4
	:echo i &gt; 5 ? "i is big" : "i is small"
&lt;	i is small ~
</source>
        <target state="translated">	:let i = 4
	:echo i &gt; 5 ? "i es grande" : "i es pequeño"
&lt;	i es pequeño ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">339</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="87" approved="yes">
        <source>The three parts of the constructs are always evaluated first, thus you could see it work as:</source>
        <target state="translated">Los tres elementos de la expresión condicional siempre son evaluados; es conveniente verlos de la siguiente forma:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">342</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="88" approved="yes">
        <source>	(a) ? (b) : (c)
</source>
        <target state="translated">	(a) ? (b) : (c)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">344</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="89" approved="yes">
        <source>*41.4*	Conditionals
</source>
        <target state="translated">*41.4*	Estructuras de decisión
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">347</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="90" approved="yes">
        <source>The ":if" commands executes the following statements, until the matching ":endif", only when a condition is met.  The generic form is:</source>
        <target state="translated">La orden «:if» ejecuta las órdenes a continuación de ella, hasta el «:endif» correspondiente, cuando se cumple la condición especificada. La forma genérica es:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">350</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="91" approved="yes">
        <source>	:if {condition}
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</context>
        </context-group>
        <note from="po-translator">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="92" approved="yes">
        <source>Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the ":endif".
   You can also use ":else".  The generic form for this is:
</source>
        <target state="translated">Las {instrucciones} se ejecutan únicamente cuando la expresión {condicion} es
verdadera, esto es, diferente de cero. Dichas instrucciones deben ser órdenes
válidas. Si las órdenes tienen errores de sintaxis, Vim no podrá encontrar el
«:endif» correspondiente.
   También puede usar «:else». La forma genérica es:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">359</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="93" approved="yes">
        <source>	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:else
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">365</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</context>
        </context-group>
        <note from="po-translator">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="94" approved="yes">
        <source>The second {statements} is only executed if the first one isn't.
   Finally, there is ":elseif":
</source>
        <target state="translated">El segundo grupo de {instrucciones} sólo se ejecuta si el primero no lo hace.
   Finalmente, está «:elseif»
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">368</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="95" approved="yes">
        <source>	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:elseif {condicion}
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">374</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="96" approved="yes">
        <source>This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: &gt;
</source>
        <target state="translated">Esta orden funciona como «:else» seguido de «:if», pero tiene la ventaja de no
requerir un «:endif» adicional.
   Un ejemplo útil que podría usar en su archivo vimrc es comprobar la opción
'term' y ejecutar órdenes diferentes de acuerdo a su valor: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">379</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="97" approved="yes">
        <source>	:if &amp;term == "xterm"
	:  " Do stuff for xterm
	:elseif &amp;term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif
</source>
        <target state="translated">	:if &amp;term == "xterm"
	:  " Configuración para xterm
	:elseif &amp;term == "vt100"
	:  " Configuración para la terminal vt100
	:else
	:  " Configuración para otras terminales
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="98" approved="yes">
        <source>LOGIC OPERATIONS</source>
        <target state="translated">OPERACIONES LÓGICAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">390</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="99" approved="yes">
        <source>We already used some of them in the examples.  These are the most often used ones:</source>
        <target state="translated">Ya hemos usado algunas de ellas en los ejemplos anteriores. A continuación listamos las más utilizadas:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">393</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="100" approved="yes">
        <source>	a == b		equal to
	a != b		not equal to
	a &gt;  b		greater than
	a &gt;= b		greater than or equal to
	a &lt;  b		less than
	a &lt;= b		less than or equal to
</source>
        <target state="translated">	a == b		igual a
	a != b		diferente de
	a &gt;  b		mayor que
	a &gt;= b		mayor o igual a
	a &lt;  b		menor que
	a &lt;= b		menor o igual a
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">400</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="101" approved="yes">
        <source>The result is one if the condition is met and zero otherwise.  An example: &gt;</source>
        <target state="translated">El resultado es uno si la condición se cumple, y cero en caso contrario. Por ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">402</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="102" approved="yes">
        <source>	:if v:version &gt;= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif
</source>
        <target state="translated">	:if v:version &gt;= 700
	:  echo "felicitaciones"
	:else
	:  echo "¡está usando una versión vieja, actualícese!"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">408</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="103" approved="yes">
        <source>Here "v:version" is a variable defined by Vim, which has the value of the Vim version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is very useful to write a script that works with multiple versions of Vim.  |v:version|</source>
        <target state="translated">La variable «v:version» es definida por Vim, y contiene el número de versión de Vim. 600 corresponde a la versión 6.0. La versión 6.1 tiene el valor 601. Esta variable es útil para escribir scripts que funcionen con distintas versiones de Vim. |v:version|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">413</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="104" approved="yes">
        <source>The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example: &gt;
</source>
        <target state="translated">Los operadores lógicos funcionan con números y con cadenas de texto. Al
comparar dos cadenas, se trabaja con la diferencia matemática de las mismas.
Esto compara valores de bytes, lo que para algunos idiomas puede no entregar
resultados correctos.
   Al comparar cadenas con números, la cadena es convertida a un número antes
de hacer la comparación. Debe tener en cuenta que, cuando el contenido de una
cadena no se asemeja a un número, se usa el número cero. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">420</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="105" approved="yes">
        <source>	:if 0 == "one"
	:  echo "yes"
	:endif
</source>
        <target state="translated">	:if 0 == "uno"
	:  echo "sí"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">424</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="106" approved="yes">
        <source>This will echo "yes", because "one" doesn't look like a number, thus it is converted to the number zero.</source>
        <target state="translated">El ejemplo mostrará «sí», porque «uno» no puede ser convertido a un número, por lo que se lo convierte al número cero.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">427</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="107" approved="yes">
        <source>For strings there are two more items:</source>
        <target state="translated">Hay dos operadores más para cadenas de texto:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">429</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="108" approved="yes">
        <source>	a =~ b		matches with
	a !~ b		does not match with
</source>
        <target state="translated">	a =~ b		coincide con
	a !~ b		no coincide con
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">432</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="109" approved="yes">
        <source>The left item "a" is used as a string.  The right item "b" is used as a pattern, like what's used for searching.  Example: &gt;</source>
        <target state="translated">El operando de la izquierda, «a», se trata como una cadena. El operando de la derecha, «b», se trata como un patrón para una búsqueda de texto. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">435</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="110" approved="yes">
        <source>	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif
</source>
        <target state="translated">	:if str =~ " "
	:  echo "str contiene un espacio"
	:endif
	:if str !~ '\.$'
	:  echo "str no termina con punto final"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">442</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="111" approved="yes">
        <source>Notice the use of a single-quote string for the pattern.  This is useful, because backslashes would need to be doubled in a double-quote string and patterns tend to contain many backslashes.</source>
        <target state="translated">Tenga en cuenta el uso de una cadena de comillas sencillas como patrón de búsqueda. En este caso es útil porque las barras inversas tendrían que insertarse por partida doble en una cadena de comillas dobles, y los patrones de búsqueda suelen contener muchas barras inversas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">446</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="112" approved="yes">
        <source>The 'ignorecase' option is used when comparing strings.  When you don't want that, append "#" to match case and "?" to ignore case.  Thus "==?" compares two strings to be equal while ignoring case.  And "!~#" checks if a pattern doesn't match, also checking the case of letters.  For the full table see |expr-==|.</source>
        <target state="translated">Al comparar cadenas se tiene en cuenta la opción 'ignorecase'. Si no desea este comportamiento, añada un «#» para diferenciar mayúsculas de minúsculas, o «?» para ignorar dicha diferencia. Así, «==?» compara dos cadenas sin diferenciar mayúsculas de minúsculas. «!~#» revisa la no coincidencia de un patrón, teniendo en cuenta diferencias de mayúsculas y minúsculas. Puede consultar la tabla completa de operadores de comparación en |expr-==|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">452</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="113" approved="yes">
        <source>MORE LOOPING</source>
        <target state="translated">MÁS SOBRE CICLOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">455</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="114" approved="yes">
        <source>The ":while" command was already mentioned.  Two more statements can be used in between the ":while" and the ":endwhile":</source>
        <target state="translated">Ya hemos mencionado la orden «:while». Hay dos instrucciones adicionales que pueden usarse entre «:while» y el «:endwhile» correspondiente:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">458</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="115" approved="yes">
        <source>	:continue		Jump back to the start of the while loop; the
				loop continues.
	:break			Jump forward to the ":endwhile"; the loop is
				discontinued.
</source>
        <target state="translated">	:continue		Salta hasta el inicio del ciclo «while»; el
				ciclo continúa.
	:break			Salta hasta después del «:endwhile»; provoca
				la terminación del ciclo.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">463</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="116" approved="yes">
        <source>Example: &gt;</source>
        <target state="translated">Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">465</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="117" approved="yes">
        <source>	:while counter &lt; 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</source>
        <target state="translated">	:while contador &lt; 40
	:  call hacer_algo()
	:  if opción_omitir
	:    continue
	:  endif
	:  if opción_terminado
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">476</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="118" approved="yes">
        <source>The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.</source>
        <target state="translated">La orden «:sleep» hace que Vim tome una pausa. El argumento «50m» especifica una duración de 50 milisegundos. Otro ejemplo es «:sleep 4», que especifica una pausa de cuatro segundos.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">479</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="119" approved="yes">
        <source>Even more looping can be done with the ":for" command, see below in |41.8|.</source>
        <target state="translated">La orden «:for» es otra estructura de control para iteración, consulte la sección |41.8|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">481</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="120" approved="yes">
        <source>*41.5*	Executing an expression
</source>
        <target state="translated">*41.5*	Ejecución de expresiones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">484</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="121" approved="yes">
        <source>So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable: &gt;
</source>
        <target state="translated">Hasta ahora, todas las órdenes mostradas han sido ejecutadas directamente por
Vim. La orden «:execute» permite ejecutar el resultado de una expresión. Ésta
es una forma poderosa de construir y ejecutar órdenes.
   Un ejemplo es saltar a una etiqueta, cuyo nombre está almacenado en una
variable: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">489</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="122" approved="yes">
        <source>	:execute "tag " . tag_name
</source>
        <target state="translated">	:execute "tag " . nombre_etiqueta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">491</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="123" approved="yes">
        <source>The "." is used to concatenate the string "tag " with the value of variable "tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that will be executed is: &gt;</source>
        <target state="translated">El «.» se usa para concatenar la cadena «tag » con el valor de la variable «nombre_etiqueta». Si suponemos que «nombre_etiqueta» tiene el contenido «obtener_orden», entonces la orden que se ejecutará es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">495</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="124" approved="yes">
        <source>	:tag get_cmd
</source>
        <target state="translated">	:tag obtener_orden
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">497</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="125" approved="yes">
        <source>The ":execute" command can only execute colon commands.  The ":normal" command executes Normal mode commands.  However, its argument is not an expression but the literal command characters.  Example: &gt;</source>
        <target state="translated">La orden «:execute» sólo puede ejecutar órdenes de la línea de órdenes (órdenes Ex, que empiezan con «:»). La orden «:normal» ejecuta órdenes del modo Normal. Sin embargo, su argumento no es una expresión, sino los caracteres literales de la orden. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">501</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="126" approved="yes">
        <source>	:normal gg=G
</source>
        <target state="translated">	:normal gg=G
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">503</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="127" approved="yes">
        <source>This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example: &gt;
</source>
        <target state="translated">Se mueve hasta la primera línea y formatea todas las líneas usando el operador
«=».
   Para usar «:normal» con el resultado de una expresión, debe combinar
«:execute» con dicha orden. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">507</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="128" approved="yes">
        <source>	:execute "normal " . normal_commands
</source>
        <target state="translated">	:execute "normal " . ordenes_modo_normal
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">509</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="129" approved="yes">
        <source>The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works: &gt;
</source>
        <target state="translated">La variables «ordenes_modo_normal» debe contener órdenes para el modo Normal.
   Asegúrese de que el argumento para «:normal» es una orden completa. En caso
contrario, Vim llegará al final del argumento e interrumpirá la orden. Por
ejemplo, si inicia el modo Insertar, debe salir del mismo. Lo siguiente
funciona adecuadamente: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">514</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="130" approved="yes">
        <source>	:execute "normal Inew text \&lt;Esc&gt;"
</source>
        <target state="translated">	:execute "normal Itexto nuevo \&lt;Esc&gt;"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">516</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="131" approved="yes">
        <source>This inserts "new text " in the current line.  Notice the use of the special key "\&lt;Esc&gt;".  This avoids having to enter a real &lt;Esc&gt; character in your script.</source>
        <target state="translated">Esta orden inserta «texto nuevo» en la línea actual. Observe el uso de la tecla especial «\&lt;Esc&gt;». Así se evita la necesidad de escribir un &lt;Esc&gt; real en el script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">520</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="132" approved="yes">
        <source>If you don't want to execute a string but evaluate it to get its expression value, you can use the eval() function: &gt;</source>
        <target state="translated">Si lo que quiere es no ejecutar una cadena de texto, sino evaluarla para obtener el valor de la expresión que contiene, use la función eval(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">523</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="133" approved="yes">
        <source>	:let optname = "path"
	:let optval = eval('&amp;' . optname)
</source>
        <target state="translated">	:let nomopcion = "path"
	:let valopcion = eval('&amp;' . nomopcion)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">526</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="134" approved="yes">
        <source>A "&amp;" character is prepended to "path", thus the argument to eval() is
"&amp;path".  The result will then be the value of the 'path' option.
   The same thing can be done with: &gt;
	:exe 'let optval = &amp;' . optname
</source>
        <target state="translated">Se antepone un «&amp;» a «path», y así el argumento para eval() es «&amp;path». El
resultado será el valor de la opción 'path'.
   Puede obtener el mismo resultado con: &gt;
	:exe 'let optval = &amp;' . optname
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">531</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="135" approved="yes">
        <source>*41.6*	Using functions
</source>
        <target state="translated">*24.1*	Funciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">534</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="136" approved="yes">
        <source>Vim defines many functions and provides a large amount of functionality that way.  A few examples will be given in this section.  You can find the whole list here: |functions|.</source>
        <target state="translated">Vim define muchas funciones y provee bastante funcionalidad a través de este mecanismo. Aquí daremos algunos ejemplos. La referencia para la lista completa se encuentra en |functions|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">538</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="137" approved="yes">
        <source>A function is called with the ":call" command.  The parameters are passed in between braces, separated by commas.  Example: &gt;</source>
        <target state="translated">Las funciones se llaman con la orden «:call». Los parámetros se introducen entre paréntesis, separados por comas. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">541</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="138" approved="yes">
        <source>	:call search("Date: ", "W")
</source>
        <target state="translated">	:call search("Fecha: ", "W")
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">543</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="139" approved="yes">
        <source>This calls the search() function, with arguments "Date: " and "W".  The search() function uses its first argument as a search pattern and the second one as flags.  The "W" flag means the search doesn't wrap around the end of the file.</source>
        <target state="translated">Se invoca a la función search(), con los argumentos «Fecha: » y «W». La función search() usa su primer argumento como patrón de búsqueda y el segundo como una serie de opciones. La opción «W» hace que la búsqueda termine al alcanzar el final del archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">548</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="140" approved="yes">
        <source>A function can be called in an expression.  Example: &gt;</source>
        <target state="translated">También es posible invocar funciones en expresiones.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">550</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="141" approved="yes">
        <source>	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)
</source>
        <target state="translated">	:let linea = getline(".")
	:let reempl = substitute(linea, '\a', "*", "g")
	:call setline(".", reempl)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">554</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="142" approved="yes">
        <source>The getline() function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this case "." is used, which means
the line where the cursor is.
   The substitute() function does something similar to the ":substitute"
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to: &gt;
</source>
        <target state="translated">La función getline() extrae una línea del búfer actual. Su argumento
especifica un número de línea. En este caso se usa «.», que se interpreta como
la línea en la que se encuentra el cursor.
   La función substitute() tiene un comportamiento similar al de la orden
«:substitute». El primer argumento es la cadena de texto sobre la cual operar,
el segundo es el patrón de búsqueda, el tercero la cadena de reemplazo. El
último argumento se corresponde con las opciones de búsqueda.
   La función setline() reemplaza la línea que se especifique en el primer
argumento, con la cadena que se pase en el segundo argumento. En este ejemplo
se reemplaza a la línea bajo el cursor con el resultado de substitute(). El
efecto de las tres instrucciones equivale a: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">566</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="143" approved="yes">
        <source>	:substitute/\a/*/g
</source>
        <target state="translated">	:substitute/\a/*/g
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">568</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="144" approved="yes">
        <source>Using the functions becomes more interesting when you do more work before and after the substitute() call.</source>
        <target state="translated">Usar estas funciones tiene efectos más interesantes cuando el procesamiento se realiza antes y después de invocar substitute().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">571</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="145" approved="yes">
        <source>FUNCTIONS						*function-list*
</source>
        <target state="translated">FUNCIONES						*function-list*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">574</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="146" approved="yes">
        <source>There are many functions.  We will mention them here, grouped by what they are used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on the function name to jump to detailed help on it.</source>
        <target state="translated">Vim cuenta con muchas funciones. Las mencionaremos aquí, agrupadas de acuerdo a su funcionalidad. En |functions| se encuentra una lista de ellas ordenada alfabéticamente. Puede ubicar el cursor sobre el nombre de una función y pulsar CTRL-] para ver documentación más detallada sobre ella.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">578</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="147" approved="yes">
        <source>String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in a ":substitute"
	strpart()		get part of a string
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression
</source>
        <target state="translated">Manipulación de cadenas:				*string-functions*
	nr2char()		obtiene un carácter dado su valor ASCII
	char2nr()		obtiene el número ASCII del carácter dado
	str2nr()		convierte una cadena a Número
	str2float()		convierte una cadena a Flotante
	printf()		formatea una cadena de acuerdo a elementos %
	escape()		escapa caracteres en una cadena con '\'
	shellescape()		escapa una cadena para usarse una orden de
				consola
	fnameescape()		escapa un nombre de archivo para usar en una
				orden Vim
	tr()			traduce caracteres de un conjunto a otro
	strtrans()		traduce una cadena para que se pueda imprimir
	tolower()		convierte una cadena a minúsculas
	toupper()		convierte una cadena a mayúsculas
	match()			posición en la que un patrón coincide en una
				cadena
	matchend()		posición en la que un patrón termina en una
				cadena
	matchstr()		coincidencia de un patrón en una cadena
	matchlist()		similar a matchstr() y retorna
				subcoincidencias
	stridx()		primer índice de una cadena corta dentro de
				una larga
	strridx()		último índice de una cadena corta dentro de
				una larga
	strlen()		longitud de una cadena
	substitute()		sustituye la coincidencia de un patrón con una
				cadena
	submatch()		obtiene una subcoincidencia específica en un
				«:substitute»
	strpart()		obtiene parte de una cadena
	expand()		expande palabras clave
	iconv()			convierte texto entre distintas codificaciones
	byteidx()		índice de byte de un carácter en una cadena
	repeat()		repite una cadena múltiples veces
	eval()			evalúa una cadena como expresión
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">607</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="148" approved="yes">
        <source>List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times
</source>
        <target state="translated">Manipulación de Listas:					*list-functions*
	get()			obtiene un elemento sin generar error al usar
				índices erróneos
	len()			número de elementos en una Lista
	empty()			comprueba si una Lista está vacía
	insert()		inserta un elemento en una Lista
	add()			añade un elemento a una Lista
	extend()		añade los contenidos de una Lista a otra Lista
	remove()		elimina uno o más elementos de una lista
	copy()			hace una copia superficial de una Lista
	deepcopy()		hace una copia completa de una Lista
	filter()		elimina elementos particulares de una Lista
	map()			cambia cada elemento de una Lista
	sort()			ordena una Lista
	reverse()		invierte el orden de una Lista
	split()			divide una cadena en una Lista
	join()			une los elementos de una Lista en una cadena
	range()			retorna una Lista con una secuencia de números
	string()		representación de una Lista en una cadena
	call()			invoca una función con una Lista como argumentos
	index()			índice de un valor en una Lista
	max()			valor máximo en una Lista
	min()			valor mínimo en una Lista
	count()			cuenta la cantidad de veces que un valor
				aparece en una Lista
	repeat()		repite una Lista múltiples veces
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">632</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="149" approved="yes">
        <source>Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears
</source>
        <target state="translated">Manipulación de Diccionarios:				*dict-functions*
	get()			obtiene una entrada sin generar error al usar
				claves erróneas
	len()			número de entradas en un Diccionario
	has_key()		comprueba si una clave aparece en un
				Diccionario
	empty()			comprueba si un Diccionario está vacío
	remove()		elimina una entrada de un Diccionario
	extend()		añade las entradas de un Diccionario a otro
	filter()		elimina entradas particulares de un
				Diccionario
	map()			cambia cada entrada de un Diccionario
	keys()			devuelve una Lista con las claves de un
				Diccionario
	values()		devuelve una Lista con los valores de un
				Diccionario
	items()			devuelve una Lista de pares clave-valor de un
				Diccionario
	copy()			hace una copia superficial de un Diccionario
	deepcopy()		hace una copia completa de un Diccionario
	string()		representación de cadena de un Diccionario
	max()			valor máximo en un Diccionario
	min()			valor mínimo en un Diccionario
	count()			cuenta la cantidad de veces que un valor
				aparece en un Diccionario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">651</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="150" approved="yes">
        <source>Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	atan()			arc tangent
</source>
        <target state="translated">Operaciones de punto flotante:				*float-functions*
	float2nr()		convertir Flotante a Número
	abs()			valor absoluto (también funciona para Números)
	round()			redondear
	ceil()			redondear hacia arriba (techo)
	floor()			redondear hacia abajo (piso)
	trunc()			eliminar valores después del punto decimal
	log10()			logaritmo en base 10
	pow()			valor de x elevado a la y potencia
	sqrt()			raíz cuadrada
	sin()			seno
	cos()			coseno
	atan()			arcotangente
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">665</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="151" approved="yes">
        <source>Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window &amp; tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window &amp; tab page
	garbagecollect()	possibly free memory
</source>
        <target state="translated">Variables:						*var-functions*
	type()			tipo de una variable
	islocked()		comprueba si una variable ha sido bloqueada
	function()		obtiene una referencia a función para el
				nombre de función dado
	getbufvar()		obtiene una variable de un búfer específico
	setbufvar()		define una variable en un búfer específico
	getwinvar()		obtiene una variable de una ventana específica
	gettabvar()		obtiene una variable de una pestaña específica
	gettabwinvar()		obtiene una variable de una ventana y pestaña
				específicas
	setwinvar()		define una variable en una ventana
				específica
	settabvar()		define una variable en una pestaña
				específica
	settabwinvar()		define una variable en una ventana y pestaña
				específicas
	garbagecollect()	potencialmente libera memoria
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">679</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="152" approved="yes">
        <source>Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line
</source>
        <target state="translated">Posición de marcas y del cursor:	*cursor-functions* *mark-functions*
	col()			número de columna del cursor o de una marca
	virtcol()		número de columna en pantalla del cursor o de
				una marca
	line()			número de línea del cursor o de una marca
	wincol()		número de columna de ventana del cursor
	winline()		número de línea de ventana del cursor
	cursor()		ubica el cursor en una linea/columna
	getpos()		obtiene la posición del cursor, marca, etc.
	setpos()		define la posición del cursor, marca, etc.
	byte2line()		obtiene el número de línea correspondiente a
				un índice en bytes
	line2byte()		índice en bytes correspondiente a una línea
				específica
	diff_filler()		obtiene la cantidad de líneas de relleno
				encima de una línea
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">692</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="153" approved="yes">
        <source>Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name
</source>
        <target state="translated">Manipulación de texto en el búfer actual:		*text-functions*
	getline()		obtiene una línea o lista de líneas del búfer
	setline()		reemplaza una línea del búfer
	append()		añade una línea o lista de líneas al búfer
	indent()		sangrado de una línea específica
	cindent()		sangrado de una línea de acuerdo al estilo
				para C
	lispindent()		sangrado de una línea de acuerdo al estilo
				para Lisp
	nextnonblank()		ubica la siguiente línea no vacía
	prevnonblank()		ubica la anterior línea no vacía
	search()			ubica una coincidencia para un patrón
	searchpos()		ubica una coincidencia para un patrón
	searchpair()		ubica la parte correspondiente a un
				inicio/medio/final
	searchpairpos()	ubica la parte correspondiente a un
				inicio/medio/final
	searchdecl()		busca la declaración de un nombre
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">707</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="154" approved="yes">
        <source>					*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
	getfperm()		get the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file
</source>
        <target state="translated">					*system-functions* *file-functions*
Funciones del sistema y manipulación de archivos:
	glob()			expande comodines
	globpath()	expande comodines en múltiples directorios
	findfile()		ubica un archivo en una lista de directorios
	finddir()		ubica un directorio en una lista de
				directorios
	resolve()		determina a dónde apunta un acceso o enlace
				directo
	fnamemodify()		modifica un nombre de archivo
	pathshorten()		abrevia nombres de directorio en una ruta
	simplify()		simplifica una ruta sin cambiar su significado
	executable()		comprueba si un programa ejecutable existe
	filereadable()		comprueba si se puede leer un archivo
	filewritable()		comprueba si se puede escribir a un archivo
	getfperm()		obtiene los permisos para un archivo
	getftype()		obtiene el tipo de un archivo
	isdirectory()		comprueba si un directorio existe
	getfsize()		obtiene el tamaño de un archivo
	getcwd()		obtiene el directorio de trabajo actual
	haslocaldir()		comprueba si se ha usado |:lcd| en la ventana
				actual
	tempname()		obtiene un nombre para un archivo temporal
	mkdir()			crea un nuevo directorio
	delete()		borra un archivo
	rename()		renombra un archivo
	system()		obtiene el resultado de una orden de consola
	hostname()		nombre del sistema
	readfile()		lee un archivo y devuelve una Lista de líneas
	writefile()		escribe una Lista de líneas a un archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">735</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="155" approved="yes">
        <source>Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string
</source>
        <target state="translated">Fecha y Hora:				*date-functions* *time-functions*
	getftime()		obtiene la hora de la última modificación de
				un archivo
	localtime()		obtiene la hora actual en segundos
	strftime()		convierte la hora a una cadena
	reltime()		devuelve la hora actual o el tiempo
				transcurrido desde una hora
	reltimestr()		convierte el resultado de reltime() a una
				cadena
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">742</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="156" approved="yes">
        <source>			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()		get a list of lines from the specified buffer
</source>
        <target state="translated">			*buffer-functions* *window-functions* *arg-functions*
Búferes, ventanas, y la lista de argumentos:
	argc()			número de entradas en la lista de argumentos
	argidx()		posición actual en la lista de argumentos
	argv()			obtiene un elemento de la lista de argumentos
	bufexists()		comprueba si un búfer existe
	buflisted()		comprueba si un búfer existe y está listado
	bufloaded()		comprueba si un búfer existe y está cargado
	bufname()		obtiene el nombre de un búfer específico
	bufnr()			obtiene el número de búfer de un búfer
				específico
	tabpagebuflist()	devuelve la Lista de búfers de una pestaña
	tabpagenr()		obtiene el número de una pestaña
	tabpagewinnr()		similar a winnr(), pero especificando la
				pestaña
	winnr()			obtiene el número de ventana de la ventana
				actual
	bufwinnr()		obtiene el número de ventana del búfer
				especificado
	winbufnr()		obtiene el número de búfer de una ventana
				específica
	getbufline()		obtiene una lista de líneas del búfer
				especificado
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">760</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="157" approved="yes">
        <source>Command line:					*command-line-functions*
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type
</source>
        <target state="translated">Línea de órdenes:				*command-line-functions*
	getcmdline()		obtiene la línea de órdenes actual
	getcmdpos()		obtiene la posición del cursor en la línea de
				órdenes
	setcmdpos()		cambia la posición del cursor en la línea de
				órdenes
	getcmdtype()		devuelve el tipo de la línea de órdenes actual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">766</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="158" approved="yes">
        <source>Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list
</source>
        <target state="translated">Listas de corrección rápida y de ubicación:		*quickfix-functions*
	getqflist()		obtiene una lista de errores de corrección
				rápida
	setqflist()		modifica una lista de corrección rápida
	getloclist()	obtiene la lista de elementos de una lista de
				ubicación
	setloclist()		modifica una lista de ubicación
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">772</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="159" approved="yes">
        <source>Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed
</source>
        <target state="translated">Completado automático en modo Insertar:		*completion-functions*
	complete()		define coincidencias encontradas
	complete_add()		añade elementos a la lista de coincidencias
				encontradas
	complete_check()	comprueba si debería interrumpir el
				completado
	pumvisible()		comprueba si se está mostrando el menú
				contextual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">778</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="160" approved="yes">
        <source>Folding:					*folding-functions*
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold
</source>
        <target state="translated">Plegado:					*folding-functions*
	foldclosed()		comprueba si hay un pliegue cerrado en una
				línea específica
	foldclosedend()	similar a foldclosed() pero devuelve la última
				línea
	foldlevel()		obtiene el nivel de plegado de la línea
				especificada
	foldtext()		genera el texto mostrado en un pliegue cerrado
	foldtextresult()	obtiene el texto mostrado en un pliegue
				cerrado
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">785</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="161" approved="yes">
        <source>Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|
</source>
        <target state="translated">Sintaxis y resaltado:	  *syntax-functions* *highlighting-functions*
	clearmatches()	elimina las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	getmatches()		obtiene todas las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	hlexists()		comprueba la existencia de un grupo de
				resaltado
	hlID()			obtiene el ID de un grupo de resaltado
	synID()			obtiene el ID de sintaxis en una posición
				específica
	synIDattr()		obtiene un atributo específico correspondiente
				a un ID de sintaxis
	synIDtrans()		obtiene un ID de sintaxis traducido
	diff_hlID()		obtiene el ID de resaltado para el modo diff
				en una posición dada
	matchadd()		define un patrón a resaltar (una
				«coincidencia»)
	matcharg()		obtiene información acerca de los argumentos
				para |:match|
	matchdelete()		borra una coincidencia definida por
				|matchadd()| o una orden |:match|
	setmatches()		restaura una lista de coincidencias guardada
				por |getmatches()|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">803</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="162" approved="yes">
        <source>Spelling:					*spell-functions*
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word
</source>
        <target state="translated">Corrección ortográfica:					*spell-functions*
	spellbadword()		ubica palabras mal escritas a partir de la
				posición actual del cursor
	spellsuggest()		devuelve las correcciones ortográficas
				sugeridas
	soundfold()		retorna el homófono de una palabra
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">808</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="163" approved="yes">
        <source>History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list
</source>
        <target state="translated">Historia:					*history-functions*
	histadd()		añade un elemento a la historia
	histdel()		elimina un elemento a la historia
	histget()		obtiene un elemento a la historia
	histnr()		obtiene el índice más grande de la lista de una
				historia
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">814</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="164" approved="yes">
        <source>Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead
</source>
        <target state="translated">Interacción:					*interactive-functions*
	browse()		despliega un diálogo de selección de archivos
	browsedir()		despliega un diálogo de selección de
				directorios
	confirm()		solicita al usuario hacer una elección
	getchar()		solicita un carácter al usuario
	getcharmod()		obtiene los modificadores usados en el último
				carácter digitado
	feedkeys()		inserta caracteres en la cola de inserción
	input()			solicita una línea de texto al usuario
	inputlist()		permite al usuario elegir un elemento de una
				lista
	inputsecret()		solicita una línea de texto al usuario, sin
				mostrarla
	inputdialog()		solicita una línea de texto al usuario usando
				un diálogo
	inputsave()		guarda y limpia el búfer de cola de inserción
	inputrestore()		restaura el búfer de la línea de inserción
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">828</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="165" approved="yes">
        <source>GUI:						*gui-functions*
	getfontname()		get name of current font being used
	getwinposx()		X position of the GUI Vim window
	getwinposy()		Y position of the GUI Vim window
</source>
        <target state="translated">Interfaz gráfica:					*gui-functions*
	getfontname()		obtiene el nombre del tipo de letra actual
	getwinposx()		posición X de la ventana gráfica de Vim
	getwinposy()		posición Y de la ventana gráfica de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">833</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="166" approved="yes">
        <source>Vim server:					*server-functions*
	serverlist()		return the list of server names
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground
</source>
        <target state="translated">Servidor Vim:					*server-functions*
	serverlist()		devuelve una lista con nombres de servidores
	remote_send()		envía órdenes (caracteres) a un servidor Vim
	remote_expr()		evalúa una expresión en un servidor Vim
	server2client()		envía una respuesta a un cliente de un
				servidor Vim
	remote_peek()		comprueba si hay respuestas de un servidor Vim
	remote_read()		lee una respuesta de un servidor Vim
	foreground()		desplaza la ventana de Vim a primer plano
	remote_foreground()	desplaza la ventana de un servidor Vim a primer
				plano
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">843</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="167" approved="yes">
        <source>Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window
</source>
        <target state="translated">Tamaño y posición de ventanas:			*window-size-functions*
	winheight()		obtiene la altura de una ventana específica
	winwidth()		obtiene el ancho de una ventana específica
	winrestcmd()		devuelve una orden para restaurar los tamaños
				de ventana
	winsaveview()		obtiene una vista de la ventana actual
	winrestview()		devuelve una vista almacenada en la ventana
				actual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">850</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="168" approved="yes">
        <source>Various:					*various-functions*
	mode()			get current editing mode
	visualmode()		last visual mode used
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim
</source>
        <target state="translated">Varios:					*various-functions*
	mode()			obtiene el modo de edición actual
	visualmode()		último modo visual usado
	hasmapto()		comprueba la existencia de una macro
	mapcheck()		comprueba la existencia de una macro que
				coincida con el argumento dado
	maparg()		obtiene el rhs de una macro
	exists()		comprueba si la variable, función, etc.,
				existe
	has()			comprueba si Vim cuenta con la característica
				dada
	changenr()		devuelve el número correspondiente al cambio
				más reciente
	cscope_connection()	comprueba si hay una conexión a cscope
	did_filetype()		comprueba si se ha usado una orden automática
				FileType
	eventhandler()		comprueba si se ha sido invocado desde un
				manejador de eventos
	getpid()		obtiene el ID de proceso de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">864</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="169" approved="yes">
        <source>	libcall()		call a function in an external library
	libcallnr()		idem, returning a number
</source>
        <target state="translated">	libcall()		llama a una función en una biblioteca externa
	libcallnr()		idéntica, pero devuelve un número en vez de una
				cadena
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">867</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="170" approved="yes">
        <source>	getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register
</source>
        <target state="translated">	getreg()		obtiene el contenido de un registro
	getregtype()		obtiene el tipo de un registro
	setreg()		asigna el tipo y contenido de un registro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">871</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="171" approved="yes">
        <source>	taglist()		get list of matching tags
	tagfiles()		get a list of tags files
</source>
        <target state="translated">	taglist()		obtiene una lista de etiquetas coincidentes
	tagfiles()		obtiene una lista de archivos de etiquetas
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">874</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="172" approved="yes">
        <source>	mzeval()		evaluate |MzScheme| expression
</source>
        <target state="translated">	mzeval()		evalúa una expresión |MzScheme|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">876</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="173" approved="yes">
        <source>*41.7*	Defining a function
</source>
        <target state="translated">*41.7*	Definición de funciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">879</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="174" approved="yes">
        <source>Vim enables you to define your own functions.  The basic function declaration begins as follows: &gt;</source>
        <target state="translated">Vim permite definir nuevas funciones. La definición básica de una función corresponde a lo siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">882</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="175" approved="yes">
        <source>	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
&lt;
	Note:
	Function names must begin with a capital letter.
</source>
        <target state="translated">	:function {nombre}({var1}, {var2}, ...)
	:  {instrucciones}
	:endfunction
&lt;
	Nota:
	Los nombres de funciones deben empezar con una letra mayúscula.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">889</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="176" approved="yes">
        <source>Let's define a short function to return the smaller of two numbers.  It starts with this line: &gt;</source>
        <target state="translated">Vamos a definir una función pequeña que retorne el más pequeño de dos números. Su definición empieza con esta línea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">892</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="177" approved="yes">
        <source>	:function Min(num1, num2)
</source>
        <target state="translated">	:function Min(num1, num2)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">894</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="178" approved="yes">
        <source>This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
   &gt;
	:  if a:num1 &lt; a:num2
</source>
        <target state="translated">Ésta le indica a Vim que la función se llama «Min» y que recibe dos
argumentos: «num1» y «num2».
   El primer paso es comprobar qué número es el más pequeño:
   &gt;
	:   if a:num1 &lt; a:num2
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">900</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="179" approved="yes">
        <source>The special prefix "a:" tells Vim that the variable is a function argument.  Let's assign the variable "smaller" the value of the smallest number: &gt;</source>
        <target state="translated">El prefijo especial «a:» le indica a Vim que la variable es un argumento de la función. Asignemos ahora a la variable «menor» el valor del menor número: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">903</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="180" approved="yes">
        <source>	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
</source>
        <target state="translated">	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">909</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="181" approved="yes">
        <source>The variable "smaller" is a local variable.  Variables used inside a function are local unless prefixed by something like "g:", "a:", or "s:".</source>
        <target state="translated">La variable «menor» es una variable local. Las variables usadas dentro de una función son locales a menos que tengan un prefijo como «g:», «a:», o «s:».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">912</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="182" approved="yes">
        <source>	Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.  Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.
</source>
        <target state="translated">	Nota:
	Para usar una variable global dentro de una función debe anteponer
	«g:» a su nombre. Dentro de una función, «g:hoy» corresponde a la
	variable global «hoy», y «hoy» es otra variable, local respecto a la
	función.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">918</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="183" approved="yes">
        <source>You now use the ":return" statement to return the smallest number to the user.  Finally, you end the function: &gt;</source>
        <target state="translated">Ahora usamos la instrucción «:return» para devolver el menor de los dos números al usuario. Finalmente, terminamos la función: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">921</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="184" approved="yes">
        <source>	:  return smaller
	:endfunction
</source>
        <target state="translated">	:  return menor
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">924</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="185" approved="yes">
        <source>The complete function definition is as follows: &gt;</source>
        <target state="translated">La función completa es la siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">926</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="186" approved="yes">
        <source>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction
</source>
        <target state="translated">	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
	:  return menor
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">935</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="187" approved="yes">
        <source>For people who like short functions, this does the same thing: &gt;</source>
        <target state="translated">Para los aficionados a las funciones cortas, lo siguiente es equivalente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">937</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="188" approved="yes">
        <source>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</source>
        <target state="translated">	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">944</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="189" approved="yes">
        <source>A user defined function is called in exactly the same way as a built-in function.  Only the name is different.  The Min function can be used like this: &gt;</source>
        <target state="translated">Las funciones definidas por el usuario se invocan exactamente de la misma forma que las funciones internas. La única diferencia es el nombre. Puede usar la función Min como sigue: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">948</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="190" approved="yes">
        <source>	:echo Min(5, 8)
</source>
        <target state="translated">	:echo Min(5, 8)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">950</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="191" approved="yes">
        <source>Only now will the function be executed and the lines be interpreted by Vim.  If there are mistakes, like using an undefined variable or function, you will now get an error message.  When defining the function these errors are not detected.</source>
        <target state="translated">Sólo en este momento se ejecutará la función y Vim interpretará las instrucciones que la componen. Si hay errores, como usar una variable o función no definida, se mostrará un mensaje de error. Al definir una función estos errores no son detectados.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">955</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="192" approved="yes">
        <source>When a function reaches ":endfunction" or ":return" is used without an argument, the function returns zero.</source>
        <target state="translated">Cuando una función llega a «:endfunction» o cuando se usa «:return» sin un argumento, se retorna cero.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">958</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="193" approved="yes">
        <source>To redefine a function that already exists, use the ! for the ":function" command: &gt;</source>
        <target state="translated">Para redefinir una función existente, use ! en la orden «:function»: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">961</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="194" approved="yes">
        <source>	:function!  Min(num1, num2, num3)
</source>
        <target state="translated">	:function!  Min(num1, num2, num3)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">963</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="195" approved="yes">
        <source>USING A RANGE</source>
        <target state="translated">USO DE RANGOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">966</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="196" approved="yes">
        <source>The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example: &gt;
</source>
        <target state="translated">La orden «:call» puede recibir un rango de líneas. Este rango puede tener dos
significados. Cuando la definición de una función tiene la palabra clave
«range», ésta se hará cargo del rango de líneas.
   La función recibirá las variables «a:firstline» y «a:lastline». Éstas
contendrán los números de línea del rango con el cual se invoca la función.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">973</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="197" approved="yes">
        <source>	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction
</source>
        <target state="translated">	:function Contar_palabras() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "encontradas " . n . " palabras"
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">983</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="198" approved="yes">
        <source>You can call this function with: &gt;</source>
        <target state="translated">Puede invocar la función con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">985</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="199" approved="yes">
        <source>	:10,30call Count_words()
</source>
        <target state="translated">	:10,30call Contar_palabras()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">987</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="200" approved="yes">
        <source>It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example: &gt;
</source>
        <target state="translated">La función se ejecutará una vez, y mostrará en la pantalla el número de
palabras.
   La otra forma de usar un rango de líneas es definiendo una función sin la
palabra clave «range». Se invocará la función una vez por cada línea en el
rango, y el cursor estará en la línea correspondiente a cada invocación.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">992</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="201" approved="yes">
        <source>	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction
</source>
        <target state="translated">	:function  Numero()
	:  echo "la línea " . line(".") . " contiene: " . getline(".")
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">996</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="202" approved="yes">
        <source>If you call this function with: &gt;</source>
        <target state="translated">Si invoca esta función con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">998</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="203" approved="yes">
        <source>	:10,15call Number()
</source>
        <target state="translated">	:10,15call Numero()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1000</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="204" approved="yes">
        <source>The function will be called six times.</source>
        <target state="translated">Se invocará la función seis veces.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1002</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="205" approved="yes">
        <source>VARIABLE NUMBER OF ARGUMENTS</source>
        <target state="translated">NÚMERO VARIABLE DE ARGUMENTOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1005</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="206" approved="yes">
        <source>Vim enables you to define functions that have a variable number of arguments.  The following command, for instance, defines a function that must have 1 argument (start) and can have up to 20 additional arguments: &gt;</source>
        <target state="translated">Vim permite la definición de funciones que reciben una cantidad variable de argumentos. Por ejemplo, la siguiente orden define una función que debe recibir un argumento (inicio) y puede recibir hasta 20 argumentos adicionales: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1009</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="207" approved="yes">
        <source>	:function Show(start, ...)
</source>
        <target state="translated">	:function Mostrar(inicio, ...)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1011</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="208" approved="yes">
        <source>The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example: &gt;
</source>
        <target state="translated">La variable «a:1» contiene el primer argumento opcional, «a:2» contiene el
segundo, y así sucesivamente. La variable «a:0» contiene la cantidad de
argumentos adicionales.
   Por ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1015</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="209" approved="yes">
        <source>	:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index &lt;= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction
</source>
        <target state="translated">	:function Mostrar(inicio, ...)
	:  echohl Title
	:  echo "inicio es " . a:inicio
	:  echohl None
	:  let indice = 1
	:  while indice &lt;= a:0
	:    echo "  Arg " . indice . " is " . a:{indice}
	:    let indice = indice + 1
	:  endwhile
	:  echo ""
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1027</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO check for bugs in the doc: it isn't "Show is ... a:start", but "start
is" a:start</context>
        </context-group>
        <note from="po-translator">TODO check for bugs in the doc: it isn't "Show is ... a:start", but "start
is" a:start</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="210" approved="yes">
        <source>This uses the ":echohl" command to specify the highlighting used for the following ":echo" command.  ":echohl None" stops it again.  The ":echon" command works like ":echo", but doesn't output a line break.</source>
        <target state="translated">Aquí se usa la orden «:echohl», que especifica el resaltado a usar en la siguiente orden «:echo». «:echohl None» hace que no se use resaltado alguno. La orden  «:echon» es similar a «:echo» pero no imprime el cambio de línea final.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1031</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="211" approved="yes">
        <source>You can also use the a:000 variable, it is a List of all the "..." arguments.  See |a:000|.</source>
        <target state="translated">También puede usar la variable a:000. Es una Lista de todos los argumentos opcionales («...»). Consulte |a:000|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1034</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="212" approved="yes">
        <source>LISTING FUNCTIONS</source>
        <target state="translated">LISTAR FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1037</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="213" approved="yes">
        <source>The ":function" command lists the names and arguments of all user-defined functions: &gt;</source>
        <target state="translated">La orden «:function» muestra una lista con los nombres y argumentos de todas las funciones definidas por el usuario (esto incluye funciones de scripts y extensiones instalados).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1040</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="214" approved="yes">
        <source>	:function
&lt;	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~
</source>
        <target state="translated">	:function
&lt;	function Mostrar(inicio, ...) ~
	function ObtenerSangradoVim() ~
	function DefinirSintaxis(nombre) ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1045</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="215" approved="yes">
        <source>To see what a function does, use its name as an argument for ":function": &gt;</source>
        <target state="translated">Para ver la definición de una función, introduzca su nombre como argumento a la orden «:function»: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1047</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="216" approved="yes">
        <source>	:function SetSyn
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:name ~
	3     endif ~
	   endfunction ~
</source>
        <target state="translated">	:function DefinirSintaxis
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:nombre ~
	3     endif ~
	   endfunction ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1053</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="217" approved="yes">
        <source>DEBUGGING</source>
        <target state="translated">DEPURACIÓN</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1056</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="218" approved="yes">
        <source>The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.
</source>
        <target state="translated">El número de línea de una instrucción es información útil cuando aparece un
mensaje de error o al depurar scripts. Acerca del modo de depurado,
consulte |debug-scripts|.
   Puede darle un valor de 12 o más a la opción 'verbose' para ver todas las
invocaciones a funciones. Con un valor de 15 o más verá cada línea ejecutada.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1061</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="219" approved="yes">
        <source>DELETING A FUNCTION</source>
        <target state="translated">ELIMINAR FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1064</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="220" approved="yes">
        <source>To delete the Show() function: &gt;</source>
        <target state="translated">Para eliminar la función Mostrar(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1066</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="221" approved="yes">
        <source>	:delfunction Show
</source>
        <target state="translated">	:delfunction Mostrar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1068</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="222" approved="yes">
        <source>You get an error when the function doesn't exist.</source>
        <target state="translated">Si la función no existe obtendrá un error al usar esta orden.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1070</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="223" approved="yes">
        <source>FUNCTION REFERENCES</source>
        <target state="translated">REFERENCIAS A FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1073</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="224" approved="yes">
        <source>Sometimes it can be useful to have a variable point to one function or another.  You can do it with the function() function.  It turns the name of a function into a reference: &gt;</source>
        <target state="translated">En ocasiones es útil que una variable pueda hacer referencia a una u otra función . Puede hacerlo usando la función function(). Ésta función convierte el nombre de una función en una referencia a la misma: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1077</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="225" approved="yes">
        <source>	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
&lt;	Wrong! ~
</source>
        <target state="translated">	:let resultado = 0		" o 1
	:function! Bien()
	:  return '¡Bien!'
	:endfunc
	:function! Mal()
	:  return '¡Mal!'
	:endfunc
	:
	:if resultado == 1
	:  let Unafunc = function('Bien')
	:else
	:  let Unafunc = function('Mal')
	:endif
	:echo call(Unafunc, [])
&lt;	¡Mal! ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1093</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="226" approved="yes">
        <source>Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.
</source>
        <target state="translated">Tenga en cuenta que el nombre de la variable que contiene la referencia a la
función debe empezar con una letra mayúscula. En caso contrario, es posible
que se confunda con el nombre de una de las funciones integradas de Vim.
   Para invocar una función usando una variable con una referencia a función
se usa la función call(). Como primer argumento recibe la referencia a la
función, y como segundo argumento una Lista con los argumentos para la función
a invocar.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1100</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="227" approved="yes">
        <source>Function references are most useful in combination with a Dictionary, as is explained in the next section.</source>
        <target state="translated">Las referencias a funciones son particularmente útiles usadas con Diccionarios, como se muestra en la siguiente sección.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1103</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="228" approved="yes">
        <source>*41.8*	Lists and Dictionaries
</source>
        <target state="translated">*41.8*	Listas y Diccionarios
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="229" approved="yes">
        <source>So far we have used the basic types String and Number.  Vim also supports two composite types: List and Dictionary.</source>
        <target state="translated">Hasta ahora hemos usado los tipos básicos, Cadena de texto y Número. Vim también ofrece otros dos: Lista y Diccionario.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1109</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="230" approved="yes">
        <source>A List is an ordered sequence of things.  The things can be any kind of value, thus you can make a List of numbers, a List of Lists and even a List of mixed items.  To create a List with three strings: &gt;</source>
        <target state="translated">Una Lista es una secuencia ordenada de elementos. Los elementos pueden ser de cualquier tipo, así que puede crear una Lista de números, una Lista de Listas e incluso una Lista de elementos de tipos diferentes. Para crear una Lista con tres cadenas de texto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1113</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="231" approved="yes">
        <source>	:let alist = ['aap', 'mies', 'noot']
</source>
        <target state="translated">	:let lista = ['aap', 'mies', 'noot']
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1115</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="232" approved="yes">
        <source>The List items are enclosed in square brackets and separated by commas.  To create an empty List: &gt;</source>
        <target state="translated">Los elementos de la Lista se rodean con corchetes y se separan con comas. Para crear una Lista vacía: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1118</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="233" approved="yes">
        <source>	:let alist = []
</source>
        <target state="translated">	:let lista = []
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1120</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="234" approved="yes">
        <source>You can add items to a List with the add() function: &gt;</source>
        <target state="translated">Puede añadir elementos a una lista mediante la función add(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1122</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="235" approved="yes">
        <source>	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
&lt;	['foo', 'bar'] ~
</source>
        <target state="translated">	:let lista = []
	:call add(lista, 'foo')
	:call add(lista, 'bar')
	:echo lista
&lt;	['foo', 'bar'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1128</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="236" approved="yes">
        <source>List concatenation is done with +: &gt;</source>
        <target state="translated">El operador de concatenación de Listas es «+»: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1130</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="237" approved="yes">
        <source>	:echo alist + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</source>
        <target state="translated">	:echo lista + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1133</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="238" approved="yes">
        <source>Or, if you want to extend a List directly: &gt;</source>
        <target state="translated">O, si lo que desea es extender una Lista directamente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1135</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="239" approved="yes">
        <source>	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
&lt;	['one', 'two', 'three'] ~
</source>
        <target state="translated">	:let lista = ['uno']
	:call extend(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', 'dos', 'tres'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1140</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="240" approved="yes">
        <source>Notice that using add() will have a different effect: &gt;</source>
        <target state="translated">Observe que usar add() tendrá un resultado diferente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1142</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="241" approved="yes">
        <source>	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
&lt;	['one', ['two', 'three']] ~
</source>
        <target state="translated">	:let lista = ['uno']
	:call add(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', ['dos', 'tres']] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1147</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="242" approved="yes">
        <source>The second argument of add() is added as a single item.</source>
        <target state="translated">El segundo argumento de add() se añade a la lista como un único elemento.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1149</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="243" approved="yes">
        <source>FOR LOOP</source>
        <target state="translated">CICLO FOR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1152</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="244" approved="yes">
        <source>One of the nice things you can do with a List is iterate over it: &gt;</source>
        <target state="translated">Una de las cosas interesantes de las Listas es iterar sobre sus elementos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1154</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="245" approved="yes">
        <source>	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
&lt;	one ~
	two ~
	three ~
</source>
        <target state="translated">	:let lista = ['uno', 'dos', 'tres']
	:for n in lista
	:  echo n
	:endfor
&lt;	uno ~
	dos ~
	tres ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1162</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="246" approved="yes">
        <source>This will loop over each element in List "alist", assigning the value to variable "n".  The generic form of a for loop is: &gt;</source>
        <target state="translated">El código mostrado iterará sobre cada elemento en la Lista «lista», asignando el valor del elemento a la variable «n». La forma genérica de un ciclo «for» es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1165</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="247" approved="yes">
        <source>	:for {varname} in {listexpression}
	:  {commands}
	:endfor
</source>
        <target state="translated">	:for {nombrevar} in {expresiónlista}
	:  {instrucciones}
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1169</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="248" approved="yes">
        <source>To loop a certain number of times you need a List of a specific length.  The range() function creates one for you: &gt;</source>
        <target state="translated">Para iterar una cantidad determinada de veces necesita una Lista con una longitud específica. La función range() puede crearla por usted: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1172</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="249" approved="yes">
        <source>	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</source>
        <target state="translated">	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1179</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="250" approved="yes">
        <source>Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards: &gt;
</source>
        <target state="translated">Observe que el primer elemento de la Lista creada por range() es cero, y por
tanto el último elemento tiene un valor de uno menos que la longitud de la
lista.
   También puede especificar el valor máximo, y el incremento o decremento
deseado: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1183</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="251" approved="yes">
        <source>	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</source>
        <target state="translated">	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1190</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="252" approved="yes">
        <source>A more useful example, looping over lines in the buffer: &gt;</source>
        <target state="translated">Ahora un ejemplo más útil, iterar sobre las líneas de un búfer: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1192</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="253" approved="yes">
        <source>	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor
</source>
        <target state="translated">	:for line in getline(1, 20)
	:  if line =~ "Fecha: "
	:    echo matchstr(line, 'Fecha: \zs.*')
	:  endif
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1198</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="254" approved="yes">
        <source>This looks into lines 1 to 20 (inclusive) and echoes any date found in there.</source>
        <target state="translated">Este ejemplo examina las líneas 1 a 20 (inclusive) y muestra en pantalla las fechas encontradas en ellas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1200</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="255" approved="yes">
        <source>DICTIONARIES</source>
        <target state="translated">DICCIONARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1203</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="256" approved="yes">
        <source>A Dictionary stores key-value pairs.  You can quickly lookup a value if you know the key.  A Dictionary is created with curly braces: &gt;</source>
        <target state="translated">Un Diccionario almacena pares clave-valor. Esto le permite obtener un valor almacenado de manera rápida, si conoce la clave del mismo. Los Diccionarios se crean usando llaves: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1206</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="257" approved="yes">
        <source>	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
</source>
        <target state="translated">	:let es2nl = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1208</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="258" approved="yes">
        <source>Now you can lookup words by putting the key in square brackets: &gt;</source>
        <target state="translated">Ahora puede buscar palabras usando la clave, poniéndola entre corchetes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1210</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="259" approved="yes">
        <source>	:echo uk2nl['two']
&lt;	twee ~
</source>
        <target state="translated">	:echo es2nl['dos']
&lt;	twee ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1213</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="260" approved="yes">
        <source>The generic form for defining a Dictionary is: &gt;</source>
        <target state="translated">La manera genérica de definir un Diccionario es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1215</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="261" approved="yes">
        <source>	{&lt;key&gt; : &lt;value&gt;, ...}
</source>
        <target state="translated">	{&lt;clave&gt; : &lt;valor&gt;, ...}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1217</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="262" approved="yes">
        <source>An empty Dictionary is one without any keys: &gt;</source>
        <target state="translated">Un Diccionario vacío se define como carente de claves: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1219</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="263" approved="yes">
        <source>	{}
</source>
        <target state="translated">	{}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="264" approved="yes">
        <source>The possibilities with Dictionaries are numerous.  There are various functions for them as well.  For example, you can obtain a list of the keys and loop over them: &gt;</source>
        <target state="translated">Los Diccionarios ofrecen numerosas posibilidades. También dispone de varias funciones para operar sobre ellos. Por ejemplo, puede obtener una lista de las claves e iterar sobre ellas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1225</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="265" approved="yes">
        <source>	:for key in keys(uk2nl)
	:  echo key
	:endfor
&lt;	three ~
	one ~
	two ~
</source>
        <target state="translated">	:for clave in keys(es2nl)
	:  echo clave
	:endfor
&lt;	tres ~
	uno ~
	dos ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1232</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="266" approved="yes">
        <source>You will notice the keys are not ordered.  You can sort the list to get a specific order: &gt;</source>
        <target state="translated">Habrá notado que las claves no están ordenadas. Puede ordenar la lista para obtener un orden específico: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="267" approved="yes">
        <source>	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
&lt;	one ~
	three ~
	two ~
</source>
        <target state="translated">	:for clave in sort(keys(es2nl))
	:  echo clave
	:endfor
&lt;	dos ~
	tres ~
	uno ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1242</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="268" approved="yes">
        <source>But you can never get back the order in which items are defined.  For that you need to use a List, it stores items in an ordered sequence.</source>
        <target state="translated">No es posible recuperar el orden en el cual se definieron los elementos del Diccionario. Para eso necesita una Lista, que almacena los elementos en una secuencia ordenada.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="269" approved="yes">
        <source>DICTIONARY FUNCTIONS</source>
        <target state="translated">FUNCIONES PARA DICCIONARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1248</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="270" approved="yes">
        <source>The items in a Dictionary can normally be obtained with an index in square brackets: &gt;</source>
        <target state="translated">Habitualmente, puede acceder a los elementos de un Diccionario usando el índice correspondiente entre corchetes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1251</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="271" approved="yes">
        <source>	:echo uk2nl['one']
&lt;	een ~
</source>
        <target state="translated">	:echo es2nl['uno']
&lt;	een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1254</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="272" approved="yes">
        <source>A method that does the same, but without so many punctuation characters: &gt;</source>
        <target state="translated">Una forma de hacer lo mismo, sin tantos caracteres: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1256</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="273" approved="yes">
        <source>	:echo uk2nl.one
&lt;	een ~
</source>
        <target state="translated">	:echo es2nl.uno
&lt;	een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1259</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="274" approved="yes">
        <source>This only works for a key that is made of ASCII letters, digits and the underscore.  You can also assign a new value this way: &gt;</source>
        <target state="translated">Esto sólo funciona con claves compuestas de caracteres ASCII, dígitos, y el guión bajo. También puede usar esta notación para asignar valores: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1262</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="275" approved="yes">
        <source>	:let uk2nl.four = 'vier'
	:echo uk2nl
&lt;	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~
</source>
        <target state="translated">	:let es2nl.cuatro = 'vier'
	:echo es2nl
&lt;	{'tres': 'drie', 'cuatro': 'vier', 'uno': 'een', 'dos': 'twee'} ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1266</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="276" approved="yes">
        <source>And now for something special: you can directly define a function and store a reference to it in the dictionary: &gt;</source>
        <target state="translated">Y ahora, algo especial: puede definir directamente una función y almacenar una referencia a la misma en un diccionario: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="277" approved="yes">
        <source>	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction
</source>
        <target state="translated">	:function es2nl.traducir(linea) dict
	:  return join(map(split(a:linea), 'get(self, v:val, "???")'))
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1273</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="278" approved="yes">
        <source>Let's first try it out: &gt;</source>
        <target state="translated">Primero probémosla: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1275</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="279" approved="yes">
        <source>	:echo uk2nl.translate('three two five one')
&lt;	drie twee ??? een ~
</source>
        <target state="translated">	:echo es2nl.traducir('tres dos cinco uno')
&lt;	drie twee ??? een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1278</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="280" approved="yes">
        <source>The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: &gt;
</source>
        <target state="translated">Lo que habrá notado primero es el «dict» al final de la línea «:function».
Así se indica que la función será usada desde un Diccionario. La variable
local «self» se referirá a dicho diccionario.
   Ahora, dividamos esa compleja instrucción de retorno: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1283</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="281" approved="yes">
        <source>	split(a:line)
</source>
        <target state="translated">	split(a:linea)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1285</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="282" approved="yes">
        <source>The split() function takes a string, chops it into white separated words and returns a list with these words.  Thus in the example it returns: &gt;</source>
        <target state="translated">La función split() toma una cadena, la divide en palabras separadas por espacios en blanco, y entrega una lista con estas palabras. En el ejemplo previo, entrega: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1288</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="283" approved="yes">
        <source>	:echo split('three two five one')
&lt;	['three', 'two', 'five', 'one'] ~
</source>
        <target state="translated">	:echo split('tres dos cinco uno')
&lt;	['tres', 'dos', 'cinco', 'uno'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1291</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="284" approved="yes">
        <source>This list is the first argument to the map() function.  This will go through the list, evaluating its second argument with "v:val" set to the value of each item.  This is a shortcut to using a for loop.  This command: &gt;</source>
        <target state="translated">Esta lista es el primer argumento para la función map(). Dicha función analizará la lista, evaluando su segundo argumento con la variable «v:val» definida con el valor de cada elemento en la lista. Es una abreviación de un ciclo for. Esta instrucción: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1295</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="285" approved="yes">
        <source>	:let alist = map(split(a:line), 'get(self, v:val, "???")')
</source>
        <target state="translated">	:let lista = map(split(a:linea), 'get(self, v:val, "???")')
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1297</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="286" approved="yes">
        <source>Is equivalent to: &gt;</source>
        <target state="translated">Equivale a: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1299</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="287" approved="yes">
        <source>	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor
</source>
        <target state="translated">	:let lista = split(a:linea)
	:for ind in range(len(lista))
	:  let lista[ind] = get(self, lista[ind], "???")
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="288" approved="yes">
        <source>The get() function checks if a key is present in a Dictionary.  If it is, then the value is retrieved.  If it isn't, then the default value is returned, in the example it's '???'.  This is a convenient way to handle situations where a key may not be present and you don't want an error message.</source>
        <target state="translated">La función get() comprueba si una clave existe en un Diccionario. Si existe, devuelve el valor asociado a la clave. Si no existe, devuelve el valor definido como predeterminado, que en el ejemplo es '???'. Esto permite manejar de una forma conveniente las situaciones en que una clave no existe y no desea hacer el manejo del error que provocaría dicha situación.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1309</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="289" approved="yes">
        <source>The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.
</source>
        <target state="translated">La función join() es el complemento de split(): une una lista de palabras,
separándolas con un espacio.
   La combinación de split(), map(), y join() es una forma elegante de filtrar
una cadena de palabras de manera sucinta.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1314</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="290" approved="yes">
        <source>OBJECT ORIENTED PROGRAMMING</source>
        <target state="translated">PROGRAMACIÓN ORIENTADA A OBJETOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1317</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="291" approved="yes">
        <source>Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: &gt;
</source>
        <target state="translated">Ahora que podemos guardar valores y funciones en un Diccionario, podemos usar
un Diccionario como un objeto.
   Anteriormente hicimos uso de un Diccionario para traducir texto de Holandés
a Español. Querríamos hacer lo mismo para otros idiomas. Primero crearemos un
objeto (esto es, un Diccionario) que tenga la función traducir, pero no tenga
palabras para traducir: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1323</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="292" approved="yes">
        <source>	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction
</source>
        <target state="translated">	:let dicctraductor = {}
	:function dicctraductor.traducir(linea) dict
	:  return join(map(split(a:linea),
			\ 'get(self.palabras, v:val, "???")'))
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1328</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="293" approved="yes">
        <source>It's slightly different from the function above, using 'self.words' to lookup word translations.  But we don't have a self.words.  Thus you could call this an abstract class.</source>
        <target state="translated">La definición es ligeramente diferente de la función anterior, ya que usa 'self.words' para buscar las traducciones de palabras. Pero no hay un self.words. Por esto decir que el Diccionario es una clase abstracta.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1332</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="294" approved="yes">
        <source>Now we can instantiate a Dutch translation object: &gt;</source>
        <target state="translated">Ahora podemos instanciar un objeto para traducción al Holandés: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1334</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="295" approved="yes">
        <source>	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
&lt;	drie een ~
</source>
        <target state="translated">	:let es2nl = copy(dicctraductor)
	:let es2nl.words = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
	:echo es2nl.translate('tres uno')
&lt;	drie een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1339</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="296" approved="yes">
        <source>And a German translator: &gt;</source>
        <target state="translated">Y un traductor al alemán: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1341</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="297" approved="yes">
        <source>	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
&lt;	drei ein ~
</source>
        <target state="translated">	:let es2de = copy(dicctraductor)
	:let es2de.words = {'uno': 'ein', 'dos': 'zwei', 'tres': 'drei'}
	:echo es2de.translate('tres uno')
&lt;	drei ein ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1346</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="298" approved="yes">
        <source>You see that the copy() function is used to make a copy of the "transdict" Dictionary and then the copy is changed to add the words.  The original remains the same, of course.</source>
        <target state="translated">Puede ver que la función copy() se usa para crear una copia del Diccionario «dicctraductor» y luego se cambia la copia, añadiendo las palabras. El original, por supuesto, permanece intacto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1350</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="299" approved="yes">
        <source>Now you can go one step further, and use your preferred translator: &gt;</source>
        <target state="translated">Ahora puede ir un paso más allá, y usar su traductor preferido: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1352</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="300" approved="yes">
        <source>	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
&lt;	een twee drie ~
</source>
        <target state="translated">	:if $LANG =~ "de"
	:  let trad = es2de
	:else
	:  let trad = es2nl
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	een twee drie ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1360</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="301" approved="yes">
        <source>Here "trans" refers to one of the two objects (Dictionaries).  No copy is made.  More about List and Dictionary identity can be found at |list-identity| and |dict-identity|.</source>
        <target state="translated">Aquí «trad» se refiere a uno de dos posibles objetos (Diccionarios). No se hace ninguna copia. Puede encontrar más información acerca de la identidad de Listas y Diccionarios en |list-identity| y |dict-identity|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1364</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="302" approved="yes">
        <source>Now you might use a language that isn't supported.  You can overrule the translate() function to do nothing: &gt;</source>
        <target state="translated">Puede que use un idioma que aún no esté incluido. Para este caso, puede redefinir la función traducir() para que no haga nada: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1367</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="303" approved="yes">
        <source>	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
&lt;	three one wladiwostok ~
</source>
        <target state="translated">	:let es2es = copy(dicctraductor)
	:function! es2es.traducir(linea)
	:  return a:linea
	:endfunction
	:echo es2es.traducir('tres one wladiwostok')
&lt;	tres uno wladiwostok ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1374</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="304" approved="yes">
        <source>Notice that a ! was used to overwrite the existing function reference.  Now use "uk2uk" when no recognized language is found: &gt;</source>
        <target state="translated">Note el «!» utilizado para redefinir la referencia a función existente. Ahora puede usar «es2es» cuando no se encuentra ningún idioma reconocido: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1377</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="305" approved="yes">
        <source>	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
&lt;	one two three ~
</source>
        <target state="translated">	:if $LANG =~ "de"
	:  let trad = es2de
	:elseif $LANG =~ "nl"
	:  let trad = es2nl
	:else
	:  let trad = es2es
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	uno dos tres ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="306" approved="yes">
        <source>For further reading see |Lists| and |Dictionaries|.</source>
        <target state="translated">Para más detalles consulte |Lists| y |Dictionaries|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1389</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="307" approved="yes">
        <source>*41.9*	Exceptions
</source>
        <target state="translated">*41.9*	Excepciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1392</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="308" approved="yes">
        <source>Let's start with an example: &gt;</source>
        <target state="translated">Empecemos con un ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1394</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="309" approved="yes">
        <source>	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</source>
        <target state="translated">	:try
	:   read ~/plantillas/pascal.tmpl
	:catch /E484:/
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1400</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="310" approved="yes">
        <source>The ":read" command will fail if the file does not exist.  Instead of generating an error message, this code catches the error and gives the user a nice message instead.</source>
        <target state="translated">La orden «:read» (leer) fallará si el archivo no existe. En vez de mostrar un mensaje de error, este código atrapa el error y le muestra al usuario un mensaje más agradable.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1404</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO instead no está como repetido?</context>
        </context-group>
        <note from="po-translator">TODO instead no está como repetido?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="311" approved="yes">
        <source>For the commands in between ":try" and ":endtry" errors are turned into exceptions.  An exception is a string.  In the case of an error the string contains the error message.  And every error message has a number.  In this case, the error we catch contains "E484:".  This number is guaranteed to stay the same (the text may change, e.g., it may be translated).</source>
        <target state="translated">Para las instrucciones entre «:try» y «:endtry» los errores se convierten en excepciones. Una excepción es una cadena de texto. Cuando aparece un error esta cadena contiene el mensaje de error. Y cada mensaje de error tiene un número. En este caso, el error que atrapamos contiene «E484:». Vim garantiza que este número permanece inalterado (el texto del mensaje de error puede cambiar, por ejemplo, puede haber sido traducido.)</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1410</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="312" approved="yes">
        <source>When the ":read" command causes another error, the pattern "E484:" will not match in it.  Thus this exception will not be caught and result in the usual error message.</source>
        <target state="translated">Cuando la orden «:read» genera un error distinto, el patrón «E484:» no coincidirá con él. La excepción no será atrapada y aparecerá el mensaje de error habitual en esos casos.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1414</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="313" approved="yes">
        <source>You might be tempted to do this: &gt;</source>
        <target state="translated">Puede sentirse tentado a hacer lo siguiente:: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1416</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="314" approved="yes">
        <source>	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</source>
        <target state="translated">	:try
	:   read ~/plantillas/pascal.tmpl
	:catch
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1422</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="315" approved="yes">
        <source>This means all errors are caught.  But then you will not see errors that are useful, such as "E21: Cannot make changes, 'modifiable' is off".</source>
        <target state="translated">De esta forma se atrapan todos los errores. Pero al hacerlo no verá errores que son útiles, como por ejemplo «E21: No se pudo modificar, 'modifiable' está desactivado»</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1425</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="316" approved="yes">
        <source>Another useful mechanism is the ":finally" command: &gt;</source>
        <target state="translated">La orden «:finally» es otro mecanismo útil: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1427</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="317" approved="yes">
        <source>	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</source>
        <target state="translated">	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1437</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="318" approved="yes">
        <source>This filters the lines from the cursor until the end of the file through the "filter" command, which takes a file name argument.  No matter if the filtering works, something goes wrong in between ":try" and ":finally" or the user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is always executed.  This makes sure you don't leave the temporary file behind.</source>
        <target state="translated">Aquí se filtran las líneas desde el cursor hasta el final del archivo usando la orden «filter», que toma como argumento un nombre de archivo. No importa si el filtrado funciona, si algo sale mal entre «:try» y «:finally», o si el usuario cancela el filtrado presionando CTRL-C, la instrucción «call delete(tmp)» siempre se ejecuta. Así se asegura de que no queden archivos temporales al acabar el proceso.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1443</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="319" approved="yes">
        <source>More information about exception handling can be found in the reference manual: |exception-handling|.</source>
        <target state="translated">Puede encontrar más información acerca del manejo de excepciones en el manual de referencia: |exception-handling|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1446</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="320" approved="yes">
        <source>*41.10*	Various remarks
</source>
        <target state="translated">*41.10*	Observaciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1449</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="321" approved="yes">
        <source>Here is a summary of items that apply to Vim scripts.  They are also mentioned elsewhere, but form a nice checklist.</source>
        <target state="translated">A continuación tiene un resumen de los elementos relevantes para escribir scripts de Vim. También se los menciona en otros lugares de la documentación, pero aquí se presentan como una conveniente lista.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1452</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="322" approved="yes">
        <source>The end-of-line character depends on the system.  For Unix a single &lt;NL&gt; character is used.  For MS-DOS, Windows, OS/2 and the like, &lt;CR&gt;&lt;LF&gt; is used.  This is important when using mappings that end in a &lt;CR&gt;.  See |:source_crnl|.</source>
        <target state="translated">El carácter de fin de línea usado depende del sistema. En sistemas Unix se usa &lt;NL&gt;. En MS-DOS, Windows, OS/2 y similares, se usa &lt;CR&gt;&lt;LF&gt;. Éste es un detalle importante a considerar al usar macros que terminan en &lt;CR&gt;. Consulte |:source_crnl|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1456</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="323" approved="yes">
        <source>WHITE SPACE</source>
        <target state="translated">ESPACIO EN BLANCO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1459</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="324" approved="yes">
        <source>Blank lines are allowed and ignored.</source>
        <target state="translated">Las líneas en blanco están permitidas, y son ignoradas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1461</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="325" approved="yes">
        <source>Leading whitespace characters (blanks and TABs) are always ignored.  The whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in the example below) are reduced to one blank character and plays the role of a separator, the whitespaces after the last (visible) character may or may not be ignored depending on the situation, see below.</source>
        <target state="translated">Los espacios en blanco al principio de cada línea (espacios y tabulados) siempre se ignoran. Los espacios en blanco entre parámetros (por ejemplo, entre 'set' y 'cpoptions' en el ejemplo a continuación) se reducen a un solo espacio blanco que actúa como separador, los espacios en blanco después del último carácter (visible) se pueden o no ignorar dependiendo del caso, véase a continuación.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1467</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="326" approved="yes">
        <source>For a ":set" command involving the "=" (equal) sign, such as in: &gt;</source>
        <target state="translated">Para una orden «:set» que incluye el símbolo «=» (igual), como en: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1469</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="327" approved="yes">
        <source>	:set cpoptions    =aABceFst
</source>
        <target state="translated">	:set cpoptions    =aABceFst
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1471</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="328" approved="yes">
        <source>the whitespace immediately before the "=" sign is ignored.  But there can be no whitespace after the "=" sign!</source>
        <target state="translated">se ignora el espacio en blanco inmediatamente antes del símbolo «=». ¡Pero no puede haber espacios a continuación del símbolo «=»!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1474</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="329" approved="yes">
        <source>To include a whitespace character in the value of an option, it must be escaped by a "\" (backslash)  as in the following example: &gt;</source>
        <target state="translated">Para incluir un espacio en blanco como valor de una opción, hay que escaparlo usando una «\» (barra inversa) como en el siguiente ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1477</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="330" approved="yes">
        <source>	:set tags=my\ nice\ file
</source>
        <target state="translated">	:set tags=mi\ lindo\ archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1479</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="331" approved="yes">
        <source>The same example written as &gt;</source>
        <target state="translated">Al escribir el ejemplo como: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1481</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug in vim doc?</context>
        </context-group>
        <note from="po-translator">TODO bug in vim doc?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="332" approved="yes">
        <source>	:set tags=my nice file
</source>
        <target state="translated">	:set tags=mi lindo archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1483</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="333" approved="yes">
        <source>will issue an error, because it is interpreted as: &gt;</source>
        <target state="translated">se obtendría un error, porque se interpreta como: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1485</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="334" approved="yes">
        <source>	:set tags=my
	:set nice
	:set file
</source>
        <target state="translated">	:set tags=mi
	:set lindo
	:set archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1489</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="335" approved="yes">
        <source>COMMENTS</source>
        <target state="translated">COMENTARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1492</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="336" approved="yes">
        <source>The character " (the double quote mark) starts a comment.  Everything after and including this character until the end-of-line is considered a comment and is ignored, except for commands that don't consider comments, as shown in examples below.  A comment can start on any character position on the line.</source>
        <target state="translated">El carácter " (comilla doble) marca el inicio de un comentario. Todo lo que aparece a continuación de éste carácter hasta el fin de línea, e incluyéndola, se considera un comentario y es ignorado, a excepción de las órdenes que no tienen en cuenta los comentarios, como se puede ver en ejemplos de esta sección. Un comentario puede empezar en cualquier punto de una línea de texto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1497</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="337" approved="yes">
        <source>There is a little "catch" with comments for some commands.  Examples: &gt;</source>
        <target state="translated">Hay un pequeño «pero» con los comentarios y ciertas órdenes. Ejemplos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1499</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="338" approved="yes">
        <source>	:abbrev dev development		" shorthand
	:map &lt;F3&gt; o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files
</source>
        <target state="translated">	:abbrev des desarrollo		" abreviación
	:map &lt;F3&gt; o#include		" insertar directiva include
	:execute orden			" ejecutar
	:!ls *.c			" listar archivos C
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1504</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="339" approved="yes">
        <source>The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of &lt;F3&gt; will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: &gt;
</source>
        <target state="translated">La abreviación 'dev' se expandirá a 'desarrollo     " abreviación'. La
macro &lt;F3&gt; constará en realidad de toda la línea desde 'o# ....' incluyendo
'" insertar directiva include'. La orden «execute» provocará un error. La
orden «!» enviará todos los caracteres a continuación al intérprete de
órdenes, provocando un error debido al carácter '"' sin la comilla de cierre
correspondiente.
   No pueden existir comentarios a continuación de las órdenes «:map»,
«:abbreviate», «:execute», ni «!» (hay algunas órdenes más con esta
restricción). Para el caso de las órdenes «:map», «:abbreviate», y «:execute»
hay un truco disponible: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1513</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="340" approved="yes">
        <source>	:abbrev dev development|" shorthand
	:map &lt;F3&gt; o#include|" insert include
	:execute cmd			|" do it
</source>
        <target state="translated">	:abbrev des desarrollo|" abreviación
	:map &lt;F3&gt; o#include|" insertar directiva include
	:execute orden			|" ejecutar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1517</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="341" approved="yes">
        <source>With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': &gt;
	:exe '!ls *.c'			|" list C files
</source>
        <target state="translated">El carácter «|» permite separar órdenes. En este caso, la siguiente orden es
simplemente un comentario. Para la última orden hay que hacer dos cosas:
|:execute| y usar «|»: &gt;
	:exe '!ls *.c'			|" listar archivos C
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1522</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="342" approved="yes">
        <source>Notice that there is no white space before the '|' in the abbreviation and mapping.  For these commands, any character until the end-of-line or '|' is included.  As a consequence of this behavior, you don't always see that trailing whitespace is included: &gt;</source>
        <target state="translated">Observe que no hay espacios en blanco antes de «|» en la abreviación ni en la macro. En estas órdenes, se incluye cualquier carácter hasta el fin de línea o hasta «|». Como consecuencia de este comportamiento, no siempre es visible cuándo se incluyen espacios en blanco al final del a línea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1527</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="343" approved="yes">
        <source>	:map &lt;F4&gt; o#include  
</source>
        <target state="translated">	:map &lt;F4&gt; o#include  
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1529</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="344" approved="yes">
        <source>To spot these problems, you can set the 'list' option when editing vimrc files.</source>
        <target state="translated">Para ver estos problemas de forma más fácil, puede activar la opción 'list' al editar archivos vimrc.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1532</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="345" approved="yes">
        <source>For Unix there is one special way to comment a line, that allows making a Vim
script executable: &gt;
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit
</source>
        <target state="translated">En Unix hay una forma especial de hacer un comentario, que permite hacer que
un script de Vim sea ejecutable: &gt;
	#!/usr/bin/env vim -S
	echo "este es un script de Vim"
	quit
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1538</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="346" approved="yes">
        <source>The "#" command by itself lists a line with the line number.  Adding an exclamation mark changes it into doing nothing, so that you can add the shell command to execute the rest of the file. |:#!| |-S|</source>
        <target state="translated">Por sí misma, la orden «#» muestra una línea junto con su número de línea. Al añadirle un símbolo de exclamación su comportamiento cambia y no tiene efecto, así que puede añadir la orden de intérprete de órdenes para ejecutar el resto del archivo. |:#!| |-S|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1542</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="347" approved="yes">
        <source>PITFALLS</source>
        <target state="translated">PROBLEMAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1545</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="348" approved="yes">
        <source>Even bigger problem arises in the following example: &gt;</source>
        <target state="translated">En el siguiente ejemplo aparecen problemas aún más grandes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1547</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="349" approved="yes">
        <source>	:map ,ab o#include
	:unmap ,ab 
</source>
        <target state="translated">	:map ,ab o#include
	:unmap ,ab 
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1550</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="350" approved="yes">
        <source>Here the unmap command will not work, because it tries to unmap ",ab ".  This does not exist as a mapped sequence.  An error will be issued, which is very hard to identify, because the ending whitespace character in ":unmap ,ab " is not visible.</source>
        <target state="translated">Aquí la orden unmap no funcionará, porque trata de eliminar la macro «,ab ». Ésta no existe como secuencia de ninguna macro. Se mostrará un error, que es muy difícil de identificar, porque el carácter de espacio final en «:unmap ,ab» no es visible.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1555</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="351" approved="yes">
        <source>And this is the same as what happens when one uses a comment after an 'unmap' command: &gt;</source>
        <target state="translated">Lo mismo sucede cuando se pone un comentario a conti de una orden 'unmap': &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1558</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="352" approved="yes">
        <source>	:unmap ,ab     " comment
</source>
        <target state="translated">	:unmap ,ab     " comentario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1560</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="353" approved="yes">
        <source>Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: &gt;
</source>
        <target state="translated">La parte correspondiente al comentario será ignorada. Sin embargo, Vim tratará
de eliminar la macro ',ab     ', que no existe. Debe reescribir la orden como:  &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1563</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="354" approved="yes">
        <source>	:unmap ,ab|    " comment
</source>
        <target state="translated">	:unmap ,ab|    " comentario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1565</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="355" approved="yes">
        <source>RESTORING THE VIEW</source>
        <target state="translated">RESTAURAR LA VISTA</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1568</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="356" approved="yes">
        <source>Sometimes you want to make a change and go back to where cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: &gt;
</source>
        <target state="translated">En ocasiones es deseable hacer un cambio y volver al sitio en que el cursor se
encontraba inicialmente. Recuperar la posición relativa también sería
agradable, de tal forma que la misma línea inicial aparezca al inicio de la
ventana.
   Este ejemplo copia la línea actual, la inserta antes de la primera línea en
el archivo y después restaura la vista original: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1574</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="357" approved="yes">
        <source>	map ,p ma"aYHmbgg"aP`bzt`a
</source>
        <target state="translated">	map ,p ma"aYHmbgg"aP`bzt`a
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1576</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="358" approved="yes">
        <source>What this does: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position
</source>
        <target state="translated">Esto es lo que hace: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			pone una marca en la posición actual del
				cursor
	  "aY			copia la línea actual al registro a
	     Hmb		va hasta la primera línea que se ve en la
				ventana y pone la marca b allí
		gg		va a la primera línea del archivo
		  "aP		pega la línea copiada por encima de la línea
		     `b		vuelve a la línea superior de la vista inicial
		       zt	ubica dicha línea como la primera de la
				ventana
			 `a	vuelve a la posición del cursor almacenada
				originalmente
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1587</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="359" approved="yes">
        <source>PACKAGING</source>
        <target state="translated">EMPAQUETAR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1590</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="360" approved="yes">
        <source>To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: &gt;
</source>
        <target state="translated">Para evitar que los nombres de funciones que defina interfieran con
otras funciones, use el siguiente esquema:
- Anteponga una cadena única a cada nombre de función. A menudo uso una
  abreviatura. Por ejemplo, uso «OV» para las funciones relacionadas con
  opciones de ventana.
- Ponga todas las definiciones de sus funciones en un mismo archivo. Cree una
  variable global para indicar que las funciones ya fueron cargadas. Cuando
  cargue el archivo de nuevo, elimine antes las definiciones de las funciones.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1599</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="361" approved="yes">
        <source>	" This is the XXX package
</source>
        <target state="translated">	" Este es el paquete XXX
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1601</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="362" approved="yes">
        <source>	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif
</source>
        <target state="translated">	if exists("XXX_cargado")
	  delfun XXX_uno
	  delfun XXX_dos
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1606</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="363" approved="yes">
        <source>	function XXX_one(a)
		... body of function ...
	endfun
</source>
        <target state="translated">	function XXX_uno(a)
		... cuerpo de la función ...
	endfun
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1610</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="364" approved="yes">
        <source>	function XXX_two(b)
		... body of function ...
	endfun
</source>
        <target state="translated">	function XXX_dos(b)
		... cuerpo de la función ...
	endfun
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1614</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="365" approved="yes">
        <source>	let XXX_loaded = 1
</source>
        <target state="translated">	let XXX_loaded = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1616</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="366" approved="yes">
        <source>*41.11*	Writing a plugin				*write-plugin*
</source>
        <target state="translated">*41.11*	Escribir extensiones				*write-plugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1619</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="367" approved="yes">
        <source>You can write a Vim script in such a way that many people can use it.  This is called a plugin.  Vim users can drop your script in their plugin directory and use its features right away |add-plugin|.</source>
        <target state="translated">Puede crear un script de Vim de tal forma que lo puedan usar varias personas. Esto se llama una extensión. Los usuarios de Vim pueden copiar el script en su directorio «plugin/», y utilizarlo en el momento con |add-plugin|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1623</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="368" approved="yes">
        <source>There are actually two types of plugins:</source>
        <target state="translated">Existen dos tipos de extensiones:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1625</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="369" approved="yes">
        <source>  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.
</source>
        <target state="translated">          Extensiones globales: Empleadas con todos los tipos de archivo.
Extensiones de tipo de archivo: Empleadas con tipos de archivo específicos.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1628</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="370" approved="yes">
        <source>In this section the first type is explained.  Most items are also relevant for writing filetype plugins.  The specifics for filetype plugins are in the next section |write-filetype-plugin|.</source>
        <target state="translated">En esta sección se describirán las extensiones globales («global plugins»). La mayoría de elementos también son necesarios para escribir extensiones de tipo de archivo («filetype plugins»). La sección a continuación, |write-filetype-plugin|, detalla las extensiones de tipo de archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1632</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="371" approved="yes">
        <source>NAME</source>
        <target state="translated">NOMBRE</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1635</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="372" approved="yes">
        <source>First of all you must choose a name for your plugin.  The features provided by the plugin should be clear from its name.  And it should be unlikely that someone else writes a plugin with the same name but which does something different.  And please limit the name to 8 characters, to avoid problems on old Windows systems.</source>
        <target state="translated">Primero, debe elegir un nombre para su extensión. El nombre debería mostrar las funcionalidades ofrecidas por la extensión. Así mismo, debería ser poco probable que alguien escriba una extensión con el mismo nombre pero otras funcionalidades. Por último, limite el nombre a ocho caracteres para evitar problemas en antiguos sistemas de Windows.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1641</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="373" approved="yes">
        <source>A script that corrects typing mistakes could be called "typecorr.vim".  We will use it here as an example.</source>
        <target state="translated">Un script que corrige errores tipográficos se podría llamar «correccort.vim». Lo usaremos como ejemplo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1644</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="374" approved="yes">
        <source>For the plugin to work for everybody, it should follow a few guidelines.  This will be explained step-by-step.  The complete example plugin is at the end.</source>
        <target state="translated">Para que funcione en cualquier sistema, la extensión debería seguir algunas normas, las cuales se detallarán paso a paso. La extensión de ejemplo completa se encuentra al final de la sección.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1647</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="375" approved="yes">
        <source>BODY</source>
        <target state="translated">CUERPO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1650</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="376" approved="yes">
        <source>Let's start with the body of the plugin, the lines that do the actual work: &gt;</source>
        <target state="translated">Vamos a comenzar con el cuerpo de la extensión, las líneas que realmente hacen el trabajo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1652</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="377" approved="yes">
        <source> 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
</source>
        <target state="translated"> 14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronización
 19	let s:cuenta = 4
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1659</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="378" approved="yes">
        <source>The actual list should be much longer, of course.</source>
        <target state="translated">Por supuesto, la lista debería ser mucho más larga.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1661</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="379" approved="yes">
        <source>The line numbers have only been added to explain a few things, don't put them in your plugin file!</source>
        <target state="translated">Los números de línea se han añadido en pro de la claridad. ¡No los incluya en su archivo de extensión!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1664</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="380" approved="yes">
        <source>HEADER</source>
        <target state="translated">ENCABEZADO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1667</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="381" approved="yes">
        <source>You will probably add new corrections to the plugin and soon have several versions laying around.  And when distributing this file, people will want to know who wrote this wonderful plugin and where they can send remarks.  Therefore, put a header at the top of your plugin: &gt;</source>
        <target state="translated">Lo más probable es que añada nuevas correcciones a la extensión, y tenga en poco tiempo varias versiones de ésta. Cuando distribuya el archivo, la gente querrá saber quién escribió esta maravillosa extensión, y dónde pueden enviar comentarios. Por ello, incluya un encabezado al principio de su extensión: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1672</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="382" approved="yes">
        <source>  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
</source>
        <target state="translated">  1	" Extensión global de Vim para la corrección de errores
  2	" Último cambio:	15 de octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1676</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="383" approved="yes">
        <source>About copyright and licensing: Since plugins are very useful and it's hardly worth restricting their distribution, please consider making your plugin either public domain or use the Vim |license|.  A short note about this near the top of the plugin should be sufficient.  Example: &gt;</source>
        <target state="translated">Derechos de autor y licencias: Debido a que las extensiones son útiles, y que no merece la pena restringir su distribución, considere que su extensión sea de dominio público, o use la licencia de Vim (|license|). Una breve nota cerca del inicio de la extensión debería servir. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1681</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="384" approved="yes">
        <source>  4	" License:	This file is placed in the public domain.
</source>
        <target state="translated">  4	" Licencia:	Este fichero pertenece al dominio público.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1683</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="385" approved="yes">
        <source>LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*
</source>
        <target state="translated">CONTINUACIÓN DE LÍNEA, EVITAR EFECTOS SECUNDARIOS	*use-cpo-save*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1686</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="386" approved="yes">
        <source>In line 18 above, the line-continuation mechanism is used |line-continuation|.  Users with 'compatible' set will run into trouble here, they will get an error message.  We can't just reset 'compatible', because that has a lot of side effects.  To avoid this, we will set the 'cpoptions' option to its Vim default value and restore it later.  That will allow the use of line-continuation and make the script work for most people.  It is done like this: &gt;</source>
        <target state="translated">En la línea 18 del ejemplo anterior se usa el mecanismo |line-continuation|, continuación de línea. Los usuarios que definan 'compatible' pueden encontrar problemas con esto, y se les mostraría un mensaje de error. No podemos simplemente reiniciar 'compatible' porque tiene muchos efectos secundarios. Para evitarlo, definimos la opción 'cpoptions' con el valor predeterminado de Vim para restaurarlo más tarde. Esto permite el uso de «line-continuation» y que el script funcione en la mayoría de sistemas. Se hace de la siguiente forma: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1693</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="387" approved="yes">
        <source> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</source>
        <target state="translated"> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1698</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="388" approved="yes">
        <source>We first store the old value of 'cpoptions' in the s:save_cpo variable.  At the end of the plugin this value is restored.</source>
        <target state="translated">Primero almacenamos el valor antiguo de 'cpoptions'  en la variable «s:save_cpo». El valor se restaurará al final de la extensión.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1701</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="389" approved="yes">
        <source>Notice that a script-local variable is used |s:var|.  A global variable could already be in use for something else.  Always use script-local variables for things that are only used in the script.</source>
        <target state="translated">Tenga en cuenta que se usa una variable local de script, |s:var|. Puede que se esté utilizando una variable global para otra cosa. Use siempre variables locales en el script para aquello que se usa sólo en el script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1705</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="390" approved="yes">
        <source>NOT LOADING</source>
        <target state="translated">EVITAR LA CARGA DE LA EXTENSIÓN</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1708</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="391" approved="yes">
        <source>It's possible that a user doesn't always want to load this plugin.  Or the system administrator has dropped it in the system-wide plugin directory, but a user has his own plugin he wants to use.  Then the user must have a chance to disable loading this specific plugin.  This will make it possible: &gt;</source>
        <target state="translated">Es posible que el usuario no desee cargar la extensión en cada momento. O que el administrador del sistema lo haya copiado al directorio de extensiones del sistema, pero el usuario quiere usar el suyo propio. En ese caso, el usuario debe tener la posibilidad de desactivar cargar esta extensión en particular. Lo siguiente lo hace posible: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1713</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="392" approved="yes">
        <source>  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
</source>
        <target state="translated">  6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1718</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="393" approved="yes">
        <source>This also avoids that when the script is loaded twice it would cause error messages for redefining functions and cause trouble for autocommands that are added twice.</source>
        <target state="translated">También evita cargar el script dos veces, lo que provocaría mensajes de error al redefinir las funciones, y provocar problemas con las órdenes automáticas que se cargan por duplicado.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1722</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="394" approved="yes">
        <source>The name is recommended to start with "loaded_" and then the file name of the plugin, literally.  The "g:" is prepended just to avoid mistakes when using the variable in a function (without "g:" it would be a variable local to the function).</source>
        <target state="translated">Se recomienda que el nombre empiece con «loaded_» y, a continuación, el nombre literal de la extensión. La «g:» se añade para evitar errores al usar la variable en una función (sin la «g:», sería una variable local a la función).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1727</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="395" approved="yes">
        <source>Using "finish" stops Vim from reading the rest of the file, it's much quicker than using if-endif around the whole file.</source>
        <target state="translated">Usar «finish» impide que Vim lea el resto del archivo, lo cual es mucho más rápido que usar «if-endif» a lo largo del archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1730</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="396" approved="yes">
        <source>MAPPING</source>
        <target state="translated">MACROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1733</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="397" approved="yes">
        <source>Now let's make the plugin more interesting: We will add a mapping that adds a correction for the word under the cursor.  We could just pick a key sequence for this mapping, but the user might already use it for something else.  To allow the user to define which keys a mapping in a plugin uses, the &lt;Leader&gt; item can be used: &gt;</source>
        <target state="translated">Ahora, vamos a hacer que la extensión sea más interesante: vamos a añadir una macro que añade una corrección para la palabra bajo el cursor. Podríamos escoger una secuencia de teclas para esta macro, pero puede que el usuario la esté usando para otra cosa. Puede usar el elemento &lt;Leader&gt; para permitir que el usuario pueda definir las teclas que utiliza la macro de una extensión: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1739</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="398" approved="yes">
        <source> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
</source>
        <target state="translated"> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1741</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="399" approved="yes">
        <source>The "&lt;Plug&gt;TypecorrAdd" thing will do the work, more about that further on.</source>
        <target state="translated">El elemento «&lt;Plug&gt;CorreccortAñadir» daría un buen resultado, a continuación dispone de más información.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1743</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="400" approved="yes">
        <source>The user can set the "mapleader" variable to the key sequence that he wants this mapping to start with.  Thus if the user has done: &gt;</source>
        <target state="translated">El usuario puede definir la variable «mapleader» con la secuencia de teclas con la que desea iniciar esta macro. Por lo tanto, si el usuario define: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1746</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="401" approved="yes">
        <source>	let mapleader = "_"
</source>
        <target state="translated">	let mapleader = "_"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1748</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="402" approved="yes">
        <source>the mapping will define "_a".  If the user didn't do this, the default value will be used, which is a backslash.  Then a map for "\a" will be defined.</source>
        <target state="translated">la macro se definirá como «_a». En caso contrario se usará el valor predeterminado, que es una barra inversa. Por ello, se definiría una macro como «\a».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1751</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="403" approved="yes">
        <source>Note that &lt;unique&gt; is used, this will cause an error message if the mapping already happened to exist. |:map-&lt;unique&gt;|</source>
        <target state="translated">Tenga en cuenta se usa &lt;unique&gt;, lo que provocaría un mensaje de error si la macro ya existe.  |:map-&lt;unique&gt;|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1754</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="404" approved="yes">
        <source>But what if the user wants to define his own key sequence? We can allow that with this mechanism: &gt;</source>
        <target state="translated">Puede usar el siguiente mecanismo para permitir que el usuario defina su propia secuencia de teclas si así lo desea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1757</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="405" approved="yes">
        <source> 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif
</source>
        <target state="translated"> 21	if !hasmapto('&lt;Plug&gt;CorreccortAñadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
 23	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1761</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="406" approved="yes">
        <source>This checks if a mapping to "&lt;Plug&gt;TypecorrAdd" already exists, and only defines the mapping from "&lt;Leader&gt;a" if it doesn't.  The user then has a chance of putting this in his vimrc file: &gt;</source>
        <target state="translated">Esto comprueba si ya existe una macro para «&lt;Plug&gt;CorrecortAñadir», y sólo define la macro de «&lt;Leader&gt;a» si no existe. Así, el usuario tiene la posibilidad de insertar esto en su archivo «vimrc»: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1765</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="407" approved="yes">
        <source>	map ,c  &lt;Plug&gt;TypecorrAdd
</source>
        <target state="translated">	map ,c  &lt;Plug&gt;CorreccortAñadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1767</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="408" approved="yes">
        <source>Then the mapped key sequence will be ",c" instead of "_a" or "\a".</source>
        <target state="translated">Así, la secuencia de teclas asignada sería «,c» en lugar de «_a» o «\a».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1769</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="409" approved="yes">
        <source>PIECES</source>
        <target state="translated">SEGMENTOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1772</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="410" approved="yes">
        <source>If a script gets longer, you often want to break up the work in pieces.  You can use functions or mappings for this.  But you don't want these functions and mappings to interfere with the ones from other scripts.  For example, you could define a function Add(), but another script could try to define the same function.  To avoid this, we define the function local to the script by prepending it with "s:".</source>
        <target state="translated">Habitualmente querrá dividir un script en segmentos cuando es demasiado largo. Para ello, puede usar funciones o macros, pero no desea que estas funciones y macros interfieran con los presentes en otros scripts. Por ejemplo, podría definir la función «Anadir()» pero otro script podría intentar definir la misma función. Para evitar esto, definimos la función como local al script anteponiendo a este «s:».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1779</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="411" approved="yes">
        <source>We will define a function that adds a new typing correction: &gt;</source>
        <target state="translated">A continuación definimos una función que añade una nueva corrección ortográfica: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1781</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="412" approved="yes">
        <source> 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction
</source>
        <target state="translated"> 30	function s:Anadir(desde, correccion)
 31	  let a = input("Introduzca la corrección para " . a:desde . ": ")
 32	  exe ":iabbrev " . a:desde . " " . a
 ..
 36	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1787</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="413" approved="yes">
        <source>Now we can call the function s:Add() from within this script.  If another script also defines s:Add(), it will be local to that script and can only be called from the script it was defined in.  There can also be a global Add()  function (without the "s:"), which is again another function.</source>
        <target state="translated">Ahora invocamos la función «s:Anadir()» desde el mismo script. Si otro script también define «s:Anadir()», será local a ese script y solo se invocará desde el script en el que se define. También puede existir una función global «Anadir()» (sin la «s:»), que es otra función distinta.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1792</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="414" approved="yes">
        <source>&lt;SID&gt; can be used with mappings.  It generates a script ID, which identifies the current script.  In our typing correction plugin we use it like this: &gt;</source>
        <target state="translated">Puede usar &lt;SID&gt; en una macro. Genera un identificador de script, que identifica al script actual. En nuestra extensión de corrección usaremos algo similar a esto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1795</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="415" approved="yes">
        <source> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 ..
 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</source>
        <target state="translated"> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAñadir  &lt;SID&gt;Añadir
 ..
 28	noremap &lt;SID&gt;Añadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1799</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="416" approved="yes">
        <source>Thus when a user types "\a", this sequence is invoked: &gt;</source>
        <target state="translated">Así, cuando el usuario teclea «\a», se invoca esta secuencia: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1801</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="417" approved="yes">
        <source>	\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()
</source>
        <target state="translated">	\a -&gt; &lt;Plug&gt;CorreccortAñadir -&gt; &lt;SID&gt;Añadir -&gt; :call &lt;SID&gt;Anadir()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1803</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="418" approved="yes">
        <source>If another script would also map &lt;SID&gt;Add, it would get another script ID and thus define another mapping.</source>
        <target state="translated">Si otro script asigna &lt;SID&gt;Añadir a una macro, tendría otro identificador de script y por ello definiría otra macro.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1806</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="419" approved="yes">
        <source>Note that instead of s:Add() we use &lt;SID&gt;Add() here.  That is because the mapping is typed by the user, thus outside of the script.  The &lt;SID&gt; is translated to the script ID, so that Vim knows in which script to look for the Add() function.</source>
        <target state="translated">Tenga en cuenta que se usó «&lt;SID&gt;Anadir()» en lugar de «s:Anadir()» aquí. Eso es porque la macro es tecleada por el usuario, y por ello, se hace desde fuera del script. &lt;SID&gt; se expande al identificador del script, de forma que Vim sabe en qué script buscar la función «Anadir()».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1811</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="420" approved="yes">
        <source>This is a bit complicated, but it's required for the plugin to work together with other plugins.  The basic rule is that you use &lt;SID&gt;Add() in mappings and s:Add() in other places (the script itself, autocommands, user commands).</source>
        <target state="translated">Es un poco complicado, pero es necesario para que la extensión funcione adecuadamente con otras. La norma básica es que debe usar &lt;SID&gt;Anadir() en las macros y s:Anadir() en otros sitios (el mismo script, órdenes automáticas, órdenes de usuario).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1815</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="421" approved="yes">
        <source>We can also add a menu entry to do the same as the mapping: &gt;</source>
        <target state="translated">También podemos añadir una entrada de menú para que haga lo mismo que la macro: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1817</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="422" approved="yes">
        <source> 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
</source>
        <target state="translated"> 26	noremenu &lt;script&gt; Plugin.Añadir\ Corrección      &lt;SID&gt;Añadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1819</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="423" approved="yes">
        <source>The "Plugin" menu is recommended for adding menu items for plugins.  In this case only one item is used.  When adding more items, creating a submenu is recommended.  For example, "Plugin.CVS" could be used for a plugin that offers CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.</source>
        <target state="translated">Se recomienda el menú «Plugin» para añadir elementos de menú de extensiones. En este caso, sólo se usa un elemento. Recomendamos crear un menú secundario si añade más elementos. Por ejemplo, podría usar «Plugin.CVS» para una extensión que ofrezca operaciones CVS como «Plugin.CVS.checkin», «Plugin.CVS.checkout», etc.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1824</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="424" approved="yes">
        <source>Note that in line 28 ":noremap" is used to avoid that any other mappings cause trouble.  Someone may have remapped ":call", for example.  In line 24 we also use ":noremap", but we do want "&lt;SID&gt;Add" to be remapped.  This is why "&lt;script&gt;" is used here.  This only allows mappings which are local to the script. |:map-&lt;script&gt;| The same is done in line 26 for ":noremenu".  |:menu-&lt;script&gt;|</source>
        <target state="translated">Tenga en cuenta que «:noremap» se usa en la línea 28 para evitar problemas con otras macros. Puede que alguien haya asignado otra macro a «:call», por ejemplo. En la línea 24 también usamos «:noremap», pero queremos reasignar «&lt;SID&gt;Añadir». Por ello usamos aquí «&lt;script&gt;». Esto solo permite el uso de macros locales al script; para más información consulte |:map-&lt;script&gt;|. Se realiza la misma acción en la línea 26 con «:noremenu»; para más información consulte  |:menu-&lt;script&gt;|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1831</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="425" approved="yes">
        <source>&lt;SID&gt; AND &lt;Plug&gt;					*using-&lt;Plug&gt;*
</source>
        <target state="translated">&lt;SID&gt; Y &lt;Plug&gt;						*using-&lt;Plug&gt;*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1834</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="426" approved="yes">
        <source>Both &lt;SID&gt; and &lt;Plug&gt; are used to avoid that mappings of typed keys interfere with mappings that are only to be used from other mappings.  Note the difference between using &lt;SID&gt; and &lt;Plug&gt;:</source>
        <target state="translated">&lt;SID&gt; y &lt;Plug&gt; se usan para evitar que las macros de las teclas pulsadas interfieran con macros sólo usadas desde otras macros. Note la diferencia entre &lt;SID&gt; y &lt;Plug&gt;:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1838</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="427" approved="yes">
        <source>&lt;Plug&gt;	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  &lt;Plug&gt; is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: &lt;Plug&gt; scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	This results in "&lt;Plug&gt;TypecorrAdd".  Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.
</source>
        <target state="translated">&lt;Plug&gt;	es visible fuera del script. Se usa para macros que el usuario
	pueda querer ligar a un secuencia de teclas. &lt;Plug&gt; es un código
	especial que una tecla nunca podrá producir.
	Para evitar que otras extensiones usen la misma secuencia de
	caracteres, use la estructura: &lt;Plug&gt; nombre-script nombre-macro
	En nuestro ejemplo, el nombre del script es «Correccort», y el nombre
	de la macro es «Añadir».
	El resultado es «&lt;Plug&gt;CorreccortAñadir». Solo el primer carácter de los
	nombres es mayúscula, facilitando ver el principio del nombre de la
	macro.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1848</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="428" approved="yes">
        <source>&lt;SID&gt;	is the script ID, a unique identifier for a script.
	Internally Vim translates &lt;SID&gt; to "&lt;SNR&gt;123_", where "123" can be any
	number.  Thus a function "&lt;SID&gt;Add()" will have a name "&lt;SNR&gt;11_Add()"
	in one script, and "&lt;SNR&gt;22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of &lt;SID&gt; in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.
</source>
        <target state="translated">&lt;SID&gt; es el identificador (ID) del script, un número único.
	Internamente, Vim traduce &lt;SID&gt; como «&lt;SNR&gt;123_», donde «123»
	puede ser cualquier número. Por ello, la función «&lt;SID&gt;Anadir()»
	tendría el nombre «&lt;SNR&gt;11_Anadir()» en un script, y «&lt;SNR&gt;22_Anadir()»
	en otro. Puede verlo si usa la orden «:function» para obtener la lista de
	funciones.
	La traducción de &lt;SID&gt; en las macros es idéntica, y así puede invocar
	una función local de un script mediante una macro.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1856</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="429" approved="yes">
        <source>USER COMMAND</source>
        <target state="translated">ORDEN DE USUARIO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1859</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="430" approved="yes">
        <source>Now let's add a user command to add a correction: &gt;</source>
        <target state="translated">Vamos a añadir una orden de usuario para añadir una corrección: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1861</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="431" approved="yes">
        <source> 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif
</source>
        <target state="translated"> 38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1865</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="432" approved="yes">
        <source>The user command is defined only if no command with the same name already exists.  Otherwise we would get an error here.  Overriding the existing user command with ":command!" is not a good idea, this would probably make the user wonder why the command he defined himself doesn't work.  |:command|</source>
        <target state="translated">La orden de usuario se define únicamente si no existe una orden con el mismo nombre. En caso contrario, provocaría un error. Sobrescribir la orden de usuario existente con «:command!» no es una buena idea, ya que haría que el usuario se pregunte porqué no funciona la orden que ha definido. |:command|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1870</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="433" approved="yes">
        <source>SCRIPT VARIABLES</source>
        <target state="translated">VARIABLES DE SCRIPT</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1873</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="434" approved="yes">
        <source>When a variable starts with "s:" it is a script variable.  It can only be used inside a script.  Outside the script it's not visible.  This avoids trouble with using the same variable name in different scripts.  The variables will be kept as long as Vim is running.  And the same variables are used when sourcing the same script again. |s:var|</source>
        <target state="translated">Cuando una variable comienza con «s:», es una variable de script. Sólo se puede usar dentro de un script, y no es visible desde fuera. Esto evita problemas al usar el mismo nombre de variable en diferentes scripts. Las variables se preservarán durante la ejecución de Vim, y se usan al cargar el mismo script otra vez. |s:var|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1879</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="435" approved="yes">
        <source>The fun is that these variables can also be used in functions, autocommands and user commands that are defined in the script.  In our example we can add a few lines to count the number of corrections: &gt;</source>
        <target state="translated">Lo interesante es que estas variables se pueden usar en funciones, órdenes automáticas y órdenes de usuario definidas en el script. En nuestro ejemplo, añadimos unas pocas líneas para contar el número de correcciones: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1883</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="436" approved="yes">
        <source> 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
</source>
        <target state="translated"> 19	let s:cuenta = 4
 ..
 30	function s:Anadir(desde, correccion)
 ..
 34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta . " correcciones en este punto"
 36	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1891</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="437" approved="yes">
        <source>First s:count is initialized to 4 in the script itself.  When later the s:Add() function is called, it increments s:count.  It doesn't matter from where the function was called, since it has been defined in the script, it will use the local variables from this script.</source>
        <target state="translated">Al principio, «s:cuenta» se inicializa en el mismo script con un valor de 4. Al invocar la función «Anadir()» posteriormente, incrementa la variable «s:cuenta». No importa desde dónde se ha invocado la función, ya que está definida en el script, y usará las variables locales al script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1896</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="438" approved="yes">
        <source>THE RESULT</source>
        <target state="translated">EL RESULTADO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1899</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="439" approved="yes">
        <source>Here is the resulting complete example: &gt;</source>
        <target state="translated">Aquí tiene el ejemplo completo finalizado: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1901</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="440" approved="yes">
        <source>  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif
 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 25
 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
 27
 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif
 41
 42	let &amp;cpo = s:save_cpo
</source>
        <target state="translated">  1 " Extensión global de Vim para la corrección de errores
  2	" Último cambio:	15 de Octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
  5
  6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1
 10
 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 13
 14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronización
 19	let s:cuenta = 4
 20
 21	if !hasmapto('&lt;Plug&gt;CorreccortAñadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
 23	endif
 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAñadir  &lt;SID&gt;Añadir
 25
 26	noremenu &lt;script&gt; Plugin.Añadir\ Corrección      &lt;SID&gt;Añadir
 27
 28	noremap &lt;SID&gt;Añadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
 29
 30	function s:Anadir(desde, correccion)
 31	  let a = input("introduce la corrección de " . a:desde . ": ")
 32	  exe ":iabbrev " . a:desde . " " . a
 33	  if a:correccion | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif
 34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta . " correcciones en este punto"
 36	endfunction
 37
 38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif
 41
 42	let &amp;cpo = s:save_cpo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1944</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO the script doesn't do what it says it does. Fails at replacement of
newly-added corrections</context>
        </context-group>
        <note from="po-translator">TODO the script doesn't do what it says it does. Fails at replacement of
newly-added corrections</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="441" approved="yes">
        <source>Line 33 wasn't explained yet.  It applies the new correction to the word under the cursor.  The |:normal| command is used to use the new abbreviation.  Note that mappings and abbreviations are expanded here, even though the function was called from a mapping defined with ":noremap".</source>
        <target state="translated">Aún no hemos explicado la línea 33. Aplica la nueva corrección a la palabra bajo el cursor. La orden |:normal| se emplea para usar la nueva abreviatura. Tenga en cuenta que aquí se expanden las macros y abreviaturas, a pesar de que la función se ha invocado desde una macro definida con «:noremap».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1949</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="442" approved="yes">
        <source>Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before writing the file: &gt;</source>
        <target state="translated">Se recomienda usar «unix» como valor para la opción 'fileformat'. De esta forma, los scripts de Vim funcionarán en cualquier sistema. Los scripts con 'fileformat' definido como «dos» no funcionarán en Unix. También puede consultar |:source_crnl|. Para asegurar que hace lo correcto, haga lo siguiente antes de escribir el archivo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1954</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="443" approved="yes">
        <source>	:set fileformat=unix
</source>
        <target state="translated">	:set fileformat=unix
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1956</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="444" approved="yes">
        <source>DOCUMENTATION						*write-local-help*
</source>
        <target state="translated">DOCUMENTACIÓN   					*write-local-help*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1959</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="445" approved="yes">
        <source>It's a good idea to also write some documentation for your plugin.  Especially when its behavior can be changed by the user.  See |add-local-help| for how they are installed.</source>
        <target state="translated">Es una buena idea crear algo de documentación para su extensión, en particular si el usuario puede modificar su comportamiento. Para lo referente a la instalación de documentación, consulte |add-local-help|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1963</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="446" approved="yes">
        <source>Here is a simple example for a plugin help file, called "typecorr.txt": &gt;</source>
        <target state="translated">Aquí tiene un simple ejemplo para un archivo de ayuda de una extensión, llamado «typecorr.txt»: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1965</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="447" approved="yes">
        <source>  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	&lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.
</source>
        <target state="translated">  1	*correcort.txt*	Una extensión para corregir errores ortográficos
  2
  3	Esta extensión corrige automáticamente cualquier error ortográfico
  4	que pueda escribir.
  5
  6	Solo hay unas pocas correcciones. Puede añadir las suyas.
  7
  8	Macros:
  9	&lt;Leader&gt;a   o   &lt;Plug&gt;CorreccortAñadir
 10		Añade una corrección para la palabra bajo el cursor.
 11
 12	Órdenes:
 13	:Corregir {palabra}
 14		Añade una corrección para {palabra}.
 15
 16							*correcort-opciones*
 17	Esta extensión no tiene opciones de configuración.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1983</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="448" approved="yes">
        <source>The first line is actually the only one for which the format matters.  It will be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of help.txt |local-additions|.  The first "*" must be in the first column of the first line.  After adding your help file do ":help" and check that the entries line up nicely.</source>
        <target state="translated">En realidad, la primera línea es la única en la que el formato importa. Se extraerá del archivo de ayuda para su ubicación en la sección «LOCAL ADDITIONS:» de help.txt |local-additions|. El primer asterisco debe estar en la primera columna de la primera línea. Ejecute «:help» después de añadir su archivo de ayuda y compruebe que las entradas están alineadas adecuadamente.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1989</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="449" approved="yes">
        <source>You can add more tags inside ** in your help file.  But be careful not to use existing help tags.  You would probably use the name of your plugin in most of them, like "typecorr-settings" in the example.</source>
        <target state="translated">Puede añadir más etiquetas entre asteriscos ** en su archivo de ayuda, pero tenga la precaución de no usar etiquetas de ayuda existentes. Probablemente use el nombre de su extensión en la mayoría de etiquetas, como «correccort-opciones» en el ejemplo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1993</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="450" approved="yes">
        <source>Using references to other parts of the help in || is recommended.  This makes it easy for the user to find associated help.</source>
        <target state="translated">Se recomienda utilizar referencias a otras partes de archivos de ayuda mediante barras, ||. Esto facilita que el usuario encuentre ayuda relacionada.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1996</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="451" approved="yes">
        <source>FILETYPE DETECTION					*plugin-filetype*
</source>
        <target state="translated">EXTENSIÓN DE TIPO DE ARCHIVO			*plugin-filetype*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1999</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en la sintaxis de vim/help ?</context>
        </context-group>
        <note from="po-translator">TODO bug en la sintaxis de vim/help ?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="452" approved="yes">
        <source>If your filetype is not already detected by Vim, you should create a filetype detection snippet in a separate file.  It is usually in the form of an autocommand that sets the filetype when the file name matches a pattern.  Example: &gt;</source>
        <target state="translated">Si Vim no detecta su tipo de archivo, debería crear un fragmento de código de detección de tipo de archivo en un archivo separado. Habitualmente, tiene la forma de una orden automática que define el tipo de archivo cuando su nombre concuerda con un patrón. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2004</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="453" approved="yes">
        <source>	au BufNewFile,BufRead *.foo			set filetype=foofoo
</source>
        <target state="translated">	au BufNewFile,BufRead *.foo			set filetype=foofoo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2006</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="454" approved="yes">
        <source>Write this single-line file as "ftdetect/foofoo.vim" in the first directory that appears in 'runtimepath'.  For Unix that would be "~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the filetype for the script name.</source>
        <target state="translated">Escriba este archivo de una sola línea como «ftdetect/foofoo.vim» en el primer directorio que aparece en su 'runtimepath'. En Unix, sería «~/.vim/ftdetect/foofoo.vim». La convención es nombrar el script como el nombre del tipo de archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2011</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="455" approved="yes">
        <source>You can make more complicated checks if you like, for example to inspect the contents of the file to recognize the language.  Also see |new-filetype|.</source>
        <target state="translated">Si lo desea, puede hacer comprobaciones más complejas como inspeccionar los contenidos de un archivo para reconocer el tipo del mismo. Consulte también |new-filetype|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2014</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="456" approved="yes">
        <source>SUMMARY							*plugin-special*
</source>
        <target state="translated">RESUMEN							*plugin-special*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2017</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="457" approved="yes">
        <source>Summary of special things to use in a plugin:</source>
        <target state="translated">Resumen de los elementos especiales a utilizar en una extensión:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2019</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="458" approved="yes">
        <source>s:name			Variables local to the script.
</source>
        <target state="translated">s:nombre		Variables locales al script.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2021</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="459" approved="yes">
        <source>&lt;SID&gt;			Script-ID, used for mappings and functions local to
			the script.
</source>
        <target state="translated">&lt;SID&gt;			El identificador del script (Script-ID), utilizado en
			macros y funciones locales al script.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2024</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="460" approved="yes">
        <source>hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.
</source>
        <target state="translated">hasmapto()		Una función que comprueba si el usuario ya ha definido
			una macro para la funcionalidad que el script ofrece.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2027</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="461" approved="yes">
        <source>&lt;Leader&gt;		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.
</source>
        <target state="translated">&lt;Leader&gt;		El valor de «mapleader», que el usuario define como
			las teclas con las que iniciar las macros de extensiones.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2030</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="462" approved="yes">
        <source>:map &lt;unique&gt;		Give a warning if a mapping already exists.
</source>
        <target state="translated">::map &lt;unique&gt;		Emite un aviso si la macro ya existe.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2032</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="463" approved="yes">
        <source>:noremap &lt;script&gt;	Use only mappings local to the script, not global
			mappings.
</source>
        <target state="translated">:noremap &lt;script&gt;	Sólo usa macros locales al script, no macros globales.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2035</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="464" approved="yes">
        <source>exists(":Cmd")		Check if a user command already exists.
</source>
        <target state="translated">exists(":Orden")	Comprueba la existencia de una orden de usuario.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2037</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="465" approved="yes">
        <source>*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*
</source>
        <target state="translated">					*write-filetype-plugin* *ftplugin*
*41.12*	Escribir extensiones de tipo de archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2040</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="466" approved="yes">
        <source>A filetype plugin is like a global plugin, except that it sets options and defines mappings for the current buffer only.  See |add-filetype-plugin| for how this type of plugin is used.</source>
        <target state="translated">Una extensión de tipo de archivo («filetype plugin») es como una extensión global, a diferencia de que define opciones y macros que solo afectan al búfer local. Para saber más acerca del uso de este tipo de extensión, consulte  |add-filetype-plugin|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2044</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="467" approved="yes">
        <source>First read the section on global plugins above |41.11|.  All that is said there also applies to filetype plugins.  There are a few extras, which are explained here.  The essential thing is that a filetype plugin should only have an effect on the current buffer.</source>
        <target state="translated">En primer lugar, consulte la sección anterior sobre extensiones globales, |41.11|. Todo lo detallado ahí también afecta a las extensiones de tipo de archivo. Hay algunos elementos adicionales, que se explican aquí. Lo esencial es que una extensión de tipo de archivo sólo debe tener efecto en el búfer actual.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2049</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="468" approved="yes">
        <source>DISABLING</source>
        <target state="translated">DESACTIVAR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2052</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="469" approved="yes">
        <source>If you are writing a filetype plugin to be used by many people, they need a chance to disable loading it.  Put this at the top of the plugin: &gt;</source>
        <target state="translated">Si esta escribiendo una extensión de tipo de archivo que mucha gente usará, necesitarán la capacidad de desactivar su carga. Inserte lo siguiente al principio de la extensión: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2055</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="470" approved="yes">
        <source>	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</source>
        <target state="translated">	" Solo hace esto cuando aún no ha finalizado con este búfer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2061</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="471" approved="yes">
        <source>This also needs to be used to avoid that the same plugin is executed twice for the same buffer (happens when using an ":edit" command without arguments).</source>
        <target state="translated">Esto también sirve para evitar la ejecución de la misma extensión por duplicado en el mismo búfer (ocurre al usar la orden «:edit» sin argumentos).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2064</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="472" approved="yes">
        <source>Now users can disable loading the default plugin completely by making a filetype plugin with only this line: &gt;</source>
        <target state="translated">Usando este mecanismo, los usuarios pueden evitar cargar la extensión predeterminada si así lo desean, creando una extensión de tipo de archivo con sólo esta línea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2067</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="473" approved="yes">
        <source>	let b:did_ftplugin = 1
</source>
        <target state="translated">	let b:did_ftplugin = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2069</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="474" approved="yes">
        <source>This does require that the filetype plugin directory comes before $VIMRUNTIME in 'runtimepath'!</source>
        <target state="translated">Esto requiere que el directorio de extensiones de tipo de archivo aparezca antes de $VIMRUNTIME en 'runtimepath'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2072</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="475" approved="yes">
        <source>If you do want to use the default plugin, but overrule one of the settings, you can write the different setting in a script: &gt;</source>
        <target state="translated">Si desea usar la extensión predeterminada, pero cambiar la configuración de alguna de sus opciones, puede escribir un valor diferente para ellas en un script: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2075</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="476" approved="yes">
        <source>	setlocal textwidth=70
</source>
        <target state="translated">	setlocal textwidth=70
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2077</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="477" approved="yes">
        <source>Now write this in the "after" directory, so that it gets sourced after the distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be "~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set "b:did_ftplugin", but it is ignored here.</source>
        <target state="translated">Escriba esto en el directorio «after», para que se lea después de la extensión de tipo de archivo predeterminado distribuido, «vim.vim» |after-directory|.  En sistemas Unix, sería «~/.vim/after/ftplugin/vim.vim». Tenga en cuenta que la extensión predeterminada habrá definido «b:did_ftplugin», pero aquí se ignora.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2082</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="478" approved="yes">
        <source>To make sure the filetype plugin only affects the current buffer use the &gt;</source>
        <target state="translated">Para asegurar que la extensión de tipo de archivo solo afecta al búfer actual, use la orden &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2087</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="479" approved="yes">
        <source>	:setlocal
</source>
        <target state="translated">	:setlocal
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2089</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="480" approved="yes">
        <source>command to set options.  And only set options which are local to a buffer (see the help for the option to check that).  When using |:setlocal| for global options or options local to a window, the value will change for many buffers, and that is not what a filetype plugin should do.</source>
        <target state="translated">para definir opciones, y sólo defina opciones locales al búfer (consulte la ayuda para la opción que comprueba esto). Al usar |:setlocal| con opciones globales u opciones locales para una ventana, el valor cambiará para muchos búfers, y una extensión de tipo de archivo no debería hacer esto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2094</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="481" approved="yes">
        <source>When an option has a value that is a list of flags or items, consider using "+=" and "-=" to keep the existing value.  Be aware that the user may have changed an option value already.  First resetting to the default value and then changing it often a good idea.  Example: &gt;</source>
        <target state="translated">Cuando una opción tiene un valor que es una lista de opciones o elementos, considere usar «+=» y «-=» para conservar el valor existente. Sea consciente de que puede que el usuario ya haya cambiado el valor de una opción. Es una buena idea restablecer el valor original y después cambiarlo. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2099</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="482" approved="yes">
        <source>	:setlocal formatoptions&amp; formatoptions+=ro
</source>
        <target state="translated">	:setlocal formatoptions&amp; formatoptions+=ro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2101</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="483" approved="yes">
        <source>MAPPINGS</source>
        <target state="translated">MACROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2104</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="484" approved="yes">
        <source>To make sure mappings will only work in the current buffer use the &gt;</source>
        <target state="translated">Para asegurar que las macros sólo funcionen en el búfer local use la orden &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="485" approved="yes">
        <source>	:map &lt;buffer&gt;
</source>
        <target state="translated">	:map &lt;buffer&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2108</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="486" approved="yes">
        <source>command.  This needs to be combined with the two-step mapping explained above.  An example of how to define functionality in a filetype plugin: &gt;</source>
        <target state="translated">Se debe usar en combinación con la macro compuesta de dos pasos explicada anteriormente. A continuación una definición de ejemplo para una funcionalidad en una extensión de tipo de archivo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2111</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="487" approved="yes">
        <source>	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</source>
        <target state="translated">	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2116</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="488" approved="yes">
        <source>|hasmapto()| is used to check if the user has already defined a map to &lt;Plug&gt;JavaImport.  If not, then the filetype plugin defines the default mapping.  This starts with |&lt;LocalLeader&gt;|, which allows the user to select the key(s) he wants filetype plugin mappings to start with.  The default is a backslash.  "&lt;unique&gt;" is used to give an error message if the mapping already exists or overlaps with an existing mapping.  |:noremap| is used to avoid that any other mappings that the user has defined interferes.  You might want to use ":noremap &lt;script&gt;" to allow remapping mappings defined in this script that start with &lt;SID&gt;.</source>
        <target state="translated">|hasmapto()| sirve para comprobar si el usuario ya ha definido una macro para «&lt;Plug&gt;JavaImport». Si no ha sido definida, la extensión de tipo de archivo define la macro actual. Esta empieza con |&lt;LocalLeader&gt;|, que permite al usuario seleccionar una o mas teclas con las que iniciar las macros de la extensión de tipo de archivo. El valor predeterminado es una barra inversa, «\». «&lt;unique&gt;» sirve para emitir un mensaje de error si la macro ya existe o entra en conflicto con otra. |:noremap| sirve para evitar que las macros definidas por el usuario interfieran. Puede que desee usar «:noremap &lt;script&gt;» para permitir redefinir macros en el script que comienza con &lt;SID&gt;.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2127</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO mal ubicados los cambios de línea</context>
        </context-group>
        <note from="po-translator">TODO mal ubicados los cambios de línea</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="489" approved="yes">
        <source>The user must have a chance to disable the mappings in a filetype plugin, without disabling everything.  Here is an example of how this is done for a plugin for the mail filetype: &gt;</source>
        <target state="translated">Tiene que ofrecer al usuario la opción de desactivar macros en una extensión de tipo de archivo, sin desactivar el resto. Aquí tiene un ejemplo de como hacerlo con una extensión para el tipo de archivo mail: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2131</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="490" approved="yes">
        <source>	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Quote text by inserting "&gt; "
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</source>
        <target state="translated">	" Añade macros, a menos que el usuario defina lo contrario.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Cita el texto insertando «&gt; »
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2142</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="491" approved="yes">
        <source>Two global variables are used:
no_plugin_maps		disables mappings for all filetype plugins
no_mail_maps		disables mappings for a specific filetype
</source>
        <target state="translated">Se utilizan dos variables globales:
no_plugin_maps		desactiva las macros de todas las extensiones de tipo
			de archivo
no_mail_maps		desactiva las macros para un tipo de archivo
			particular
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2146</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="492" approved="yes">
        <source>USER COMMANDS</source>
        <target state="translated">ÓRDENES DE USUARIO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2149</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="493" approved="yes">
        <source>To add a user command for a specific file type, so that it can only be used in one buffer, use the "-buffer" argument to |:command|.  Example: &gt;</source>
        <target state="translated">El argumento «-buffer» de |:command| permite añadir una orden de usuario para un tipo de archivo específico y que solo afecta al búfer local. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2152</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="494" approved="yes">
        <source>	:command -buffer  Make  make %:r.s
</source>
        <target state="translated">	:command -buffer  Make  make %:r.s
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2154</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="495" approved="yes">
        <source>VARIABLES</source>
        <target state="translated">VARIABLES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2157</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="496" approved="yes">
        <source>A filetype plugin will be sourced for each buffer of the type it's for.  Local script variables |s:var| will be shared between all invocations.  Use local buffer variables |b:var| if you want a variable specifically for one buffer.</source>
        <target state="translated">Las extensiones de tipo de archivo serán cargadas en cada búfer del tipo correspondiente. Las variables de script locales |s:var| se compartirán entre las diferentes llamadas a una misma extensión (o script en general.) Use las variables locales al búfer |b:var| si desea usar una variable local a un búfer.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2161</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="497" approved="yes">
        <source>FUNCTIONS</source>
        <target state="translated">FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2164</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="498" approved="yes">
        <source>When defining a function, this only needs to be done once.  But the filetype plugin will be sourced every time a file with this filetype will be opened.  This construct makes sure the function is only defined once: &gt;</source>
        <target state="translated">Cada función necesita ser definida una sola vez. Pero la extensión de tipo de archivo se cargará cada vez que se abra un archivo del tipo correspondiente. Esta estructura asegura que la función se defina una sola vez: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2168</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="499" approved="yes">
        <source>	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</source>
        <target state="translated">	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2175</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="500" approved="yes">
        <source>UNDO							*undo_ftplugin*
</source>
        <target state="translated">DESHACER 					*undo_ftplugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2177</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="501" approved="yes">
        <source>When the user does ":setfiletype xyz" the effect of the previous filetype should be undone.  Set the b:undo_ftplugin variable to the commands that will undo the settings in your filetype plugin.  Example: &gt;</source>
        <target state="translated">Cuando el usuario hace «:setfiletype xyz», el efecto del tipo de archivo anterior debería desaparecer. Defina la variable «b:undo_ftplugin» con las órdenes que deshacen los cambios de configuración de su extensión de tipo de archivo.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2181</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="502" approved="yes">
        <source>	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</source>
        <target state="translated">	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2184</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="503" approved="yes">
        <source>Using ":setlocal" with "&lt;" after the option name resets the option to its global value.  That is mostly the best way to reset the option value.</source>
        <target state="translated">Usar «:setlocal» con «&lt;» después del nombre de la opción restablece la opción a su valor global. Habitualmente, es la mejor forma de restablecer el valor de una opción.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2187</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="504" approved="yes">
        <source>This does require removing the "C" flag from 'cpoptions' to allow line continuation, as mentioned above |use-cpo-save|.</source>
        <target state="translated">Esto requiere eliminar la opción «C» de 'cpoptions' para permitir la continuación de la línea, como se mencionó anteriormente |use-cpo-save|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2190</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="505" approved="yes">
        <source>FILE NAME</source>
        <target state="translated">NOMBRE DE ARCHIVO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2193</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="506" approved="yes">
        <source>The filetype must be included in the file name |ftplugin-name|.  Use one of these three forms:</source>
        <target state="translated">El nombre del archivo debe incluir el tipo de archivo |ftplugin-name|. Puede usar una de las tres formas a continuación:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2196</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="507" approved="yes">
        <source>	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim
</source>
        <target state="translated">	.../ftplugin/algo.vim
	.../ftplugin/algo_foo.vim
	.../ftplugin/algo/bar.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2200</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="508" approved="yes">
        <source>"stuff" is the filetype, "foo" and "bar" are arbitrary names.</source>
        <target state="translated">«algo» es el tipo de archivo, «foo» y «bar» son nombres aleatorios.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2202</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="509" approved="yes">
        <source>SUMMARY							*ftplugin-special*
</source>
        <target state="translated">RESUMEN							*ftplugin-special*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2205</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="510" approved="yes">
        <source>Summary of special things to use in a filetype plugin:</source>
        <target state="translated">Un resumen de los aspectos a considerar cuando escriba una extensión de tipo de archivo:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2207</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="511" approved="yes">
        <source>&lt;LocalLeader&gt;		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.
</source>
        <target state="translated">&lt;LocalLeader&gt;		El valor de «maplocalleader», que el usuario define
			como la tecla que inicia las macros de extensión de
			tipo de archivo.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2210</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="512" approved="yes">
        <source>:map &lt;buffer&gt;		Define a mapping local to the buffer.
</source>
        <target state="translated">:map &lt;buffer&gt;		Define una macro local al búfer.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2212</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="513" approved="yes">
        <source>:noremap &lt;script&gt;	Only remap mappings defined in this script that start
			with &lt;SID&gt;.
</source>
        <target state="translated">:noremap &lt;script&gt;	Sólo modifica macros definidas en el script que
			comienzan con &lt;SID&gt;.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2215</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="514" approved="yes">
        <source>:setlocal		Set an option for the current buffer only.
</source>
        <target state="translated">:setlocal		Define una opción para el búfer actual.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2217</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="515" approved="yes">
        <source>:command -buffer	Define a user command local to the buffer.
</source>
        <target state="translated">:command -buffer	Define una orden de usuario local al búfer.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2219</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="516" approved="yes">
        <source>exists("*s:Func")	Check if a function was already defined.
</source>
        <target state="translated">exists("*s:Funcion")	Comprueba si una función ya se ha definido
			anteriormente.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="517" approved="yes">
        <source>Also see |plugin-special|, the special things used for all plugins.</source>
        <target state="translated">Consulte también |plugin-special|, las cosas especiales utilizadas por todas las extensiones.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2223</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="518" approved="yes">
        <source>*41.13*	Writing a compiler plugin		*write-compiler-plugin*
</source>
        <target state="translated">*41.13*	Escribir extensiones para compiladores	*write-compiler-plugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2226</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="519" approved="yes">
        <source>A compiler plugin sets options for use with a specific compiler.  The user can load it with the |:compiler| command.  The main use is to set the 'errorformat' and 'makeprg' options.</source>
        <target state="translated">Una extensión de compilador define opciones a usar con un compilador específico. El usuario puede cargarlo con la orden |:compiler|. El uso principal es definir las opciones 'errorformat' y 'makeprg'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2230</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="520" approved="yes">
        <source>Easiest is to have a look at examples.  This command will edit all the default compiler plugins: &gt;</source>
        <target state="translated">Lo más sencillo es ver unos ejemplos. Esta orden editará todas las extensiones de compilador predeterminadas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2233</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="521" approved="yes">
        <source>	:next $VIMRUNTIME/compiler/*.vim
</source>
        <target state="translated">	:next $VIMRUNTIME/compiler/*.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="522" approved="yes">
        <source>Use |:next| to go to the next plugin file.</source>
        <target state="translated">Use |:next| para ir al siguiente archivo de extensión.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2237</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="523" approved="yes">
        <source>There are two special items about these files.  First is a mechanism to allow a user to overrule or add to the default file.  The default files start with: &gt;</source>
        <target state="translated">Hay dos aspectos a tener en cuenta con estas extensiones. En primer lugar, deben contar con un mecanismo que permita al usuario anular o añadir cambios a la extensión. Las extensiones predeterminadas comienzan con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2240</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="524" approved="yes">
        <source>	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</source>
        <target state="translated">	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="525" approved="yes">
        <source>When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
							*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: &gt;
</source>
        <target state="translated">Cuando escribe un archivo de compilador, y lo ubica en su directorio de
ejecución personal (esto es, «~/.vim/compiler» en sistemas Unix), debe definir
la variable «current_compiler» para que la extensión de compilador
predeterminada evite hacer cambios en la configuración.
							*:CompilerSet*
El segundo mecanismo es usar «:set» con «:compiler!», y «:setlocal» con
«:compiler». Para ello, Vim define la orden de usuario «:CompilerSet». Por
otra parte, las versiones anteriores de Vim no cuentan de ella, y por ello su
extensión debe definirlo. Aquí tiene un ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2254</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="526" approved="yes">
        <source>  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" use the default 'errorformat'
  CompilerSet makeprg=nmake
</source>
        <target state="translated">  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" usa 'errorformat' predeterminado
  CompilerSet makeprg=nmake
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2260</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="527" approved="yes">
        <source>When you write a compiler plugin for the Vim distribution or for a system-wide runtime directory, use the mechanism mentioned above.  When "current_compiler" was already set by a user plugin nothing will be done.</source>
        <target state="translated">Use el mecanismo mostrado aquí cuando escriba una extensión de compilador para la distribución Vim o para un directorio de tiempo de ejecución del sistema. No se hará nada si «current_compiler» ya está definido por una extensión de usuario.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2264</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="528" approved="yes">
        <source>When you write a compiler plugin to overrule settings from a default plugin, don't check "current_compiler".  This plugin is supposed to be loaded last, thus it should be in a directory at the end of 'runtimepath'.  For Unix that could be ~/.vim/after/compiler.</source>
        <target state="translated">Cuando escribe una extensión de compilador para cambiar las opciones definidas por una extensión predeterminada, evite comprobar «current_compiler». Esta extensión se debería cargar al final, y por ello debería estar en un directorio al final de 'runtimepath'. En sistemas Unix, podría ser «~/.vim/after/compiler».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="529" approved="yes">
        <source>*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*
</source>
        <target state="translated">*41.14*	Escribir extensiones que carguen rápidamente  *write-plugin-quickload*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2272</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="530" approved="yes">
        <source>A plugin may grow and become quite long.  The startup delay may become noticeable, while you hardly ever use the plugin.  Then it's time for a quickload plugin.</source>
        <target state="translated">Puede que una extensión crezca, y que sea demasiado larga. Puede que el tiempo de carga empiece a hacerse notorio, y además, que usted apenas use la extensión. En este caso, hay que usar una extensión de carga rápida («quickload»).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2276</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="531" approved="yes">
        <source>The basic idea is that the plugin is loaded twice.  The first time user commands and mappings are defined that offer the functionality.  The second time the functions that implement the functionality are defined.</source>
        <target state="translated">La idea principal es que la extensión se carga dos veces. La primera vez, se definen las órdenes de usuario y macros que ofrecen la funcionalidad de la extensión. La segunda vez, se definen las funciones que implementan tales funcionalidades.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2280</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="532" approved="yes">
        <source>It may sound surprising that quickload means loading a script twice.  What we mean is that it loads quickly the first time, postponing the bulk of the script to the second time, which only happens when you actually use it.  When you always use the functionality it actually gets slower!</source>
        <target state="translated">Puede que sorprenda que «carga rápida» signifique cargar una extensión dos veces.  Lo que queremos decir es que se carga rápidamente la primera, demorando la carga de la mayoría de la extensión a la segunda vez, lo que sólo ocurre cuando realmente la usa. ¡Si usa siempre la funcionalidad que provee la extensión, no obtendrá ninguna ventaja!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2285</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="533" approved="yes">
        <source>Note that since Vim 7 there is an alternative: use the |autoload| functionality |41.15|.</source>
        <target state="translated">Tenga en cuenta que hay una alternativa a partir de la versión 7 de Vim: use la funcionalidad |autoload|, |41.15|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2288</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="534" approved="yes">
        <source>The following example shows how it's done: &gt;</source>
        <target state="translated">Los siguientes ejemplos muestran como se hace: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2290</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="535" approved="yes">
        <source>	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" License:	This file is placed in the public domain.
</source>
        <target state="translated">	" Extensión global de Vim para mostrar la carga rápida
	" Último cambio:	2005 Feb 25
	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" Licencia:	Este archivo se encuentra en el dominio público
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2295</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="536" approved="yes">
        <source>	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;
</source>
        <target state="translated">	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('algo')&lt;CR&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2299</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="537" approved="yes">
        <source>		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</source>
        <target state="translated">		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="538" approved="yes">
        <source>	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read functionality here
	endfunction
</source>
        <target state="translated">	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" Funcionalidad de lectura aquí
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2309</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="539" approved="yes">
        <source>	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write functionality here
	endfunction
</source>
        <target state="translated">	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" Funcionalidad de escritura aquí
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2314</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="540" approved="yes">
        <source>When the script is first loaded "s:did_load" is not set.  The commands between the "if" and "endif" will be executed.  This ends in a |:finish| command, thus the rest of the script is not executed.</source>
        <target state="translated">Cuando el script se carga por primera vez, «s:did_load» no está definida, y se ejecutan las órdenes entre «if» y «endif». Se termina con una orden |:finish|, impidiendo ejecutar el resto del script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2318</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="541" approved="yes">
        <source>The second time the script is loaded "s:did_load" exists and the commands after the "endif" are executed.  This defines the (possible long)  BufNetRead() and BufNetWrite() functions.</source>
        <target state="translated">La segunda vez que se carga, «s:did_load» existe y se ejecutan las órdenes después de «endif». Esto define las (posiblemente largas) funciones BufNetRead() y BufNetWrite().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2322</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="542" approved="yes">
        <source>If you drop this script in your plugin directory Vim will execute it on startup.  This is the sequence of events that happens:</source>
        <target state="translated">Si ubica este script en su directorio «plugin», Vim lo ejecutará al inicio. A continuación la secuencia de los eventos:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2325</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="543" approved="yes">
        <source>1. The "BNRead" command is defined and the &lt;F19&gt; key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.
</source>
        <target state="translated">1. Se define la orden «BNRead» y la tecla &lt;F19&gt; se asigna a una macro al cargar
el script al inicio. Se define una orden automática |FuncUndefined|. La orden
  «:finish» hace que el script finalice antes.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2329</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="544" approved="yes">
        <source>2. The user types the BNRead command or presses the &lt;F19&gt; key.  The
   BufNetRead() or BufNetWrite() function will be called.
</source>
        <target state="translated">2. El usuario introduce la orden «BNRead» o pulsa la tecla &lt;F19&gt;. Se
  invoca la función «BufNetRead()» o «BufNetWrite()».
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2332</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="545" approved="yes">
        <source>3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "&lt;sfile&gt;" (see |expand()|).
</source>
        <target state="translated">3. Vim no puede encontrar la función y ejecuta la orden automática
  |FuncUndefined|. Ya que el patrón «BufNet*» coincide con la función invocada,
  se ejecutará la orden «source nombre-archivo». «nombre-archivo» debe ser
  igual al nombre del script, sin importar su ubicación, ya que procede de
  expandir «&lt;sfile&gt;» (consulte |expand()|).
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2338</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="546" approved="yes">
        <source>4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.
</source>
        <target state="translated">4. El script se carga otra vez, la variable «s:did_load» existe, y se
   definen las funciones.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2341</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="547" approved="yes">
        <source>Notice that the functions that are loaded afterwards match the pattern in the |FuncUndefined| autocommand.  You must make sure that no other plugin defines functions that match this pattern.</source>
        <target state="translated">Tenga en cuenta que las funciones se cargan después de comparar el patrón en la orden automática |FuncUndefined|. Debe comprobar que ninguna otra extensión define funciones que coincidan con este patrón.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2345</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="548" approved="yes">
        <source>*41.15*	Writing library scripts			*write-library-script*
</source>
        <target state="translated">*41.15*	Crear bibliotecas				*write-library-script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2348</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="549" approved="yes">
        <source>Some functionality will be required in several places.  When this becomes more than a few lines you will want to put it in one script and use it from many scripts.  We will call that one script a library script.</source>
        <target state="translated">Algunas funcionalidades son necesarias en varios lugares. Cuando se trata de algo más que unos pocas líneas, querrá ubicarlo en un script, y usarlo desde varios otros. Vamos a denominar ese script como biblioteca.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2352</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="550" approved="yes">
        <source>Manually loading a library script is possible, so long as you avoid loading it when it's already done.  You can do this with the |exists()| function.  Example: &gt;</source>
        <target state="translated">Cargar una biblioteca manualmente es posible, siempre que evite cargarla cuando ya lo está. Puede evitarlo con la función |exists()|. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2356</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="551" approved="yes">
        <source>	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)
</source>
        <target state="translated">	if !exists('*MiFuncionBiblioteca')
	   runtime library/biblioteca.vim
	endif
	call MiFuncionBiblioteca(arg)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2361</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="552" approved="yes">
        <source>Here you need to know that MyLibFunction() is defined in a script "library/mylibscript.vim" in one of the directories in 'runtimepath'.</source>
        <target state="translated">Aquí tiene que saber que MiFunciónBiblioteca() se define en el script «library/biblioteca.vim», en uno de los directorios de 'runtimepath'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2364</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="553" approved="yes">
        <source>To make this a bit simpler Vim offers the autoload mechanism.  Then the example looks like this: &gt;</source>
        <target state="translated">Para hacer esto más sencillo, Vim ofrece el mecanismo «autoload» (carga automática). Así, el ejemplo tendría este aspecto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2367</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="554" approved="yes">
        <source>	call mylib#myfunction(arg)
</source>
        <target state="translated">	call mibiblioteca#mifuncion(arg)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2369</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="555" approved="yes">
        <source>That's a lot simpler, isn't it? Vim will recognize the function name and when it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.  That script must define the "mylib#myfunction()" function.</source>
        <target state="translated">Mucho más sencillo, ¿verdad? Vim reconoce el nombre de la función y, cuando no esté definida, la buscará el script «autoload/mibiblioteca.vim» en 'runtimepath'. El script debe definir la función «mibiblioteca#mifuncion()».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2373</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="556" approved="yes">
        <source>You can put many other functions in the mylib.vim script, you are free to organize your functions in library scripts.  But you must use function names where the part before the '#' matches the script name.  Otherwise Vim would not know what script to load.</source>
        <target state="translated">Puede almacenar varias funciones en el script mibiblioteca.vim, y puede organizar como desee las funciones en sus bibliotecas. Pero debe usar nombres de funciones en las que la parte que precede a «#» coincide con el nombre del script. En caso contrario, Vim no sabrá qué script cargar.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2378</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="557" approved="yes">
        <source>If you get really enthusiastic and write lots of library scripts, you may want to use subdirectories.  Example: &gt;</source>
        <target state="translated">Si esto le entusiasma, y escribe muchas bibliotecas, puede que quiera usar subdirectorios. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2381</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="558" approved="yes">
        <source>	call netlib#ftp#read('somefile')
</source>
        <target state="translated">	call netlib#ftp#read('somefile')
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2383</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="559" approved="yes">
        <source>For Unix the library script used for this could be:</source>
        <target state="translated">En sistemas Unix, la biblioteca a usar podría ser:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2385</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="560" approved="yes">
        <source>	~/.vim/autoload/netlib/ftp.vim
</source>
        <target state="translated">	~/.vim/autoload/netlib/ftp.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="561" approved="yes">
        <source>Where the function is defined like this: &gt;</source>
        <target state="translated">Donde se define la función así: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2389</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="562" approved="yes">
        <source>	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction
</source>
        <target state="translated">	function netlib#ftp#read(nombre_archivo)
		"  Lee al archivo mediante FTP
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2393</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="563" approved="yes">
        <source>Notice that the name the function is defined with is exactly the same as the name used for calling the function.  And the part before the last '#' exactly matches the subdirectory and script name.</source>
        <target state="translated">Tenga en cuenta que el nombre con el que se define la función es idéntico al utilizado para invocar la función. Y la parte a continuación del último «#» coincide con el subdirectorio y el nombre del script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2397</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="564" approved="yes">
        <source>You can use the same mechanism for variables: &gt;</source>
        <target state="translated">Puede utilizar el mismo mecanismo con variables: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2399</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="565" approved="yes">
        <source>	let weekdays = dutch#weekdays
</source>
        <target state="translated">	let dias_semana = colombia#dias_semana
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2401</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="566" approved="yes">
        <source>This will load the script "autoload/dutch.vim", which should contain something like: &gt;</source>
        <target state="translated">Esto cargará el script «autoload/colombia.vim», que contendría algo similar a lo siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2404</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">revisar que caracteres no-ascii sirvan</context>
        </context-group>
        <note from="po-translator">revisar que caracteres no-ascii sirvan</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="567" approved="yes">
        <source>	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']
</source>
        <target state="translated">	let colombia#dias_semana = ['lunes', 'martes', 'miércoles', 'jueves',
		\ 'viernes', 'sábado', 'domingo']
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2407</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">revisar que caracteres no-ascii sirvan</context>
        </context-group>
        <note from="po-translator">revisar que caracteres no-ascii sirvan</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="568" approved="yes">
        <source>Further reading: |autoload|.</source>
        <target state="translated">Lecturas adicionales: |autoload|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2409</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="569" approved="yes">
        <source>*41.16*	Distributing Vim scripts			*distribute-script*
</source>
        <target state="translated">*41.16*	Distribuir scripts de Vim			*distribute-script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2412</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="570" approved="yes">
        <source>Vim users will look for scripts on the Vim website: http://www.vim.org.  If you made something that is useful for others, share it!</source>
        <target state="translated">Los usuarios de Vim buscarán scripts en el sitio web de Vim: http://www.vim.org. Si ha creado algo útil para otros, ¡compártalo!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2415</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="571" approved="yes">
        <source>Vim scripts can be used on any system.  There might not be a tar or gzip command.  If you want to pack files together and/or compress them the "zip" utility is recommended.</source>
        <target state="translated">Los scripts de Vim se pueden usar en cualquier sistema. Las órdenes tar o gzip pueden no estar disponibles en dichos sistemas. Si desea empaquetar o comprimir los archivos, se recomienda usar la herramienta «zip».</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2419</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="572" approved="yes">
        <source>For utmost portability use Vim itself to pack scripts together.  This can be done with the Vimball utility.  See |vimball|.</source>
        <target state="translated">Para obtener la máxima portabilidad use Vim para empaquetar los scripts. Puede hacer esto con la herramienta Vimball. Consulte |vimball|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2422</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="573" approved="yes">
        <source>It's good if you add a line to allow automatic updating.  See |glvs-plugins|.</source>
        <target state="translated">Es una buena idea añadir una línea para pemitir la actualización automática. Consulte |glvs-plugins|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2424</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="574" approved="yes">
        <source>Next chapter: |usr_42.txt| Add new menus</source>
        <target state="translated">Capítulo siguiente: |usr_42.esx| Añadir menús nuevos</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2428</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
    </body>
  </file>
</xliff>
