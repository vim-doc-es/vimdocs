<?xml version='1.0' encoding='utf-8'?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.1" version="1.1">
  <file original="po/usr_41.txt.po" source-language="en-US" datatype="plaintext">
    <body>
      <trans-unit xml:space="preserve" id="1" approved="no" restype="x-gettext-domain-header">
        <source>Project-Id-Version: Vim 7.3
Report-Msgid-Bugs-To: vim@bugs.org
POT-Creation-Date: 2010-12-09 16:51+0100
PO-Revision-Date: 2011-02-26 19:16+0200
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: vim-doc-es
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.7.0-beta4
X-Project-Style: default
</source>
        <target state="translated">Project-Id-Version: Vim 7.3
Report-Msgid-Bugs-To: vim@bugs.org
POT-Creation-Date: 2010-12-09 16:51+0100
PO-Revision-Date: 2011-02-26 19:16+0200
Last-Translator: Omar Campagne &lt;ocampagne@gmail.com&gt;
Language-Team: vim-doc-es
Language: es
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Plural-Forms: nplurals=2; plural=(n != 1);
X-Generator: Virtaal 0.7.0-beta4
X-Project-Style: default
</target>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">Spanish translations for Vim package
Copyright (C) 2010 Free Software Foundation, Inc.
This file is distributed under the same license as the Vim package.
Automatically generated, 2010.
Omar Campagne &lt;ocampagne@gmail.com&gt;, 2011.</context>
        </context-group>
        <note from="po-translator">Spanish translations for Vim package
Copyright (C) 2010 Free Software Foundation, Inc.
This file is distributed under the same license as the Vim package.
Automatically generated, 2010.
Omar Campagne &lt;ocampagne@gmail.com&gt;, 2011.</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="2" approved="yes">
        <source>==============================================================================
</source>
        <target state="translated">==============================================================================
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">18</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">79</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">180</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">290</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">518</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">596</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">689</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">817</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/intro.txt</context>
          <context context-type="linenumber">880</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">7</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">58</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">172</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">281</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">340</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">352</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">19</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">50</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">100</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">181</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">25</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">69</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">130</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">179</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">307</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">369</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">406</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">560</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">74</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">101</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">147</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">172</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">223</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">265</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">491</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">552</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">650</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">74</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">160</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">194</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">324</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">360</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">390</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">446</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">469</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">510</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">63</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">219</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">418</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">467</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">506</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">621</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">50</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">135</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">189</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">270</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">276</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">63</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">179</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">316</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">404</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">444</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">475</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">26</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">82</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">109</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">161</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">215</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">278</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">337</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">477</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">509</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">597</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">124</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">175</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">259</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">285</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">342</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">378</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">547</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">621</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">667</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">692</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">820</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">82</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">288</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">303</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">25</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">90</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">131</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">177</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">202</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">231</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">281</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">309</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">113</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">158</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">285</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">327</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">380</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">24</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">47</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">87</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">236</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">385</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">438</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">495</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">148</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">213</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">272</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">396</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">114</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">156</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">238</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">324</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">339</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">96</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">119</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">268</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">305</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">336</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">369</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">493</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">537</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">583</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">602</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">132</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">210</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">287</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">453</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">574</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">46</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">103</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">136</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">217</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">26</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">88</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">136</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">350</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">427</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">469</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">510</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">559</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">27</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">54</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">121</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">185</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">211</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">315</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">331</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">375</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">389</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">422</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">273</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">441</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">570</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">609</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">23</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">202</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">336</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">409</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">515</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">639</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">22</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">81</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">133</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">160</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">208</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">268</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">44</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">92</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">140</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">176</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">20</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">279</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">424</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">653</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">33</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">133</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">267</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">345</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">482</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">532</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">877</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1104</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1390</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1447</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1617</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2038</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2224</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2270</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2346</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2410</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2425</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">140</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">254</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">293</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">361</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">21</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">214</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">288</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">341</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">417</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">494</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="3" approved="yes">
        <source>		     VIM USER MANUAL - by Bram Moolenaar
</source>
        <target state="translated">		MANUAL DE USUARIO DE VIM - por Bram Moolenaar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">4</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="4" approved="yes">
        <source>Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:</source>
        <target state="translated">Copyright: consulte |manual-copyright| vim:tw=78:ts=8:ft=help:norl:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_toc.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_01.txt</context>
          <context context-type="linenumber">185</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_02.txt</context>
          <context context-type="linenumber">564</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_03.txt</context>
          <context context-type="linenumber">654</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_04.txt</context>
          <context context-type="linenumber">514</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_05.txt</context>
          <context context-type="linenumber">625</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_06.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_07.txt</context>
          <context context-type="linenumber">479</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">601</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_09.txt</context>
          <context context-type="linenumber">289</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_10.txt</context>
          <context context-type="linenumber">824</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_11.txt</context>
          <context context-type="linenumber">307</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_12.txt</context>
          <context context-type="linenumber">358</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_20.txt</context>
          <context context-type="linenumber">384</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_21.txt</context>
          <context context-type="linenumber">499</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_22.txt</context>
          <context context-type="linenumber">400</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_23.txt</context>
          <context context-type="linenumber">343</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">606</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_25.txt</context>
          <context context-type="linenumber">578</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_26.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_27.txt</context>
          <context context-type="linenumber">563</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_28.txt</context>
          <context context-type="linenumber">426</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_29.txt</context>
          <context context-type="linenumber">613</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_30.txt</context>
          <context context-type="linenumber">643</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_31.txt</context>
          <context context-type="linenumber">272</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_32.txt</context>
          <context context-type="linenumber">180</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_40.txt</context>
          <context context-type="linenumber">657</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2429</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_42.txt</context>
          <context context-type="linenumber">365</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_90.txt</context>
          <context context-type="linenumber">498</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="5" approved="yes">
        <source>OPTIONS</source>
        <target state="translated">OPCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_08.txt</context>
          <context context-type="linenumber">153</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_24.txt</context>
          <context context-type="linenumber">168</context>
        </context-group>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2085</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="6" approved="yes">
        <source>*usr_41.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</source>
        <target state="translated">*usr_41.esx*	Para Vim versin 7.3.  ltimo cambio: 20/7/2010
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="7" approved="yes">
        <source>			      Write a Vim script
</source>
        <target state="translated">			     Escribir scripts para Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">6</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="8" approved="yes">
        <source>The Vim script language is used for the startup vimrc file, syntax files, and many other things.  This chapter explains the items that can be used in a Vim script.  There are a lot of them, thus this is a long chapter.</source>
        <target state="translated">El lenguaje de programacin de Vim se usa en el archivo de arranque vimrc, los archivos de sintaxis, y muchas otras cosas. Este captulo presenta y explica en detalle los elementos que componen un script de Vim. Hay muchos de ellos, por lo que ste es un captulo largo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">11</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="9" approved="yes">
        <source>|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts
</source>
        <target state="translated">|41.1|	Introduccin
|41.2|	Variables
|41.3|	Expresiones
|41.4|	Estructuras de decisin
|41.5|	Ejecucin de expresiones
|41.6|	Funciones
|41.7|	Definicin de funciones
|41.8|	Listas y Diccionarios
|41.9|	Excepciones
|41.10|	Observaciones
|41.11|	Escribir extensiones
|41.12|	Escribir extensiones para tipo de archivo
|41.13|	Escribir extensiones para compiladores
|41.14|	Escribir extensiones que carguen rpidamente
|41.15|	Escribir bibliotecas
|41.16|	Distribuir scripts de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">28</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="10" approved="yes">
        <source>     Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|
</source>
        <target state="translated"> Captulo siguiente: |usr_42.esx|  Aadir mens nuevos
  Captulo anterior: |usr_40.esx|  Crear rdenes nuevas
Tabla de contenidos: |usr_toc.txt|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">32</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="11" approved="yes">
        <source>*41.1*	Introduction				*vim-script-intro* *script*
</source>
        <target state="translated">*41.1*	Introduccin				*vim-script-intro* *script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">35</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="12" approved="yes">
        <source>Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
":"; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.
</source>
        <target state="translated">Su primer acercamiento a los scripts de Vim es el archivo vimrc. Vim lo lee en
el arranque y ejecuta las rdenes que se encuentren ah. En este archivo puede
dar el valor que prefiera a las opciones existentes, as como usar
cualquier orden (algunas veces se hace referencia a las rdenes que empiezan
con : como rdenes Ex, o simplemente rdenes).
   Los archivos de sintaxis tambin son scripts de Vim, porque son archivos en
los que se configuran opciones para un tipo de archivo particular. Es posible
definir una macro complicada en un archivo Vim separado. Tambin puede
idear otros usos.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">43</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="13" approved="yes">
        <source>Let's start with a simple example: &gt;</source>
        <target state="translated">Empecemos con un ejemplo sencillo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">45</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="14" approved="yes">
        <source>	:let i = 1
	:while i &lt; 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
&lt;
	Note:
	The ":" characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim script file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"
</source>
        <target state="translated">	:let i = 1
	:while i &lt; 5
	:  echo "cuenta es" i
	:  let i += 1
	:endwhile
&lt;
	Nota:
	En realidad en el ejemplo de arriba los caracteres : no son
	necesarios. Slo es necesario su uso al escribir una orden. En los
	archivos de script de Vim es posible omitirlos. Aqu se muestran para
	evidenciar que son rdenes de la lnea de rdenes, y no rdenes del
	modo Normal.
	Nota:
	Puede probar los ejemplos que se muestran aqu copiando el texto
	correspondiente, y ejecutndolo con la orden :@"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">60</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="15" approved="yes">
        <source>The output of the example code is:</source>
        <target state="translated">La salida generada por el ejemplo tiene el siguiente aspecto:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">62</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="16" approved="yes">
        <source>	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~
</source>
        <target state="translated">	cuenta es 1 ~
	cuenta es 2 ~
	cuenta es 3 ~
	cuenta es 4 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">67</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="17" approved="yes">
        <source>In the first line the ":let" command assigns a value to a variable.  The generic form is: &gt;</source>
        <target state="translated">En la primera lnea la orden :let le asigna un valor a una variable. La forma genrica de hacerlo es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">70</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="18" approved="yes">
        <source>	:let {variable} = {expression}
</source>
        <target state="translated">	:let {variable} = {expresin}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">72</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="19" approved="yes">
        <source>In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is: &gt;
</source>
        <target state="translated">En este caso el nombre de la variable es i y la expresin es simplemente un
valor, el nmero uno.
   La orden :while inicia un ciclo. La forma genrica de esta orden es: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">76</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="20" approved="yes">
        <source>	:while {condition}
	:  {statements}
	:endwhile
</source>
        <target state="translated">	:while {condicion}
	:  {instrucciones}
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">80</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="21" approved="yes">
        <source>The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i &lt; 5".  This
is true when the variable i is smaller than five.
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
</source>
        <target state="translated">Las instrucciones hasta el :endwhile correspondiente se ejecutan mientras
que la {condicion} se siga cumpliendo. La condicin aqu es la expresin
i &lt; 5.  sta es verdadera cuando la variable i es menor a cinco.
	Nota:
	Si llega a escribir un ciclo while que nunca termina de ejecutarse,
	puede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">87</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="22" approved="yes">
        <source>The ":echo" command prints its arguments.  In this case the string "count is" and the value of the variable i.  Since i is one, this will print:</source>
        <target state="translated">La orden :echo imprime en pantalla los argumentos que se le introduzcan. En este caso son la cadena cuenta es y el valor de la variable i. Como i vale uno, se imprimir:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">90</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="23" approved="yes">
        <source>	count is 1 ~
</source>
        <target state="translated">	cuenta es 1 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">92</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="24" approved="yes">
        <source>Then there is the ":let i += 1" command.  This does the same thing as ":let i = i + 1".  This adds one to the variable i and assigns the new value to the same variable.</source>
        <target state="translated">Luego est la orden :let i += 1. sta tiene el mismo efecto que :let i = i + 1. Le aade uno a la variable i y asigna el resultado a la misma variable.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">96</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="25" approved="yes">
        <source>The example was given to explain the commands, but would you really want to make such a loop it can be written much more compact: &gt;</source>
        <target state="translated">El ejemplo se dio para ilustrar las rdenes usadas; si se quisiera un ciclo con la funcionalidad mostrada, se puede escribir algo mucho ms compacto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">99</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="26" approved="yes">
        <source>	:for i in range(1, 4)
	:  echo "count is" i
	:endfor
</source>
        <target state="translated">	:for i in range(1, 4)
	:  echo "cuenta es" i
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">103</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="27" approved="yes">
        <source>We won't explain how |:for| and |range()| work until later.  Follow the links if you are impatient.</source>
        <target state="translated">El funcionamiento de |:for| y |range()| se explicar despus. Siga los enlaces si no desea esperar.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="28" approved="yes">
        <source>THREE KINDS OF NUMBERS</source>
        <target state="translated">TRES CLASES DE NMEROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">109</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="29" approved="yes">
        <source>Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
number, it will be interpreted as an octal number!
   The ":echo" command always prints decimal numbers.  Example: &gt;
</source>
        <target state="translated">Los nmeros pueden ser decimales, hexadecimales, u octales. Un nmero
hexadecimal empieza con 0x o 0X. Por ejemplo, 0x1f es 31 en decimal. Un
nmero octal empieza con cero. 017 es 15 en decimal. Tenga cuidado: no ponga
ceros al comienzo de un nmero decimal, ser interpretado como un octal!
   La orden :echo siempre muestra los nmeros como decimales. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">115</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="30" approved="yes">
        <source>	:echo 0x7f 036
&lt;	127 30 ~
</source>
        <target state="translated">	:echo 0x7f 036
&lt;	127 30 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">118</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="31" approved="yes">
        <source>A number is made negative with a minus sign.  This also works for hexadecimal
and octal numbers.   A minus sign is also used for subtraction.  Compare this
with the previous example: &gt;
</source>
        <target state="translated">Se pueden obtener nmeros negativos aadindoles un signo de resta. Esto funciona
tambin para nmeros octales y hexadecimales. El signo menos tambin se usa
para la substraccin. Compare lo siguiente con el ejemplo anterior: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">122</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="32" approved="yes">
        <source>	:echo 0x7f -036
&lt;	97 ~
</source>
        <target state="translated">	:echo 0x7f -036
&lt;	97 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">125</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="33" approved="yes">
        <source>White space in an expression is ignored.  However, it's recommended to use it for separating items, to make the expression easier to read.  For example, to avoid the confusion with a negative number above, put a space between the minus sign and the following number: &gt;</source>
        <target state="translated">En las expresiones se ignoran los espacios en blanco. Sin embargo, es recomendable usarlo para separar elementos, para hacer que las expresiones sean ms legibles. Por ejemplo, para evitar confundir el ejemplo anterior con un nmero negativo, ponga un espacio entre el signo de resta y el nmero que lo sigue: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">130</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="34" approved="yes">
        <source>	:echo 0x7f - 036
</source>
        <target state="translated">	:echo 0x7f - 036
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">132</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="35" approved="yes">
        <source>*41.2*	Variables
</source>
        <target state="translated">*41.2*	Variables
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">135</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="36" approved="yes">
        <source>A variable name consists of ASCII letters, digits and the underscore.  It cannot start with a digit.  Valid variable names are:</source>
        <target state="translated">Los nombres de variables pueden consistir de las letras del cdigo ASCII, dgitos, y el guin bajo. No pueden empezar con dgitos. Los siguientes son nombres vlidos de variables:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">138</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="37" approved="yes">
        <source>	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH
</source>
        <target state="translated">	contador
	_aap3
	nombre_de_variable_largo_con_guion_bajo
	FuncLongitud
	LONGITUD
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">144</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="38" approved="yes">
        <source>Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command: &gt;
</source>
        <target state="translated">foo+bar y 6var no son nombres vlidos.
   Estas variables son globales. Para ver un listado de las variables
definidas actualmente, use la siguiente orden: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">148</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="39" approved="yes">
        <source>	:let
</source>
        <target state="translated">	:let
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">150</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="40" approved="yes">
        <source>You can use global variables everywhere.  This also means that when the variable "count" is used in one script file, it might also be used in another file.  This leads to confusion at least, and real problems at worst.  To avoid this, you can use a variable local to a script file by prepending "s:".  For example, one script contains this code: &gt;</source>
        <target state="translated">Puede usar variables globales en cualquier parte. Esto implica que cuando usa la variable cuenta en un archivo, sta tambin puede ser usada en otro archivo, lo que al menos crea confusin, y en el peor de los casos genera problemas reales. Para evitar este problema, puede declarar variables como locales respecto al archivo del script, anteponiendo s: a su nombre. Por ejemplo, considere un script con las siguientes instrucciones: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">156</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="41" approved="yes">
        <source>	:let s:count = 1
	:while s:count &lt; 5
	:  source other.vim
	:  let s:count += 1
	:endwhile
</source>
        <target state="translated">	:let s:cuenta = 1
	:while s:cuenta &lt; 5
	:  source otro.vim
	:  let s:cuenta += 1
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">162</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="42" approved="yes">
        <source>Since "s:count" is local to this script, you can be sure that sourcing the "other.vim" script will not change this variable.  If "other.vim" also uses an "s:count" variable, it will be a different copy, local to that script.  More about script-local variables here: |script-variable|.</source>
        <target state="translated">Ya que el mbito de s:cuenta es local al script, puede estar seguro de que cargar el archivo otro.vim no har cambios a dicha variable. Si otro.vim tambin usa una variable s:cuenta, ser una copia distinta, local al mbito de ese script. Puede encontrar ms informacin acerca de las variables locales a un script en |script-variable|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">167</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="43" approved="yes">
        <source>There are more kinds of variables, see |internal-variables|.  The most often used ones are:</source>
        <target state="translated">Existen ms clases de variables, consulte |internal-variables|. Las que se usan ms frecuentemente son:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">170</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="44" approved="yes">
        <source>	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim
</source>
        <target state="translated">	b:nombre		variable local a un bfer
	w:nombre		variable local a una ventana
	g:nombre		variable global (incluso dentro de funciones)
	v:nombre		variable predeterminada por Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">175</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="45" approved="yes">
        <source>DELETING VARIABLES</source>
        <target state="translated">ELIMINAR VARIABLES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">178</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="46" approved="yes">
        <source>Variables take up memory and show up in the output of the ":let" command.  To delete a variable use the ":unlet" command.  Example: &gt;</source>
        <target state="translated">Las variables que aparecen en el listado que genera la orden :let consumen recursos de memoria. Para eliminar una variable use la orden :unlet. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">181</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="47" approved="yes">
        <source>	:unlet s:count
</source>
        <target state="translated">	:unlet s:cuenta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">183</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="48" approved="yes">
        <source>This deletes the script-local variable "s:count" to free up the memory it uses.  If you are not sure if the variable exists, and don't want an error message when it doesn't, append !: &gt;</source>
        <target state="translated">Esta orden elimina la variable s:count, local al script actual, para liberar la memoria que sta usa. Si no est seguro de que una variable exista, y no quiere obtener mensajes de error si no existe, aada ! a la orden: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">187</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="49" approved="yes">
        <source>	:unlet! s:count
</source>
        <target state="translated">	:unlet! s:cuenta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">189</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="50" approved="yes">
        <source>When a script finishes, the local variables used there will not be automatically freed.  The next time the script executes, it can still use the old value.  Example: &gt;</source>
        <target state="translated">Cuando la ejecucin de un script termina, no se liberan automticamente los recursos usados por sus variables locales. La prxima vez que se ejecute el script, los valores antiguos estarn disponibles. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">193</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="51" approved="yes">
        <source>	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"
</source>
        <target state="translated">	:if !exists("s:cuenta_llamadas")
	:  let s:cuenta_llamadas = 0
	:endif
	:let s:cuenta_llamadas = s:cuenta_llamadas + 1
	:echo "llamado" s:cuenta_llamadas "veces"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">199</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="52" approved="yes">
        <source>The "exists()" function checks if a variable has already been defined.  Its argument is the name of the variable you want to check.  Not the variable itself! If you would do this: &gt;</source>
        <target state="translated">La funcin exists() comprueba la existencia de una variable. Recibe como argumento el nombre de la variable a comprobar. No la variable como tal! Si intenta esto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">203</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="53" approved="yes">
        <source>	:if !exists(s:call_count)
</source>
        <target state="translated">	:if !exists(s:cuenta_llamadas)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">205</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="54" approved="yes">
        <source>Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
	Note:
	Vim automatically converts a string to a number when it is looking for
	a number.  When using a string that doesn't start with a digit the
	resulting number is zero.  Thus look out for this: &gt;
		:if "true"
&lt;	The "true" will be interpreted as a zero, thus as false!
</source>
        <target state="translated">El valor de s:cuenta_llamadas se usar como el nombre de variable que
exists() revisar. se no es el efecto esperado.
   El smbolo de exclamacin ! niega un valor. Cuando un valor es verdadero,
se vuelve falso. Cuando es falso, se vuelve verdadero. Puede leer este smbolo
como not (negacin lgica). As, if !exists() se lee como if not
exists().
   Vim considera como verdadero cualquier valor distinto de cero. Cero
equivale a falso.
	Nota:
	Vim convierte las cadenas de texto a nmeros de manera automtica
	cuando se espera un nmero. Cuando se hace esta conversin con una
	cadena que no empieza con un dgito el nmero resultante es cero.
	Debido a esto, tenga cuidado con instrucciones como: &gt;
		:if "verdadero"
&lt;	en este caso, la cadena verdadero ser interpretada como un cero, y
	por tanto como falso!
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">218</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="55" approved="yes">
        <source>STRING VARIABLES AND CONSTANTS</source>
        <target state="translated">VARIABLES CADENAS DE TEXTO Y CONSTANTES CADENAS DE TEXTO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="56" approved="yes">
        <source>So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes: &gt;
</source>
        <target state="translated">Hasta ahora slo se han usado nmeros como valores de variables. Tambin es
posible usar cadenas de texto. Los tipos bsicos de variables que Vim soporta
son nmeros y cadenas. El tipo de cada variable es dinmico, y se fija cada
vez que se asigna un valor a una variable mediante :let. Refirase a |41.8|
para ms informacin acerca de tipos.
   Para asignar un valor de tipo cadena a una variable, debe usar una
constante de cadena. Hay dos tipos de estas constantes. El primero es la
cadena con comillas dobles: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">228</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="57" approved="yes">
        <source>	:let name = "peter"
	:echo name
&lt;	peter ~
</source>
        <target state="translated">	:let nombre = "pedro"
	:echo nombre
&lt;	pedro ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">232</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="58" approved="yes">
        <source>If you want to include a double quote inside the string, put a backslash in front of it: &gt;</source>
        <target state="translated">Si quiere incluir una comilla doble en el contenido de la cadena, ponga una barra inversa antes de la misma: &gt; </target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="59" approved="yes">
        <source>	:let name = "\"peter\""
	:echo name
&lt;	"peter" ~
</source>
        <target state="translated">	:let nombre = "\"pedro\""
	:echo nombre
&lt;	"pedro" ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">239</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="60" approved="yes">
        <source>To avoid the need for a backslash, you can use a string in single quotes: &gt;</source>
        <target state="translated">Para evitar el uso de la barra inversa, puede usar una cadena con comillas sencillas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">241</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="61" approved="yes">
        <source>	:let name = '"peter"'
	:echo name
&lt;	"peter" ~
</source>
        <target state="translated">	:let nombre = '"pedro"'
	:echo nombre
&lt;	"pedro" ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="62" approved="yes">
        <source>Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:
</source>
        <target state="translated">En una cadena de comillas sencillas todos los caracteres tienen solamente su
significado literal. Slo la comilla sencilla es especial: debe usar dos
seguidas para obtener una dentro de una cadena. La barra inversa se considera
literalmente, por lo que no es posible usarla para cambiar el significado del
carcter despus de ella.
   En las cadenas de comillas dobles es posible usar caracteres especiales. A
continuacin algunos de los ms usados:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">252</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="63" approved="yes">
        <source>	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, line break
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, backspace
	\"		"
	\\		\, backslash
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</source>
        <target state="translated">	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, salto de lnea
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, retroceso
	\"		"
	\\		\, barra inversa
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">262</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="64" approved="yes">
        <source>The last two are just examples.  The  "\&lt;name&gt;" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.
</source>
        <target state="translated">Los ltimos dos slo son ejemplos. Se puede usar la forma \&lt;nombre&gt; para
incluir la tecla nombre.
   Consulte |expr-quote| para ver la lista completa de elementos especiales
en una cadena de texto.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">266</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="65" approved="yes">
        <source>*41.3*	Expressions
</source>
        <target state="translated">*41.3*	Expresiones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="66" approved="yes">
        <source>Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:
</source>
        <target state="translated">Vim tiene una forma expresiva, pero sencilla, de manejar expresiones. Puede
leer la definicin aqu: |expression-syntax|. A continuacin mostraremos
algunos de los elementos ms comunes.
   Los nmeros, cadenas, y las variables mencionadas anteriormente son
expresiones por s mismas. As que, en donde sea que se espere una expresin,
puede usar un nmero, una cadena, o una variable. Otros de los elementos
comunes en una expresin son:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">276</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="67" approved="yes">
        <source>	$NAME		environment variable
	&amp;name		option
	@r		register
</source>
        <target state="translated">	$NOMBRE		variable de entorno
	&amp;nombre		opcin
	@r		registro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">280</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="68" approved="yes">
        <source>Examples: &gt;</source>
        <target state="translated">Ejemplos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">282</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="69" approved="yes">
        <source>	:echo "The value of 'tabstop' is" &amp;ts
	:echo "Your home directory is" $HOME
	:if @a &gt; 5
</source>
        <target state="translated">	:echo "El valor de 'tabstop' es" &amp;ts
	:echo "Su directorio personal es" $HOME
	:if @a &gt; 5
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">286</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="70" approved="yes">
        <source>The &amp;name form can be used to save an option value, set it to a new value, do something and restore the old value.  Example: &gt;</source>
        <target state="translated">Puede usar la forma &amp;nombre para guardar el valor de una opcin, fijarla a un nuevo valor, hacer algo, y restaurar el valor original. Por ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">289</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="71" approved="yes">
        <source>	:let save_ic = &amp;ic
	:set noic
	:/The Start/,$delete
	:let &amp;ic = save_ic
</source>
        <target state="translated">	:let ic_orig = &amp;ic
	:set noic
	:/El Principio/,$delete
	:let &amp;ic = ic_orig
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">294</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="72" approved="yes">
        <source>This makes sure the "The Start" pattern is used with the 'ignorecase' option off.  Still, it keeps the value that the user had set.  (Another way to do this would be to add "\C" to the pattern, see |/\C|.)</source>
        <target state="translated">Con esto se asegura que el patrn El Principio se buscar con la opcin 'ignorecase' desactivada. Sin embargo, se conserva y restaura el valor que el usuario defini para la opcin. (Otra forma de hacer esta bsqueda es aadir \C al patrn, consulte |/\C|.)</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">298</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="73" approved="yes">
        <source>MATHEMATICS</source>
        <target state="translated">MATEMTICAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">301</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="74" approved="yes">
        <source>It becomes more interesting if we combine these basic items.  Let's start with mathematics on numbers:</source>
        <target state="translated">Las cosas se hacen ms interesantes si combinamos estos elementos bsicos. Empecemos con operaciones matemticas sobre nmeros:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="75" approved="yes">
        <source>	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo
</source>
        <target state="translated">	a + b		adicin
	a - b		sustraccin
	a * b		multiplicacin
	a / b		divisin
	a % b		mdulo (residuo)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">310</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="76" approved="yes">
        <source>The usual precedence is used.  Example: &gt;</source>
        <target state="translated">Se maneja la precendencia de operadores usual. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">312</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="77" approved="yes">
        <source>	:echo 10 + 5 * 2
&lt;	20 ~
</source>
        <target state="translated">	:echo 10 + 5 * 2
&lt;	20 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">315</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="78" approved="yes">
        <source>Grouping is done with braces.  No surprises here.  Example: &gt;</source>
        <target state="translated">Puede cambiar la precendencia de las operaciones usando parntesis. Esto no es nada nuevo.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">317</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO file bug on vim's documentation. Parentheses, not braces</context>
        </context-group>
        <note from="po-translator">TODO file bug on vim's documentation. Parentheses, not braces</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="79" approved="yes">
        <source>	:echo (10 + 5) * 2
&lt;	30 ~
</source>
        <target state="translated">	:echo (10 + 5) * 2
&lt;	30 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">320</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="80" approved="yes">
        <source>Strings can be concatenated with ".".  Example: &gt;</source>
        <target state="translated">Puede unir cadenas usando .. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">322</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="81" approved="yes">
        <source>	:echo "foo" . "bar"
&lt;	foobar ~
</source>
        <target state="translated">	:echo "foo" . "bar"
&lt;	foobar ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">325</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="82" approved="yes">
        <source>When the ":echo" command gets multiple arguments, it separates them with a space.  In the example the argument is a single expression, thus no space is inserted.</source>
        <target state="translated">Cuando recibe varios argumentos, la orden :echo los muestra en pantalla separados con espacios. En el ejemplo anterior el argumento es una nica expresin, por lo que no se insertan espacios.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">329</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="83" approved="yes">
        <source>Borrowed from the C language is the conditional expression:</source>
        <target state="translated">Del lenguaje C se tom la expresin condicional:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">331</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="84" approved="yes">
        <source>	a ? b : c
</source>
        <target state="translated">	a ? b : c
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">333</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="85" approved="yes">
        <source>If "a" evaluates to true "b" is used, otherwise "c" is used.  Example: &gt;</source>
        <target state="translated">Si a se evala como verdadero, la expresin corresponder a b, y en caso contrario a c. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">335</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="86" approved="yes">
        <source>	:let i = 4
	:echo i &gt; 5 ? "i is big" : "i is small"
&lt;	i is small ~
</source>
        <target state="translated">	:let i = 4
	:echo i &gt; 5 ? "i es grande" : "i es pequeo"
&lt;	i es pequeo ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">339</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="87" approved="yes">
        <source>The three parts of the constructs are always evaluated first, thus you could see it work as:</source>
        <target state="translated">Los tres elementos de la expresin condicional siempre son evaluados; es conveniente verlos de la siguiente forma:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">342</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="88" approved="yes">
        <source>	(a) ? (b) : (c)
</source>
        <target state="translated">	(a) ? (b) : (c)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">344</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="89" approved="yes">
        <source>*41.4*	Conditionals
</source>
        <target state="translated">*41.4*	Estructuras de decisin
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">347</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="90" approved="yes">
        <source>The ":if" commands executes the following statements, until the matching ":endif", only when a condition is met.  The generic form is:</source>
        <target state="translated">La orden :if ejecuta las rdenes a continuacin de ella, hasta el :endif correspondiente, cuando se cumple la condicin especificada. La forma genrica es:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">350</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="91" approved="yes">
        <source>	:if {condition}
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">354</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</context>
        </context-group>
        <note from="po-translator">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="92" approved="yes">
        <source>Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the ":endif".
   You can also use ":else".  The generic form for this is:
</source>
        <target state="translated">Las {instrucciones} se ejecutan nicamente cuando la expresin {condicion} es
verdadera, esto es, diferente de cero. Dichas instrucciones deben ser rdenes
vlidas. Si las rdenes tienen errores de sintaxis, Vim no podr encontrar el
:endif correspondiente.
   Tambin puede usar :else. La forma genrica es:
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">359</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="93" approved="yes">
        <source>	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:else
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">365</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</context>
        </context-group>
        <note from="po-translator">TODO bug en sintaxis de help.vim? no admite caracteres no-ascii entre las
llaves</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="94" approved="yes">
        <source>The second {statements} is only executed if the first one isn't.
   Finally, there is ":elseif":
</source>
        <target state="translated">El segundo grupo de {instrucciones} slo se ejecuta si el primero no lo hace.
   Finalmente, est :elseif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">368</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="95" approved="yes">
        <source>	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif
</source>
        <target state="translated">	:if {condicion}
	   {instrucciones}
	:elseif {condicion}
	   {instrucciones}
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">374</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="96" approved="yes">
        <source>This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: &gt;
</source>
        <target state="translated">Esta orden funciona como :else seguido de :if, pero tiene la ventaja de no
requerir un :endif adicional.
   Un ejemplo til que podra usar en su archivo vimrc es comprobar la opcin
'term' y ejecutar rdenes diferentes de acuerdo a su valor: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">379</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="97" approved="yes">
        <source>	:if &amp;term == "xterm"
	:  " Do stuff for xterm
	:elseif &amp;term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif
</source>
        <target state="translated">	:if &amp;term == "xterm"
	:  " Configuracin para xterm
	:elseif &amp;term == "vt100"
	:  " Configuracin para la terminal vt100
	:else
	:  " Configuracin para otras terminales
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="98" approved="yes">
        <source>LOGIC OPERATIONS</source>
        <target state="translated">OPERACIONES LGICAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">390</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="99" approved="yes">
        <source>We already used some of them in the examples.  These are the most often used ones:</source>
        <target state="translated">Ya hemos usado algunas de ellas en los ejemplos anteriores. A continuacin listamos las ms utilizadas:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">393</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="100" approved="yes">
        <source>	a == b		equal to
	a != b		not equal to
	a &gt;  b		greater than
	a &gt;= b		greater than or equal to
	a &lt;  b		less than
	a &lt;= b		less than or equal to
</source>
        <target state="translated">	a == b		igual a
	a != b		diferente de
	a &gt;  b		mayor que
	a &gt;= b		mayor o igual a
	a &lt;  b		menor que
	a &lt;= b		menor o igual a
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">400</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="101" approved="yes">
        <source>The result is one if the condition is met and zero otherwise.  An example: &gt;</source>
        <target state="translated">El resultado es uno si la condicin se cumple, y cero en caso contrario. Por ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">402</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="102" approved="yes">
        <source>	:if v:version &gt;= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif
</source>
        <target state="translated">	:if v:version &gt;= 700
	:  echo "felicitaciones"
	:else
	:  echo "est usando una versin vieja, actualcese!"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">408</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="103" approved="yes">
        <source>Here "v:version" is a variable defined by Vim, which has the value of the Vim version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is very useful to write a script that works with multiple versions of Vim.  |v:version|</source>
        <target state="translated">La variable v:version es definida por Vim, y contiene el nmero de versin de Vim. 600 corresponde a la versin 6.0. La versin 6.1 tiene el valor 601. Esta variable es til para escribir scripts que funcionen con distintas versiones de Vim. |v:version|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">413</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="104" approved="yes">
        <source>The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example: &gt;
</source>
        <target state="translated">Los operadores lgicos funcionan con nmeros y con cadenas de texto. Al
comparar dos cadenas, se trabaja con la diferencia matemtica de las mismas.
Esto compara valores de bytes, lo que para algunos idiomas puede no entregar
resultados correctos.
   Al comparar cadenas con nmeros, la cadena es convertida a un nmero antes
de hacer la comparacin. Debe tener en cuenta que, cuando el contenido de una
cadena no se asemeja a un nmero, se usa el nmero cero. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">420</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="105" approved="yes">
        <source>	:if 0 == "one"
	:  echo "yes"
	:endif
</source>
        <target state="translated">	:if 0 == "uno"
	:  echo "s"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">424</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="106" approved="yes">
        <source>This will echo "yes", because "one" doesn't look like a number, thus it is converted to the number zero.</source>
        <target state="translated">El ejemplo mostrar s, porque uno no puede ser convertido a un nmero, por lo que se lo convierte al nmero cero.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">427</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="107" approved="yes">
        <source>For strings there are two more items:</source>
        <target state="translated">Hay dos operadores ms para cadenas de texto:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">429</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="108" approved="yes">
        <source>	a =~ b		matches with
	a !~ b		does not match with
</source>
        <target state="translated">	a =~ b		coincide con
	a !~ b		no coincide con
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">432</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="109" approved="yes">
        <source>The left item "a" is used as a string.  The right item "b" is used as a pattern, like what's used for searching.  Example: &gt;</source>
        <target state="translated">El operando de la izquierda, a, se trata como una cadena. El operando de la derecha, b, se trata como un patrn para una bsqueda de texto. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">435</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="110" approved="yes">
        <source>	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif
</source>
        <target state="translated">	:if str =~ " "
	:  echo "str contiene un espacio"
	:endif
	:if str !~ '\.$'
	:  echo "str no termina con punto final"
	:endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">442</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="111" approved="yes">
        <source>Notice the use of a single-quote string for the pattern.  This is useful, because backslashes would need to be doubled in a double-quote string and patterns tend to contain many backslashes.</source>
        <target state="translated">Tenga en cuenta el uso de una cadena de comillas sencillas como patrn de bsqueda. En este caso es til porque las barras inversas tendran que insertarse por partida doble en una cadena de comillas dobles, y los patrones de bsqueda suelen contener muchas barras inversas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">446</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="112" approved="yes">
        <source>The 'ignorecase' option is used when comparing strings.  When you don't want that, append "#" to match case and "?" to ignore case.  Thus "==?" compares two strings to be equal while ignoring case.  And "!~#" checks if a pattern doesn't match, also checking the case of letters.  For the full table see |expr-==|.</source>
        <target state="translated">Al comparar cadenas se tiene en cuenta la opcin 'ignorecase'. Si no desea este comportamiento, aada un # para diferenciar maysculas de minsculas, o ? para ignorar dicha diferencia. As, ==? compara dos cadenas sin diferenciar maysculas de minsculas. !~# revisa la no coincidencia de un patrn, teniendo en cuenta diferencias de maysculas y minsculas. Puede consultar la tabla completa de operadores de comparacin en |expr-==|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">452</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="113" approved="yes">
        <source>MORE LOOPING</source>
        <target state="translated">MS SOBRE CICLOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">455</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="114" approved="yes">
        <source>The ":while" command was already mentioned.  Two more statements can be used in between the ":while" and the ":endwhile":</source>
        <target state="translated">Ya hemos mencionado la orden :while. Hay dos instrucciones adicionales que pueden usarse entre :while y el :endwhile correspondiente:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">458</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="115" approved="yes">
        <source>	:continue		Jump back to the start of the while loop; the
				loop continues.
	:break			Jump forward to the ":endwhile"; the loop is
				discontinued.
</source>
        <target state="translated">	:continue		Salta hasta el inicio del ciclo while; el
				ciclo contina.
	:break			Salta hasta despus del :endwhile; provoca
				la terminacin del ciclo.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">463</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="116" approved="yes">
        <source>Example: &gt;</source>
        <target state="translated">Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">465</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="117" approved="yes">
        <source>	:while counter &lt; 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</source>
        <target state="translated">	:while contador &lt; 40
	:  call hacer_algo()
	:  if opcin_omitir
	:    continue
	:  endif
	:  if opcin_terminado
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">476</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="118" approved="yes">
        <source>The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.</source>
        <target state="translated">La orden :sleep hace que Vim tome una pausa. El argumento 50m especifica una duracin de 50 milisegundos. Otro ejemplo es :sleep 4, que especifica una pausa de cuatro segundos.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">479</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="119" approved="yes">
        <source>Even more looping can be done with the ":for" command, see below in |41.8|.</source>
        <target state="translated">La orden :for es otra estructura de control para iteracin, consulte la seccin |41.8|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">481</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="120" approved="yes">
        <source>*41.5*	Executing an expression
</source>
        <target state="translated">*41.5*	Ejecucin de expresiones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">484</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="121" approved="yes">
        <source>So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable: &gt;
</source>
        <target state="translated">Hasta ahora, todas las rdenes mostradas han sido ejecutadas directamente por
Vim. La orden :execute permite ejecutar el resultado de una expresin. sta
es una forma poderosa de construir y ejecutar rdenes.
   Un ejemplo es saltar a una etiqueta, cuyo nombre est almacenado en una
variable: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">489</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="122" approved="yes">
        <source>	:execute "tag " . tag_name
</source>
        <target state="translated">	:execute "tag " . nombre_etiqueta
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">491</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="123" approved="yes">
        <source>The "." is used to concatenate the string "tag " with the value of variable "tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that will be executed is: &gt;</source>
        <target state="translated">El . se usa para concatenar la cadena tag  con el valor de la variable nombre_etiqueta. Si suponemos que nombre_etiqueta tiene el contenido obtener_orden, entonces la orden que se ejecutar es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">495</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="124" approved="yes">
        <source>	:tag get_cmd
</source>
        <target state="translated">	:tag obtener_orden
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">497</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="125" approved="yes">
        <source>The ":execute" command can only execute colon commands.  The ":normal" command executes Normal mode commands.  However, its argument is not an expression but the literal command characters.  Example: &gt;</source>
        <target state="translated">La orden :execute slo puede ejecutar rdenes de la lnea de rdenes (rdenes Ex, que empiezan con :). La orden :normal ejecuta rdenes del modo Normal. Sin embargo, su argumento no es una expresin, sino los caracteres literales de la orden. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">501</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="126" approved="yes">
        <source>	:normal gg=G
</source>
        <target state="translated">	:normal gg=G
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">503</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="127" approved="yes">
        <source>This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example: &gt;
</source>
        <target state="translated">Se mueve hasta la primera lnea y formatea todas las lneas usando el operador
=.
   Para usar :normal con el resultado de una expresin, debe combinar
:execute con dicha orden. Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">507</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="128" approved="yes">
        <source>	:execute "normal " . normal_commands
</source>
        <target state="translated">	:execute "normal " . ordenes_modo_normal
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">509</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="129" approved="yes">
        <source>The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works: &gt;
</source>
        <target state="translated">La variables ordenes_modo_normal debe contener rdenes para el modo Normal.
   Asegrese de que el argumento para :normal es una orden completa. En caso
contrario, Vim llegar al final del argumento e interrumpir la orden. Por
ejemplo, si inicia el modo Insertar, debe salir del mismo. Lo siguiente
funciona adecuadamente: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">514</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="130" approved="yes">
        <source>	:execute "normal Inew text \&lt;Esc&gt;"
</source>
        <target state="translated">	:execute "normal Itexto nuevo \&lt;Esc&gt;"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">516</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="131" approved="yes">
        <source>This inserts "new text " in the current line.  Notice the use of the special key "\&lt;Esc&gt;".  This avoids having to enter a real &lt;Esc&gt; character in your script.</source>
        <target state="translated">Esta orden inserta texto nuevo en la lnea actual. Observe el uso de la tecla especial \&lt;Esc&gt;. As se evita la necesidad de escribir un &lt;Esc&gt; real en el script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">520</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="132" approved="yes">
        <source>If you don't want to execute a string but evaluate it to get its expression value, you can use the eval() function: &gt;</source>
        <target state="translated">Si lo que quiere es no ejecutar una cadena de texto, sino evaluarla para obtener el valor de la expresin que contiene, use la funcin eval(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">523</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="133" approved="yes">
        <source>	:let optname = "path"
	:let optval = eval('&amp;' . optname)
</source>
        <target state="translated">	:let nomopcion = "path"
	:let valopcion = eval('&amp;' . nomopcion)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">526</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="134" approved="yes">
        <source>A "&amp;" character is prepended to "path", thus the argument to eval() is
"&amp;path".  The result will then be the value of the 'path' option.
   The same thing can be done with: &gt;
	:exe 'let optval = &amp;' . optname
</source>
        <target state="translated">Se antepone un &amp; a path, y as el argumento para eval() es &amp;path. El
resultado ser el valor de la opcin 'path'.
   Puede obtener el mismo resultado con: &gt;
	:exe 'let optval = &amp;' . optname
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">531</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="135" approved="yes">
        <source>*41.6*	Using functions
</source>
        <target state="translated">*24.1*	Funciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">534</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="136" approved="yes">
        <source>Vim defines many functions and provides a large amount of functionality that way.  A few examples will be given in this section.  You can find the whole list here: |functions|.</source>
        <target state="translated">Vim define muchas funciones y provee bastante funcionalidad a travs de este mecanismo. Aqu daremos algunos ejemplos. La referencia para la lista completa se encuentra en |functions|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">538</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="137" approved="yes">
        <source>A function is called with the ":call" command.  The parameters are passed in between braces, separated by commas.  Example: &gt;</source>
        <target state="translated">Las funciones se llaman con la orden :call. Los parmetros se introducen entre parntesis, separados por comas. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">541</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="138" approved="yes">
        <source>	:call search("Date: ", "W")
</source>
        <target state="translated">	:call search("Fecha: ", "W")
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">543</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="139" approved="yes">
        <source>This calls the search() function, with arguments "Date: " and "W".  The search() function uses its first argument as a search pattern and the second one as flags.  The "W" flag means the search doesn't wrap around the end of the file.</source>
        <target state="translated">Se invoca a la funcin search(), con los argumentos Fecha:  y W. La funcin search() usa su primer argumento como patrn de bsqueda y el segundo como una serie de opciones. La opcin W hace que la bsqueda termine al alcanzar el final del archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">548</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="140" approved="yes">
        <source>A function can be called in an expression.  Example: &gt;</source>
        <target state="translated">Tambin es posible invocar funciones en expresiones.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">550</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="141" approved="yes">
        <source>	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)
</source>
        <target state="translated">	:let linea = getline(".")
	:let reempl = substitute(linea, '\a', "*", "g")
	:call setline(".", reempl)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">554</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="142" approved="yes">
        <source>The getline() function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this case "." is used, which means
the line where the cursor is.
   The substitute() function does something similar to the ":substitute"
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to: &gt;
</source>
        <target state="translated">La funcin getline() extrae una lnea del bfer actual. Su argumento
especifica un nmero de lnea. En este caso se usa ., que se interpreta como
la lnea en la que se encuentra el cursor.
   La funcin substitute() tiene un comportamiento similar al de la orden
:substitute. El primer argumento es la cadena de texto sobre la cual operar,
el segundo es el patrn de bsqueda, el tercero la cadena de reemplazo. El
ltimo argumento se corresponde con las opciones de bsqueda.
   La funcin setline() reemplaza la lnea que se especifique en el primer
argumento, con la cadena que se pase en el segundo argumento. En este ejemplo
se reemplaza a la lnea bajo el cursor con el resultado de substitute(). El
efecto de las tres instrucciones equivale a: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">566</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="143" approved="yes">
        <source>	:substitute/\a/*/g
</source>
        <target state="translated">	:substitute/\a/*/g
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">568</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="144" approved="yes">
        <source>Using the functions becomes more interesting when you do more work before and after the substitute() call.</source>
        <target state="translated">Usar estas funciones tiene efectos ms interesantes cuando el procesamiento se realiza antes y despus de invocar substitute().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">571</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="145" approved="yes">
        <source>FUNCTIONS						*function-list*
</source>
        <target state="translated">FUNCIONES						*function-list*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">574</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="146" approved="yes">
        <source>There are many functions.  We will mention them here, grouped by what they are used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on the function name to jump to detailed help on it.</source>
        <target state="translated">Vim cuenta con muchas funciones. Las mencionaremos aqu, agrupadas de acuerdo a su funcionalidad. En |functions| se encuentra una lista de ellas ordenada alfabticamente. Puede ubicar el cursor sobre el nombre de una funcin y pulsar CTRL-] para ver documentacin ms detallada sobre ella.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">578</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="147" approved="yes">
        <source>String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in a ":substitute"
	strpart()		get part of a string
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression
</source>
        <target state="translated">Manipulacin de cadenas:				*string-functions*
	nr2char()		obtiene un carcter dado su valor ASCII
	char2nr()		obtiene el nmero ASCII del carcter dado
	str2nr()		convierte una cadena a Nmero
	str2float()		convierte una cadena a Flotante
	printf()		formatea una cadena de acuerdo a elementos %
	escape()		escapa caracteres en una cadena con '\'
	shellescape()		escapa una cadena para usarse una orden de
				consola
	fnameescape()		escapa un nombre de archivo para usar en una
				orden Vim
	tr()			traduce caracteres de un conjunto a otro
	strtrans()		traduce una cadena para que se pueda imprimir
	tolower()		convierte una cadena a minsculas
	toupper()		convierte una cadena a maysculas
	match()			posicin en la que un patrn coincide en una
				cadena
	matchend()		posicin en la que un patrn termina en una
				cadena
	matchstr()		coincidencia de un patrn en una cadena
	matchlist()		similar a matchstr() y retorna
				subcoincidencias
	stridx()		primer ndice de una cadena corta dentro de
				una larga
	strridx()		ltimo ndice de una cadena corta dentro de
				una larga
	strlen()		longitud de una cadena
	substitute()		sustituye la coincidencia de un patrn con una
				cadena
	submatch()		obtiene una subcoincidencia especfica en un
				:substitute
	strpart()		obtiene parte de una cadena
	expand()		expande palabras clave
	iconv()			convierte texto entre distintas codificaciones
	byteidx()		ndice de byte de un carcter en una cadena
	repeat()		repite una cadena mltiples veces
	eval()			evala una cadena como expresin
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">607</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="148" approved="yes">
        <source>List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times
</source>
        <target state="translated">Manipulacin de Listas:					*list-functions*
	get()			obtiene un elemento sin generar error al usar
				ndices errneos
	len()			nmero de elementos en una Lista
	empty()			comprueba si una Lista est vaca
	insert()		inserta un elemento en una Lista
	add()			aade un elemento a una Lista
	extend()		aade los contenidos de una Lista a otra Lista
	remove()		elimina uno o ms elementos de una lista
	copy()			hace una copia superficial de una Lista
	deepcopy()		hace una copia completa de una Lista
	filter()		elimina elementos particulares de una Lista
	map()			cambia cada elemento de una Lista
	sort()			ordena una Lista
	reverse()		invierte el orden de una Lista
	split()			divide una cadena en una Lista
	join()			une los elementos de una Lista en una cadena
	range()			retorna una Lista con una secuencia de nmeros
	string()		representacin de una Lista en una cadena
	call()			invoca una funcin con una Lista como argumentos
	index()			ndice de un valor en una Lista
	max()			valor mximo en una Lista
	min()			valor mnimo en una Lista
	count()			cuenta la cantidad de veces que un valor
				aparece en una Lista
	repeat()		repite una Lista mltiples veces
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">632</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="149" approved="yes">
        <source>Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears
</source>
        <target state="translated">Manipulacin de Diccionarios:				*dict-functions*
	get()			obtiene una entrada sin generar error al usar
				claves errneas
	len()			nmero de entradas en un Diccionario
	has_key()		comprueba si una clave aparece en un
				Diccionario
	empty()			comprueba si un Diccionario est vaco
	remove()		elimina una entrada de un Diccionario
	extend()		aade las entradas de un Diccionario a otro
	filter()		elimina entradas particulares de un
				Diccionario
	map()			cambia cada entrada de un Diccionario
	keys()			devuelve una Lista con las claves de un
				Diccionario
	values()		devuelve una Lista con los valores de un
				Diccionario
	items()			devuelve una Lista de pares clave-valor de un
				Diccionario
	copy()			hace una copia superficial de un Diccionario
	deepcopy()		hace una copia completa de un Diccionario
	string()		representacin de cadena de un Diccionario
	max()			valor mximo en un Diccionario
	min()			valor mnimo en un Diccionario
	count()			cuenta la cantidad de veces que un valor
				aparece en un Diccionario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">651</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="150" approved="yes">
        <source>Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	atan()			arc tangent
</source>
        <target state="translated">Operaciones de punto flotante:				*float-functions*
	float2nr()		convertir Flotante a Nmero
	abs()			valor absoluto (tambin funciona para Nmeros)
	round()			redondear
	ceil()			redondear hacia arriba (techo)
	floor()			redondear hacia abajo (piso)
	trunc()			eliminar valores despus del punto decimal
	log10()			logaritmo en base 10
	pow()			valor de x elevado a la y potencia
	sqrt()			raz cuadrada
	sin()			seno
	cos()			coseno
	atan()			arcotangente
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">665</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="151" approved="yes">
        <source>Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window &amp; tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window &amp; tab page
	garbagecollect()	possibly free memory
</source>
        <target state="translated">Variables:						*var-functions*
	type()			tipo de una variable
	islocked()		comprueba si una variable ha sido bloqueada
	function()		obtiene una referencia a funcin para el
				nombre de funcin dado
	getbufvar()		obtiene una variable de un bfer especfico
	setbufvar()		define una variable en un bfer especfico
	getwinvar()		obtiene una variable de una ventana especfica
	gettabvar()		obtiene una variable de una pestaa especfica
	gettabwinvar()		obtiene una variable de una ventana y pestaa
				especficas
	setwinvar()		define una variable en una ventana
				especfica
	settabvar()		define una variable en una pestaa
				especfica
	settabwinvar()		define una variable en una ventana y pestaa
				especficas
	garbagecollect()	potencialmente libera memoria
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">679</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="152" approved="yes">
        <source>Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line
</source>
        <target state="translated">Posicin de marcas y del cursor:	*cursor-functions* *mark-functions*
	col()			nmero de columna del cursor o de una marca
	virtcol()		nmero de columna en pantalla del cursor o de
				una marca
	line()			nmero de lnea del cursor o de una marca
	wincol()		nmero de columna de ventana del cursor
	winline()		nmero de lnea de ventana del cursor
	cursor()		ubica el cursor en una linea/columna
	getpos()		obtiene la posicin del cursor, marca, etc.
	setpos()		define la posicin del cursor, marca, etc.
	byte2line()		obtiene el nmero de lnea correspondiente a
				un ndice en bytes
	line2byte()		ndice en bytes correspondiente a una lnea
				especfica
	diff_filler()		obtiene la cantidad de lneas de relleno
				encima de una lnea
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">692</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="153" approved="yes">
        <source>Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name
</source>
        <target state="translated">Manipulacin de texto en el bfer actual:		*text-functions*
	getline()		obtiene una lnea o lista de lneas del bfer
	setline()		reemplaza una lnea del bfer
	append()		aade una lnea o lista de lneas al bfer
	indent()		sangrado de una lnea especfica
	cindent()		sangrado de una lnea de acuerdo al estilo
				para C
	lispindent()		sangrado de una lnea de acuerdo al estilo
				para Lisp
	nextnonblank()		ubica la siguiente lnea no vaca
	prevnonblank()		ubica la anterior lnea no vaca
	search()			ubica una coincidencia para un patrn
	searchpos()		ubica una coincidencia para un patrn
	searchpair()		ubica la parte correspondiente a un
				inicio/medio/final
	searchpairpos()	ubica la parte correspondiente a un
				inicio/medio/final
	searchdecl()		busca la declaracin de un nombre
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">707</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="154" approved="yes">
        <source>					*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
	getfperm()		get the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file
</source>
        <target state="translated">					*system-functions* *file-functions*
Funciones del sistema y manipulacin de archivos:
	glob()			expande comodines
	globpath()	expande comodines en mltiples directorios
	findfile()		ubica un archivo en una lista de directorios
	finddir()		ubica un directorio en una lista de
				directorios
	resolve()		determina a dnde apunta un acceso o enlace
				directo
	fnamemodify()		modifica un nombre de archivo
	pathshorten()		abrevia nombres de directorio en una ruta
	simplify()		simplifica una ruta sin cambiar su significado
	executable()		comprueba si un programa ejecutable existe
	filereadable()		comprueba si se puede leer un archivo
	filewritable()		comprueba si se puede escribir a un archivo
	getfperm()		obtiene los permisos para un archivo
	getftype()		obtiene el tipo de un archivo
	isdirectory()		comprueba si un directorio existe
	getfsize()		obtiene el tamao de un archivo
	getcwd()		obtiene el directorio de trabajo actual
	haslocaldir()		comprueba si se ha usado |:lcd| en la ventana
				actual
	tempname()		obtiene un nombre para un archivo temporal
	mkdir()			crea un nuevo directorio
	delete()		borra un archivo
	rename()		renombra un archivo
	system()		obtiene el resultado de una orden de consola
	hostname()		nombre del sistema
	readfile()		lee un archivo y devuelve una Lista de lneas
	writefile()		escribe una Lista de lneas a un archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">735</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="155" approved="yes">
        <source>Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string
</source>
        <target state="translated">Fecha y Hora:				*date-functions* *time-functions*
	getftime()		obtiene la hora de la ltima modificacin de
				un archivo
	localtime()		obtiene la hora actual en segundos
	strftime()		convierte la hora a una cadena
	reltime()		devuelve la hora actual o el tiempo
				transcurrido desde una hora
	reltimestr()		convierte el resultado de reltime() a una
				cadena
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">742</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="156" approved="yes">
        <source>			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()		get a list of lines from the specified buffer
</source>
        <target state="translated">			*buffer-functions* *window-functions* *arg-functions*
Bferes, ventanas, y la lista de argumentos:
	argc()			nmero de entradas en la lista de argumentos
	argidx()		posicin actual en la lista de argumentos
	argv()			obtiene un elemento de la lista de argumentos
	bufexists()		comprueba si un bfer existe
	buflisted()		comprueba si un bfer existe y est listado
	bufloaded()		comprueba si un bfer existe y est cargado
	bufname()		obtiene el nombre de un bfer especfico
	bufnr()			obtiene el nmero de bfer de un bfer
				especfico
	tabpagebuflist()	devuelve la Lista de bfers de una pestaa
	tabpagenr()		obtiene el nmero de una pestaa
	tabpagewinnr()		similar a winnr(), pero especificando la
				pestaa
	winnr()			obtiene el nmero de ventana de la ventana
				actual
	bufwinnr()		obtiene el nmero de ventana del bfer
				especificado
	winbufnr()		obtiene el nmero de bfer de una ventana
				especfica
	getbufline()		obtiene una lista de lneas del bfer
				especificado
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">760</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="157" approved="yes">
        <source>Command line:					*command-line-functions*
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type
</source>
        <target state="translated">Lnea de rdenes:				*command-line-functions*
	getcmdline()		obtiene la lnea de rdenes actual
	getcmdpos()		obtiene la posicin del cursor en la lnea de
				rdenes
	setcmdpos()		cambia la posicin del cursor en la lnea de
				rdenes
	getcmdtype()		devuelve el tipo de la lnea de rdenes actual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">766</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="158" approved="yes">
        <source>Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list
</source>
        <target state="translated">Listas de correccin rpida y de ubicacin:		*quickfix-functions*
	getqflist()		obtiene una lista de errores de correccin
				rpida
	setqflist()		modifica una lista de correccin rpida
	getloclist()	obtiene la lista de elementos de una lista de
				ubicacin
	setloclist()		modifica una lista de ubicacin
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">772</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="159" approved="yes">
        <source>Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed
</source>
        <target state="translated">Completado automtico en modo Insertar:		*completion-functions*
	complete()		define coincidencias encontradas
	complete_add()		aade elementos a la lista de coincidencias
				encontradas
	complete_check()	comprueba si debera interrumpir el
				completado
	pumvisible()		comprueba si se est mostrando el men
				contextual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">778</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="160" approved="yes">
        <source>Folding:					*folding-functions*
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold
</source>
        <target state="translated">Plegado:					*folding-functions*
	foldclosed()		comprueba si hay un pliegue cerrado en una
				lnea especfica
	foldclosedend()	similar a foldclosed() pero devuelve la ltima
				lnea
	foldlevel()		obtiene el nivel de plegado de la lnea
				especificada
	foldtext()		genera el texto mostrado en un pliegue cerrado
	foldtextresult()	obtiene el texto mostrado en un pliegue
				cerrado
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">785</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="161" approved="yes">
        <source>Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|
</source>
        <target state="translated">Sintaxis y resaltado:	  *syntax-functions* *highlighting-functions*
	clearmatches()	elimina las coincidencias definidas por
				|matchadd()| y las rdenes |:match|
	getmatches()		obtiene todas las coincidencias definidas por
				|matchadd()| y las rdenes |:match|
	hlexists()		comprueba la existencia de un grupo de
				resaltado
	hlID()			obtiene el ID de un grupo de resaltado
	synID()			obtiene el ID de sintaxis en una posicin
				especfica
	synIDattr()		obtiene un atributo especfico correspondiente
				a un ID de sintaxis
	synIDtrans()		obtiene un ID de sintaxis traducido
	diff_hlID()		obtiene el ID de resaltado para el modo diff
				en una posicin dada
	matchadd()		define un patrn a resaltar (una
				coincidencia)
	matcharg()		obtiene informacin acerca de los argumentos
				para |:match|
	matchdelete()		borra una coincidencia definida por
				|matchadd()| o una orden |:match|
	setmatches()		restaura una lista de coincidencias guardada
				por |getmatches()|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">803</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="162" approved="yes">
        <source>Spelling:					*spell-functions*
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word
</source>
        <target state="translated">Correccin ortogrfica:					*spell-functions*
	spellbadword()		ubica palabras mal escritas a partir de la
				posicin actual del cursor
	spellsuggest()		devuelve las correcciones ortogrficas
				sugeridas
	soundfold()		retorna el homfono de una palabra
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">808</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="163" approved="yes">
        <source>History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list
</source>
        <target state="translated">Historia:					*history-functions*
	histadd()		aade un elemento a la historia
	histdel()		elimina un elemento a la historia
	histget()		obtiene un elemento a la historia
	histnr()		obtiene el ndice ms grande de la lista de una
				historia
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">814</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="164" approved="yes">
        <source>Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead
</source>
        <target state="translated">Interaccin:					*interactive-functions*
	browse()		despliega un dilogo de seleccin de archivos
	browsedir()		despliega un dilogo de seleccin de
				directorios
	confirm()		solicita al usuario hacer una eleccin
	getchar()		solicita un carcter al usuario
	getcharmod()		obtiene los modificadores usados en el ltimo
				carcter digitado
	feedkeys()		inserta caracteres en la cola de insercin
	input()			solicita una lnea de texto al usuario
	inputlist()		permite al usuario elegir un elemento de una
				lista
	inputsecret()		solicita una lnea de texto al usuario, sin
				mostrarla
	inputdialog()		solicita una lnea de texto al usuario usando
				un dilogo
	inputsave()		guarda y limpia el bfer de cola de insercin
	inputrestore()		restaura el bfer de la lnea de insercin
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">828</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="165" approved="yes">
        <source>GUI:						*gui-functions*
	getfontname()		get name of current font being used
	getwinposx()		X position of the GUI Vim window
	getwinposy()		Y position of the GUI Vim window
</source>
        <target state="translated">Interfaz grfica:					*gui-functions*
	getfontname()		obtiene el nombre del tipo de letra actual
	getwinposx()		posicin X de la ventana grfica de Vim
	getwinposy()		posicin Y de la ventana grfica de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">833</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="166" approved="yes">
        <source>Vim server:					*server-functions*
	serverlist()		return the list of server names
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground
</source>
        <target state="translated">Servidor Vim:					*server-functions*
	serverlist()		devuelve una lista con nombres de servidores
	remote_send()		enva rdenes (caracteres) a un servidor Vim
	remote_expr()		evala una expresin en un servidor Vim
	server2client()		enva una respuesta a un cliente de un
				servidor Vim
	remote_peek()		comprueba si hay respuestas de un servidor Vim
	remote_read()		lee una respuesta de un servidor Vim
	foreground()		desplaza la ventana de Vim a primer plano
	remote_foreground()	desplaza la ventana de un servidor Vim a primer
				plano
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">843</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="167" approved="yes">
        <source>Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window
</source>
        <target state="translated">Tamao y posicin de ventanas:			*window-size-functions*
	winheight()		obtiene la altura de una ventana especfica
	winwidth()		obtiene el ancho de una ventana especfica
	winrestcmd()		devuelve una orden para restaurar los tamaos
				de ventana
	winsaveview()		obtiene una vista de la ventana actual
	winrestview()		devuelve una vista almacenada en la ventana
				actual
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">850</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="168" approved="yes">
        <source>Various:					*various-functions*
	mode()			get current editing mode
	visualmode()		last visual mode used
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim
</source>
        <target state="translated">Varios:					*various-functions*
	mode()			obtiene el modo de edicin actual
	visualmode()		ltimo modo visual usado
	hasmapto()		comprueba la existencia de una macro
	mapcheck()		comprueba la existencia de una macro que
				coincida con el argumento dado
	maparg()		obtiene el rhs de una macro
	exists()		comprueba si la variable, funcin, etc.,
				existe
	has()			comprueba si Vim cuenta con la caracterstica
				dada
	changenr()		devuelve el nmero correspondiente al cambio
				ms reciente
	cscope_connection()	comprueba si hay una conexin a cscope
	did_filetype()		comprueba si se ha usado una orden automtica
				FileType
	eventhandler()		comprueba si se ha sido invocado desde un
				manejador de eventos
	getpid()		obtiene el ID de proceso de Vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">864</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="169" approved="yes">
        <source>	libcall()		call a function in an external library
	libcallnr()		idem, returning a number
</source>
        <target state="translated">	libcall()		llama a una funcin en una biblioteca externa
	libcallnr()		idntica, pero devuelve un nmero en vez de una
				cadena
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">867</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="170" approved="yes">
        <source>	getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register
</source>
        <target state="translated">	getreg()		obtiene el contenido de un registro
	getregtype()		obtiene el tipo de un registro
	setreg()		asigna el tipo y contenido de un registro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">871</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="171" approved="yes">
        <source>	taglist()		get list of matching tags
	tagfiles()		get a list of tags files
</source>
        <target state="translated">	taglist()		obtiene una lista de etiquetas coincidentes
	tagfiles()		obtiene una lista de archivos de etiquetas
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">874</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="172" approved="yes">
        <source>	mzeval()		evaluate |MzScheme| expression
</source>
        <target state="translated">	mzeval()		evala una expresin |MzScheme|
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">876</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="173" approved="yes">
        <source>*41.7*	Defining a function
</source>
        <target state="translated">*41.7*	Definicin de funciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">879</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="174" approved="yes">
        <source>Vim enables you to define your own functions.  The basic function declaration begins as follows: &gt;</source>
        <target state="translated">Vim permite definir nuevas funciones. La definicin bsica de una funcin corresponde a lo siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">882</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="175" approved="yes">
        <source>	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
&lt;
	Note:
	Function names must begin with a capital letter.
</source>
        <target state="translated">	:function {nombre}({var1}, {var2}, ...)
	:  {instrucciones}
	:endfunction
&lt;
	Nota:
	Los nombres de funciones deben empezar con una letra mayscula.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">889</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="176" approved="yes">
        <source>Let's define a short function to return the smaller of two numbers.  It starts with this line: &gt;</source>
        <target state="translated">Vamos a definir una funcin pequea que retorne el ms pequeo de dos nmeros. Su definicin empieza con esta lnea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">892</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="177" approved="yes">
        <source>	:function Min(num1, num2)
</source>
        <target state="translated">	:function Min(num1, num2)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">894</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="178" approved="yes">
        <source>This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
   &gt;
	:  if a:num1 &lt; a:num2
</source>
        <target state="translated">sta le indica a Vim que la funcin se llama Min y que recibe dos
argumentos: num1 y num2.
   El primer paso es comprobar qu nmero es el ms pequeo:
   &gt;
	:   if a:num1 &lt; a:num2
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">900</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="179" approved="yes">
        <source>The special prefix "a:" tells Vim that the variable is a function argument.  Let's assign the variable "smaller" the value of the smallest number: &gt;</source>
        <target state="translated">El prefijo especial a: le indica a Vim que la variable es un argumento de la funcin. Asignemos ahora a la variable menor el valor del menor nmero: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">903</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="180" approved="yes">
        <source>	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
</source>
        <target state="translated">	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">909</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="181" approved="yes">
        <source>The variable "smaller" is a local variable.  Variables used inside a function are local unless prefixed by something like "g:", "a:", or "s:".</source>
        <target state="translated">La variable menor es una variable local. Las variables usadas dentro de una funcin son locales a menos que tengan un prefijo como g:, a:, o s:.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">912</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="182" approved="yes">
        <source>	Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.  Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.
</source>
        <target state="translated">	Nota:
	Para usar una variable global dentro de una funcin debe anteponer
	g: a su nombre. Dentro de una funcin, g:hoy corresponde a la
	variable global hoy, y hoy es otra variable, local respecto a la
	funcin.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">918</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="183" approved="yes">
        <source>You now use the ":return" statement to return the smallest number to the user.  Finally, you end the function: &gt;</source>
        <target state="translated">Ahora usamos la instruccin :return para devolver el menor de los dos nmeros al usuario. Finalmente, terminamos la funcin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">921</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="184" approved="yes">
        <source>	:  return smaller
	:endfunction
</source>
        <target state="translated">	:  return menor
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">924</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="185" approved="yes">
        <source>The complete function definition is as follows: &gt;</source>
        <target state="translated">La funcin completa es la siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">926</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="186" approved="yes">
        <source>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction
</source>
        <target state="translated">	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
	:  return menor
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">935</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="187" approved="yes">
        <source>For people who like short functions, this does the same thing: &gt;</source>
        <target state="translated">Para los aficionados a las funciones cortas, lo siguiente es equivalente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">937</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="188" approved="yes">
        <source>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</source>
        <target state="translated">	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">944</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="189" approved="yes">
        <source>A user defined function is called in exactly the same way as a built-in function.  Only the name is different.  The Min function can be used like this: &gt;</source>
        <target state="translated">Las funciones definidas por el usuario se invocan exactamente de la misma forma que las funciones internas. La nica diferencia es el nombre. Puede usar la funcin Min como sigue: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">948</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="190" approved="yes">
        <source>	:echo Min(5, 8)
</source>
        <target state="translated">	:echo Min(5, 8)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">950</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="191" approved="yes">
        <source>Only now will the function be executed and the lines be interpreted by Vim.  If there are mistakes, like using an undefined variable or function, you will now get an error message.  When defining the function these errors are not detected.</source>
        <target state="translated">Slo en este momento se ejecutar la funcin y Vim interpretar las instrucciones que la componen. Si hay errores, como usar una variable o funcin no definida, se mostrar un mensaje de error. Al definir una funcin estos errores no son detectados.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">955</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="192" approved="yes">
        <source>When a function reaches ":endfunction" or ":return" is used without an argument, the function returns zero.</source>
        <target state="translated">Cuando una funcin llega a :endfunction o cuando se usa :return sin un argumento, se retorna cero.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">958</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="193" approved="yes">
        <source>To redefine a function that already exists, use the ! for the ":function" command: &gt;</source>
        <target state="translated">Para redefinir una funcin existente, use ! en la orden :function: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">961</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="194" approved="yes">
        <source>	:function!  Min(num1, num2, num3)
</source>
        <target state="translated">	:function!  Min(num1, num2, num3)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">963</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="195" approved="yes">
        <source>USING A RANGE</source>
        <target state="translated">USO DE RANGOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">966</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="196" approved="yes">
        <source>The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example: &gt;
</source>
        <target state="translated">La orden :call puede recibir un rango de lneas. Este rango puede tener dos
significados. Cuando la definicin de una funcin tiene la palabra clave
range, sta se har cargo del rango de lneas.
   La funcin recibir las variables a:firstline y a:lastline. stas
contendrn los nmeros de lnea del rango con el cual se invoca la funcin.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">973</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="197" approved="yes">
        <source>	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction
</source>
        <target state="translated">	:function Contar_palabras() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "encontradas " . n . " palabras"
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">983</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="198" approved="yes">
        <source>You can call this function with: &gt;</source>
        <target state="translated">Puede invocar la funcin con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">985</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="199" approved="yes">
        <source>	:10,30call Count_words()
</source>
        <target state="translated">	:10,30call Contar_palabras()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">987</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="200" approved="yes">
        <source>It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example: &gt;
</source>
        <target state="translated">La funcin se ejecutar una vez, y mostrar en la pantalla el nmero de
palabras.
   La otra forma de usar un rango de lneas es definiendo una funcin sin la
palabra clave range. Se invocar la funcin una vez por cada lnea en el
rango, y el cursor estar en la lnea correspondiente a cada invocacin.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">992</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="201" approved="yes">
        <source>	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction
</source>
        <target state="translated">	:function  Numero()
	:  echo "la lnea " . line(".") . " contiene: " . getline(".")
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">996</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="202" approved="yes">
        <source>If you call this function with: &gt;</source>
        <target state="translated">Si invoca esta funcin con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">998</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="203" approved="yes">
        <source>	:10,15call Number()
</source>
        <target state="translated">	:10,15call Numero()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1000</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="204" approved="yes">
        <source>The function will be called six times.</source>
        <target state="translated">Se invocar la funcin seis veces.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1002</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="205" approved="yes">
        <source>VARIABLE NUMBER OF ARGUMENTS</source>
        <target state="translated">NMERO VARIABLE DE ARGUMENTOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1005</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="206" approved="yes">
        <source>Vim enables you to define functions that have a variable number of arguments.  The following command, for instance, defines a function that must have 1 argument (start) and can have up to 20 additional arguments: &gt;</source>
        <target state="translated">Vim permite la definicin de funciones que reciben una cantidad variable de argumentos. Por ejemplo, la siguiente orden define una funcin que debe recibir un argumento (inicio) y puede recibir hasta 20 argumentos adicionales: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1009</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="207" approved="yes">
        <source>	:function Show(start, ...)
</source>
        <target state="translated">	:function Mostrar(inicio, ...)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1011</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="208" approved="yes">
        <source>The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example: &gt;
</source>
        <target state="translated">La variable a:1 contiene el primer argumento opcional, a:2 contiene el
segundo, y as sucesivamente. La variable a:0 contiene la cantidad de
argumentos adicionales.
   Por ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1015</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="209" approved="yes">
        <source>	:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index &lt;= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction
</source>
        <target state="translated">	:function Mostrar(inicio, ...)
	:  echohl Title
	:  echo "inicio es " . a:inicio
	:  echohl None
	:  let indice = 1
	:  while indice &lt;= a:0
	:    echo "  Arg " . indice . " is " . a:{indice}
	:    let indice = indice + 1
	:  endwhile
	:  echo ""
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1027</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO check for bugs in the doc: it isn't "Show is ... a:start", but "start
is" a:start</context>
        </context-group>
        <note from="po-translator">TODO check for bugs in the doc: it isn't "Show is ... a:start", but "start
is" a:start</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="210" approved="yes">
        <source>This uses the ":echohl" command to specify the highlighting used for the following ":echo" command.  ":echohl None" stops it again.  The ":echon" command works like ":echo", but doesn't output a line break.</source>
        <target state="translated">Aqu se usa la orden :echohl, que especifica el resaltado a usar en la siguiente orden :echo. :echohl None hace que no se use resaltado alguno. La orden  :echon es similar a :echo pero no imprime el cambio de lnea final.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1031</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="211" approved="yes">
        <source>You can also use the a:000 variable, it is a List of all the "..." arguments.  See |a:000|.</source>
        <target state="translated">Tambin puede usar la variable a:000. Es una Lista de todos los argumentos opcionales (...). Consulte |a:000|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1034</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="212" approved="yes">
        <source>LISTING FUNCTIONS</source>
        <target state="translated">LISTAR FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1037</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="213" approved="yes">
        <source>The ":function" command lists the names and arguments of all user-defined functions: &gt;</source>
        <target state="translated">La orden :function muestra una lista con los nombres y argumentos de todas las funciones definidas por el usuario (esto incluye funciones de scripts y extensiones instalados).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1040</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="214" approved="yes">
        <source>	:function
&lt;	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~
</source>
        <target state="translated">	:function
&lt;	function Mostrar(inicio, ...) ~
	function ObtenerSangradoVim() ~
	function DefinirSintaxis(nombre) ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1045</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="215" approved="yes">
        <source>To see what a function does, use its name as an argument for ":function": &gt;</source>
        <target state="translated">Para ver la definicin de una funcin, introduzca su nombre como argumento a la orden :function: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1047</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="216" approved="yes">
        <source>	:function SetSyn
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:name ~
	3     endif ~
	   endfunction ~
</source>
        <target state="translated">	:function DefinirSintaxis
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:nombre ~
	3     endif ~
	   endfunction ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1053</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="217" approved="yes">
        <source>DEBUGGING</source>
        <target state="translated">DEPURACIN</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1056</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="218" approved="yes">
        <source>The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.
</source>
        <target state="translated">El nmero de lnea de una instruccin es informacin til cuando aparece un
mensaje de error o al depurar scripts. Acerca del modo de depurado,
consulte |debug-scripts|.
   Puede darle un valor de 12 o ms a la opcin 'verbose' para ver todas las
invocaciones a funciones. Con un valor de 15 o ms ver cada lnea ejecutada.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1061</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="219" approved="yes">
        <source>DELETING A FUNCTION</source>
        <target state="translated">ELIMINAR FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1064</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="220" approved="yes">
        <source>To delete the Show() function: &gt;</source>
        <target state="translated">Para eliminar la funcin Mostrar(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1066</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="221" approved="yes">
        <source>	:delfunction Show
</source>
        <target state="translated">	:delfunction Mostrar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1068</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="222" approved="yes">
        <source>You get an error when the function doesn't exist.</source>
        <target state="translated">Si la funcin no existe obtendr un error al usar esta orden.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1070</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="223" approved="yes">
        <source>FUNCTION REFERENCES</source>
        <target state="translated">REFERENCIAS A FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1073</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="224" approved="yes">
        <source>Sometimes it can be useful to have a variable point to one function or another.  You can do it with the function() function.  It turns the name of a function into a reference: &gt;</source>
        <target state="translated">En ocasiones es til que una variable pueda hacer referencia a una u otra funcin . Puede hacerlo usando la funcin function(). sta funcin convierte el nombre de una funcin en una referencia a la misma: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1077</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="225" approved="yes">
        <source>	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
&lt;	Wrong! ~
</source>
        <target state="translated">	:let resultado = 0		" o 1
	:function! Bien()
	:  return 'Bien!'
	:endfunc
	:function! Mal()
	:  return 'Mal!'
	:endfunc
	:
	:if resultado == 1
	:  let Unafunc = function('Bien')
	:else
	:  let Unafunc = function('Mal')
	:endif
	:echo call(Unafunc, [])
&lt;	Mal! ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1093</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="226" approved="yes">
        <source>Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.
</source>
        <target state="translated">Tenga en cuenta que el nombre de la variable que contiene la referencia a la
funcin debe empezar con una letra mayscula. En caso contrario, es posible
que se confunda con el nombre de una de las funciones integradas de Vim.
   Para invocar una funcin usando una variable con una referencia a funcin
se usa la funcin call(). Como primer argumento recibe la referencia a la
funcin, y como segundo argumento una Lista con los argumentos para la funcin
a invocar.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1100</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="227" approved="yes">
        <source>Function references are most useful in combination with a Dictionary, as is explained in the next section.</source>
        <target state="translated">Las referencias a funciones son particularmente tiles usadas con Diccionarios, como se muestra en la siguiente seccin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1103</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="228" approved="yes">
        <source>*41.8*	Lists and Dictionaries
</source>
        <target state="translated">*41.8*	Listas y Diccionarios
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="229" approved="yes">
        <source>So far we have used the basic types String and Number.  Vim also supports two composite types: List and Dictionary.</source>
        <target state="translated">Hasta ahora hemos usado los tipos bsicos, Cadena de texto y Nmero. Vim tambin ofrece otros dos: Lista y Diccionario.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1109</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="230" approved="yes">
        <source>A List is an ordered sequence of things.  The things can be any kind of value, thus you can make a List of numbers, a List of Lists and even a List of mixed items.  To create a List with three strings: &gt;</source>
        <target state="translated">Una Lista es una secuencia ordenada de elementos. Los elementos pueden ser de cualquier tipo, as que puede crear una Lista de nmeros, una Lista de Listas e incluso una Lista de elementos de tipos diferentes. Para crear una Lista con tres cadenas de texto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1113</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="231" approved="yes">
        <source>	:let alist = ['aap', 'mies', 'noot']
</source>
        <target state="translated">	:let lista = ['aap', 'mies', 'noot']
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1115</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="232" approved="yes">
        <source>The List items are enclosed in square brackets and separated by commas.  To create an empty List: &gt;</source>
        <target state="translated">Los elementos de la Lista se rodean con corchetes y se separan con comas. Para crear una Lista vaca: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1118</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="233" approved="yes">
        <source>	:let alist = []
</source>
        <target state="translated">	:let lista = []
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1120</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="234" approved="yes">
        <source>You can add items to a List with the add() function: &gt;</source>
        <target state="translated">Puede aadir elementos a una lista mediante la funcin add(): &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1122</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="235" approved="yes">
        <source>	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
&lt;	['foo', 'bar'] ~
</source>
        <target state="translated">	:let lista = []
	:call add(lista, 'foo')
	:call add(lista, 'bar')
	:echo lista
&lt;	['foo', 'bar'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1128</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="236" approved="yes">
        <source>List concatenation is done with +: &gt;</source>
        <target state="translated">El operador de concatenacin de Listas es +: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1130</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="237" approved="yes">
        <source>	:echo alist + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</source>
        <target state="translated">	:echo lista + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1133</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="238" approved="yes">
        <source>Or, if you want to extend a List directly: &gt;</source>
        <target state="translated">O, si lo que desea es extender una Lista directamente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1135</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="239" approved="yes">
        <source>	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
&lt;	['one', 'two', 'three'] ~
</source>
        <target state="translated">	:let lista = ['uno']
	:call extend(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', 'dos', 'tres'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1140</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="240" approved="yes">
        <source>Notice that using add() will have a different effect: &gt;</source>
        <target state="translated">Observe que usar add() tendr un resultado diferente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1142</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="241" approved="yes">
        <source>	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
&lt;	['one', ['two', 'three']] ~
</source>
        <target state="translated">	:let lista = ['uno']
	:call add(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', ['dos', 'tres']] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1147</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="242" approved="yes">
        <source>The second argument of add() is added as a single item.</source>
        <target state="translated">El segundo argumento de add() se aade a la lista como un nico elemento.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1149</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="243" approved="yes">
        <source>FOR LOOP</source>
        <target state="translated">CICLO FOR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1152</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="244" approved="yes">
        <source>One of the nice things you can do with a List is iterate over it: &gt;</source>
        <target state="translated">Una de las cosas interesantes de las Listas es iterar sobre sus elementos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1154</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="245" approved="yes">
        <source>	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
&lt;	one ~
	two ~
	three ~
</source>
        <target state="translated">	:let lista = ['uno', 'dos', 'tres']
	:for n in lista
	:  echo n
	:endfor
&lt;	uno ~
	dos ~
	tres ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1162</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="246" approved="yes">
        <source>This will loop over each element in List "alist", assigning the value to variable "n".  The generic form of a for loop is: &gt;</source>
        <target state="translated">El cdigo mostrado iterar sobre cada elemento en la Lista lista, asignando el valor del elemento a la variable n. La forma genrica de un ciclo for es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1165</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="247" approved="yes">
        <source>	:for {varname} in {listexpression}
	:  {commands}
	:endfor
</source>
        <target state="translated">	:for {nombrevar} in {expresinlista}
	:  {instrucciones}
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1169</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="248" approved="yes">
        <source>To loop a certain number of times you need a List of a specific length.  The range() function creates one for you: &gt;</source>
        <target state="translated">Para iterar una cantidad determinada de veces necesita una Lista con una longitud especfica. La funcin range() puede crearla por usted: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1172</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="249" approved="yes">
        <source>	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</source>
        <target state="translated">	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1179</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="250" approved="yes">
        <source>Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards: &gt;
</source>
        <target state="translated">Observe que el primer elemento de la Lista creada por range() es cero, y por
tanto el ltimo elemento tiene un valor de uno menos que la longitud de la
lista.
   Tambin puede especificar el valor mximo, y el incremento o decremento
deseado: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1183</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="251" approved="yes">
        <source>	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</source>
        <target state="translated">	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1190</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="252" approved="yes">
        <source>A more useful example, looping over lines in the buffer: &gt;</source>
        <target state="translated">Ahora un ejemplo ms til, iterar sobre las lneas de un bfer: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1192</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="253" approved="yes">
        <source>	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor
</source>
        <target state="translated">	:for line in getline(1, 20)
	:  if line =~ "Fecha: "
	:    echo matchstr(line, 'Fecha: \zs.*')
	:  endif
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1198</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="254" approved="yes">
        <source>This looks into lines 1 to 20 (inclusive) and echoes any date found in there.</source>
        <target state="translated">Este ejemplo examina las lneas 1 a 20 (inclusive) y muestra en pantalla las fechas encontradas en ellas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1200</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="255" approved="yes">
        <source>DICTIONARIES</source>
        <target state="translated">DICCIONARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1203</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="256" approved="yes">
        <source>A Dictionary stores key-value pairs.  You can quickly lookup a value if you know the key.  A Dictionary is created with curly braces: &gt;</source>
        <target state="translated">Un Diccionario almacena pares clave-valor. Esto le permite obtener un valor almacenado de manera rpida, si conoce la clave del mismo. Los Diccionarios se crean usando llaves: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1206</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="257" approved="yes">
        <source>	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
</source>
        <target state="translated">	:let es2nl = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1208</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="258" approved="yes">
        <source>Now you can lookup words by putting the key in square brackets: &gt;</source>
        <target state="translated">Ahora puede buscar palabras usando la clave, ponindola entre corchetes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1210</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="259" approved="yes">
        <source>	:echo uk2nl['two']
&lt;	twee ~
</source>
        <target state="translated">	:echo es2nl['dos']
&lt;	twee ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1213</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="260" approved="yes">
        <source>The generic form for defining a Dictionary is: &gt;</source>
        <target state="translated">La manera genrica de definir un Diccionario es: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1215</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="261" approved="yes">
        <source>	{&lt;key&gt; : &lt;value&gt;, ...}
</source>
        <target state="translated">	{&lt;clave&gt; : &lt;valor&gt;, ...}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1217</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="262" approved="yes">
        <source>An empty Dictionary is one without any keys: &gt;</source>
        <target state="translated">Un Diccionario vaco se define como carente de claves: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1219</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="263" approved="yes">
        <source>	{}
</source>
        <target state="translated">	{}
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="264" approved="yes">
        <source>The possibilities with Dictionaries are numerous.  There are various functions for them as well.  For example, you can obtain a list of the keys and loop over them: &gt;</source>
        <target state="translated">Los Diccionarios ofrecen numerosas posibilidades. Tambin dispone de varias funciones para operar sobre ellos. Por ejemplo, puede obtener una lista de las claves e iterar sobre ellas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1225</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="265" approved="yes">
        <source>	:for key in keys(uk2nl)
	:  echo key
	:endfor
&lt;	three ~
	one ~
	two ~
</source>
        <target state="translated">	:for clave in keys(es2nl)
	:  echo clave
	:endfor
&lt;	tres ~
	uno ~
	dos ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1232</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="266" approved="yes">
        <source>You will notice the keys are not ordered.  You can sort the list to get a specific order: &gt;</source>
        <target state="translated">Habr notado que las claves no estn ordenadas. Puede ordenar la lista para obtener un orden especfico: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="267" approved="yes">
        <source>	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
&lt;	one ~
	three ~
	two ~
</source>
        <target state="translated">	:for clave in sort(keys(es2nl))
	:  echo clave
	:endfor
&lt;	dos ~
	tres ~
	uno ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1242</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="268" approved="yes">
        <source>But you can never get back the order in which items are defined.  For that you need to use a List, it stores items in an ordered sequence.</source>
        <target state="translated">No es posible recuperar el orden en el cual se definieron los elementos del Diccionario. Para eso necesita una Lista, que almacena los elementos en una secuencia ordenada.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="269" approved="yes">
        <source>DICTIONARY FUNCTIONS</source>
        <target state="translated">FUNCIONES PARA DICCIONARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1248</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="270" approved="yes">
        <source>The items in a Dictionary can normally be obtained with an index in square brackets: &gt;</source>
        <target state="translated">Habitualmente, puede acceder a los elementos de un Diccionario usando el ndice correspondiente entre corchetes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1251</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="271" approved="yes">
        <source>	:echo uk2nl['one']
&lt;	een ~
</source>
        <target state="translated">	:echo es2nl['uno']
&lt;	een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1254</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="272" approved="yes">
        <source>A method that does the same, but without so many punctuation characters: &gt;</source>
        <target state="translated">Una forma de hacer lo mismo, sin tantos caracteres: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1256</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="273" approved="yes">
        <source>	:echo uk2nl.one
&lt;	een ~
</source>
        <target state="translated">	:echo es2nl.uno
&lt;	een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1259</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="274" approved="yes">
        <source>This only works for a key that is made of ASCII letters, digits and the underscore.  You can also assign a new value this way: &gt;</source>
        <target state="translated">Esto slo funciona con claves compuestas de caracteres ASCII, dgitos, y el guin bajo. Tambin puede usar esta notacin para asignar valores: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1262</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="275" approved="yes">
        <source>	:let uk2nl.four = 'vier'
	:echo uk2nl
&lt;	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~
</source>
        <target state="translated">	:let es2nl.cuatro = 'vier'
	:echo es2nl
&lt;	{'tres': 'drie', 'cuatro': 'vier', 'uno': 'een', 'dos': 'twee'} ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1266</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="276" approved="yes">
        <source>And now for something special: you can directly define a function and store a reference to it in the dictionary: &gt;</source>
        <target state="translated">Y ahora, algo especial: puede definir directamente una funcin y almacenar una referencia a la misma en un diccionario: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="277" approved="yes">
        <source>	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction
</source>
        <target state="translated">	:function es2nl.traducir(linea) dict
	:  return join(map(split(a:linea), 'get(self, v:val, "???")'))
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1273</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="278" approved="yes">
        <source>Let's first try it out: &gt;</source>
        <target state="translated">Primero probmosla: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1275</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="279" approved="yes">
        <source>	:echo uk2nl.translate('three two five one')
&lt;	drie twee ??? een ~
</source>
        <target state="translated">	:echo es2nl.traducir('tres dos cinco uno')
&lt;	drie twee ??? een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1278</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="280" approved="yes">
        <source>The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: &gt;
</source>
        <target state="translated">Lo que habr notado primero es el dict al final de la lnea :function.
As se indica que la funcin ser usada desde un Diccionario. La variable
local self se referir a dicho diccionario.
   Ahora, dividamos esa compleja instruccin de retorno: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1283</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="281" approved="yes">
        <source>	split(a:line)
</source>
        <target state="translated">	split(a:linea)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1285</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="282" approved="yes">
        <source>The split() function takes a string, chops it into white separated words and returns a list with these words.  Thus in the example it returns: &gt;</source>
        <target state="translated">La funcin split() toma una cadena, la divide en palabras separadas por espacios en blanco, y entrega una lista con estas palabras. En el ejemplo previo, entrega: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1288</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="283" approved="yes">
        <source>	:echo split('three two five one')
&lt;	['three', 'two', 'five', 'one'] ~
</source>
        <target state="translated">	:echo split('tres dos cinco uno')
&lt;	['tres', 'dos', 'cinco', 'uno'] ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1291</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="284" approved="yes">
        <source>This list is the first argument to the map() function.  This will go through the list, evaluating its second argument with "v:val" set to the value of each item.  This is a shortcut to using a for loop.  This command: &gt;</source>
        <target state="translated">Esta lista es el primer argumento para la funcin map(). Dicha funcin analizar la lista, evaluando su segundo argumento con la variable v:val definida con el valor de cada elemento en la lista. Es una abreviacin de un ciclo for. Esta instruccin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1295</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="285" approved="yes">
        <source>	:let alist = map(split(a:line), 'get(self, v:val, "???")')
</source>
        <target state="translated">	:let lista = map(split(a:linea), 'get(self, v:val, "???")')
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1297</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="286" approved="yes">
        <source>Is equivalent to: &gt;</source>
        <target state="translated">Equivale a: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1299</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="287" approved="yes">
        <source>	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor
</source>
        <target state="translated">	:let lista = split(a:linea)
	:for ind in range(len(lista))
	:  let lista[ind] = get(self, lista[ind], "???")
	:endfor
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="288" approved="yes">
        <source>The get() function checks if a key is present in a Dictionary.  If it is, then the value is retrieved.  If it isn't, then the default value is returned, in the example it's '???'.  This is a convenient way to handle situations where a key may not be present and you don't want an error message.</source>
        <target state="translated">La funcin get() comprueba si una clave existe en un Diccionario. Si existe, devuelve el valor asociado a la clave. Si no existe, devuelve el valor definido como predeterminado, que en el ejemplo es '???'. Esto permite manejar de una forma conveniente las situaciones en que una clave no existe y no desea hacer el manejo del error que provocara dicha situacin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1309</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="289" approved="yes">
        <source>The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.
</source>
        <target state="translated">La funcin join() es el complemento de split(): une una lista de palabras,
separndolas con un espacio.
   La combinacin de split(), map(), y join() es una forma elegante de filtrar
una cadena de palabras de manera sucinta.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1314</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="290" approved="yes">
        <source>OBJECT ORIENTED PROGRAMMING</source>
        <target state="translated">PROGRAMACIN ORIENTADA A OBJETOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1317</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="291" approved="yes">
        <source>Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: &gt;
</source>
        <target state="translated">Ahora que podemos guardar valores y funciones en un Diccionario, podemos usar
un Diccionario como un objeto.
   Anteriormente hicimos uso de un Diccionario para traducir texto de Holands
a Espaol. Querramos hacer lo mismo para otros idiomas. Primero crearemos un
objeto (esto es, un Diccionario) que tenga la funcin traducir, pero no tenga
palabras para traducir: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1323</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="292" approved="yes">
        <source>	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction
</source>
        <target state="translated">	:let dicctraductor = {}
	:function dicctraductor.traducir(linea) dict
	:  return join(map(split(a:linea),
			\ 'get(self.palabras, v:val, "???")'))
	:endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1328</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="293" approved="yes">
        <source>It's slightly different from the function above, using 'self.words' to lookup word translations.  But we don't have a self.words.  Thus you could call this an abstract class.</source>
        <target state="translated">La definicin es ligeramente diferente de la funcin anterior, ya que usa 'self.words' para buscar las traducciones de palabras. Pero no hay un self.words. Por esto decir que el Diccionario es una clase abstracta.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1332</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="294" approved="yes">
        <source>Now we can instantiate a Dutch translation object: &gt;</source>
        <target state="translated">Ahora podemos instanciar un objeto para traduccin al Holands: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1334</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="295" approved="yes">
        <source>	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
&lt;	drie een ~
</source>
        <target state="translated">	:let es2nl = copy(dicctraductor)
	:let es2nl.words = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
	:echo es2nl.translate('tres uno')
&lt;	drie een ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1339</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="296" approved="yes">
        <source>And a German translator: &gt;</source>
        <target state="translated">Y un traductor al alemn: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1341</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="297" approved="yes">
        <source>	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
&lt;	drei ein ~
</source>
        <target state="translated">	:let es2de = copy(dicctraductor)
	:let es2de.words = {'uno': 'ein', 'dos': 'zwei', 'tres': 'drei'}
	:echo es2de.translate('tres uno')
&lt;	drei ein ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1346</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="298" approved="yes">
        <source>You see that the copy() function is used to make a copy of the "transdict" Dictionary and then the copy is changed to add the words.  The original remains the same, of course.</source>
        <target state="translated">Puede ver que la funcin copy() se usa para crear una copia del Diccionario dicctraductor y luego se cambia la copia, aadiendo las palabras. El original, por supuesto, permanece intacto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1350</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="299" approved="yes">
        <source>Now you can go one step further, and use your preferred translator: &gt;</source>
        <target state="translated">Ahora puede ir un paso ms all, y usar su traductor preferido: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1352</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="300" approved="yes">
        <source>	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
&lt;	een twee drie ~
</source>
        <target state="translated">	:if $LANG =~ "de"
	:  let trad = es2de
	:else
	:  let trad = es2nl
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	een twee drie ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1360</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="301" approved="yes">
        <source>Here "trans" refers to one of the two objects (Dictionaries).  No copy is made.  More about List and Dictionary identity can be found at |list-identity| and |dict-identity|.</source>
        <target state="translated">Aqu trad se refiere a uno de dos posibles objetos (Diccionarios). No se hace ninguna copia. Puede encontrar ms informacin acerca de la identidad de Listas y Diccionarios en |list-identity| y |dict-identity|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1364</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="302" approved="yes">
        <source>Now you might use a language that isn't supported.  You can overrule the translate() function to do nothing: &gt;</source>
        <target state="translated">Puede que use un idioma que an no est incluido. Para este caso, puede redefinir la funcin traducir() para que no haga nada: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1367</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="303" approved="yes">
        <source>	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
&lt;	three one wladiwostok ~
</source>
        <target state="translated">	:let es2es = copy(dicctraductor)
	:function! es2es.traducir(linea)
	:  return a:linea
	:endfunction
	:echo es2es.traducir('tres one wladiwostok')
&lt;	tres uno wladiwostok ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1374</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="304" approved="yes">
        <source>Notice that a ! was used to overwrite the existing function reference.  Now use "uk2uk" when no recognized language is found: &gt;</source>
        <target state="translated">Note el ! utilizado para redefinir la referencia a funcin existente. Ahora puede usar es2es cuando no se encuentra ningn idioma reconocido: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1377</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="305" approved="yes">
        <source>	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
&lt;	one two three ~
</source>
        <target state="translated">	:if $LANG =~ "de"
	:  let trad = es2de
	:elseif $LANG =~ "nl"
	:  let trad = es2nl
	:else
	:  let trad = es2es
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	uno dos tres ~
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="306" approved="yes">
        <source>For further reading see |Lists| and |Dictionaries|.</source>
        <target state="translated">Para ms detalles consulte |Lists| y |Dictionaries|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1389</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="307" approved="yes">
        <source>*41.9*	Exceptions
</source>
        <target state="translated">*41.9*	Excepciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1392</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="308" approved="yes">
        <source>Let's start with an example: &gt;</source>
        <target state="translated">Empecemos con un ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1394</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="309" approved="yes">
        <source>	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</source>
        <target state="translated">	:try
	:   read ~/plantillas/pascal.tmpl
	:catch /E484:/
	:   echo Lo siento, no encuentro el archivo plantilla para Pascal.
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1400</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="310" approved="yes">
        <source>The ":read" command will fail if the file does not exist.  Instead of generating an error message, this code catches the error and gives the user a nice message instead.</source>
        <target state="translated">La orden :read (leer) fallar si el archivo no existe. En vez de mostrar un mensaje de error, este cdigo atrapa el error y le muestra al usuario un mensaje ms agradable.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1404</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO instead no est como repetido?</context>
        </context-group>
        <note from="po-translator">TODO instead no est como repetido?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="311" approved="yes">
        <source>For the commands in between ":try" and ":endtry" errors are turned into exceptions.  An exception is a string.  In the case of an error the string contains the error message.  And every error message has a number.  In this case, the error we catch contains "E484:".  This number is guaranteed to stay the same (the text may change, e.g., it may be translated).</source>
        <target state="translated">Para las instrucciones entre :try y :endtry los errores se convierten en excepciones. Una excepcin es una cadena de texto. Cuando aparece un error esta cadena contiene el mensaje de error. Y cada mensaje de error tiene un nmero. En este caso, el error que atrapamos contiene E484:. Vim garantiza que este nmero permanece inalterado (el texto del mensaje de error puede cambiar, por ejemplo, puede haber sido traducido.)</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1410</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="312" approved="yes">
        <source>When the ":read" command causes another error, the pattern "E484:" will not match in it.  Thus this exception will not be caught and result in the usual error message.</source>
        <target state="translated">Cuando la orden :read genera un error distinto, el patrn E484: no coincidir con l. La excepcin no ser atrapada y aparecer el mensaje de error habitual en esos casos.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1414</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="313" approved="yes">
        <source>You might be tempted to do this: &gt;</source>
        <target state="translated">Puede sentirse tentado a hacer lo siguiente:: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1416</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="314" approved="yes">
        <source>	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</source>
        <target state="translated">	:try
	:   read ~/plantillas/pascal.tmpl
	:catch
	:   echo Lo siento, no encuentro el archivo plantilla para Pascal.
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1422</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="315" approved="yes">
        <source>This means all errors are caught.  But then you will not see errors that are useful, such as "E21: Cannot make changes, 'modifiable' is off".</source>
        <target state="translated">De esta forma se atrapan todos los errores. Pero al hacerlo no ver errores que son tiles, como por ejemplo E21: No se pudo modificar, 'modifiable' est desactivado</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1425</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="316" approved="yes">
        <source>Another useful mechanism is the ":finally" command: &gt;</source>
        <target state="translated">La orden :finally es otro mecanismo til: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1427</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="317" approved="yes">
        <source>	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</source>
        <target state="translated">	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1437</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="318" approved="yes">
        <source>This filters the lines from the cursor until the end of the file through the "filter" command, which takes a file name argument.  No matter if the filtering works, something goes wrong in between ":try" and ":finally" or the user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is always executed.  This makes sure you don't leave the temporary file behind.</source>
        <target state="translated">Aqu se filtran las lneas desde el cursor hasta el final del archivo usando la orden filter, que toma como argumento un nombre de archivo. No importa si el filtrado funciona, si algo sale mal entre :try y :finally, o si el usuario cancela el filtrado presionando CTRL-C, la instruccin call delete(tmp) siempre se ejecuta. As se asegura de que no queden archivos temporales al acabar el proceso.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1443</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="319" approved="yes">
        <source>More information about exception handling can be found in the reference manual: |exception-handling|.</source>
        <target state="translated">Puede encontrar ms informacin acerca del manejo de excepciones en el manual de referencia: |exception-handling|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1446</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="320" approved="yes">
        <source>*41.10*	Various remarks
</source>
        <target state="translated">*41.10*	Observaciones
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1449</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="321" approved="yes">
        <source>Here is a summary of items that apply to Vim scripts.  They are also mentioned elsewhere, but form a nice checklist.</source>
        <target state="translated">A continuacin tiene un resumen de los elementos relevantes para escribir scripts de Vim. Tambin se los menciona en otros lugares de la documentacin, pero aqu se presentan como una conveniente lista.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1452</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="322" approved="yes">
        <source>The end-of-line character depends on the system.  For Unix a single &lt;NL&gt; character is used.  For MS-DOS, Windows, OS/2 and the like, &lt;CR&gt;&lt;LF&gt; is used.  This is important when using mappings that end in a &lt;CR&gt;.  See |:source_crnl|.</source>
        <target state="translated">El carcter de fin de lnea usado depende del sistema. En sistemas Unix se usa &lt;NL&gt;. En MS-DOS, Windows, OS/2 y similares, se usa &lt;CR&gt;&lt;LF&gt;. ste es un detalle importante a considerar al usar macros que terminan en &lt;CR&gt;. Consulte |:source_crnl|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1456</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="323" approved="yes">
        <source>WHITE SPACE</source>
        <target state="translated">ESPACIO EN BLANCO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1459</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="324" approved="yes">
        <source>Blank lines are allowed and ignored.</source>
        <target state="translated">Las lneas en blanco estn permitidas, y son ignoradas.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1461</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="325" approved="yes">
        <source>Leading whitespace characters (blanks and TABs) are always ignored.  The whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in the example below) are reduced to one blank character and plays the role of a separator, the whitespaces after the last (visible) character may or may not be ignored depending on the situation, see below.</source>
        <target state="translated">Los espacios en blanco al principio de cada lnea (espacios y tabulados) siempre se ignoran. Los espacios en blanco entre parmetros (por ejemplo, entre 'set' y 'cpoptions' en el ejemplo a continuacin) se reducen a un solo espacio blanco que acta como separador, los espacios en blanco despus del ltimo carcter (visible) se pueden o no ignorar dependiendo del caso, vase a continuacin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1467</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="326" approved="yes">
        <source>For a ":set" command involving the "=" (equal) sign, such as in: &gt;</source>
        <target state="translated">Para una orden :set que incluye el smbolo = (igual), como en: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1469</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="327" approved="yes">
        <source>	:set cpoptions    =aABceFst
</source>
        <target state="translated">	:set cpoptions    =aABceFst
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1471</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="328" approved="yes">
        <source>the whitespace immediately before the "=" sign is ignored.  But there can be no whitespace after the "=" sign!</source>
        <target state="translated">se ignora el espacio en blanco inmediatamente antes del smbolo =. Pero no puede haber espacios a continuacin del smbolo =!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1474</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="329" approved="yes">
        <source>To include a whitespace character in the value of an option, it must be escaped by a "\" (backslash)  as in the following example: &gt;</source>
        <target state="translated">Para incluir un espacio en blanco como valor de una opcin, hay que escaparlo usando una \ (barra inversa) como en el siguiente ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1477</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="330" approved="yes">
        <source>	:set tags=my\ nice\ file
</source>
        <target state="translated">	:set tags=mi\ lindo\ archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1479</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="331" approved="yes">
        <source>The same example written as &gt;</source>
        <target state="translated">Al escribir el ejemplo como: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1481</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug in vim doc?</context>
        </context-group>
        <note from="po-translator">TODO bug in vim doc?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="332" approved="yes">
        <source>	:set tags=my nice file
</source>
        <target state="translated">	:set tags=mi lindo archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1483</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="333" approved="yes">
        <source>will issue an error, because it is interpreted as: &gt;</source>
        <target state="translated">se obtendra un error, porque se interpreta como: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1485</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="334" approved="yes">
        <source>	:set tags=my
	:set nice
	:set file
</source>
        <target state="translated">	:set tags=mi
	:set lindo
	:set archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1489</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="335" approved="yes">
        <source>COMMENTS</source>
        <target state="translated">COMENTARIOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1492</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="336" approved="yes">
        <source>The character " (the double quote mark) starts a comment.  Everything after and including this character until the end-of-line is considered a comment and is ignored, except for commands that don't consider comments, as shown in examples below.  A comment can start on any character position on the line.</source>
        <target state="translated">El carcter " (comilla doble) marca el inicio de un comentario. Todo lo que aparece a continuacin de ste carcter hasta el fin de lnea, e incluyndola, se considera un comentario y es ignorado, a excepcin de las rdenes que no tienen en cuenta los comentarios, como se puede ver en ejemplos de esta seccin. Un comentario puede empezar en cualquier punto de una lnea de texto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1497</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="337" approved="yes">
        <source>There is a little "catch" with comments for some commands.  Examples: &gt;</source>
        <target state="translated">Hay un pequeo pero con los comentarios y ciertas rdenes. Ejemplos: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1499</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="338" approved="yes">
        <source>	:abbrev dev development		" shorthand
	:map &lt;F3&gt; o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files
</source>
        <target state="translated">	:abbrev des desarrollo		" abreviacin
	:map &lt;F3&gt; o#include		" insertar directiva include
	:execute orden			" ejecutar
	:!ls *.c			" listar archivos C
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1504</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="339" approved="yes">
        <source>The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of &lt;F3&gt; will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: &gt;
</source>
        <target state="translated">La abreviacin 'dev' se expandir a 'desarrollo     " abreviacin'. La
macro &lt;F3&gt; constar en realidad de toda la lnea desde 'o# ....' incluyendo
'" insertar directiva include'. La orden execute provocar un error. La
orden ! enviar todos los caracteres a continuacin al intrprete de
rdenes, provocando un error debido al carcter '"' sin la comilla de cierre
correspondiente.
   No pueden existir comentarios a continuacin de las rdenes :map,
:abbreviate, :execute, ni ! (hay algunas rdenes ms con esta
restriccin). Para el caso de las rdenes :map, :abbreviate, y :execute
hay un truco disponible: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1513</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="340" approved="yes">
        <source>	:abbrev dev development|" shorthand
	:map &lt;F3&gt; o#include|" insert include
	:execute cmd			|" do it
</source>
        <target state="translated">	:abbrev des desarrollo|" abreviacin
	:map &lt;F3&gt; o#include|" insertar directiva include
	:execute orden			|" ejecutar
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1517</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="341" approved="yes">
        <source>With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': &gt;
	:exe '!ls *.c'			|" list C files
</source>
        <target state="translated">El carcter | permite separar rdenes. En este caso, la siguiente orden es
simplemente un comentario. Para la ltima orden hay que hacer dos cosas:
|:execute| y usar |: &gt;
	:exe '!ls *.c'			|" listar archivos C
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1522</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="342" approved="yes">
        <source>Notice that there is no white space before the '|' in the abbreviation and mapping.  For these commands, any character until the end-of-line or '|' is included.  As a consequence of this behavior, you don't always see that trailing whitespace is included: &gt;</source>
        <target state="translated">Observe que no hay espacios en blanco antes de | en la abreviacin ni en la macro. En estas rdenes, se incluye cualquier carcter hasta el fin de lnea o hasta |. Como consecuencia de este comportamiento, no siempre es visible cundo se incluyen espacios en blanco al final del a lnea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1527</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="343" approved="yes">
        <source>	:map &lt;F4&gt; o#include  
</source>
        <target state="translated">	:map &lt;F4&gt; o#include  
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1529</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="344" approved="yes">
        <source>To spot these problems, you can set the 'list' option when editing vimrc files.</source>
        <target state="translated">Para ver estos problemas de forma ms fcil, puede activar la opcin 'list' al editar archivos vimrc.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1532</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="345" approved="yes">
        <source>For Unix there is one special way to comment a line, that allows making a Vim
script executable: &gt;
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit
</source>
        <target state="translated">En Unix hay una forma especial de hacer un comentario, que permite hacer que
un script de Vim sea ejecutable: &gt;
	#!/usr/bin/env vim -S
	echo "este es un script de Vim"
	quit
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1538</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="346" approved="yes">
        <source>The "#" command by itself lists a line with the line number.  Adding an exclamation mark changes it into doing nothing, so that you can add the shell command to execute the rest of the file. |:#!| |-S|</source>
        <target state="translated">Por s misma, la orden # muestra una lnea junto con su nmero de lnea. Al aadirle un smbolo de exclamacin su comportamiento cambia y no tiene efecto, as que puede aadir la orden de intrprete de rdenes para ejecutar el resto del archivo. |:#!| |-S|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1542</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="347" approved="yes">
        <source>PITFALLS</source>
        <target state="translated">PROBLEMAS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1545</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="348" approved="yes">
        <source>Even bigger problem arises in the following example: &gt;</source>
        <target state="translated">En el siguiente ejemplo aparecen problemas an ms grandes: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1547</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="349" approved="yes">
        <source>	:map ,ab o#include
	:unmap ,ab 
</source>
        <target state="translated">	:map ,ab o#include
	:unmap ,ab 
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1550</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="350" approved="yes">
        <source>Here the unmap command will not work, because it tries to unmap ",ab ".  This does not exist as a mapped sequence.  An error will be issued, which is very hard to identify, because the ending whitespace character in ":unmap ,ab " is not visible.</source>
        <target state="translated">Aqu la orden unmap no funcionar, porque trata de eliminar la macro ,ab . sta no existe como secuencia de ninguna macro. Se mostrar un error, que es muy difcil de identificar, porque el carcter de espacio final en :unmap ,ab no es visible.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1555</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="351" approved="yes">
        <source>And this is the same as what happens when one uses a comment after an 'unmap' command: &gt;</source>
        <target state="translated">Lo mismo sucede cuando se pone un comentario a conti de una orden 'unmap': &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1558</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="352" approved="yes">
        <source>	:unmap ,ab     " comment
</source>
        <target state="translated">	:unmap ,ab     " comentario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1560</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="353" approved="yes">
        <source>Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: &gt;
</source>
        <target state="translated">La parte correspondiente al comentario ser ignorada. Sin embargo, Vim tratar
de eliminar la macro ',ab     ', que no existe. Debe reescribir la orden como:  &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1563</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="354" approved="yes">
        <source>	:unmap ,ab|    " comment
</source>
        <target state="translated">	:unmap ,ab|    " comentario
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1565</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="355" approved="yes">
        <source>RESTORING THE VIEW</source>
        <target state="translated">RESTAURAR LA VISTA</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1568</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="356" approved="yes">
        <source>Sometimes you want to make a change and go back to where cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: &gt;
</source>
        <target state="translated">En ocasiones es deseable hacer un cambio y volver al sitio en que el cursor se
encontraba inicialmente. Recuperar la posicin relativa tambin sera
agradable, de tal forma que la misma lnea inicial aparezca al inicio de la
ventana.
   Este ejemplo copia la lnea actual, la inserta antes de la primera lnea en
el archivo y despus restaura la vista original: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1574</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="357" approved="yes">
        <source>	map ,p ma"aYHmbgg"aP`bzt`a
</source>
        <target state="translated">	map ,p ma"aYHmbgg"aP`bzt`a
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1576</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="358" approved="yes">
        <source>What this does: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position
</source>
        <target state="translated">Esto es lo que hace: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			pone una marca en la posicin actual del
				cursor
	  "aY			copia la lnea actual al registro a
	     Hmb		va hasta la primera lnea que se ve en la
				ventana y pone la marca b all
		gg		va a la primera lnea del archivo
		  "aP		pega la lnea copiada por encima de la lnea
		     `b		vuelve a la lnea superior de la vista inicial
		       zt	ubica dicha lnea como la primera de la
				ventana
			 `a	vuelve a la posicin del cursor almacenada
				originalmente
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1587</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="359" approved="yes">
        <source>PACKAGING</source>
        <target state="translated">EMPAQUETAR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1590</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="360" approved="yes">
        <source>To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: &gt;
</source>
        <target state="translated">Para evitar que los nombres de funciones que defina interfieran con
otras funciones, use el siguiente esquema:
- Anteponga una cadena nica a cada nombre de funcin. A menudo uso una
  abreviatura. Por ejemplo, uso OV para las funciones relacionadas con
  opciones de ventana.
- Ponga todas las definiciones de sus funciones en un mismo archivo. Cree una
  variable global para indicar que las funciones ya fueron cargadas. Cuando
  cargue el archivo de nuevo, elimine antes las definiciones de las funciones.
Ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1599</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="361" approved="yes">
        <source>	" This is the XXX package
</source>
        <target state="translated">	" Este es el paquete XXX
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1601</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="362" approved="yes">
        <source>	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif
</source>
        <target state="translated">	if exists("XXX_cargado")
	  delfun XXX_uno
	  delfun XXX_dos
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1606</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="363" approved="yes">
        <source>	function XXX_one(a)
		... body of function ...
	endfun
</source>
        <target state="translated">	function XXX_uno(a)
		... cuerpo de la funcin ...
	endfun
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1610</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="364" approved="yes">
        <source>	function XXX_two(b)
		... body of function ...
	endfun
</source>
        <target state="translated">	function XXX_dos(b)
		... cuerpo de la funcin ...
	endfun
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1614</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="365" approved="yes">
        <source>	let XXX_loaded = 1
</source>
        <target state="translated">	let XXX_loaded = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1616</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="366" approved="yes">
        <source>*41.11*	Writing a plugin				*write-plugin*
</source>
        <target state="translated">*41.11*	Escribir extensiones				*write-plugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1619</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="367" approved="yes">
        <source>You can write a Vim script in such a way that many people can use it.  This is called a plugin.  Vim users can drop your script in their plugin directory and use its features right away |add-plugin|.</source>
        <target state="translated">Puede crear un script de Vim de tal forma que lo puedan usar varias personas. Esto se llama una extensin. Los usuarios de Vim pueden copiar el script en su directorio plugin/, y utilizarlo en el momento con |add-plugin|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1623</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="368" approved="yes">
        <source>There are actually two types of plugins:</source>
        <target state="translated">Existen dos tipos de extensiones:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1625</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="369" approved="yes">
        <source>  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.
</source>
        <target state="translated">          Extensiones globales: Empleadas con todos los tipos de archivo.
Extensiones de tipo de archivo: Empleadas con tipos de archivo especficos.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1628</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="370" approved="yes">
        <source>In this section the first type is explained.  Most items are also relevant for writing filetype plugins.  The specifics for filetype plugins are in the next section |write-filetype-plugin|.</source>
        <target state="translated">En esta seccin se describirn las extensiones globales (global plugins). La mayora de elementos tambin son necesarios para escribir extensiones de tipo de archivo (filetype plugins). La seccin a continuacin, |write-filetype-plugin|, detalla las extensiones de tipo de archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1632</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="371" approved="yes">
        <source>NAME</source>
        <target state="translated">NOMBRE</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1635</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="372" approved="yes">
        <source>First of all you must choose a name for your plugin.  The features provided by the plugin should be clear from its name.  And it should be unlikely that someone else writes a plugin with the same name but which does something different.  And please limit the name to 8 characters, to avoid problems on old Windows systems.</source>
        <target state="translated">Primero, debe elegir un nombre para su extensin. El nombre debera mostrar las funcionalidades ofrecidas por la extensin. As mismo, debera ser poco probable que alguien escriba una extensin con el mismo nombre pero otras funcionalidades. Por ltimo, limite el nombre a ocho caracteres para evitar problemas en antiguos sistemas de Windows.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1641</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="373" approved="yes">
        <source>A script that corrects typing mistakes could be called "typecorr.vim".  We will use it here as an example.</source>
        <target state="translated">Un script que corrige errores tipogrficos se podra llamar correccort.vim. Lo usaremos como ejemplo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1644</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="374" approved="yes">
        <source>For the plugin to work for everybody, it should follow a few guidelines.  This will be explained step-by-step.  The complete example plugin is at the end.</source>
        <target state="translated">Para que funcione en cualquier sistema, la extensin debera seguir algunas normas, las cuales se detallarn paso a paso. La extensin de ejemplo completa se encuentra al final de la seccin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1647</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="375" approved="yes">
        <source>BODY</source>
        <target state="translated">CUERPO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1650</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="376" approved="yes">
        <source>Let's start with the body of the plugin, the lines that do the actual work: &gt;</source>
        <target state="translated">Vamos a comenzar con el cuerpo de la extensin, las lneas que realmente hacen el trabajo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1652</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="377" approved="yes">
        <source> 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
</source>
        <target state="translated"> 14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronizacin
 19	let s:cuenta = 4
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1659</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="378" approved="yes">
        <source>The actual list should be much longer, of course.</source>
        <target state="translated">Por supuesto, la lista debera ser mucho ms larga.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1661</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="379" approved="yes">
        <source>The line numbers have only been added to explain a few things, don't put them in your plugin file!</source>
        <target state="translated">Los nmeros de lnea se han aadido en pro de la claridad. No los incluya en su archivo de extensin!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1664</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="380" approved="yes">
        <source>HEADER</source>
        <target state="translated">ENCABEZADO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1667</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="381" approved="yes">
        <source>You will probably add new corrections to the plugin and soon have several versions laying around.  And when distributing this file, people will want to know who wrote this wonderful plugin and where they can send remarks.  Therefore, put a header at the top of your plugin: &gt;</source>
        <target state="translated">Lo ms probable es que aada nuevas correcciones a la extensin, y tenga en poco tiempo varias versiones de sta. Cuando distribuya el archivo, la gente querr saber quin escribi esta maravillosa extensin, y dnde pueden enviar comentarios. Por ello, incluya un encabezado al principio de su extensin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1672</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="382" approved="yes">
        <source>  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
</source>
        <target state="translated">  1	" Extensin global de Vim para la correccin de errores
  2	" ltimo cambio:	15 de octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1676</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="383" approved="yes">
        <source>About copyright and licensing: Since plugins are very useful and it's hardly worth restricting their distribution, please consider making your plugin either public domain or use the Vim |license|.  A short note about this near the top of the plugin should be sufficient.  Example: &gt;</source>
        <target state="translated">Derechos de autor y licencias: Debido a que las extensiones son tiles, y que no merece la pena restringir su distribucin, considere que su extensin sea de dominio pblico, o use la licencia de Vim (|license|). Una breve nota cerca del inicio de la extensin debera servir. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1681</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="384" approved="yes">
        <source>  4	" License:	This file is placed in the public domain.
</source>
        <target state="translated">  4	" Licencia:	Este fichero pertenece al dominio pblico.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1683</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="385" approved="yes">
        <source>LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*
</source>
        <target state="translated">CONTINUACIN DE LNEA, EVITAR EFECTOS SECUNDARIOS	*use-cpo-save*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1686</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="386" approved="yes">
        <source>In line 18 above, the line-continuation mechanism is used |line-continuation|.  Users with 'compatible' set will run into trouble here, they will get an error message.  We can't just reset 'compatible', because that has a lot of side effects.  To avoid this, we will set the 'cpoptions' option to its Vim default value and restore it later.  That will allow the use of line-continuation and make the script work for most people.  It is done like this: &gt;</source>
        <target state="translated">En la lnea 18 del ejemplo anterior se usa el mecanismo |line-continuation|, continuacin de lnea. Los usuarios que definan 'compatible' pueden encontrar problemas con esto, y se les mostrara un mensaje de error. No podemos simplemente reiniciar 'compatible' porque tiene muchos efectos secundarios. Para evitarlo, definimos la opcin 'cpoptions' con el valor predeterminado de Vim para restaurarlo ms tarde. Esto permite el uso de line-continuation y que el script funcione en la mayora de sistemas. Se hace de la siguiente forma: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1693</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="387" approved="yes">
        <source> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</source>
        <target state="translated"> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1698</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="388" approved="yes">
        <source>We first store the old value of 'cpoptions' in the s:save_cpo variable.  At the end of the plugin this value is restored.</source>
        <target state="translated">Primero almacenamos el valor antiguo de 'cpoptions'  en la variable s:save_cpo. El valor se restaurar al final de la extensin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1701</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="389" approved="yes">
        <source>Notice that a script-local variable is used |s:var|.  A global variable could already be in use for something else.  Always use script-local variables for things that are only used in the script.</source>
        <target state="translated">Tenga en cuenta que se usa una variable local de script, |s:var|. Puede que se est utilizando una variable global para otra cosa. Use siempre variables locales en el script para aquello que se usa slo en el script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1705</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="390" approved="yes">
        <source>NOT LOADING</source>
        <target state="translated">EVITAR LA CARGA DE LA EXTENSIN</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1708</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="391" approved="yes">
        <source>It's possible that a user doesn't always want to load this plugin.  Or the system administrator has dropped it in the system-wide plugin directory, but a user has his own plugin he wants to use.  Then the user must have a chance to disable loading this specific plugin.  This will make it possible: &gt;</source>
        <target state="translated">Es posible que el usuario no desee cargar la extensin en cada momento. O que el administrador del sistema lo haya copiado al directorio de extensiones del sistema, pero el usuario quiere usar el suyo propio. En ese caso, el usuario debe tener la posibilidad de desactivar cargar esta extensin en particular. Lo siguiente lo hace posible: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1713</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="392" approved="yes">
        <source>  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
</source>
        <target state="translated">  6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1718</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="393" approved="yes">
        <source>This also avoids that when the script is loaded twice it would cause error messages for redefining functions and cause trouble for autocommands that are added twice.</source>
        <target state="translated">Tambin evita cargar el script dos veces, lo que provocara mensajes de error al redefinir las funciones, y provocar problemas con las rdenes automticas que se cargan por duplicado.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1722</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="394" approved="yes">
        <source>The name is recommended to start with "loaded_" and then the file name of the plugin, literally.  The "g:" is prepended just to avoid mistakes when using the variable in a function (without "g:" it would be a variable local to the function).</source>
        <target state="translated">Se recomienda que el nombre empiece con loaded_ y, a continuacin, el nombre literal de la extensin. La g: se aade para evitar errores al usar la variable en una funcin (sin la g:, sera una variable local a la funcin).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1727</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="395" approved="yes">
        <source>Using "finish" stops Vim from reading the rest of the file, it's much quicker than using if-endif around the whole file.</source>
        <target state="translated">Usar finish impide que Vim lea el resto del archivo, lo cual es mucho ms rpido que usar if-endif a lo largo del archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1730</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="396" approved="yes">
        <source>MAPPING</source>
        <target state="translated">MACROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1733</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="397" approved="yes">
        <source>Now let's make the plugin more interesting: We will add a mapping that adds a correction for the word under the cursor.  We could just pick a key sequence for this mapping, but the user might already use it for something else.  To allow the user to define which keys a mapping in a plugin uses, the &lt;Leader&gt; item can be used: &gt;</source>
        <target state="translated">Ahora, vamos a hacer que la extensin sea ms interesante: vamos a aadir una macro que aade una correccin para la palabra bajo el cursor. Podramos escoger una secuencia de teclas para esta macro, pero puede que el usuario la est usando para otra cosa. Puede usar el elemento &lt;Leader&gt; para permitir que el usuario pueda definir las teclas que utiliza la macro de una extensin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1739</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="398" approved="yes">
        <source> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
</source>
        <target state="translated"> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1741</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="399" approved="yes">
        <source>The "&lt;Plug&gt;TypecorrAdd" thing will do the work, more about that further on.</source>
        <target state="translated">El elemento &lt;Plug&gt;CorreccortAadir dara un buen resultado, a continuacin dispone de ms informacin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1743</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="400" approved="yes">
        <source>The user can set the "mapleader" variable to the key sequence that he wants this mapping to start with.  Thus if the user has done: &gt;</source>
        <target state="translated">El usuario puede definir la variable mapleader con la secuencia de teclas con la que desea iniciar esta macro. Por lo tanto, si el usuario define: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1746</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="401" approved="yes">
        <source>	let mapleader = "_"
</source>
        <target state="translated">	let mapleader = "_"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1748</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="402" approved="yes">
        <source>the mapping will define "_a".  If the user didn't do this, the default value will be used, which is a backslash.  Then a map for "\a" will be defined.</source>
        <target state="translated">la macro se definir como _a. En caso contrario se usar el valor predeterminado, que es una barra inversa. Por ello, se definira una macro como \a.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1751</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="403" approved="yes">
        <source>Note that &lt;unique&gt; is used, this will cause an error message if the mapping already happened to exist. |:map-&lt;unique&gt;|</source>
        <target state="translated">Tenga en cuenta se usa &lt;unique&gt;, lo que provocara un mensaje de error si la macro ya existe.  |:map-&lt;unique&gt;|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1754</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="404" approved="yes">
        <source>But what if the user wants to define his own key sequence? We can allow that with this mechanism: &gt;</source>
        <target state="translated">Puede usar el siguiente mecanismo para permitir que el usuario defina su propia secuencia de teclas si as lo desea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1757</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="405" approved="yes">
        <source> 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif
</source>
        <target state="translated"> 21	if !hasmapto('&lt;Plug&gt;CorreccortAadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAadir
 23	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1761</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="406" approved="yes">
        <source>This checks if a mapping to "&lt;Plug&gt;TypecorrAdd" already exists, and only defines the mapping from "&lt;Leader&gt;a" if it doesn't.  The user then has a chance of putting this in his vimrc file: &gt;</source>
        <target state="translated">Esto comprueba si ya existe una macro para &lt;Plug&gt;CorrecortAadir, y slo define la macro de &lt;Leader&gt;a si no existe. As, el usuario tiene la posibilidad de insertar esto en su archivo vimrc: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1765</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="407" approved="yes">
        <source>	map ,c  &lt;Plug&gt;TypecorrAdd
</source>
        <target state="translated">	map ,c  &lt;Plug&gt;CorreccortAadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1767</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="408" approved="yes">
        <source>Then the mapped key sequence will be ",c" instead of "_a" or "\a".</source>
        <target state="translated">As, la secuencia de teclas asignada sera ,c en lugar de _a o \a.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1769</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="409" approved="yes">
        <source>PIECES</source>
        <target state="translated">SEGMENTOS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1772</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="410" approved="yes">
        <source>If a script gets longer, you often want to break up the work in pieces.  You can use functions or mappings for this.  But you don't want these functions and mappings to interfere with the ones from other scripts.  For example, you could define a function Add(), but another script could try to define the same function.  To avoid this, we define the function local to the script by prepending it with "s:".</source>
        <target state="translated">Habitualmente querr dividir un script en segmentos cuando es demasiado largo. Para ello, puede usar funciones o macros, pero no desea que estas funciones y macros interfieran con los presentes en otros scripts. Por ejemplo, podra definir la funcin Anadir() pero otro script podra intentar definir la misma funcin. Para evitar esto, definimos la funcin como local al script anteponiendo a este s:.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1779</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="411" approved="yes">
        <source>We will define a function that adds a new typing correction: &gt;</source>
        <target state="translated">A continuacin definimos una funcin que aade una nueva correccin ortogrfica: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1781</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="412" approved="yes">
        <source> 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction
</source>
        <target state="translated"> 30	function s:Anadir(desde, correccion)
 31	  let a = input("Introduzca la correccin para " . a:desde . ": ")
 32	  exe ":iabbrev " . a:desde . " " . a
 ..
 36	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1787</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="413" approved="yes">
        <source>Now we can call the function s:Add() from within this script.  If another script also defines s:Add(), it will be local to that script and can only be called from the script it was defined in.  There can also be a global Add()  function (without the "s:"), which is again another function.</source>
        <target state="translated">Ahora invocamos la funcin s:Anadir() desde el mismo script. Si otro script tambin define s:Anadir(), ser local a ese script y solo se invocar desde el script en el que se define. Tambin puede existir una funcin global Anadir() (sin la s:), que es otra funcin distinta.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1792</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="414" approved="yes">
        <source>&lt;SID&gt; can be used with mappings.  It generates a script ID, which identifies the current script.  In our typing correction plugin we use it like this: &gt;</source>
        <target state="translated">Puede usar &lt;SID&gt; en una macro. Genera un identificador de script, que identifica al script actual. En nuestra extensin de correccin usaremos algo similar a esto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1795</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="415" approved="yes">
        <source> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 ..
 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</source>
        <target state="translated"> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAadir  &lt;SID&gt;Aadir
 ..
 28	noremap &lt;SID&gt;Aadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1799</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="416" approved="yes">
        <source>Thus when a user types "\a", this sequence is invoked: &gt;</source>
        <target state="translated">As, cuando el usuario teclea \a, se invoca esta secuencia: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1801</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="417" approved="yes">
        <source>	\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()
</source>
        <target state="translated">	\a -&gt; &lt;Plug&gt;CorreccortAadir -&gt; &lt;SID&gt;Aadir -&gt; :call &lt;SID&gt;Anadir()
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1803</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="418" approved="yes">
        <source>If another script would also map &lt;SID&gt;Add, it would get another script ID and thus define another mapping.</source>
        <target state="translated">Si otro script asigna &lt;SID&gt;Aadir a una macro, tendra otro identificador de script y por ello definira otra macro.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1806</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="419" approved="yes">
        <source>Note that instead of s:Add() we use &lt;SID&gt;Add() here.  That is because the mapping is typed by the user, thus outside of the script.  The &lt;SID&gt; is translated to the script ID, so that Vim knows in which script to look for the Add() function.</source>
        <target state="translated">Tenga en cuenta que se us &lt;SID&gt;Anadir() en lugar de s:Anadir() aqu. Eso es porque la macro es tecleada por el usuario, y por ello, se hace desde fuera del script. &lt;SID&gt; se expande al identificador del script, de forma que Vim sabe en qu script buscar la funcin Anadir().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1811</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="420" approved="yes">
        <source>This is a bit complicated, but it's required for the plugin to work together with other plugins.  The basic rule is that you use &lt;SID&gt;Add() in mappings and s:Add() in other places (the script itself, autocommands, user commands).</source>
        <target state="translated">Es un poco complicado, pero es necesario para que la extensin funcione adecuadamente con otras. La norma bsica es que debe usar &lt;SID&gt;Anadir() en las macros y s:Anadir() en otros sitios (el mismo script, rdenes automticas, rdenes de usuario).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1815</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="421" approved="yes">
        <source>We can also add a menu entry to do the same as the mapping: &gt;</source>
        <target state="translated">Tambin podemos aadir una entrada de men para que haga lo mismo que la macro: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1817</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="422" approved="yes">
        <source> 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
</source>
        <target state="translated"> 26	noremenu &lt;script&gt; Plugin.Aadir\ Correccin      &lt;SID&gt;Aadir
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1819</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="423" approved="yes">
        <source>The "Plugin" menu is recommended for adding menu items for plugins.  In this case only one item is used.  When adding more items, creating a submenu is recommended.  For example, "Plugin.CVS" could be used for a plugin that offers CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.</source>
        <target state="translated">Se recomienda el men Plugin para aadir elementos de men de extensiones. En este caso, slo se usa un elemento. Recomendamos crear un men secundario si aade ms elementos. Por ejemplo, podra usar Plugin.CVS para una extensin que ofrezca operaciones CVS como Plugin.CVS.checkin, Plugin.CVS.checkout, etc.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1824</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="424" approved="yes">
        <source>Note that in line 28 ":noremap" is used to avoid that any other mappings cause trouble.  Someone may have remapped ":call", for example.  In line 24 we also use ":noremap", but we do want "&lt;SID&gt;Add" to be remapped.  This is why "&lt;script&gt;" is used here.  This only allows mappings which are local to the script. |:map-&lt;script&gt;| The same is done in line 26 for ":noremenu".  |:menu-&lt;script&gt;|</source>
        <target state="translated">Tenga en cuenta que :noremap se usa en la lnea 28 para evitar problemas con otras macros. Puede que alguien haya asignado otra macro a :call, por ejemplo. En la lnea 24 tambin usamos :noremap, pero queremos reasignar &lt;SID&gt;Aadir. Por ello usamos aqu &lt;script&gt;. Esto solo permite el uso de macros locales al script; para ms informacin consulte |:map-&lt;script&gt;|. Se realiza la misma accin en la lnea 26 con :noremenu; para ms informacin consulte  |:menu-&lt;script&gt;|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1831</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="425" approved="yes">
        <source>&lt;SID&gt; AND &lt;Plug&gt;					*using-&lt;Plug&gt;*
</source>
        <target state="translated">&lt;SID&gt; Y &lt;Plug&gt;						*using-&lt;Plug&gt;*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1834</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="426" approved="yes">
        <source>Both &lt;SID&gt; and &lt;Plug&gt; are used to avoid that mappings of typed keys interfere with mappings that are only to be used from other mappings.  Note the difference between using &lt;SID&gt; and &lt;Plug&gt;:</source>
        <target state="translated">&lt;SID&gt; y &lt;Plug&gt; se usan para evitar que las macros de las teclas pulsadas interfieran con macros slo usadas desde otras macros. Note la diferencia entre &lt;SID&gt; y &lt;Plug&gt;:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1838</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="427" approved="yes">
        <source>&lt;Plug&gt;	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  &lt;Plug&gt; is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: &lt;Plug&gt; scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	This results in "&lt;Plug&gt;TypecorrAdd".  Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.
</source>
        <target state="translated">&lt;Plug&gt;	es visible fuera del script. Se usa para macros que el usuario
	pueda querer ligar a un secuencia de teclas. &lt;Plug&gt; es un cdigo
	especial que una tecla nunca podr producir.
	Para evitar que otras extensiones usen la misma secuencia de
	caracteres, use la estructura: &lt;Plug&gt; nombre-script nombre-macro
	En nuestro ejemplo, el nombre del script es Correccort, y el nombre
	de la macro es Aadir.
	El resultado es &lt;Plug&gt;CorreccortAadir. Solo el primer carcter de los
	nombres es mayscula, facilitando ver el principio del nombre de la
	macro.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1848</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="428" approved="yes">
        <source>&lt;SID&gt;	is the script ID, a unique identifier for a script.
	Internally Vim translates &lt;SID&gt; to "&lt;SNR&gt;123_", where "123" can be any
	number.  Thus a function "&lt;SID&gt;Add()" will have a name "&lt;SNR&gt;11_Add()"
	in one script, and "&lt;SNR&gt;22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of &lt;SID&gt; in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.
</source>
        <target state="translated">&lt;SID&gt; es el identificador (ID) del script, un nmero nico.
	Internamente, Vim traduce &lt;SID&gt; como &lt;SNR&gt;123_, donde 123
	puede ser cualquier nmero. Por ello, la funcin &lt;SID&gt;Anadir()
	tendra el nombre &lt;SNR&gt;11_Anadir() en un script, y &lt;SNR&gt;22_Anadir()
	en otro. Puede verlo si usa la orden :function para obtener la lista de
	funciones.
	La traduccin de &lt;SID&gt; en las macros es idntica, y as puede invocar
	una funcin local de un script mediante una macro.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1856</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="429" approved="yes">
        <source>USER COMMAND</source>
        <target state="translated">ORDEN DE USUARIO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1859</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="430" approved="yes">
        <source>Now let's add a user command to add a correction: &gt;</source>
        <target state="translated">Vamos a aadir una orden de usuario para aadir una correccin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1861</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="431" approved="yes">
        <source> 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif
</source>
        <target state="translated"> 38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1865</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="432" approved="yes">
        <source>The user command is defined only if no command with the same name already exists.  Otherwise we would get an error here.  Overriding the existing user command with ":command!" is not a good idea, this would probably make the user wonder why the command he defined himself doesn't work.  |:command|</source>
        <target state="translated">La orden de usuario se define nicamente si no existe una orden con el mismo nombre. En caso contrario, provocara un error. Sobrescribir la orden de usuario existente con :command! no es una buena idea, ya que hara que el usuario se pregunte porqu no funciona la orden que ha definido. |:command|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1870</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="433" approved="yes">
        <source>SCRIPT VARIABLES</source>
        <target state="translated">VARIABLES DE SCRIPT</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1873</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="434" approved="yes">
        <source>When a variable starts with "s:" it is a script variable.  It can only be used inside a script.  Outside the script it's not visible.  This avoids trouble with using the same variable name in different scripts.  The variables will be kept as long as Vim is running.  And the same variables are used when sourcing the same script again. |s:var|</source>
        <target state="translated">Cuando una variable comienza con s:, es una variable de script. Slo se puede usar dentro de un script, y no es visible desde fuera. Esto evita problemas al usar el mismo nombre de variable en diferentes scripts. Las variables se preservarn durante la ejecucin de Vim, y se usan al cargar el mismo script otra vez. |s:var|</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1879</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="435" approved="yes">
        <source>The fun is that these variables can also be used in functions, autocommands and user commands that are defined in the script.  In our example we can add a few lines to count the number of corrections: &gt;</source>
        <target state="translated">Lo interesante es que estas variables se pueden usar en funciones, rdenes automticas y rdenes de usuario definidas en el script. En nuestro ejemplo, aadimos unas pocas lneas para contar el nmero de correcciones: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1883</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="436" approved="yes">
        <source> 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
</source>
        <target state="translated"> 19	let s:cuenta = 4
 ..
 30	function s:Anadir(desde, correccion)
 ..
 34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta . " correcciones en este punto"
 36	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1891</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="437" approved="yes">
        <source>First s:count is initialized to 4 in the script itself.  When later the s:Add() function is called, it increments s:count.  It doesn't matter from where the function was called, since it has been defined in the script, it will use the local variables from this script.</source>
        <target state="translated">Al principio, s:cuenta se inicializa en el mismo script con un valor de 4. Al invocar la funcin Anadir() posteriormente, incrementa la variable s:cuenta. No importa desde dnde se ha invocado la funcin, ya que est definida en el script, y usar las variables locales al script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1896</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="438" approved="yes">
        <source>THE RESULT</source>
        <target state="translated">EL RESULTADO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1899</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="439" approved="yes">
        <source>Here is the resulting complete example: &gt;</source>
        <target state="translated">Aqu tiene el ejemplo completo finalizado: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1901</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="440" approved="yes">
        <source>  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif
 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 25
 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
 27
 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif
 41
 42	let &amp;cpo = s:save_cpo
</source>
        <target state="translated">  1 " Extensin global de Vim para la correccin de errores
  2	" ltimo cambio:	15 de Octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
  5
  6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1
 10
 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 13
 14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronizacin
 19	let s:cuenta = 4
 20
 21	if !hasmapto('&lt;Plug&gt;CorreccortAadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAadir
 23	endif
 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAadir  &lt;SID&gt;Aadir
 25
 26	noremenu &lt;script&gt; Plugin.Aadir\ Correccin      &lt;SID&gt;Aadir
 27
 28	noremap &lt;SID&gt;Aadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
 29
 30	function s:Anadir(desde, correccion)
 31	  let a = input("introduce la correccin de " . a:desde . ": ")
 32	  exe ":iabbrev " . a:desde . " " . a
 33	  if a:correccion | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif
 34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta . " correcciones en este punto"
 36	endfunction
 37
 38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif
 41
 42	let &amp;cpo = s:save_cpo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1944</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO the script doesn't do what it says it does. Fails at replacement of
newly-added corrections</context>
        </context-group>
        <note from="po-translator">TODO the script doesn't do what it says it does. Fails at replacement of
newly-added corrections</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="441" approved="yes">
        <source>Line 33 wasn't explained yet.  It applies the new correction to the word under the cursor.  The |:normal| command is used to use the new abbreviation.  Note that mappings and abbreviations are expanded here, even though the function was called from a mapping defined with ":noremap".</source>
        <target state="translated">An no hemos explicado la lnea 33. Aplica la nueva correccin a la palabra bajo el cursor. La orden |:normal| se emplea para usar la nueva abreviatura. Tenga en cuenta que aqu se expanden las macros y abreviaturas, a pesar de que la funcin se ha invocado desde una macro definida con :noremap.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1949</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="442" approved="yes">
        <source>Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before writing the file: &gt;</source>
        <target state="translated">Se recomienda usar unix como valor para la opcin 'fileformat'. De esta forma, los scripts de Vim funcionarn en cualquier sistema. Los scripts con 'fileformat' definido como dos no funcionarn en Unix. Tambin puede consultar |:source_crnl|. Para asegurar que hace lo correcto, haga lo siguiente antes de escribir el archivo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1954</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="443" approved="yes">
        <source>	:set fileformat=unix
</source>
        <target state="translated">	:set fileformat=unix
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1956</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="444" approved="yes">
        <source>DOCUMENTATION						*write-local-help*
</source>
        <target state="translated">DOCUMENTACIN   					*write-local-help*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1959</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="445" approved="yes">
        <source>It's a good idea to also write some documentation for your plugin.  Especially when its behavior can be changed by the user.  See |add-local-help| for how they are installed.</source>
        <target state="translated">Es una buena idea crear algo de documentacin para su extensin, en particular si el usuario puede modificar su comportamiento. Para lo referente a la instalacin de documentacin, consulte |add-local-help|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1963</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="446" approved="yes">
        <source>Here is a simple example for a plugin help file, called "typecorr.txt": &gt;</source>
        <target state="translated">Aqu tiene un simple ejemplo para un archivo de ayuda de una extensin, llamado typecorr.txt: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1965</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="447" approved="yes">
        <source>  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	&lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.
</source>
        <target state="translated">  1	*correcort.txt*	Una extensin para corregir errores ortogrficos
  2
  3	Esta extensin corrige automticamente cualquier error ortogrfico
  4	que pueda escribir.
  5
  6	Solo hay unas pocas correcciones. Puede aadir las suyas.
  7
  8	Macros:
  9	&lt;Leader&gt;a   o   &lt;Plug&gt;CorreccortAadir
 10		Aade una correccin para la palabra bajo el cursor.
 11
 12	rdenes:
 13	:Corregir {palabra}
 14		Aade una correccin para {palabra}.
 15
 16							*correcort-opciones*
 17	Esta extensin no tiene opciones de configuracin.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1983</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="448" approved="yes">
        <source>The first line is actually the only one for which the format matters.  It will be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of help.txt |local-additions|.  The first "*" must be in the first column of the first line.  After adding your help file do ":help" and check that the entries line up nicely.</source>
        <target state="translated">En realidad, la primera lnea es la nica en la que el formato importa. Se extraer del archivo de ayuda para su ubicacin en la seccin LOCAL ADDITIONS: de help.txt |local-additions|. El primer asterisco debe estar en la primera columna de la primera lnea. Ejecute :help despus de aadir su archivo de ayuda y compruebe que las entradas estn alineadas adecuadamente.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1989</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="449" approved="yes">
        <source>You can add more tags inside ** in your help file.  But be careful not to use existing help tags.  You would probably use the name of your plugin in most of them, like "typecorr-settings" in the example.</source>
        <target state="translated">Puede aadir ms etiquetas entre asteriscos ** en su archivo de ayuda, pero tenga la precaucin de no usar etiquetas de ayuda existentes. Probablemente use el nombre de su extensin en la mayora de etiquetas, como correccort-opciones en el ejemplo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1993</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="450" approved="yes">
        <source>Using references to other parts of the help in || is recommended.  This makes it easy for the user to find associated help.</source>
        <target state="translated">Se recomienda utilizar referencias a otras partes de archivos de ayuda mediante barras, ||. Esto facilita que el usuario encuentre ayuda relacionada.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1996</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="451" approved="yes">
        <source>FILETYPE DETECTION					*plugin-filetype*
</source>
        <target state="translated">EXTENSIN DE TIPO DE ARCHIVO			*plugin-filetype*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">1999</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO bug en la sintaxis de vim/help ?</context>
        </context-group>
        <note from="po-translator">TODO bug en la sintaxis de vim/help ?</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="452" approved="yes">
        <source>If your filetype is not already detected by Vim, you should create a filetype detection snippet in a separate file.  It is usually in the form of an autocommand that sets the filetype when the file name matches a pattern.  Example: &gt;</source>
        <target state="translated">Si Vim no detecta su tipo de archivo, debera crear un fragmento de cdigo de deteccin de tipo de archivo en un archivo separado. Habitualmente, tiene la forma de una orden automtica que define el tipo de archivo cuando su nombre concuerda con un patrn. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2004</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="453" approved="yes">
        <source>	au BufNewFile,BufRead *.foo			set filetype=foofoo
</source>
        <target state="translated">	au BufNewFile,BufRead *.foo			set filetype=foofoo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2006</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="454" approved="yes">
        <source>Write this single-line file as "ftdetect/foofoo.vim" in the first directory that appears in 'runtimepath'.  For Unix that would be "~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the filetype for the script name.</source>
        <target state="translated">Escriba este archivo de una sola lnea como ftdetect/foofoo.vim en el primer directorio que aparece en su 'runtimepath'. En Unix, sera ~/.vim/ftdetect/foofoo.vim. La convencin es nombrar el script como el nombre del tipo de archivo.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2011</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="455" approved="yes">
        <source>You can make more complicated checks if you like, for example to inspect the contents of the file to recognize the language.  Also see |new-filetype|.</source>
        <target state="translated">Si lo desea, puede hacer comprobaciones ms complejas como inspeccionar los contenidos de un archivo para reconocer el tipo del mismo. Consulte tambin |new-filetype|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2014</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="456" approved="yes">
        <source>SUMMARY							*plugin-special*
</source>
        <target state="translated">RESUMEN							*plugin-special*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2017</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="457" approved="yes">
        <source>Summary of special things to use in a plugin:</source>
        <target state="translated">Resumen de los elementos especiales a utilizar en una extensin:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2019</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="458" approved="yes">
        <source>s:name			Variables local to the script.
</source>
        <target state="translated">s:nombre		Variables locales al script.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2021</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="459" approved="yes">
        <source>&lt;SID&gt;			Script-ID, used for mappings and functions local to
			the script.
</source>
        <target state="translated">&lt;SID&gt;			El identificador del script (Script-ID), utilizado en
			macros y funciones locales al script.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2024</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="460" approved="yes">
        <source>hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.
</source>
        <target state="translated">hasmapto()		Una funcin que comprueba si el usuario ya ha definido
			una macro para la funcionalidad que el script ofrece.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2027</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="461" approved="yes">
        <source>&lt;Leader&gt;		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.
</source>
        <target state="translated">&lt;Leader&gt;		El valor de mapleader, que el usuario define como
			las teclas con las que iniciar las macros de extensiones.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2030</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="462" approved="yes">
        <source>:map &lt;unique&gt;		Give a warning if a mapping already exists.
</source>
        <target state="translated">::map &lt;unique&gt;		Emite un aviso si la macro ya existe.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2032</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="463" approved="yes">
        <source>:noremap &lt;script&gt;	Use only mappings local to the script, not global
			mappings.
</source>
        <target state="translated">:noremap &lt;script&gt;	Slo usa macros locales al script, no macros globales.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2035</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="464" approved="yes">
        <source>exists(":Cmd")		Check if a user command already exists.
</source>
        <target state="translated">exists(":Orden")	Comprueba la existencia de una orden de usuario.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2037</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="465" approved="yes">
        <source>*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*
</source>
        <target state="translated">					*write-filetype-plugin* *ftplugin*
*41.12*	Escribir extensiones de tipo de archivo
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2040</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="466" approved="yes">
        <source>A filetype plugin is like a global plugin, except that it sets options and defines mappings for the current buffer only.  See |add-filetype-plugin| for how this type of plugin is used.</source>
        <target state="translated">Una extensin de tipo de archivo (filetype plugin) es como una extensin global, a diferencia de que define opciones y macros que solo afectan al bfer local. Para saber ms acerca del uso de este tipo de extensin, consulte  |add-filetype-plugin|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2044</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="467" approved="yes">
        <source>First read the section on global plugins above |41.11|.  All that is said there also applies to filetype plugins.  There are a few extras, which are explained here.  The essential thing is that a filetype plugin should only have an effect on the current buffer.</source>
        <target state="translated">En primer lugar, consulte la seccin anterior sobre extensiones globales, |41.11|. Todo lo detallado ah tambin afecta a las extensiones de tipo de archivo. Hay algunos elementos adicionales, que se explican aqu. Lo esencial es que una extensin de tipo de archivo slo debe tener efecto en el bfer actual.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2049</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="468" approved="yes">
        <source>DISABLING</source>
        <target state="translated">DESACTIVAR</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2052</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="469" approved="yes">
        <source>If you are writing a filetype plugin to be used by many people, they need a chance to disable loading it.  Put this at the top of the plugin: &gt;</source>
        <target state="translated">Si esta escribiendo una extensin de tipo de archivo que mucha gente usar, necesitarn la capacidad de desactivar su carga. Inserte lo siguiente al principio de la extensin: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2055</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="470" approved="yes">
        <source>	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</source>
        <target state="translated">	" Solo hace esto cuando an no ha finalizado con este bfer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2061</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="471" approved="yes">
        <source>This also needs to be used to avoid that the same plugin is executed twice for the same buffer (happens when using an ":edit" command without arguments).</source>
        <target state="translated">Esto tambin sirve para evitar la ejecucin de la misma extensin por duplicado en el mismo bfer (ocurre al usar la orden :edit sin argumentos).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2064</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="472" approved="yes">
        <source>Now users can disable loading the default plugin completely by making a filetype plugin with only this line: &gt;</source>
        <target state="translated">Usando este mecanismo, los usuarios pueden evitar cargar la extensin predeterminada si as lo desean, creando una extensin de tipo de archivo con slo esta lnea: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2067</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="473" approved="yes">
        <source>	let b:did_ftplugin = 1
</source>
        <target state="translated">	let b:did_ftplugin = 1
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2069</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="474" approved="yes">
        <source>This does require that the filetype plugin directory comes before $VIMRUNTIME in 'runtimepath'!</source>
        <target state="translated">Esto requiere que el directorio de extensiones de tipo de archivo aparezca antes de $VIMRUNTIME en 'runtimepath'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2072</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="475" approved="yes">
        <source>If you do want to use the default plugin, but overrule one of the settings, you can write the different setting in a script: &gt;</source>
        <target state="translated">Si desea usar la extensin predeterminada, pero cambiar la configuracin de alguna de sus opciones, puede escribir un valor diferente para ellas en un script: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2075</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="476" approved="yes">
        <source>	setlocal textwidth=70
</source>
        <target state="translated">	setlocal textwidth=70
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2077</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="477" approved="yes">
        <source>Now write this in the "after" directory, so that it gets sourced after the distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be "~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set "b:did_ftplugin", but it is ignored here.</source>
        <target state="translated">Escriba esto en el directorio after, para que se lea despus de la extensin de tipo de archivo predeterminado distribuido, vim.vim |after-directory|.  En sistemas Unix, sera ~/.vim/after/ftplugin/vim.vim. Tenga en cuenta que la extensin predeterminada habr definido b:did_ftplugin, pero aqu se ignora.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2082</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="478" approved="yes">
        <source>To make sure the filetype plugin only affects the current buffer use the &gt;</source>
        <target state="translated">Para asegurar que la extensin de tipo de archivo solo afecta al bfer actual, use la orden &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2087</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="479" approved="yes">
        <source>	:setlocal
</source>
        <target state="translated">	:setlocal
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2089</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="480" approved="yes">
        <source>command to set options.  And only set options which are local to a buffer (see the help for the option to check that).  When using |:setlocal| for global options or options local to a window, the value will change for many buffers, and that is not what a filetype plugin should do.</source>
        <target state="translated">para definir opciones, y slo defina opciones locales al bfer (consulte la ayuda para la opcin que comprueba esto). Al usar |:setlocal| con opciones globales u opciones locales para una ventana, el valor cambiar para muchos bfers, y una extensin de tipo de archivo no debera hacer esto.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2094</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="481" approved="yes">
        <source>When an option has a value that is a list of flags or items, consider using "+=" and "-=" to keep the existing value.  Be aware that the user may have changed an option value already.  First resetting to the default value and then changing it often a good idea.  Example: &gt;</source>
        <target state="translated">Cuando una opcin tiene un valor que es una lista de opciones o elementos, considere usar += y -= para conservar el valor existente. Sea consciente de que puede que el usuario ya haya cambiado el valor de una opcin. Es una buena idea restablecer el valor original y despus cambiarlo. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2099</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="482" approved="yes">
        <source>	:setlocal formatoptions&amp; formatoptions+=ro
</source>
        <target state="translated">	:setlocal formatoptions&amp; formatoptions+=ro
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2101</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="483" approved="yes">
        <source>MAPPINGS</source>
        <target state="translated">MACROS</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2104</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="484" approved="yes">
        <source>To make sure mappings will only work in the current buffer use the &gt;</source>
        <target state="translated">Para asegurar que las macros slo funcionen en el bfer local use la orden &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2106</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="485" approved="yes">
        <source>	:map &lt;buffer&gt;
</source>
        <target state="translated">	:map &lt;buffer&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2108</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="486" approved="yes">
        <source>command.  This needs to be combined with the two-step mapping explained above.  An example of how to define functionality in a filetype plugin: &gt;</source>
        <target state="translated">Se debe usar en combinacin con la macro compuesta de dos pasos explicada anteriormente. A continuacin una definicin de ejemplo para una funcionalidad en una extensin de tipo de archivo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2111</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="487" approved="yes">
        <source>	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</source>
        <target state="translated">	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2116</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="488" approved="yes">
        <source>|hasmapto()| is used to check if the user has already defined a map to &lt;Plug&gt;JavaImport.  If not, then the filetype plugin defines the default mapping.  This starts with |&lt;LocalLeader&gt;|, which allows the user to select the key(s) he wants filetype plugin mappings to start with.  The default is a backslash.  "&lt;unique&gt;" is used to give an error message if the mapping already exists or overlaps with an existing mapping.  |:noremap| is used to avoid that any other mappings that the user has defined interferes.  You might want to use ":noremap &lt;script&gt;" to allow remapping mappings defined in this script that start with &lt;SID&gt;.</source>
        <target state="translated">|hasmapto()| sirve para comprobar si el usuario ya ha definido una macro para &lt;Plug&gt;JavaImport. Si no ha sido definida, la extensin de tipo de archivo define la macro actual. Esta empieza con |&lt;LocalLeader&gt;|, que permite al usuario seleccionar una o mas teclas con las que iniciar las macros de la extensin de tipo de archivo. El valor predeterminado es una barra inversa, \. &lt;unique&gt; sirve para emitir un mensaje de error si la macro ya existe o entra en conflicto con otra. |:noremap| sirve para evitar que las macros definidas por el usuario interfieran. Puede que desee usar :noremap &lt;script&gt; para permitir redefinir macros en el script que comienza con &lt;SID&gt;.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2127</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">TODO mal ubicados los cambios de lnea</context>
        </context-group>
        <note from="po-translator">TODO mal ubicados los cambios de lnea</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="489" approved="yes">
        <source>The user must have a chance to disable the mappings in a filetype plugin, without disabling everything.  Here is an example of how this is done for a plugin for the mail filetype: &gt;</source>
        <target state="translated">Tiene que ofrecer al usuario la opcin de desactivar macros en una extensin de tipo de archivo, sin desactivar el resto. Aqu tiene un ejemplo de como hacerlo con una extensin para el tipo de archivo mail: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2131</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="490" approved="yes">
        <source>	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Quote text by inserting "&gt; "
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</source>
        <target state="translated">	" Aade macros, a menos que el usuario defina lo contrario.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Cita el texto insertando &gt; 
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2142</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="491" approved="yes">
        <source>Two global variables are used:
no_plugin_maps		disables mappings for all filetype plugins
no_mail_maps		disables mappings for a specific filetype
</source>
        <target state="translated">Se utilizan dos variables globales:
no_plugin_maps		desactiva las macros de todas las extensiones de tipo
			de archivo
no_mail_maps		desactiva las macros para un tipo de archivo
			particular
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2146</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="492" approved="yes">
        <source>USER COMMANDS</source>
        <target state="translated">RDENES DE USUARIO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2149</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="493" approved="yes">
        <source>To add a user command for a specific file type, so that it can only be used in one buffer, use the "-buffer" argument to |:command|.  Example: &gt;</source>
        <target state="translated">El argumento -buffer de |:command| permite aadir una orden de usuario para un tipo de archivo especfico y que solo afecta al bfer local. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2152</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="494" approved="yes">
        <source>	:command -buffer  Make  make %:r.s
</source>
        <target state="translated">	:command -buffer  Make  make %:r.s
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2154</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="495" approved="yes">
        <source>VARIABLES</source>
        <target state="translated">VARIABLES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2157</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="496" approved="yes">
        <source>A filetype plugin will be sourced for each buffer of the type it's for.  Local script variables |s:var| will be shared between all invocations.  Use local buffer variables |b:var| if you want a variable specifically for one buffer.</source>
        <target state="translated">Las extensiones de tipo de archivo sern cargadas en cada bfer del tipo correspondiente. Las variables de script locales |s:var| se compartirn entre las diferentes llamadas a una misma extensin (o script en general.) Use las variables locales al bfer |b:var| si desea usar una variable local a un bfer.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2161</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="497" approved="yes">
        <source>FUNCTIONS</source>
        <target state="translated">FUNCIONES</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2164</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="498" approved="yes">
        <source>When defining a function, this only needs to be done once.  But the filetype plugin will be sourced every time a file with this filetype will be opened.  This construct makes sure the function is only defined once: &gt;</source>
        <target state="translated">Cada funcin necesita ser definida una sola vez. Pero la extensin de tipo de archivo se cargar cada vez que se abra un archivo del tipo correspondiente. Esta estructura asegura que la funcin se defina una sola vez: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2168</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="499" approved="yes">
        <source>	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</source>
        <target state="translated">	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2175</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="500" approved="yes">
        <source>UNDO							*undo_ftplugin*
</source>
        <target state="translated">DESHACER 					*undo_ftplugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2177</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="501" approved="yes">
        <source>When the user does ":setfiletype xyz" the effect of the previous filetype should be undone.  Set the b:undo_ftplugin variable to the commands that will undo the settings in your filetype plugin.  Example: &gt;</source>
        <target state="translated">Cuando el usuario hace :setfiletype xyz, el efecto del tipo de archivo anterior debera desaparecer. Defina la variable b:undo_ftplugin con las rdenes que deshacen los cambios de configuracin de su extensin de tipo de archivo.  Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2181</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="502" approved="yes">
        <source>	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</source>
        <target state="translated">	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2184</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="503" approved="yes">
        <source>Using ":setlocal" with "&lt;" after the option name resets the option to its global value.  That is mostly the best way to reset the option value.</source>
        <target state="translated">Usar :setlocal con &lt; despus del nombre de la opcin restablece la opcin a su valor global. Habitualmente, es la mejor forma de restablecer el valor de una opcin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2187</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="504" approved="yes">
        <source>This does require removing the "C" flag from 'cpoptions' to allow line continuation, as mentioned above |use-cpo-save|.</source>
        <target state="translated">Esto requiere eliminar la opcin C de 'cpoptions' para permitir la continuacin de la lnea, como se mencion anteriormente |use-cpo-save|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2190</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="505" approved="yes">
        <source>FILE NAME</source>
        <target state="translated">NOMBRE DE ARCHIVO</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2193</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="506" approved="yes">
        <source>The filetype must be included in the file name |ftplugin-name|.  Use one of these three forms:</source>
        <target state="translated">El nombre del archivo debe incluir el tipo de archivo |ftplugin-name|. Puede usar una de las tres formas a continuacin:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2196</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="507" approved="yes">
        <source>	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim
</source>
        <target state="translated">	.../ftplugin/algo.vim
	.../ftplugin/algo_foo.vim
	.../ftplugin/algo/bar.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2200</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="508" approved="yes">
        <source>"stuff" is the filetype, "foo" and "bar" are arbitrary names.</source>
        <target state="translated">algo es el tipo de archivo, foo y bar son nombres aleatorios.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2202</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="509" approved="yes">
        <source>SUMMARY							*ftplugin-special*
</source>
        <target state="translated">RESUMEN							*ftplugin-special*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2205</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="510" approved="yes">
        <source>Summary of special things to use in a filetype plugin:</source>
        <target state="translated">Un resumen de los aspectos a considerar cuando escriba una extensin de tipo de archivo:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2207</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="511" approved="yes">
        <source>&lt;LocalLeader&gt;		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.
</source>
        <target state="translated">&lt;LocalLeader&gt;		El valor de maplocalleader, que el usuario define
			como la tecla que inicia las macros de extensin de
			tipo de archivo.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2210</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="512" approved="yes">
        <source>:map &lt;buffer&gt;		Define a mapping local to the buffer.
</source>
        <target state="translated">:map &lt;buffer&gt;		Define una macro local al bfer.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2212</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="513" approved="yes">
        <source>:noremap &lt;script&gt;	Only remap mappings defined in this script that start
			with &lt;SID&gt;.
</source>
        <target state="translated">:noremap &lt;script&gt;	Slo modifica macros definidas en el script que
			comienzan con &lt;SID&gt;.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2215</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="514" approved="yes">
        <source>:setlocal		Set an option for the current buffer only.
</source>
        <target state="translated">:setlocal		Define una opcin para el bfer actual.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2217</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="515" approved="yes">
        <source>:command -buffer	Define a user command local to the buffer.
</source>
        <target state="translated">:command -buffer	Define una orden de usuario local al bfer.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2219</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="516" approved="yes">
        <source>exists("*s:Func")	Check if a function was already defined.
</source>
        <target state="translated">exists("*s:Funcion")	Comprueba si una funcin ya se ha definido
			anteriormente.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2221</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="517" approved="yes">
        <source>Also see |plugin-special|, the special things used for all plugins.</source>
        <target state="translated">Consulte tambin |plugin-special|, las cosas especiales utilizadas por todas las extensiones.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2223</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="518" approved="yes">
        <source>*41.13*	Writing a compiler plugin		*write-compiler-plugin*
</source>
        <target state="translated">*41.13*	Escribir extensiones para compiladores	*write-compiler-plugin*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2226</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="519" approved="yes">
        <source>A compiler plugin sets options for use with a specific compiler.  The user can load it with the |:compiler| command.  The main use is to set the 'errorformat' and 'makeprg' options.</source>
        <target state="translated">Una extensin de compilador define opciones a usar con un compilador especfico. El usuario puede cargarlo con la orden |:compiler|. El uso principal es definir las opciones 'errorformat' y 'makeprg'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2230</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="520" approved="yes">
        <source>Easiest is to have a look at examples.  This command will edit all the default compiler plugins: &gt;</source>
        <target state="translated">Lo ms sencillo es ver unos ejemplos. Esta orden editar todas las extensiones de compilador predeterminadas: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2233</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="521" approved="yes">
        <source>	:next $VIMRUNTIME/compiler/*.vim
</source>
        <target state="translated">	:next $VIMRUNTIME/compiler/*.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2235</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="522" approved="yes">
        <source>Use |:next| to go to the next plugin file.</source>
        <target state="translated">Use |:next| para ir al siguiente archivo de extensin.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2237</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="523" approved="yes">
        <source>There are two special items about these files.  First is a mechanism to allow a user to overrule or add to the default file.  The default files start with: &gt;</source>
        <target state="translated">Hay dos aspectos a tener en cuenta con estas extensiones. En primer lugar, deben contar con un mecanismo que permita al usuario anular o aadir cambios a la extensin. Las extensiones predeterminadas comienzan con: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2240</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="524" approved="yes">
        <source>	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</source>
        <target state="translated">	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2245</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="525" approved="yes">
        <source>When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
							*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: &gt;
</source>
        <target state="translated">Cuando escribe un archivo de compilador, y lo ubica en su directorio de
ejecucin personal (esto es, ~/.vim/compiler en sistemas Unix), debe definir
la variable current_compiler para que la extensin de compilador
predeterminada evite hacer cambios en la configuracin.
							*:CompilerSet*
El segundo mecanismo es usar :set con :compiler!, y :setlocal con
:compiler. Para ello, Vim define la orden de usuario :CompilerSet. Por
otra parte, las versiones anteriores de Vim no cuentan de ella, y por ello su
extensin debe definirlo. Aqu tiene un ejemplo: &gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2254</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="526" approved="yes">
        <source>  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" use the default 'errorformat'
  CompilerSet makeprg=nmake
</source>
        <target state="translated">  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" usa 'errorformat' predeterminado
  CompilerSet makeprg=nmake
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2260</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="527" approved="yes">
        <source>When you write a compiler plugin for the Vim distribution or for a system-wide runtime directory, use the mechanism mentioned above.  When "current_compiler" was already set by a user plugin nothing will be done.</source>
        <target state="translated">Use el mecanismo mostrado aqu cuando escriba una extensin de compilador para la distribucin Vim o para un directorio de tiempo de ejecucin del sistema. No se har nada si current_compiler ya est definido por una extensin de usuario.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2264</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="528" approved="yes">
        <source>When you write a compiler plugin to overrule settings from a default plugin, don't check "current_compiler".  This plugin is supposed to be loaded last, thus it should be in a directory at the end of 'runtimepath'.  For Unix that could be ~/.vim/after/compiler.</source>
        <target state="translated">Cuando escribe una extensin de compilador para cambiar las opciones definidas por una extensin predeterminada, evite comprobar current_compiler. Esta extensin se debera cargar al final, y por ello debera estar en un directorio al final de 'runtimepath'. En sistemas Unix, podra ser ~/.vim/after/compiler.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2269</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="529" approved="yes">
        <source>*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*
</source>
        <target state="translated">*41.14*	Escribir extensiones que carguen rpidamente  *write-plugin-quickload*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2272</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="530" approved="yes">
        <source>A plugin may grow and become quite long.  The startup delay may become noticeable, while you hardly ever use the plugin.  Then it's time for a quickload plugin.</source>
        <target state="translated">Puede que una extensin crezca, y que sea demasiado larga. Puede que el tiempo de carga empiece a hacerse notorio, y adems, que usted apenas use la extensin. En este caso, hay que usar una extensin de carga rpida (quickload).</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2276</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="531" approved="yes">
        <source>The basic idea is that the plugin is loaded twice.  The first time user commands and mappings are defined that offer the functionality.  The second time the functions that implement the functionality are defined.</source>
        <target state="translated">La idea principal es que la extensin se carga dos veces. La primera vez, se definen las rdenes de usuario y macros que ofrecen la funcionalidad de la extensin. La segunda vez, se definen las funciones que implementan tales funcionalidades.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2280</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="532" approved="yes">
        <source>It may sound surprising that quickload means loading a script twice.  What we mean is that it loads quickly the first time, postponing the bulk of the script to the second time, which only happens when you actually use it.  When you always use the functionality it actually gets slower!</source>
        <target state="translated">Puede que sorprenda que carga rpida signifique cargar una extensin dos veces.  Lo que queremos decir es que se carga rpidamente la primera, demorando la carga de la mayora de la extensin a la segunda vez, lo que slo ocurre cuando realmente la usa. Si usa siempre la funcionalidad que provee la extensin, no obtendr ninguna ventaja!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2285</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="533" approved="yes">
        <source>Note that since Vim 7 there is an alternative: use the |autoload| functionality |41.15|.</source>
        <target state="translated">Tenga en cuenta que hay una alternativa a partir de la versin 7 de Vim: use la funcionalidad |autoload|, |41.15|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2288</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="534" approved="yes">
        <source>The following example shows how it's done: &gt;</source>
        <target state="translated">Los siguientes ejemplos muestran como se hace: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2290</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="535" approved="yes">
        <source>	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" License:	This file is placed in the public domain.
</source>
        <target state="translated">	" Extensin global de Vim para mostrar la carga rpida
	" ltimo cambio:	2005 Feb 25
	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" Licencia:	Este archivo se encuentra en el dominio pblico
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2295</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="536" approved="yes">
        <source>	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;
</source>
        <target state="translated">	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('algo')&lt;CR&gt;
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2299</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="537" approved="yes">
        <source>		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</source>
        <target state="translated">		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2304</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="538" approved="yes">
        <source>	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read functionality here
	endfunction
</source>
        <target state="translated">	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" Funcionalidad de lectura aqu
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2309</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="539" approved="yes">
        <source>	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write functionality here
	endfunction
</source>
        <target state="translated">	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" Funcionalidad de escritura aqu
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2314</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="540" approved="yes">
        <source>When the script is first loaded "s:did_load" is not set.  The commands between the "if" and "endif" will be executed.  This ends in a |:finish| command, thus the rest of the script is not executed.</source>
        <target state="translated">Cuando el script se carga por primera vez, s:did_load no est definida, y se ejecutan las rdenes entre if y endif. Se termina con una orden |:finish|, impidiendo ejecutar el resto del script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2318</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="541" approved="yes">
        <source>The second time the script is loaded "s:did_load" exists and the commands after the "endif" are executed.  This defines the (possible long)  BufNetRead() and BufNetWrite() functions.</source>
        <target state="translated">La segunda vez que se carga, s:did_load existe y se ejecutan las rdenes despus de endif. Esto define las (posiblemente largas) funciones BufNetRead() y BufNetWrite().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2322</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="542" approved="yes">
        <source>If you drop this script in your plugin directory Vim will execute it on startup.  This is the sequence of events that happens:</source>
        <target state="translated">Si ubica este script en su directorio plugin, Vim lo ejecutar al inicio. A continuacin la secuencia de los eventos:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2325</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="543" approved="yes">
        <source>1. The "BNRead" command is defined and the &lt;F19&gt; key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.
</source>
        <target state="translated">1. Se define la orden BNRead y la tecla &lt;F19&gt; se asigna a una macro al cargar
el script al inicio. Se define una orden automtica |FuncUndefined|. La orden
  :finish hace que el script finalice antes.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2329</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="544" approved="yes">
        <source>2. The user types the BNRead command or presses the &lt;F19&gt; key.  The
   BufNetRead() or BufNetWrite() function will be called.
</source>
        <target state="translated">2. El usuario introduce la orden BNRead o pulsa la tecla &lt;F19&gt;. Se
  invoca la funcin BufNetRead() o BufNetWrite().
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2332</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="545" approved="yes">
        <source>3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "&lt;sfile&gt;" (see |expand()|).
</source>
        <target state="translated">3. Vim no puede encontrar la funcin y ejecuta la orden automtica
  |FuncUndefined|. Ya que el patrn BufNet* coincide con la funcin invocada,
  se ejecutar la orden source nombre-archivo. nombre-archivo debe ser
  igual al nombre del script, sin importar su ubicacin, ya que procede de
  expandir &lt;sfile&gt; (consulte |expand()|).
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2338</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="546" approved="yes">
        <source>4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.
</source>
        <target state="translated">4. El script se carga otra vez, la variable s:did_load existe, y se
   definen las funciones.
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2341</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="547" approved="yes">
        <source>Notice that the functions that are loaded afterwards match the pattern in the |FuncUndefined| autocommand.  You must make sure that no other plugin defines functions that match this pattern.</source>
        <target state="translated">Tenga en cuenta que las funciones se cargan despus de comparar el patrn en la orden automtica |FuncUndefined|. Debe comprobar que ninguna otra extensin define funciones que coincidan con este patrn.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2345</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="548" approved="yes">
        <source>*41.15*	Writing library scripts			*write-library-script*
</source>
        <target state="translated">*41.15*	Crear bibliotecas				*write-library-script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2348</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="549" approved="yes">
        <source>Some functionality will be required in several places.  When this becomes more than a few lines you will want to put it in one script and use it from many scripts.  We will call that one script a library script.</source>
        <target state="translated">Algunas funcionalidades son necesarias en varios lugares. Cuando se trata de algo ms que unos pocas lneas, querr ubicarlo en un script, y usarlo desde varios otros. Vamos a denominar ese script como biblioteca.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2352</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="550" approved="yes">
        <source>Manually loading a library script is possible, so long as you avoid loading it when it's already done.  You can do this with the |exists()| function.  Example: &gt;</source>
        <target state="translated">Cargar una biblioteca manualmente es posible, siempre que evite cargarla cuando ya lo est. Puede evitarlo con la funcin |exists()|. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2356</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="551" approved="yes">
        <source>	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)
</source>
        <target state="translated">	if !exists('*MiFuncionBiblioteca')
	   runtime library/biblioteca.vim
	endif
	call MiFuncionBiblioteca(arg)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2361</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="552" approved="yes">
        <source>Here you need to know that MyLibFunction() is defined in a script "library/mylibscript.vim" in one of the directories in 'runtimepath'.</source>
        <target state="translated">Aqu tiene que saber que MiFuncinBiblioteca() se define en el script library/biblioteca.vim, en uno de los directorios de 'runtimepath'.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2364</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="553" approved="yes">
        <source>To make this a bit simpler Vim offers the autoload mechanism.  Then the example looks like this: &gt;</source>
        <target state="translated">Para hacer esto ms sencillo, Vim ofrece el mecanismo autoload (carga automtica). As, el ejemplo tendra este aspecto: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2367</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="554" approved="yes">
        <source>	call mylib#myfunction(arg)
</source>
        <target state="translated">	call mibiblioteca#mifuncion(arg)
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2369</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="555" approved="yes">
        <source>That's a lot simpler, isn't it? Vim will recognize the function name and when it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.  That script must define the "mylib#myfunction()" function.</source>
        <target state="translated">Mucho ms sencillo, verdad? Vim reconoce el nombre de la funcin y, cuando no est definida, la buscar el script autoload/mibiblioteca.vim en 'runtimepath'. El script debe definir la funcin mibiblioteca#mifuncion().</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2373</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="556" approved="yes">
        <source>You can put many other functions in the mylib.vim script, you are free to organize your functions in library scripts.  But you must use function names where the part before the '#' matches the script name.  Otherwise Vim would not know what script to load.</source>
        <target state="translated">Puede almacenar varias funciones en el script mibiblioteca.vim, y puede organizar como desee las funciones en sus bibliotecas. Pero debe usar nombres de funciones en las que la parte que precede a # coincide con el nombre del script. En caso contrario, Vim no sabr qu script cargar.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2378</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="557" approved="yes">
        <source>If you get really enthusiastic and write lots of library scripts, you may want to use subdirectories.  Example: &gt;</source>
        <target state="translated">Si esto le entusiasma, y escribe muchas bibliotecas, puede que quiera usar subdirectorios. Ejemplo: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2381</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="558" approved="yes">
        <source>	call netlib#ftp#read('somefile')
</source>
        <target state="translated">	call netlib#ftp#read('somefile')
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2383</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="559" approved="yes">
        <source>For Unix the library script used for this could be:</source>
        <target state="translated">En sistemas Unix, la biblioteca a usar podra ser:</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2385</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="560" approved="yes">
        <source>	~/.vim/autoload/netlib/ftp.vim
</source>
        <target state="translated">	~/.vim/autoload/netlib/ftp.vim
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2387</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="561" approved="yes">
        <source>Where the function is defined like this: &gt;</source>
        <target state="translated">Donde se define la funcin as: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2389</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="562" approved="yes">
        <source>	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction
</source>
        <target state="translated">	function netlib#ftp#read(nombre_archivo)
		"  Lee al archivo mediante FTP
	endfunction
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2393</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="563" approved="yes">
        <source>Notice that the name the function is defined with is exactly the same as the name used for calling the function.  And the part before the last '#' exactly matches the subdirectory and script name.</source>
        <target state="translated">Tenga en cuenta que el nombre con el que se define la funcin es idntico al utilizado para invocar la funcin. Y la parte a continuacin del ltimo # coincide con el subdirectorio y el nombre del script.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2397</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="564" approved="yes">
        <source>You can use the same mechanism for variables: &gt;</source>
        <target state="translated">Puede utilizar el mismo mecanismo con variables: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2399</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="565" approved="yes">
        <source>	let weekdays = dutch#weekdays
</source>
        <target state="translated">	let dias_semana = colombia#dias_semana
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2401</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="566" approved="yes">
        <source>This will load the script "autoload/dutch.vim", which should contain something like: &gt;</source>
        <target state="translated">Esto cargar el script autoload/colombia.vim, que contendra algo similar a lo siguiente: &gt;</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2404</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">revisar que caracteres no-ascii sirvan</context>
        </context-group>
        <note from="po-translator">revisar que caracteres no-ascii sirvan</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="567" approved="yes">
        <source>	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']
</source>
        <target state="translated">	let colombia#dias_semana = ['lunes', 'martes', 'mircoles', 'jueves',
		\ 'viernes', 'sbado', 'domingo']
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2407</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-trancomment">revisar que caracteres no-ascii sirvan</context>
        </context-group>
        <note from="po-translator">revisar que caracteres no-ascii sirvan</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="568" approved="yes">
        <source>Further reading: |autoload|.</source>
        <target state="translated">Lecturas adicionales: |autoload|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2409</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="569" approved="yes">
        <source>*41.16*	Distributing Vim scripts			*distribute-script*
</source>
        <target state="translated">*41.16*	Distribuir scripts de Vim			*distribute-script*
</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2412</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="570" approved="yes">
        <source>Vim users will look for scripts on the Vim website: http://www.vim.org.  If you made something that is useful for others, share it!</source>
        <target state="translated">Los usuarios de Vim buscarn scripts en el sitio web de Vim: http://www.vim.org. Si ha creado algo til para otros, comprtalo!</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2415</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="571" approved="yes">
        <source>Vim scripts can be used on any system.  There might not be a tar or gzip command.  If you want to pack files together and/or compress them the "zip" utility is recommended.</source>
        <target state="translated">Los scripts de Vim se pueden usar en cualquier sistema. Las rdenes tar o gzip pueden no estar disponibles en dichos sistemas. Si desea empaquetar o comprimir los archivos, se recomienda usar la herramienta zip.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2419</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="572" approved="yes">
        <source>For utmost portability use Vim itself to pack scripts together.  This can be done with the Vimball utility.  See |vimball|.</source>
        <target state="translated">Para obtener la mxima portabilidad use Vim para empaquetar los scripts. Puede hacer esto con la herramienta Vimball. Consulte |vimball|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2422</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="573" approved="yes">
        <source>It's good if you add a line to allow automatic updating.  See |glvs-plugins|.</source>
        <target state="translated">Es una buena idea aadir una lnea para pemitir la actualizacin automtica. Consulte |glvs-plugins|.</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2424</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
      <trans-unit xml:space="preserve" id="574" approved="yes">
        <source>Next chapter: |usr_42.txt| Add new menus</source>
        <target state="translated">Captulo siguiente: |usr_42.esx| Aadir mens nuevos</target>
        <context-group name="po-reference" purpose="location">
          <context context-type="sourcefile">original/txt/usr_41.txt</context>
          <context context-type="linenumber">2428</context>
        </context-group>
        <context-group name="po-entry" purpose="information">
          <context context-type="x-po-autocomment">type: Plain text</context>
        </context-group>
        <note from="developer">type: Plain text</note>
      </trans-unit>
    </body>
  </file>
</xliff>
