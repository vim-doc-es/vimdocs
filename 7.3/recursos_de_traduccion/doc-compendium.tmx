<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit - po2tmx" creationtoolversion="1.9.0-beta2" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		     VIM USER MANUAL - by Bram Moolenaar
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		MANUAL DE USUARIO DE VIM - por Bram Moolenaar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_10.txt*	For Vim version 7.3.  Last change: 2006 Nov 05
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_10.esx*	Para Vim versión 7.3.  Último cambio: 5/11/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Making big changes
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			   Realizar grandes cambios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 4 several ways to make small changes were explained.  This chapter goes into making changes that are repeated or can affect a large amount of text.  The Visual mode allows doing various things with blocks of text.  Use an external program to do really complicated things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 4 se explicaron algunas formas de hacer cambios pequeños. Este capítulo tratará de cambios que se repiten o que afectan a grandes porciones del texto. El modo Visual permite hacer varias cosas con bloques de texto. Use un programa externo para hacer las cosas más complicadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|10.1|	Record and playback commands
|10.2|	Substitution
|10.3|	Command ranges
|10.4|	The global command
|10.5|	Visual block mode
|10.6|	Reading and writing part of a file
|10.7|	Formatting text
|10.8|	Changing case
|10.9|	Using an external program
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|10.1|	Órdenes de grabación y reproducción
|10.2|	Sustitución
|10.3|	Rangos de aplicación
|10.4|	Las órdenes globales
|10.5|	El modo de bloque Visual
|10.6|	Leer y escribir parte de un archivo
|10.7|	Formatear texto
|10.8|	Cambiar mayúsculas y minúsculas
|10.9|	Uso de un programa externo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_11.txt|  Recovering from a crash
 Previous chapter: |usr_09.txt|  Using the GUI
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_11.esx|  Recuperarse de un fallo
  Capítulo anterior: |usr_09.esx|  Uso de la interfaz gráfica
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.1*	Record and playback commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.1*	Órdenes de grabación y reproducción
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." command repeats the preceding change.  But what if you want to do something more complex than a single change? That's where command recording comes in.  There are three steps:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «.» repite el cambio precedente. ¿Pero qué ocurre si quiere hacer algo más complicado que un simple cambio? Para eso tenemos la orden de grabación («:recording»). Hay que seguir tres pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. The "q{register}" command starts recording keystrokes into the register
   named {register}.  The register name must be between a and z.
2. Type your commands.
3. To finish recording, press q (without any extra character).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. La orden «q{registro}» inicia la grabación de teclas pulsadas en un registro
   llamado{registro}. El nombre del registro debe estar en el rango (a-z).
2. Introduzca sus órdenes.
3. Pulse q para detener la grabación (sin ningún carácter adicional).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take a look at how to use these commands in practice.  You have a list of filenames that look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a echarle un vistazo a cómo se usan las órdenes en la práctica. Tiene una lista de nombres de archivo como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start by moving to the first character of the first line.  Next you execute the following commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comienza desplazándose al primer carácter de la primera línea. A continuación ejecute la siguiente orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	qa			Start recording a macro in register a.
	^			Move to the beginning of the line.
	i#include "&lt;Esc&gt;	Insert the string #include " at the beginning
				of the line.
	$			Move to the end of the line.
	a"&lt;Esc&gt;			Append the character double quotation mark (")
				to the end of the line.
	j			Go to the next line.
	q			Stop recording the macro.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	qa			Comenzar a grabar la macro en el registro «a».
	^			Ir al comienzo de la línea.
	i#include "&lt;Esc&gt;	Insertar el #include " al comienzo de cada
				línea.
	$			Ir al final de la línea.
	a"&lt;Esc&gt;			Añadir el carácter de comillas dobles (") al
				final de la línea.
	j			Ir a la próxima línea.
	q			Detener la grabación de la macro.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you have done the work once, you can repeat the change by typing the
command "@a" three times.
   The "@a" command can be preceded by a count, which will cause the macro to
be executed that number of times.  In this case you would type: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que ha realizado el trabajo una vez, puede repetir el cambio tecleando
la orden «@a» tres veces.
   La orden «@a» puede venir precedido de un multiplicador, el cuál causará
que la macro se ejecute ese número determinado de veces. En este caso: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	3@a
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	3@a
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have the lines you want to change in various places.  Just move the
cursor to each location and use the "@a" command.  If you have done that once,
you can do it again with "@@".  That's a bit easier to type.  If you now
execute register b with "@b", the next "@@" will use register b.
   If you compare the playback method with using ".", there are several
differences.  First of all, "." can only repeat one change.  As seen in the
example above, "@a" can do several changes, and move around as well.
Secondly, "." can only remember the last change.  Executing a register allows
you to make any changes and then still use "@a" to replay the recorded
commands.  Finally, you can use 26 different registers.  Thus you can remember
26 different command sequences to execute.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez tenga las líneas que quiere cambiar en varios lugares. Simplemente
mueva el cursor a cada ubicación y use la orden «@a». Si ha hecho eso
una vez, puede repetirlo con «@@». Es un poco más sencillo de teclear. Si
ejecuta el registro b con «@b», el próximo «@@» usará el registro b.
   Si compara esto con el método «.», hay varias diferencias. Lo primero,
«.x sólo puede repetir un cambio. Como ha podido ver en el ejemplo de
arriba, «@a» puede llevar a cabo varios cambios, incluyendo movimientos.  Por
otro lado, «.» sólo puede recordar el último cambio. Ejecutar un registro le
permite hacer algunos cambios en el texto y poder usar todavía las órdenes
grabadas. Por último, puede usar 26 registros distintos. De este modo
puede reusar 26 secuencias diferentes.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The registers used for recording are the same ones you used for yank and
delete commands.  This allows you to mix recording with other commands to
manipulate the registers.
   Suppose you have recorded a few commands in register n.  When you execute
this with "@n" you notice you did something wrong.  You could try recording
again, but perhaps you will make another mistake.  Instead, use this trick:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los registros que se usan para grabar son los mismos que se usan para las
órdenes de copiar y eliminar. Esto le permite mezclar la grabación con otras
órdenes para manipular los registros.
   Suponga que ha grabado algunas órdenes en el registro n. Cuando lo
ejecuta con «@n», se da cuenta de que algo no va bien. Podría intentar
grabarlo de nuevo, pero quizá cometa otro error. Mejor usar este truco:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can execute the corrected commands with "@n".  (If your recorded commands include line breaks, adjust the last two items in the example to include all the lines.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede ejecutar las órdenes corregidas con «@n». (Si las órdenes grabadas incluyen saltos de línea, ajuste los dos últimos puntos explicados anteriormente para incluir todas las líneas.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have used a lowercase letter for the register name.  To append to a
register, use an uppercase letter.
   Suppose you have recorded a command to change a word to register c.  It
works properly, but you would like to add a search for the next word to
change.  This can be done with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta el momento hemos usado letras en minúscula para el nombre del registro.
Para añadir a un registro, use una letra en mayúscula.
   Suponga por un momento que ha grabado una orden para cambiar una
palabra en el registro c. Funciona correctamente, pero quisiera añadir una
búsqueda para la siguiente palabra a cambiar. Esto se puede hacer así: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	qC/word&lt;Enter&gt;q
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	qC/palabra&lt;Entrar&gt;q
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start with "qC", which records to the c register and appends.  Thus writing to an uppercase register name means to append to the register with the same letter, but lowercase.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comience con «qC», que añadirá al registro c. De este modo siempre podrá escribir el registro al que quieras añadir nuevos pasos mediante la misma de letra de identificación, pero en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works both with recording and with yank and delete commands.  For example, you want to collect a sequence of lines into the a register.  Yank the first line with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona tanto grabando como y con las órdenes de copiar y eliminar. Por ejemplo, quieres reunir una secuencia de líneas en un registro. Copie la primera línea con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"aY
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"aY
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"AY
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"AY
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeat this command for all lines.  The a register now contains all those lines, in the order you yanked them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repita la orden para todas las líneas. El registro «a» contiene ahora todas estas líneas, en el orden en el que las ha copiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.2*	Substitution						*find-replace*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.2*	Sustitución
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":substitute" command enables you to perform string replacements on a whole range of lines.  The general form of this command is as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:substitute» le permite ejecutar sustituciones de cadenas de caracteres en un rango de líneas. La forma general es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:[range]substitute/from/to/[flags]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:[rango]substitute/de/a/[opciones]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command changes the "from" string to the "to" string in the lines specified with [range].  For example, you can change "Professor" to "Teacher" in all lines with the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden cambia la cadena «de» por la cadena «a» en las líneas especificadas con [rango]. Por ejemplo, puede cambiar «profesor» por «maestro» en todas las líneas con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%substitute/Professor/Teacher/
&lt;
	Note:
	The ":substitute" command is almost never spelled out completely.
	Most of the time, people use the abbreviated version ":s".  From here
	on the abbreviation will be used.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%substitute/profesor/maestro/
&lt;
	Nota:
	La orden «:substitute» casi nunca se escribe completamente. La mayoría
	de las veces la gente escribe la versión abreviada ":s". A partir de
	ahora, se empleará la abreviatura.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "%" before the command specifies the command works on all lines.  Without a range, ":s" only works on the current line.  More about ranges in the next section |10.3|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «%» antes de la orden especifica que se ejecuta en todas las líneas. Sin rango, «:s» sólo funciona en la línea actual. Más sobre los rangos en la próxima sección |10.3|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the ":substitute" command changes only the first occurrence on each line.  For example, the preceding command changes the line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, la orden «:substitute» cambia sólo la primera palabra encontrada en cada línea. Por ejemplo, la orden anterior cambia esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Professor Smith criticized Professor Johnson today. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El profesor Pinilla ha criticado hoy al profesor Burgos. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Teacher Smith criticized Professor Johnson today. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El maestro Pinilla ha criticado hoy al profesor Burgos. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change every occurrence on the line, you need to add the g (global) flag.  The command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para cambiar todas palabras que aparezcan en la línea deberá usar la opción g (global). La orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/Professor/Teacher/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/profesor/maestro/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Teacher Smith criticized Teacher Johnson today. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El maestro Pinilla ha criticado hoy al maestro Burgos. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other flags include p (print), which causes the ":substitute" command to print out the last line it changes.  The c (confirm) flag tells ":substitute" to ask you for confirmation before it performs each substitution.  Enter the following: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otras opciones incluyen p (print = imprimir), que hace la orden «:s» muestre en pantalla la última línea que cambió. La «c» (confirm = confirmar) le dice a «:s» que pida confirmación antes que se ejecute cada sustitución. Introduzca lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/Professor/Teacher/c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/profesor/maestro/c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim finds the first occurrence of "Professor" and displays the text it is about to change.  You get the following prompt: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encuentra la primera aparición de «profesor» y muestra el texto que está a punto de cambiar. Le aparecerá la siguiente pregunta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	replace with Teacher (y/n/a/q/l/^E/^Y)?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	replace with maestro (y/n/a/q/l/^E/^Y)?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	y		Yes; make this change.
	n		No; skip this match.
	a		All; make this change and all remaining ones without
			further confirmation.
	q		Quit; don't make any more changes.
	l		Last; make this change and then quit.
	CTRL-E		Scroll the text one line up.
	CTRL-Y		Scroll the text one line down.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	y               Si; hacer el cambio.
	n               No; omitir esta coincidenci.
	a               Todo; hacer este cambio y todos los restantes sin
			pedir más confirmación.
	q               Quit; no hacer más cambios.
	l               Último; hacer este cambio y salir.
	CTRL-E          Desplazar el texto hacia arriba.
	CTRL-Y          Desplazar el texto hacia abajo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s/^the/these/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s/^Eso/Aquello/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are substituting with a "from" or "to" part that includes a slash, you need to put a backslash before it.  A simpler way is to use another character instead of the slash.  A plus, for example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sustituye con una parte «de» o «a» que incluyan una barra inclinada, tendrá que poner una barra inversa antes de él. Una forma más sencilla es usar otro carácter como separador en lugar de la barra. Un «+», por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s+one/two+one or two+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s+uno/dos+uno o dos+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.3*	Command ranges
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.3*	Rangos de aplicación
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":substitute" command, and many other : commands, can be applied to a
selection of lines.  This is called a range.
   The simple form of a range is {number},{number}.  For example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:substitute» y muchas otras órdenes «:» se pueden aplicar a
una selección de líneas. A esto se le llama rango.
   La forma más simple de un rango es {n},{n} (n es un número entero). Por ej:
&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:1,5s/this/that/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:1,5s/esto/aquello/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executes the substitute command on the lines 1 to 5.  Line 5 is included.  The range is always placed before the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecuta la orden sustituir desde la línea 1 a la 5. La línea 5 queda incluida. El rango se sitúa justo antes de la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:54s/President/Fool/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:54s/Político/Demagogo/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands work on the whole file when you do not specify a range.  To make them work on the current line the "." address is used.  The ":write" command works like that.  Without a range, it writes the whole file.  To make it write only the current line into a file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes funcionan sobre un archivo completo cuando no le especifica un rango. Para hacerlos funcionar en la línea actual, use «.». La orden «:write» funciona de ese modo. Sin un rango, escribe el archivo completo. Para hacer que sólo escriba una línea a un archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.write otherfile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.write otroarchivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first line always has number one.  How about the last line? The "$" character is used for this.  For example, to substitute in the lines from the cursor to the end: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera línea siempre tiene como numeración el 1. ¿Pero qué ocurre con la última línea? Puede usar el carácter «$» ppara esto.  Por ejemplo, para sustituir en las líneas desde la del cursor hasta el final: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.,$s/yes/no/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.,$s/si/no/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you are editing a chapter in a book, and want to replace all occurrences of "grey" with "gray".  But only in this chapter, not in the next one.  You know that only chapter boundaries have the word "Chapter" in the first column.  This command will work then: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editado un capítulo de un libro y que desea reemplazar todas las palabras «grisx con «blanco». Pero sólo en ese capítulo, no en el siguiente.  Sabe que los límites entre capítulos tienen la palabra «Capítulo» en la primera columna. Esta orden funcionaría aquí: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:?^Chapter?,/^Chapter/s=grey=gray=g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:?^Capítulo?,/^Capítulo/s=gris=azul=g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see a search pattern is used twice.  The first "?^Chapter?" finds the
line above the current position that matches this pattern.  Thus the ?pattern?
range is used to search backwards.  Similarly, "/^Chapter/" is used to search
forward for the start of the next chapter.
   To avoid confusion with the slashes, the "=" character was used in the
substitute command here.  A slash or another character would have worked as
well.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede observar que un patrón se ha usado en dos ocasiones. La primera
«?^Chapter?» busca el patrón en sentido inverso. Por lo tanto «?patrón?»
buscará encima de la línea actual. De forma similar, «/^Capítulo/» se usa para
buscar hacia delante el comienzo del nuevo capítulo.
   Para evitar confusión con las barras, el carácter «=» se ha empleado en
la orden sustituir. Una barra o cualquier otro carácter habría funcionado
igual de bien.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a slight error in the above command: If the title of the next chapter
had included "grey" it would be replaced as well.  Maybe that's what you
wanted, but what if you didn't?  Then you can specify an offset.
   To search for a pattern and then use the line above it: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño error en la orden de arriba: Si el título del siguiente
capítulo hubiese incluido «grisx habría sido reemplazado igualmente. Quizá
quería eso, ¿pero qué ocurre si no? Puede especificar un «offset».
   Para buscar un patrón e indicar la línea anterior: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/Chapter/-1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/Capítulo/-1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any number instead of the 1.  To address the second line below the match: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar cualquier número en lugar de 1. Para indicar la segunda línea por debajo de la cadena encontrada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/Chapter/+2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/Capítulo/+2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The offsets can also be used with the other items in a range.  Look at this one: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El desplazamiento se puede emplear también con otros elementos en un rango.  Observe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.+3,$-5
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.+3,$-5
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of figuring out the line numbers of certain positions, remembering them
and typing them in a range, you can use marks.
   Place the marks as mentioned in chapter 3.  For example, use "mt" to mark
the top of an area and "mb" to mark the bottom.  Then you can use this range
to specify the lines between the marks (including the lines with the marks): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de adivinar el número de algunas líneas en determinadas posiciones,
e introducirlas en un rango, puede usar marcadores.
   Ponga marcas como se explica en el capítulo 3. Por ejemplo, usa «ms» para
marcar la parte superior de un área y «mi» para marcar la parte inferior".
Puede usar el rango para especificar las líneas entre las marcas
(inclusive): &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:'t,'b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:'t,'b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can select text with Visual mode.  If you then press ":" to start a colon command, you will see this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede seleccionar texto con el modo Visual. Si pulsa «:» para iniciar una orden, verá lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:'&lt;,'&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:'&lt;,'&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	When using Visual mode to select part of a line, or using CTRL-V to
	select a block of text, the colon commands will still apply to whole
	lines.  This might change in a future version of Vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Cuando use el modo Visual para seleccionar parte de una línea, o use
	CTRL-V para seleccionar un bloque de texto, las órdenes se aplicarán
	a líneas completas. Puede que esto cambie en una futura versión.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The '&lt; and '&gt; are actually marks, placed at the start and end of the Visual selection.  The marks remain at their position until another Visual selection is made.  Thus you can use the "'&lt;" command to jump to position where the Visual area started.  And you can mix the marks with other items: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los «'&lt;» y «'&gt;» son marcadores que se sitúan al principio y al final de la selección. Estos marcadores mantienen estas posiciones hasta que aparece una nueva selección Visual. Por lo tanto, puede usar la orden «"'&lt;"» para saltar al lugar donde el área Visual comenzaba. También puede mezclarlas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:'&gt;,$
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:'&gt;,$
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you know how many lines you want to change, you can type the number and then ":".  For example, when you type "5:", you will get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando sepa cuántas líneas quieres cambiar, puede teclear el número y luego «:».  Si, por ejemplo, escribe «5:» obtendrá: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.,.+4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.,.+4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can type the command you want to use.  It will use the range "." (current line) until ".+4" (four lines down).  Thus it spans five lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puedes ejecutar la orden que quiera usar. Usará el rango «.» (línea actual) hasta «.+4» (cuatro líneas más). Esto hará un total de cinco líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.4*	The global command
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.4*	Las órdenes globales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":global" command is one of the more powerful features of Vim.  It allows you to find a match for a pattern and execute a command there.  The general form is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:global» es una de las características más potentes de Vim.  Permite que encuentre una cadena con un patrón y ejecute una orden en esa ubicación. El formato habitual es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:[range]global/{pattern}/{command}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:[rango]global/{patrón}/{orden}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to the ":substitute" command.  But, instead of replacing the matched text with other text, the command {command} is executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es similar a la orden «:substitute». Pero en lugar de reemplazar el texto concordado con otro texto, la orden {orden} se ejecutará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	The command executed for ":global" must be one that starts with a
	colon.  Normal mode commands can not be used directly.  The |:normal|
	command can do this for you.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	La orden ejecutada con «:global» debe ser uno que comience con un
	punto y coma. Las órdenes para el modo Normal no se pueden emplear de
	forma directa. De esto se encargará |:normal|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to change "foobar" to "barfoo", but only in C++ style comments.  These comments start with "//".  Use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiere cambiar «foobar» por «barfoo», pero solamente en los comentarios de C++. Estos comentarios empiezan por «//». Use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:g+//+s/foobar/barfoo/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:g+//+s/foobar/barfoo/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with ":substitute", any pattern can be used.  When you learn more complicated patterns later, you can use them here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como ocurre con «:substitute», puede emplear cualquier patrón.  Cuando aprenda patrones más complicados, podrá usarlos aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.5*	Visual block mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.5*	El modo de bloque Visual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With CTRL-V you can start selection of a rectangular area of text.  There are a few commands that do something special with the text block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con CTRL-V puede seleccionar un área rectangular de texto. Hay algunas órdenes que hacen algo especial con los bloques de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	include one ~
	include two ~
	include three ~
	include four ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	include uno ~
	include dos ~
	include tres ~
	include cuatro ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the "o" of "one" and press CTRL-V.  Move it down with "3j" to "four".  You now have a block selection that spans four lines.  Now type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a la «u» de «uno» y presione CTRL-V. Desplácese hacia abajo con «3j» hasta«"cuatro». Tiene una selección que abarca cuatro líneas. Teclee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Imain.&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Imain.&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	include main.uno ~
	include main.dos ~
	include main.tres ~
	include main.cuatro ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the block spans short lines that do not extend into the block, the text is not inserted in that line.  For example, make a Visual block selection that includes the word "long" in the first and last line of this text, and thus has no text selected in the second line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el bloque abarca líneas que no caben dentro del área del bloque, el texto no se insertará en esa línea. Por ejemplo, haga un bloque Visual que no incluya la palabra «larga» en la primera y última línea de este texto, de manera que no se seleccione texto en la segunda línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a long line ~
	short ~
	Any other long line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea larga ~
	corta ~
	Cualquier es una línea larga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		  ^^^^ selected block
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		    ^^^^^ bloque seleccionado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the command "Ivery &lt;Esc&gt;".  The result is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora usa la orden «Imuy &lt;Esc&gt;». El resultado es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a very long line ~
	short ~
	Any other very long line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea muy larga ~
	corta ~
	Esto es una línea muy larga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "A" command works the same way, except that it appends after the right
side of the block.  And it does insert text in a short line.  Thus you can
make a choice whether you do or don't want to append text to a short line.
   There is one special case for "A": Select a Visual block and then use "$"
to make the block extend to the end of each line.  Using "A" now will append
the text to the end of each line.
   Using the same example from above, and then typing "$A XXX&lt;Esc&gt;, you get
this result:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «A» funciona de la misma manera, excepto que se añade a la derecha
del bloque. En este caso sí se añade al final de la línea corta. De este
modo puede elegir si quieres añadir o no un texto a la línea corta.
   Hay un caso especial para «Ax: seleccione un bloque Visual y pulsw «$» para
hacer que el bloque se extienda al final de cada línea. Usar «A» añadirá el
texto al final de cada línea.
   De usar el mismo ejemplo que arriba y teclear «$A XXX&lt;Esc&gt;» obtendría el
siguiente resultado:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea larga XXX~
	corta XXX~
	Esto es una línea larga XXX~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This really requires using the "$" command.  Vim remembers that it was used.  Making the same selection by moving the cursor to the end of the longest line with other movement commands will not have the same result.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto requiere el uso de la orden «$». Vim recordará que los ha usado. Hacer la misma selección con el cursor hasta el final de la línea más larga con otras órdenes no te dará el mismo resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Visual block "c" command deletes the block and then throws you into Insert
mode to enable you to type in a string.  The string will be inserted in each
line in the block.
   Starting with the same selection of the "long" words as above, then typing
"c_LONG_&lt;Esc&gt;", you get this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden de bloque Visual «c» elimina el bloque y le devuelve al modo
Insertar para que escriba en una cadena de caracteres. La cadena se
insertará en cada línea del bloque.
   Comenzando con la misma selección que las palabras zlarga» de arriba,
y teclear después «c_LARGA_&lt;Esc&gt;», le daría esto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea _LARGA_ ~
	corta ~
	Esto es una línea _LARGA_ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with "I" the short line is not changed.  Also, you can't enter a newline in the new text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como ocurre con «Ix, la línea corta no cambia. Del mismo modo, no podrá introducir una nueva línea en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a new text ~
	short ~
	Any other new text ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es un texto nuevo ~
	corta ~
	Esto es un texto nuevo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that, even though only the "long" word was selected, the text after it
is deleted as well.  Thus only the location of the left edge of the visual
block really matters.
   Again, short lines that do not reach into the block are excluded.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que aunque sólo se seleccionó la palabra «larga», el texto
tras ella fue eliminado igualmente. Por lo tanto sólo la posición del borde
izquierdo del eje izquierdo importa realmente.
   Una vez más, las palabras que no forman parte del bloque se excluyen.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fill the whole block with one character, use the "r" command.  Again, starting with the same example text from above, and then typing "rx":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para rellenar un bloque completo con un sólo carácter, usw la orden «r».  Pruébelo de nuevo con el texto de antes, pulsando «rx»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a xxxx line ~
	short ~
	Any other xxxx line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea larga ~
	corta ~
	Cualquier es una línea larga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	If you want to include characters beyond the end of the line in the
	block, check out the 'virtualedit' feature in chapter 25.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Si desea incluir los caracteres más allá del final de línea en el
	bloque, consulte la opción 'virtualedit' en el capítulo 25.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command "&gt;" shifts the selected text to the right one shift amount,
inserting whitespace.  The starting point for this shift is the left edge of
the visual block.
   With the same example again, "&gt;" gives this result:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «&gt;» empuja el texto hacia la derecha un espacio determinado,
insertando espacios en blanco. El punto base empleado para esta operación es
el borde izquierdo del bloque visual.
   Con el mismo ejemplo de nuevo, «&gt;» le da el resultado:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a	  long line ~
	short ~
	Any other	  long line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una	línea larga ~
	corta ~
	Esto es una	línea larga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The shift amount is specified with the 'shiftwidth' option.  To change it to use 4 spaces: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio del desplazamiento se especifica con la opción 'shiftwidth".  Para cambiarlo a cuatro espacios: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set shiftwidth=4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set shiftwidth=4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "&lt;" command removes one shift amount of whitespace at the left edge of the block.  This command is limited by the amount of text that is there; so if there is less than a shift amount of whitespace available, it removes what it can.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «&lt;» desplaza por cada empuje la misma cantidad de espacios en blanco hacia la izquierda. Esta orden se limita al texto que se encuentre, de manera que eliminará la cantidad de espacio en blanco disponible sin sobreescribir texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a long line short Any other long line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es una línea larga corta Esto es una línea larga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "J" command doesn't require a blockwise selection.  It works with "v" and "V" selection in exactly the same way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «J» no requiere selección de bloques. Funciona de igual modo con la selección «v» y «V».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.6*	Reading and writing part of a file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.6*	Leer y escribir parte de un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Hola Juan, ~
	Aquí tienes el parche que arregla el problema: ~
	Un saludo, Pedro. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:read patch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:read parche
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	&lt;	for (i = 0; i &lt;= length; ++i) ~
	--- ~
	&gt;	for (i = 0; i &lt; length; ++i) ~
	Bye, Pierre. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Hola Juan, ~
	Aquí tienes el parche que arregla el problema: ~
	2c2 ~
	&lt;	for (i = 0; i &lt;= length; ++i) ~
	--- ~
	&gt;	for (i = 0; i &lt; length; ++i) ~
	Un saludo, Pedro. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":read" command accepts a range.  The file will be put below the last line
number of this range.  Thus ":$r patch" appends the file "patch" at the end of
the file.
   What if you want to read the file above the first line?  This can be done
with the line number zero.  This line doesn't really exist, you will get an
error message when using it with most commands.  But this command is allowed:
&gt;
	:0read patch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:read» acepta un rango. El archivo será colocado justo debajo de
la última línea de este rango. Por lo tanto, «:$r parche» añadirá el
archivo «parche» al final del actual.
   ¿Qué ocurre si quiere pegar el archivo encima de la primera línea? Esto
se puede realizar con el número de línea cero. Este número de línea en
realidad no existe, lo cuál hará que con muchas órdenes reciba un error. &gt;
&gt;
:0read parche
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a range of lines to a file, the ":write" command can be used.  Without a range it writes the whole file.  With a range only the specified lines are written: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para guardar un rango de líneas en un archivo puede usar la orden «:write».  Sin el rango esto guardará el archivo completo. Pero con un rango especificado únicamente las líneas que se especifiquen se escribirán: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.,$write tempo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.,$write tempo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This writes the lines from the cursor until the end of the file into the file "tempo".  If this file already exists you will get an error message.  Vim protects you from accidentally overwriting an existing file.  If you know what you are doing and want to overwrite the file, append !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará las líneas desde el cursor hasta el final del texto en el archivo «tempo». Si este archivo existe actualmente obtendrá un mensaje de error. Vim le protege de que sobreescriba un archivo preexistente. Si sabe lo que hace y quiere sobreescribirlo, añada «!»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.,$write! tempo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.,$write! tempo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CAREFUL: The ! must follow the ":write" command immediately, without white space.  Otherwise it becomes a filter command, which is explained later in this chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CUIDADO: El «!» debe ponerse justo después de la orden «:write», sin el espacio en blanco. En caso contrario, se convierte en una orden de filtro, el cuál se explica en el capítulo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first section of this chapter was explained how to collect a number of lines into a register.  The same can be done to collect lines in a file.  Write the first line with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera sección de este capítulo se explicó cómo reunir una serie de líneas en un registro. Se puede hacer lo mismo para reunir líneas en un archivo. Escriba una primera línea con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.write collection
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.write archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:.write &gt;&gt;collection
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:.write &gt;&gt;archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "&gt;&gt;" tells Vim the "collection" file is not to be written as a new file,
but the line must be appended at the end.   You can repeat this as many times
as you like.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «&gt;&gt;» le dice a Vim que «archivo» no se debe escribir como un nuevo
archivo sino que la línea se deba añadir al final. Puede repetir esto
tantas veces como desee.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.7*	Formatting text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.7*	Formatear texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are typing plain text, it's nice if the length of each line is automatically trimmed to fit in the window.  To make this happen while inserting text, set the 'textwidth' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando introducza texto, tal vez le resulta útil que, si la longitud de cada línea supera un número, sea automáticamente partida. Para hacer esto posible, active la opción 'textwidth': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set textwidth=72
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set textwidth=72
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might remember that in the example vimrc file this command was used for every text file.  Thus if you are using that vimrc file, you were already using it.  To check the current value of 'textwidth': &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quizá se acuerde de que en el ejemplo de archivo «vimrc» esta orden era empleada para cualquier tipo de archivo. Por lo tanto, si está usando ese archivo «vimrc», ya lo tiene activado. Para comprobar el valor actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set textwidth
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set textwidth
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gqap
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gqap
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	A blank line, which contains white space, does NOT separate
	paragraphs.  This is hard to notice!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Una línea que contiene espacios en blanco NO separa párrafos. Esto
	suele ser difícil de notar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of "ap" you could use any motion or text object.  If your paragraphs are properly separated, you can use this command to format the whole file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de «ap» puede usar cualquier movimiento u objeto de texto. Si sus párrafos están adecuadamente separados, puede usar esto para formatear todo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gggqG
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gggqG
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.8*	Changing case
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.8*	Cambiar mayúsculas y minúsculas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have text with section headers in lowercase.  You want to make the word "section" all uppercase.  Do this with the "gU" operator.  Start with the cursor in the first column: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene texto con las cabeceras de sección en minúscula. Quiere que la palabra «sección» esté en mayúsculas.   Puede hacerlo con el operador «gU». Comience con el cursor en la primera columna: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     gUw
&lt;	section header	    ----&gt;      SECTION header
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			     gUw
&lt;	cabecera de sección ----&gt;      cabecera de SECCIÓN
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     guw
&lt;	SECTION header	    ----&gt;      section header
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			     guw
	cabecera de SECCIÓN ----&gt;      cabecera de sección
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				g~~ 
&lt;	Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				      g~~ 
	Algunas CHICAS se divierten  ----&gt;  aLGUNAS chicas SE DIVIERTEN ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.9*	Using an external program
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.9*	Uso de un programa externo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a very powerful set of commands, it can do anything.  But there may
still be something that an external command can do better or faster.
   The command "!{motion}{program}" takes a block of text and filters it
through an external program.  In other words, it runs the system command
represented by {program}, giving it the block of text represented by {motion}
as input.  The output of this command then replaces the selected block.
   Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.  The sort command sorts a file.  If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt.  (This works on both UNIX and Microsoft Windows.) &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene un conjunto de órdenes muy potente para hacer cualquier cosa.
Pero siempre hay un programa externo que es mejor para una tarea específica.
   La orden «!{movimiento}{programa}» recoge un bloque de un texto y lo
filtra a través de un programa externo. En otras palabras, ejecuta la
orden de sistema {programa}, dándole el bloque de texto representado por
{movimiento} como entrada. La salida de la orden sustituirá la selección.
   Ya que esto requiere más explicación si no usa los filtros UNIX
habitualmente, veamos un ejemplo. La orden «sort» ordena un archivo. Si
ejecuta lo siguiente, el archivo desordenado entrada.txt será ordenado y
guardado en output.txt. (Esto funciona en UNIX y en Windows.) &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	sort &lt;input.txt &gt;output.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	sort &lt;input.txt &gt;output.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now do the same thing in Vim.  You want to sort lines 1 through 5 of a file.  You start by putting the cursor on line 1.  Next you execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora haga lo mismo en Vim. Desea ordenar las líneas de la 1 a la 5. Para comenzar, ponga el cursor en la línea 1. A continuación ejecute la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	!5G
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	!5G
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!" tells Vim that you are performing a filter operation.  The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.  The "5G" command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.
   In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.  You can now type in the name of the filter
program, in this case "sort".  Therefore, your full command is as follows: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «!» le dice a Vim que está realizando una operación filtro. El editor
Vim espera que introduzca a continuación un orden de movimiento para saber
qué filtrar. La orden «5G» le dice a Vim que vaya a la línea 5, de forma
que sepa que tiene que filtrar desde la línea 1 (la actual) hasta la 5.
   Antes de filtrar nada, la línea de órdenes se activa y muestra un «!».
Ahora es el momento de que escriba el filtro, en este caso «sort». Por lo
tanto, la orden completo sería: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	!5Gsort&lt;Enter&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	!5Gsort&lt;Entrar&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is that the sort program is run on the first 5 lines.  The output of the program replaces these lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es que se ejecuta el programa «sort» sobre las 5 primeras líneas. La salida del programa reemplaza estas líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	line 55			      line 11
	line 33			      line 22
	line 11		--&gt;	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	línea 55		      línea 11
	línea 33		      línea 22
	línea 11	--&gt;	      línea 33
	línea 22		      línea 44
	línea 44		      línea 55
	última línea		      última línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!!" command filters the current line through a filter.  In Unix the "date" command prints the current time and date.  "!!date&lt;Enter&gt;" replaces the current line with the output of "date".  This is useful to add a timestamp to a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «!!» filtra la línea actual. En Unix, la orden »date» imprime la hora y fecha actuales. «!!date&lt;Entrar&gt;» reemplaza la línea actual con la salida de «date». Esto es útil para añadir una marca de tiempo al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting a shell, sending it text and capturing the output requires that Vim knows how the shell works exactly.  When you have problems with filtering, check the values of these options:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciar la consola, enviarle texto y capturar la salida requiere que Vim sepa exactamente cómo funciona la consola de forma precisa. Cuando tenga problemas con el filtrado, comprueba los valores de las siguientes opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	'shell'		specifies the program that Vim uses to execute
			external programs.
	'shellcmdflag'	argument to pass a command to the shell
	'shellquote'	quote to be used around the command
	'shellxquote'	quote to be used around the command and redirection
	'shelltype'	kind of shell (only for the Amiga)
	'shellslash'	use forward slashes in the command (only for
			MS-Windows and alikes)
	'shellredir'	string used to write the command output into a file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	'shell'		especifica el programa que Vim empleará para ejecutar
			programas externos.
	'shellcmdflag'	argumento para pasar un orden a la consola
	'shellquote'	comillas a usar alrededor de la orden
	'shellxquote'	comillas a usar alrededor de la orden y redirección
	'shelltype'	tipo de consola (sólo para Amiga)
	'shellslash'	usar barras inclinadas en la orden (sólo para
			Windows y similares)
	'shellredir'	cadena para escribir la salida a un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix this is hardly ever a problem, because there are two kinds of shells:
"sh" like and "csh" like.  Vim checks the 'shell' option and sets related
options automatically, depending on whether it sees "csh" somewhere in
'shell'.
   On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.  Check the help for the options
for more information.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix esto es raramente un problema, porque hay dos tipos de consola: «sh» y
«csh». Vim comprueba la opción 'shell' y configura todo automáticamente,
dependiendo de si ve «cshx en algún lugar de 'shell'.
   Sin embargo, en Windows, hay muchos tipos de consolas y quizá tenga que
ajustar las opciones para hacer que el filtrado funcione correctamente.
Busque en la ayuda más información sobre las opciones de configuración
de la consola para poder solucionarlo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>on Unix: &gt;
	:read !ls
on MS-Windows: &gt;
	:read !dir
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>en Unix: &gt;
	:read !ls
en MS-Windows: &gt;
	:read !dir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output of the "ls" or "dir" command is captured and inserted in the text,
below the cursor.  This is similar to reading a file, except that the "!" is
used to tell Vim that a command follows.
   The command may have arguments.  And a range can be used to tell where Vim
should put the lines: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida de las órdenes «ls» o «dir» se puede capturar e insertar en el
texto, debajo del cursor. Esto es similar a leer un archivo, excepto que el
«!» se emplea para decirle a Vim que hay una orden a continuación.
   Puede que la orden tenga argumentos. Puede emplear un rango para
decirle a Vim dónde debería poner las líneas: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:0read !date -u
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:0read !date -u
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This inserts the current time and date in UTC format at the top of the file.  (Well, if you have a date command that accepts the "-u" argument.)  Note the difference with using "!!date": that replaced a line, while ":read !date" will insert a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto inserta la hora y fecha actuales en formato UTC en la primera línea del archivo. (Bueno, si tienes una orden «date» que acepta el argumento «-u».) Tenga en cuenta la diferencia de usar «!!date»; esto reemplazó una línea, mientras que «:read !date» insertó una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Unix command "wc" counts words.  To count the words in the current file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden Unix «wc» cuenta palabras. Para contar las del archivo actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write !wc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write !wc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the same write command as before, but instead of a file name the "!" character is used and the name of an external command.  The written text will be passed to the specified command as its standard input.  The output could look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la misma orden «write» vista que anteriormente, pero en lugar de un nombre de archivo, se emplean el carácter «!» y una orden externa. El texto guardado será pasado al orden especificado como entrada estándar. La salida será algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>       4      47     249 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>       4      47     249 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "wc" command isn't verbose.  This means you have 4 lines, 47 words and 249 characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «wc» no es muy informativa. Esto significa que tiene 4 líneas, 47 palabras y 249 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write! wc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write! wc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will write the file "wc" in the current directory, with force.  White space is important here!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará el archivo «wc» en el directorio actual con la opción «force» (forzar). ¡El espacio en blanco es muy importante en este caso!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the external command produced an error message, the display may have been messed up.  Vim is very efficient and only redraws those parts of the screen that it knows need redrawing.  But it can't know about what another program has written.  To tell Vim to redraw the screen: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la orden externa produjo un mensaje de error, la pantalla de Vim tal vez esté sobreescrita con información confusa. Vim es muy eficiente y sólo reescribe aquellas partes de la pantalla que lo necesiten. Pero no puede saber sobre lo que otro programa ha tocado. Para decirle a Vim que redibuje la pantalla: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-L
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-L
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_20.txt*	For Vim version 7.3.  Last change: 2006 Apr 24
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_20.esx*	Para Vim versión 7.3. Último cambio: 24/5/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		     Typing command-line commands quickly
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		    Ser eficaz con la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a few generic features that makes it easier to enter commands.  Colon commands can be abbreviated, edited and repeated.  Completion is available for nearly everything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim posee algunas características genéricas que le facilitan introducir órdenes.  Las órdenes de colon («:») se pueden abreviar, editar y repetir. Dispone de auto compleción para prácticamente todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|20.1|	Command line editing
|20.2|	Command line abbreviations
|20.3|	Command line completion
|20.4|	Command line history
|20.5|	Command line window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|20.1|	Edición en línea de órdenes
|20.2|	Abreviaturas en línea de órdenes
|20.3|	Autocompletado en la línea de órdenes
|20.4|	Histórico de la línea de órdenes
|20.5|	Ventana de la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_21.txt|  Go away and come back
 Previous chapter: |usr_12.txt|  Clever tricks
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_21.esx| Abandonar el editor y volver
  Capítulo anterior: |usr_12.esx| Trucos ingeniosos
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.1*	Command line editing
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.1*	Edición en línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use a colon (:) command or search for a string with / or ?, Vim puts the cursor on the bottom of the screen.  There you type the command or search pattern.  This is called the Command line.  Also when it's used for entering a search command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa una orden de colon («:») o busca una cadena con «/» o «?», Vim sitúa el cursor en la parte inferior de la pantalla. Ahí es donde introduce la orden o el patrón de búsqueda. A esto se le llama la línea de órdenes.  También cuando se usa para introducir una orden de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most obvious way to edit the command you type is by pressing the &lt;BS&gt; key.
This erases the character before the cursor.  To erase another character,
typed earlier, first move the cursor with the cursor keys.
   For example, you have typed this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera más obvia de editar la orden introducida es pulsando la tecla &lt;BS&gt;.
Esto elimina el carácter anterior al cursor. Para eliminar otro carácter
introducido previamente, desplace antes el cursor con las teclas del cursos.
   Por ejemplo, suponga que ha tecleado esto: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s/col/pig/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s/vaba/cerdo/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you hit &lt;Enter&gt;, you notice that "col" should be "cow".  To correct this, you type &lt;Left&gt; five times.  The cursor is now just after "col".  Type &lt;BS&gt; and "w" to correct: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de pulsar &lt;Intro&gt;, notará que «vaba» debería ser «vaca». Para corregir esto, pulse &lt;Izquierda&gt; seis veces. El cursor está ahora sobre «vaba».  Teclee &lt;BS&gt; y «w» para corregirlo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s/cow/pig/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s/vaca/cerdo/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can press &lt;Enter&gt; directly.  You don't have to move the cursor to the end of the line before executing the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya puede pulsar &lt;Intro&gt; directamente. No tiene que desplazar el cursor al final de la línea antes de ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&lt;Left&gt;			one character left
	&lt;Right&gt;			one character right
	&lt;S-Left&gt; or &lt;C-Left&gt;	one word left
	&lt;S-Right&gt; or &lt;C-Right&gt;	one word right
	CTRL-B or &lt;Home&gt;	to begin of command line
	CTRL-E or &lt;End&gt;		to end of command line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&lt;Izquierda&gt;		un carácter a la izquierda
	&lt;Derecha&gt;		un carácter a la derecha
	&lt;S-Izq.&gt; o &lt;C-Izq.&gt;	una palabra a la izquierda
	&lt;S-Der.&gt; o &lt;C-Der.&gt;	una palabra a la derecha
	CTRL-B o &lt;Inicio&gt;	al inicio de la línea de órdenes
	CTRL-E o &lt;Fin&gt;		al final de la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	&lt;S-Left&gt; (cursor left key with Shift key pressed) and &lt;C-Left&gt; (cursor
	left key with Control pressed) will not work on all keyboards.  Same
	for the other Shift and Control combinations.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	&lt;S-Izq.&gt; (tecla izquierda del cursor con la tecla Shift pulsada) y
	&lt;C-Izq.&gt; (tecla izquierda del cursor con la tecla Control pulsada) no
	 funciona en todos los teclados. Ocurre lo mismo con las otras
	 combinaciones con Shift y Control.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned, &lt;BS&gt; deletes the character before the cursor.  To delete a whole word use CTRL-W.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como ya se ha dicho, &lt;BS&gt; elimina el carácter anterior al cursor. Para eliminar toda una palabra, use CTRL-W.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the fine pig ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/el sutil cerdo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		     CTRL-W
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		     CTRL-W
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the fine ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/el sutil ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Insert&gt; key toggles between inserting characters and replacing the existing ones.  Start with this text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Insertar&gt; conmuta entra insertar caracteres y reemplaza los existentes. Comience con este texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the start of "fine" with &lt;S-Left&gt; twice (or &lt;Left&gt; eight times, if &lt;S-Left&gt; doesn't work).  Now press &lt;Insert&gt; to switch to overstrike and type "great":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplace el cursor al inicio de «sutil» con &lt;S-Izq.&gt; dos veces (o &lt;Izq.&gt; ocho veces, si &lt;S-Izq.&gt; no funciona. Pulse ahora &lt;Insertar&gt; para pasar a superposición y teclee «gran»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the greatpig ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/el grancerdo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oops, we lost the space.  Now, don't use &lt;BS&gt;, because it would delete the "t" (this is different from Replace mode).  Instead, press &lt;Insert&gt; to switch from overstrike to inserting, and type the space:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya, hemos perdido un espacio. Ahora, no use &lt;BS&gt; porque eliminaría la «t» (a diferencia del modo Reemplazar). En lugar de ello, pulse &lt;Insertar&gt; para pasar de superposición a insertar, e introduzca el espacio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the great pig ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/el gran cerdo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You thought of executing a : or / command, but changed your mind.  To get rid of what you already typed, without executing it, press CTRL-C or &lt;Esc&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se le ocurrió ejecutar una orden «:» o «/», pero cambió de opinión. Para desechar de lo que ya tecleó sin ejecutarlo pulse CTRL-C o &lt;Esc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	&lt;Esc&gt; is the universal "get out" key.  Unfortunately, in the good old
	Vi pressing &lt;Esc&gt; in a command line executed the command!  Since that
	might be considered to be a bug, Vim uses &lt;Esc&gt; to cancel the command.
	But with the 'cpoptions' option it can be made Vi compatible.  And
	when using a mapping (which might be written for Vi) &lt;Esc&gt; also works
	Vi compatible.  Therefore, using CTRL-C is a method that always works.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	&lt;Esc&gt; es la tecla universal de salir. Desafortunadamente, en el
	bueno y viejo Vi, pulsar &lt;Esc&gt; la línea de órdenes ejecutaba la orden.
	Ya que	esto se puede considerar un fallo, Vim usa &lt;Esc&gt; para cancelar
	la orden.
	Pero puede hacer que sea compatible con Vi con la opción 'cpoptions'.
	Y cuando usa una macro (quizá escrito para Vi) &lt;Esc&gt; también funciona
	de manera compatible con Vi. Por ello, siempre funcionará el metodo
 	CTRL-C.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are at the start of the command line, pressing &lt;BS&gt; will cancel the command.  It's like deleting the ":" or "/" that the line starts with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se halla al inicio de la línea de órdenes, pulsar &lt;BS&gt; cancelaría la orden. Es como eliminar el «:» o «/» al inicio de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.2*	Command line abbreviations
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.2*	Abreviaturas en línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of the ":" commands are really long.  We already mentioned that ":substitute" can be abbreviated to ":s".  This is a generic mechanism, all ":" commands can be abbreviated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas de las órdenes «:» son muy largas. Ya hemos mencionado que «:substitute» se puede abreviar con «:s». Este es un mecanismo genérico, todas las órdenes «:» se pueden abreviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How short can a command get?  There are 26 letters, and many more commands.
For example, ":set" also starts with ":s", but ":s" doesn't start a ":set"
command.  Instead ":set" can be abbreviated to ":se".
   When the shorter form of a command could be used for two commands, it
stands for only one of them.  There is no logic behind which one, you have to
learn them.  In the help files the shortest form that works is mentioned.  For
example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Como de corto puede ser una orden? Hay unas 30 letras, y muchas más órdenes.
Por ejemplo, «:set» también empieza con «:s», pero «:s» no inicia la orden
«:set». En lugar de ello, puede abreviar «:set» con «:se».
   Cuando se podría usar la forma corta de una orden para dos órdenes, sólo
simboliza uno de ellos. No hay una lógica detrás de cada elección, tendrá que
aprenderlos. En los archivos de ayuda se menciona la forma más corta que
funciona.
Por ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s[ubstitute]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s[ubstitute]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that the shortest form of ":substitute" is ":s".  The following characters are optional.  Thus ":su" and ":sub" also work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que la forma corta de «:substitute» es «:s». Los siguientes caracteres son opcionales. Por ello, también funcionan «:su» y «:sub».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the user manual we will either use the full name of command, or a short version that is still readable.  For example, ":function" can be abbreviated to ":fu".  But since most people don't understand what that stands for, we will use ":fun".  (Vim doesn't have a ":funny" command, otherwise ":fun" would be confusing too.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el manual de usuario usaremos o bien el nombre completo de la orden, o una versión corta pero legible. Por ejemplo, se puede acortar «:function» a «:fu».  Pero debido a que la mayoría de la gente no entiende qué simboliza, nosotros usaremos «:fun». (Vim no tiene una orden llamada «:funny», en caso contrario, esto también sería confuso.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that in Vim scripts you write the full command name.  That
makes it easier to read back when you make later changes.  Except for some
often used commands like ":w" (":write") and ":r" (":read").
   A particularly confusing one is ":end", which could stand for ":endif",
":endwhile" or ":endfunction".  Therefore, always use the full name.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recomendamos que escriba la orden completa en los Vim scripts. Esto hace
más fácil leerlo cuando introduce cambios más tarde. A excepción de órdenes
usadas con frecuencia como «:w» («:write») y «:r» («:read»).
  Un caso particularmente confuso es «:end», que podría simbolizar «:endif»,
«:endwhile» o «:endfunction». Por ello, use siempre el nombre completo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the user manual the long version of the option names is used.  Many options also have a short name.  Unlike ":" commands, there is only one short name that works.  For example, the short name of 'autoindent' is 'ai'.  Thus these two commands do the same thing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el manual de usuario se usa la versión larga de los nombres de opción. Varias opciones tienen también un nombre corto. A diferencia de las órdenes «:», sólo hay un nombre corto que funcione. Por ejemplo, el nombre corto de 'autoindent' es 'ai'. Por ello, estas dos órdenes hacen lo mismo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set autoindent
	:set ai
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set autoindent
	:set ai
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.3*	Command line completion
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.3*	Autocompletado en la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is one of those Vim features that, by itself, is a reason to switch from Vi to Vim.  Once you have used this, you can't do without.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una opción que en si misma hace que merezca la pena pasar de Vi a Vim.  Una vez que haya usado esto, no podrá vivir sin el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	info.txt
	intro.txt
	bodyofthepaper.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	info.txt
	intro.txt
	bodyofthepaper.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit bodyofthepaper.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit bodyofthepaper.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's easy to type this wrong.  A much quicker way is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es fácil equivocarse al teclear esto. Una manera más rápida es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit b&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit b&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which will result in the same command.  What happened? The &lt;Tab&gt; key does completion of the word before the cursor.  In this case "b".  Vim looks in the directory and finds only one file that starts with a "b".  That must be the one you are looking for, thus Vim completes the file name for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene a ser la misma orden. ¿Qué ocurrió? La tecla &lt;Tab&gt; realiza el autocompletado de la palabra anterior al cursor. «b» en este caso. Vim busca en el directorio y encuentra sólo un archivo cuyo nombre empieza por «b». Este debe ser el que está buscando, y por ello Vim completa por usted el nombre del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee ahora: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit i&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit i&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit info.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit info.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The beep means that Vim has found more than one match.  It then uses the first match it found (alphabetically).  If you press &lt;Tab&gt; again, you get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El pitido significa que Vim encontró más de una coincidencia. Entonces usa la primera coincidencia encontrada (en orden alfabético). Si pulsa &lt;Tab&gt; otra vez, obtendrá: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit intro.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit intro.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, if the first &lt;Tab&gt; doesn't give you the file you were looking for, press
it again.  If there are more matches, you will see them all, one at a time.
   If you press &lt;Tab&gt; on the last matching entry, you will go back to what you
first typed: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si el primer &lt;Tab&gt; no le da el archivo que está buscando, púlselo
otra vez. Si hay más coincidencias, las verá todas de una en una.  Si pulsa
&lt;Tab&gt; otra vez en la última entrada coincidente, volverá a lo que tecleo en un
principio: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit i
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit i
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	      &lt;------------------- &lt;Tab&gt; -------------------------+
								  |
		  &lt;Tab&gt; --&gt;		       &lt;Tab&gt; --&gt;
	:edit i		      :edit info.txt		   :edit intro.txt
		  &lt;-- CTRL-P		       &lt;-- CTRL-P
	   |
	   +---------------------- CTRL-P ------------------------&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	      &lt;------------------- &lt;Tab&gt; -------------------------+
								  |
		  &lt;Tab&gt; --&gt;		       &lt;Tab&gt; --&gt;
	:edit i		      :edit info.txt		   :edit intro.txt
		  &lt;-- CTRL-P		       &lt;-- CTRL-P
	   |
	   +---------------------- CTRL-P ------------------------&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set icon
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set icon
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set isk&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set isk&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword=@,48-57,_,192-255
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword=@,48-57,_,192-255
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens here is that Vim inserts the old value of the option.  Now you
can edit it.
   What is completed with &lt;Tab&gt; is what Vim expects in that place.  Just try
it out to see how it works.  In some situations you will not get what you
want.  That's either because Vim doesn't know what you want, or because
completion was not implemented for that situation.  In that case you will get
a &lt;Tab&gt; inserted (displayed as ^I).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que aquí ocurre es que Vim inserta el valor antiguo de la opción. Puede
editarla ahora.
   Lo que se completó con &lt;Tab&gt; es lo que Vim espera en primer lugar. Pruebe
esto ahora para ver su funcionamiento. En algunas situaciones no obtendrá lo
que desea. Esto es debido a que Vim no sabe lo que quiere, o porque no se ha
implementado el autocompletado para este evento. En ese caso, obtendrá un
&lt;Tab&gt; insertado (se mostrará como ^I).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are many matches, you would like to see an overview.  Do this by pressing CTRL-D.  For example, pressing CTRL-D after: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando haya coinicidencias, querrá una vista general. Obtenga esto pulsando CTRL-D. Por ejemplo, si pulsa CTRL-D después de: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set is
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set is
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set is
	incsearch  isfname    isident    iskeyword  isprint
	:set is
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set is
	incsearch  isfname    isident    iskeyword  isprint
	:set is
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-L command completes the word to the longest unambiguous string.  If you type ":edit i" and there are files "info.txt" and "info_backup.txt" you will get ":edit info".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-L completa la palabra hasta llegar a la cadena no ambigua más larga. Si teclea «:edit i» y hay archivos «info.txt» e «info_backup.txt» obtendrá «:edit info».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.4*	Command line history
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.4*	Histórico de la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 3 we briefly mentioned the history.  The basics are that you can use the &lt;Up&gt; key to recall an older command line.  &lt;Down&gt; then takes you back to newer commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 3 mencionamos de manera breve el historial. Lo básico es que puede usar la tecla &lt;Arriba&gt; para invocar una orden ya pasada. &lt;Abajo&gt; le lleva a aquellas órdenes más recientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are actually four histories.  The ones we will mention here are for ":" commands and for "/" and "?" search commands.  The "/" and "?" commands share the same history, because they are both search commands.  The two other histories are for expressions and input lines for the input() function.  |cmdline-history|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, hay cuatro historiales. Los que vamos a mencionar aquí son las órdenes «:» y las órdenes de búsqueda «/» y «?». Las órdenes «/» y «?» comparten el mismo historial, ya que ambos son órdenes de búsqueda. Los otros dos historiales sirven para las expresiones y líneas de entrada de la función input().  |cmdline-history|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have done a ":set" command, typed ten more colon commands and then want to repeat that ":set" command again.  You could press ":" and then ten times &lt;Up&gt;.  There is a quicker way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que ejecutó una orden «:set», introdujo diez órdenes «:» más y que después quiera repetir la orden «:set» otra vez. Puede pulsar «:» y diez veces &lt;Arriba&gt;. Existe una manera más rápida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:se&lt;Up&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:se&lt;Up&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will now go back to the previous command that started with "se".  You have a good chance that this is the ":set" command you were looking for.  At least you should not have to press &lt;Up&gt; very often (unless ":set" commands is all you have done).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim volverá ahora a la orden anterior que empezase con «se». Tendrá muchas posibilidades de que esta sea la oren «:set» que estaba buscando. Por lo menos no tendrá que pulsar &lt;Arriba&gt; varias veces (a menos que las órdenes «:set» sea todo lo que ha hecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Up&gt; key will use the text typed so far and compare it with the lines in
the history.  Only matching lines will be used.
   If you do not find the line you were looking for, use &lt;Down&gt; to go back to
what you typed and correct that.  Or use CTRL-U to start all over again.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Arriba&gt; usará el texto introducido hasta el momento y lo comparará
con las líneas en el historial. Solo se usarán las líneas coincidentes.
   En caso de no encontrar la línea que buscaba, use &lt;Down&gt; para volver a lo
que tecleó y corrija eso. O use CTRL-U para iniciar el proceso otra vez. 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:history
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:history
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's the history of ":" commands.  The search history is displayed with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el historial de las órdenes «:». Puede ver el historial de búsquedas con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:history /
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:history /
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.5*	Command line window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.5*	Ventana de la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing the text in the command line works different from typing text in Insert mode.  It doesn't allow many commands to change the text.  For most commands that's OK, but sometimes you have to type a complicated command.  That's where the command line window is useful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear el texto en la línea de órdenes funciona de manera distinta a teclear texto en el modo Insertar. No permite a varias órdenes modificar el texto.  Esto está bien para varias órdenes, aunque a veces tiene que teclear una orden complicada. En esta situación es cuando la ventana de línea de órdenes es útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	q:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	q:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim now opens a (small) window at the bottom.  It contains the command line history, and an empty line at the end:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá ahora una pequeña ventana en la base. Contiene el historial de la línea de órdenes, y una línea vacía al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------+
	|other window			      |
	|~				      |
	|file.txt=============================|
	|:e c				      |
	|:e config.h.in			      |
	|:set path=.,/usr/include,,	      |
	|:set iskeyword=@,48-57,_,192-255     |
	|:set is			      |
	|:q				      |
	|:				      |
	|command-line=========================|
	|				      |
	+-------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------------+
	|otra ventana			      |
	|~				      |
	|file.txt=============================|
	|:e c				      |
	|:e config.h.in			      |
	|:set path=.,/usr/include,,	      |
	|:set iskeyword=@,48-57,_,192-255     |
	|:set is			      |
	|:q				      |
	|:				      |
	|línea de órdenes=====================|
	|				      |
	+-------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now in Normal mode.  You can use the "hjkl" keys to move around.  For example, move up with "5k" to the ":e config.h.in" line.  Type "$h" to go to the "i" of "in" and type "cwout".  Now you have changed the line to:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora se encuentra en el modo Normal. Puede usar las teclas «hjkl» para desplazarse. Por ejemplo, desplácese con «5k» hasta la línea «:e config.h.in». Teclee «$h» para ir a la «i» de «in» y teclee «cwout».  Ahora, ha cambiado la línea a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:e config.h.out ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:e config.h.out ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command line window is very useful when you want to have overview of the
history, lookup a similar command, change it a bit and execute it.  A search
command can be used to find something.
   In the previous example the "?config" search command could have been used
to find the previous command that contains "config".  It's a bit strange,
because you are using a command line to search in the command line window.
While typing that search command you can't open another command line window,
there can be only one.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana de línea de órdenes es muy útil cuando quiere una vista general
del historial, mirar una orden similar, modificarlo y ejecutarlo. Puede usar
una orden de búsqueda para buscar algo.
   En el ejemplo anterior, la orden de búsqueda «?config» se podría haber
usado para encontrar una orden anterior que contenga «?config». Es un poco
extraño, pues está usando una línea de órdenes para buscar en la ventana de
línea de órdenes. No podrá abrir otra ventana de línea de órdenes mientras
teclee la orden de búsqueda, ya que sólo puede haber una.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_08.txt*	For Vim version 7.3.  Last change: 2006 Jul 18
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_08.esx*	Para Vim versión 7.3.  Último cambio: 18/6/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Splitting windows
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			    Dividir en ventanas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display two different files above each other.  Or view two locations in the file at the same time.  See the difference between two files by putting them side by side.  All this is possible with split windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mostrar dos archivos diferentes uno encima del otro. Mirar dos puntos del mismo archivo a la vez. Ver las diferencias entre un archivo y otro poniéndolos uno al lado del otro. Todo esto es posible dividiendo en ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|08.1|	Split a window
|08.2|	Split a window on another file
|08.3|	Window size
|08.4|	Vertical splits
|08.5|	Moving windows
|08.6|	Commands for all windows
|08.7|	Viewing differences with vimdiff
|08.8|	Various
|08.9|  Tab pages
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|08.1|	Dividir una ventana
|08.2|	Dividir una ventana con otro archivo
|08.3|	Tamaño de ventana
|08.4|	Divisiones verticales
|08.5|	Mover ventanas
|08.6|	Órdenes sobre todas las ventanas
|08.7|	Ver las diferencias con «vimdiff»
|08.8|	Varios
|08.9|	Pestañas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_09.txt|  Using the GUI
 Previous chapter: |usr_07.txt|  Editing more than one file
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_09.esx|  Uso de la interfaz gráfica
  Capítulo anterior: |usr_07.esx|  Editar más de un archivo
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.1*	Split a window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.1*  Dividir una ventana
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:split
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:split
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	|/* file one.c */		   |
	|~				   |
	|~				   |
	|one.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	|/* archivo uno.c */		   |
	|~				   |
	|~				   |
	|uno.c=============================|
	|/* archivo uno.c */		   |
	|~				   |
	|uno.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-W w command can be used to jump between the windows.  If you are in the top window, CTRL-W w jumps to the window below it.  If you are in the bottom window it will jump to the first window.  (CTRL-W CTRL-W does the same thing, in case you let go of the CTRL key a bit later.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-W w se puede usar para saltar de una ventana a otra. Si está en la ventana superior, CTRL-W w salta a la ventana inferior. Si está en la ventana inferior saltará a la primera ventana. (CTRL-W CTRL-W hace lo mismo, en caso de que suelte la tecla CTRL un poco después.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:close
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:close
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, any command that quits editing a file works, like ":quit" and "ZZ".  But ":close" prevents you from accidentally exiting Vim when you close the last window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, cualquier orden que salga del archivo funciona, como «:quit» y «ZZ». Pero «:close» evitará que salga accidentalmente de Vim cuando cierre la última ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:only
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:only
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This closes all windows, except for the current one.  If any of the other windows has changes, you will get an error message and that window won't be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto cierra todas las ventanas, excepto la actual. Si cualquiera de las otras ventanas tiene cambios, obtendrá un mensaje de error y esa ventana no se cerrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.2*	Split a window on another file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.2*	Dividir una ventana con otro archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following command opens a second window and starts editing the given file:
&gt;
	:split two.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente orden abre una segunda ventana y comienza la edición de un
archivo:
&gt;
	:split two.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	|/* archivo dos.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* archivo uno.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:new
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:new
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.3*	Window size
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.3*	Tamaño de ventana
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":split" command can take a number argument.  If specified, this will be the height of the new window.  For example, the following opens a new window three lines high and starts editing the file alpha.c: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:split» puede recibir un argumento numérico. Si se especifica, este será la altura de la nueva ventana. Por ejemplo, el siguiente abre una nueva ventana con una altura de tres líneas y edita el archivo alpha.c: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:3split alpha.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:3split alpha.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For existing windows you can change the size in several ways.  When you have a working mouse, it is easy: Move the mouse pointer to the status line that separates two windows, and drag it up or down.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ventanas ya existentes puede cambiar el tamaño de varias formas.  Cuando tiene un ratón, es fácil: Coloque el puntero en la línea de estado que separa las dos ventanas y arrástrela.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W +
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W +
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W -
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W -
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both of these commands take a count and increase or decrease the window size by that many lines.  Thus "4 CTRL-W +" make the window four lines higher.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ambas órdenes reciben un multiplicador que modificará la altura de ventana ese número de líneas. «4 CTRL-W +» hará la ventana cuatro líneas más alta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{height}CTRL-W _
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{altura}CTRL-W _
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's: a number {height}, CTRL-W and then an underscore (the - key with Shift
on English-US keyboards).
   To make a window as high as it can be, use the CTRL-W _ command without a
count.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O sea: un número {altura}, CTRL-W y luego un guión bajo (Mayúsculas más la
tecla -).
   Para maximizar una ventana, use la orden CTRL-W _ sin ningún
multiplicador ni argumento.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim you can do many things very quickly from the keyboard.  Unfortunately, the window resizing commands require quite a bit of typing.  In this case, using the mouse is faster.  Position the mouse pointer on a status line.  Now press the left mouse button and drag.  The status line will move, thus making the window on one side higher and the other smaller.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim puede hacer muchas cosas muy rápidamente desde el teclado. Por desgracia, las órdenes de ajuste de las ventanas requieren mucho trabajo.  En este caso, usar el ratón es más rápido. Coloque el ratón sobre la línea de estado. Ahora presione el botón izquierdo y arrastre. La línea de estado se desplazará, ajustando el tamaño de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'winheight' option can be set to a minimal desired height of a window and
'winminheight' to a hard minimum height.
   Likewise, there is 'winwidth' for the minimal desired width and
'winminwidth' for the hard minimum width.
   The 'equalalways' option, when set, makes Vim equalize the windows sizes
when a window is closed or opened.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'winheight' se puede ajustar a una altura mínima de ventana y
'winminheight' a un mínimo estricto.
   Del mismo modo, hay un ancho 'winwidth' para el ancho mínimo deseado y un
'winminheight' para un ancho mínimo estricto.
   La opción 'equalalways', cuando está activa, hace que Vim equilibre el
tamaño de las ventanas cuando éstas se cierran o se abren nuevas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.4*	Vertical splits
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.4*	Divisiones verticales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":split" command creates the new window above the current one.  To make the window appear at the left side, use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:split» crea una nueva ventana sobre la actual. Para hacer que una ventana aparezca en el lateral izquierda, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:vsplit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:vsplit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or: &gt;
	:vsplit two.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>o: &gt;
	:vsplit two.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+--------------------------------------+
	|/* file two.c */   |/* file one.c */  |
	|~		    |~		       |
	|~		    |~		       |
	|~		    |~		       |
	|two.c===============one.c=============|
	|				       |
	+--------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+--------------------------------------+
	|/*archivo dos.c */ |/*archivo uno.c */|
	|~                  |~                 |
	|~                  |~                 |
	|~                  |~                 |
	|two.c===============one.c=============|
	|                                      |
	+--------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also the ":vnew" command, to open a vertically split window on a new, empty file.  Another way to do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hay una orden «:vnew», para abrir una partición vertical con un archivo nuevo. Otra forma de hacer esto es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:vertical new
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:vertical new
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":vertical" command can be inserted before another command that splits a window.  This will cause that command to split the window vertically instead of horizontally.  (If the command doesn't split a window, it works unmodified.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:vertical» se puede insertar justo antes de otra orden que divida la ventana. Esto puede hacer que la ventana se divida verticalmente en lugar de horizontalmente. (Si la orden no divide ventanas se ejecuta de modo normal.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since you can split windows horizontally and vertically as much as you like, you can create almost any layout of windows.  Then you can use these commands to move between them:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que puede dividir ventanas horizontal y verticalmente a voluntad, puede crear casi cualquier estructura. Una vez las haya creado se puede desplazar por ellas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W h	move to the window on the left
	CTRL-W j	move to the window below
	CTRL-W k	move to the window above
	CTRL-W l	move to the window on the right
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W h        moverse a la ventana de la izquierda
	CTRL-W j        moverse a la ventana de abajo
	CTRL-W k        moverse a la ventana de arriba
	CTRL-W l        moverse a la ventana de la derecha
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W t	move to the TOP window
	CTRL-W b	move to the BOTTOM window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W t        moverse a la ventana superior (TOP)
	CTRL-W b        moverse a la ventana inferior (BOTTOM)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the same letters as used for moving the cursor.  And the
cursor keys can also be used, if you like.
   More commands to move to other windows: |Q_wi|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se habrá dado cuenta de que son las mismas teclas empleadas para mover el
cursor. También puede usar las teclas de flechas si lo desea.
   Más órdenes para moverse a otras ventanas: |Q_wi|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.5*	Moving windows
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.5*	Mover ventanas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have split a few windows, but now they are in the wrong place.  Then you need a command to move the window somewhere else.  For example, you have three windows like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imagine que ha creado unas cuantas ventanas, pero están en el lugar equivocado. Necesitará una orden para mover las ventanas a otro lugar. Por ejemplo, tiene tres ventanas como estas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file three.c */		   |
	|~				   |
	|~				   |
	|three.c===========================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	|/* archivo dos.c */		   |
	|~				   |
	|~				   |
	|dos.c=============================|
	|/* archivo tres.c */		   |
	|~				   |
	|~				   |
	|tres.c============================|
	|/* archivo uno.c */		   |
	|~				   |
	|uno.c=============================|
	|				   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clearly the last one should be at the top.  Go to that window (using CTRL-W w)  and the type this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente la última ventana debería estar en la parte superior. Vaya a esa ventana (usando CTRL-W w) y luego teclee la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W K
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W K
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------------+
	|/* two.c */  |/* three.c */  |/* one.c */  |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|two.c=========three.c=========one.c========|
	|					    |
	+-------------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------------------+
	|/* dos.c */  |/*  tres.c */  |/* uno.c */  |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|dos.c==========tres.c=========uno.c========|
	|					    |
	+-------------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------------+
	|/* three.c */				    |
	|~					    |
	|~					    |
	|three.c====================================|
	|/* two.c */	       |/* one.c */	    |
	|~		       |~		    |
	|two.c==================one.c===============|
	|					    |
	+-------------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------------------+
	|/* tres.c */				    |
	|~					    |
	|~					    |
	|tres.c=====================================|
	|/* dos.c */	       |/* uno.c */	    |
	|~		       |~		    |
	|dos.c==================uno.c===============|
	|					    |
	+-------------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W H	move window to the far left
	CTRL-W J	move window to the bottom
	CTRL-W L	move window to the far right
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W H	mover la ventana al extremo izquierdo
	CTRL-W J	mover la ventana al extremo inferior
	CTRL-W L	mover la ventana al extremo derecho
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.6*	Commands for all windows
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.6*	Órdenes sobre todas las ventanas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have several windows open and you want to quit Vim, you can close each window separately.  A quicker way is using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene varias ventanas abiertas y quiere salir de Vim, puede cerrar cada ventana por su cuenta. Una forma más rápida es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:qall
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:qall
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stands for "quit all".  If any of the windows contain changes, Vim will not exit.  The cursor will automatically be positioned in a window with changes.  You can then either use ":write" to save the changes, or ":quit!" to throw them away.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene de «quit all» (cerrar todo). Si alguna de las ventanas contiene cambios, Vim no saldrá. El cursor se pondrá automáticamente en la ventana con cambios. Puede usar «:w» para guardar los cambios, o «:q!» para eliminarlos completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wall
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wall
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stands for "write all".  But actually, it only writes files with
changes.  Vim knows it doesn't make sense to write files that were not
changed.
   And then there is the combination of ":qall" and ":wall": the "write and
quit all" command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene de «write all» (escribir/guardar todo). Pero, de hecho, sólo
escribe archivos con cambios. Vim sabe que no tiene sentido guardar
archivos sin cambios.
   También hay una combinación de «:qall» y «:wall»: la orden «guardar y
salir de todas las ventanas»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wqall
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wqall
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This writes all modified files and quits Vim.
   Finally, there is a command that quits Vim and throws away all changes: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guarda todos los archivos modificados y sale de Vim.
   Por último, hay una orden que sale de Vim y no guarda nada: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:qall!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:qall!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -o one.txt two.txt three.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -o uno.txt dos.txt tres.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------+
	|file one.txt			|
	|~				|
	|one.txt========================|
	|file two.txt			|
	|~				|
	|two.txt========================|
	|file three.txt			|
	|~				|
	|three.txt======================|
	|				|
	+-------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------+
	|archivo uno.txt		|
	|~				|
	|uno.txt========================|
	|archivo dos.txt		|
	|~				|
	|dos.txt========================|
	|archivo tres.txt		|
	|~				|
	|tres.txt=======================|
	|				|
	+-------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-O" argument is used to get vertically split windows.
   When Vim is already running, the ":all" command opens a window for each
file in the argument list.  ":vertical all" does it with vertical splits.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-O"» se usa para que las divisiones se hagan verticalmente.
   Cuando Vim está ejecutándose, la orden «:all» abre una ventana para cada
archivo en la lista de argumentos.  «:vertical all» lo hace verticalmente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.7*	Viewing differences with vimdiff
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.7*	Ver las diferencias con «vimdiff»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a special way to start Vim, which shows the differences between two
files.  Let's take a file "main.c" and insert a few characters in one line.
Write this file with the 'backup' option set, so that the backup file
"main.c~" will contain the previous version of the file.
   Type this command in a shell (not in Vim): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una manera especial de arrancar Vim que muestra las diferencias entre
dos archivos. Cojamos un archivo «main.c» e insertemos unos caracteres en una
línea. Escriba el archivo con la opción 'backup' activada, de manera que el
archivo «main.c~» contendrá la versión anterior.
   Escribe la siguiente orden en una consola (no en Vim): &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vimdiff main.c~ main.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vimdiff main.c~ main.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will start, with two windows side by side.  You will only see the line in which you added characters, and a few lines above and below it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim arrancará con dos ventanas verticales. Verá solamente la línea en la que ha añadido los cambios y unas cuántas líneas por debajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	 VV		      VV
	+-----------------------------------------+
	|+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- fold
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	changed text	  |  &lt;- changed line
	|  text		     |	text		  |
	|  text		     |	------------------|  &lt;- deleted line
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|+ +--432 lines: text|+ +--432 lines: text|  &lt;- fold
	|  ~		     |	~		  |
	|  ~		     |	~		  |
	|main.c~==============main.c==============|
	|					  |
	+-----------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	 VV		      VV
	+-----------------------------------------+
	|+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- pliegue
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto modificado  |  &lt;- línea modificada
	|  texto	     |	texto		  |
	|  texto	     |	------------------|  &lt;- línea eliminada
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|+ +--432 lines:texto|+ +--432 lines:texto|  &lt;- pliegue
	|  ~		     |	~		  |
	|  ~		     |	~		  |
	|main.c~==============main.c==============|
	|					  |
	+-----------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lines that were not modified have been collapsed into one line.  This is
called a closed fold.  They are indicated in the picture with "&lt;- fold".  Thus
the single fold line at the top stands for 123 text lines.  These lines are
equal in both files.
   The line marked with "&lt;- changed line" is highlighted, and the inserted
text is displayed with another color.  This clearly shows what the difference
is between the two files.
   The line that was deleted is displayed with "---" in the main.c window.
See the "&lt;- deleted line" marker in the picture.  These characters are not
really there.  They just fill up main.c, so that it displays the same number
of lines as the other window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas que no se modificaron se han agrupado en una sola línea. A
esto se le denomina pliegue (fold) cerrado. Se indican con «&lt;- pliegue»
en la figura. La línea de arriba marca que hay 123 líneas. Estas líneas son
iguales en ambos archivos.
   La línea marcada con «&lt;- línea modificada» está resaltada y el texto
insertado se muestra con otro color. Esto muestra claramente las
diferencias entre los dos archivos.
   La línea que se eliminó se muestra con «---» en la ventana «main.c».
Observe el «&lt;- línea eliminada» en la figura. Estos caracteres no están ahí
realmente. Simplemente llenan el espacio necesario en «main.c» para que
ambos archivos tengan el mismo número de líneas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each window has a column on the left with a slightly different background.  In
the picture above these are indicated with "VV".  You notice there is a plus
character there, in front of each closed fold.  Move the mouse pointer to that
plus and click the left button.  The fold will open, and you can see the text
that it contains.
   The fold column contains a minus sign for an open fold.  If you click on
this -, the fold will close.
   Obviously, this only works when you have a working mouse.  You can also use
"zo" to open a fold and "zc" to close it.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada ventana tiene una columna en la izquierda que tiene un fondo
ligeramente diferente. En la figura de arriba se indican con «VV». Fíjese
que hay un carácter «+» en ese sitio, enfrente de cada pliegue cerrado.
Mueva el puntero del ratón a ese signo «+» y pulse el botón izquierdo. 
Esto abrirá el pliegue, mostrando el texto que contiene.
   La columna del pliegue muestra un «-» para un pliegue abierto. Si pulsa
este «-», el pliegue se cerrará.
   Obviamente, esto sólo funciona cuando tiene un ratón configurado. También
puedes usar «zo» para abrir un pliegue y «zc» para cerrarlo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to start in diff mode can be done from inside Vim.  Edit the "main.c" file, then make a split and show the differences: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera de iniciar el modo diff es hacerlo desde Vim. Edite el archivo «main.c», haga después un «split» y muestre las diferencias: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit main.c
	:vertical diffsplit main.c~ 
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit main.c
	:vertical diffsplit main.c~ 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":vertical" command is used to make the window split vertically.  If you omit this, you will get a horizontal split.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:vertical» se usa para hacer que las ventanas se dividan verticalmente. Si omite esto, obtendrá una división horizontal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a patch or diff file, you can use the third way to start diff mode.  First edit the file to which the patch applies.  Then tell Vim the name of the patch file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene un parche o un archivo diff, puede usarlo como una tercera manera de iniciar el modo diff. Primero edite el archivo sobre el cuál se aplica el parche. Entonces escribe la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit main.c
	:vertical diffpatch main.c.diff
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit main.c
	:vertical diffpatch main.c.diff
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARNING: The patch file must contain only one patch, for the file you are
editing.  Otherwise you will get a lot of error messages, and some files might
be patched unexpectedly.
   The patching will only be done to the copy of the file in Vim.  The file on
your harddisk will remain unmodified (until you decide to write the file).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>AVISO: El parche debe contener un solo parche, el del archivo que está
editando. En caso contrario, recibirá muchos de mensajes de error y
algunos archivos pueden verse parcheados de forma imprevista.
   El parcheo será realizado sólo sobre una copia del archivo en Vim. El
archivo del disco duro no se modificará hasta que no lo guardes.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the files have more changes, you can scroll in the usual way.  Vim will
try to keep both the windows start at the same position, so you can easily see
the differences side by side.
   When you don't want this for a moment, use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando los archivos tienen muchos cambios, puede desplazarse de manera
normal. Vim intentará hacer que ambas ventanas comiencen con el mismo
desplazamiento, para que pueda ver las diferencias en cada lado.
   Cuando no quiera que esto ocurra, use lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set noscrollbind
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set noscrollbind
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have disabled folding in some way, it may be difficult to find the changes.  Use this command to jump forward to the next change: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando haya desactivado los pliegues de algún modo, puede ser más difícil encontrar los cambios. Use esta orden para saltar al siguiente cambio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	]c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	]c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can move text from one window to the other.  This either removes differences or adds new ones.  Vim doesn't keep the highlighting updated in all situations.  To update it use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mover texto de una ventana a otra. Esto elimina diferencias o añade unas nuevas. Vim no mantiene el texto resaltado en todas las situaciones.  Para actualizarlo deberá escribir: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:diffupdate
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:diffupdate
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove a difference, you can move the text in a highlighted block from one window to another.  Take the "main.c" and "main.c~" example above.  Move the cursor to the left window, on the line that was deleted in the other window.  Now type this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una diferencia, puede mover el texto de un bloque resaltado desde una ventana a otra. Suponga el «main.c» y el «main.c~» del ejemplo.  Mueva el cursor a la izquierda de la ventana, sobre la línea que se eliminó en la otra ventana. Ahora escriba esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	dp
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	dp
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will be removed by putting the text of the current window in the
other window.  "dp" stands for "diff put".
   You can also do it the other way around.  Move the cursor to the right
window, to the line where "changed" was inserted.  Now type this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio se eliminará poniendo el texto de la ventana actual en la otra
ventana. «dp» viene de «diff put» (put = poner).
   Puede hacerlo también de la forma completamente opuesta. Mueva el cursor
a la ventana de la derecha, donde se insertó el cambio. Escriba: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	do
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	do
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will now be removed by getting the text from the other window.  Since there are no changes left now, Vim puts all text in a closed fold.  "do" stands for "diff obtain".  "dg" would have been better, but that already has a different meaning ("dgg" deletes from the cursor until the first line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio será ahora eliminado obteniendo el texto desde la otra ventana.  Ya que no hay cambios restantes, Vim pondrá todo el texto en un pliegue cerrado.  «do» viene de «diff obtain» (obtain = obtener). «dg» podría ser mejor (de g = get = obtener) pero «dgg» ya tenía un significado diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.8*	Various
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.8*	Varios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	0	never
	1	only when there are split windows (the default)
	2	always
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	0	nunca
	1	sólo cuando hay más ventanas (predeterminado)
	2	siempre
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many commands that edit another file have a variant that splits the window.
For Command-line commands this is done by prepending an "s".  For example:
":tag" jumps to a tag, ":stag" splits the window and jumps to a
tag.
   For Normal mode commands a CTRL-W is prepended.  CTRL-^ jumps to the
alternate file, CTRL-W CTRL-^ splits the window and edits the alternate file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchas órdenes que editan otro archivo disponen de una variante que divide la
ventana. Para los de la línea de órdenes se hace con el prefijo «s». Por
ejemplo «:tag» salta a una etiqueta, «:stag» divide la ventana y salta a la
etiqueta.
   Para órdenes del modo normal se teclea CTRL-W antes. CTRL-^ salta al
archivo alterno, CTRL-W CTRL-^ divide la ventana y edita el archivo alterno.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'splitbelow' option can be set to make a new window appear below the current window.  The 'splitright' option can be set to make a vertically split window appear right of the current window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede activar la opción 'splitbelow' para hacer que la nueva ventana aparezca debajo de la actual. Puede activar la opción 'splitright' para hacer que una partición vertical aparezca a la derecha de la ventana actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:leftabove {cmd}	left or above the current window
	:aboveleft {cmd}	idem
	:rightbelow {cmd}	right or below the current window
	:belowright {cmd}	idem
	:topleft {cmd}		at the top or left of the Vim window
	:botright {cmd}		at the bottom or right of the Vim window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:leftabove {cmd}	izquierda o encima de la actual
	:aboveleft {cmd}	ídem
	:rightbelow {cmd}	derecha o debajo de la actual
	:belowright {cmd}	ídem
	:topleft {cmd}		encima o a la izquierda de la ventana de 					Vim
	:botright {cmd}		debajo o a la derecha de la ventana de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.9*	Tab pages
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.9*	Pestañas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have noticed that windows never overlap.  That means you quickly run out of screen space.  The solution for this is called Tab pages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habrá notado que las ventanas no se superponen. Esto significa que puede rápidamente acabar sin espacio suficiente. La solución son las pestañas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assume you are editing "thisfile".  To create a new tab page use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editando «estearchivo». Para crear una nueva pestaña: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tabedit thatfile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tabedit «aquélarchivo»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will edit the file "thatfile" in a window that occupies the whole Vim window.  And you will notice a bar at the top with the two file names:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto editará el archivo «aquélarchivo» en una ventana que ocupe todo el espacio de Vim. Verá que hay una nueva barra en la parte superior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	| thisfile | /thatfile/ __________X|    (thatfile is bold)
	|/* thatfile */			   |
	|that				   |
	|that				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	| estearchivo | /aquélarchivo/ ___X|   (aquélarchivo está en
	|				   |	negrita)
	|/* aquélarchivo */		   |
	|aquél				   |
	|aquél				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have two tab pages.  The first one has a window for "thisfile" and the second one a window for "thatfile".  It's like two pages that are on top of eachother, with a tab sticking out of each page showing the file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora tiene dos pestañas. La primera tiene una ventana para «estearchivo» y la segunda para «aquélarchivo». Es como dos páginas una encima de la otra, con una pestaña sobresaliendo de cada página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	| /thisfile/ | thatfile __________X|    (thisfile is bold)
	|/* thisfile */			   |
	|this				   |
	|this				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	| /estearchivo/ | aquélarchivo ___X|   (estearchivo está en
	|				   |	negrita)
	|/* estearchivo */		   |
	|este				   |
	|este				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can switch between tab pages by clicking on the label in the top line.  If you don't have a mouse or don't want to use it, you can use the "gt" command.  Mnemonic: Goto Tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo puede pasar entre pestañas pulsando sobre la etiqueta de la línea superior. Si no dispone del ratón o no lo quiere usar, puede emplear la orden «gt».  Nemotecnia: Goto Tab (ir a pestaña).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tab split
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tab split
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------+
	| thisfile | /thisfile/ | thatfile __X|   (thisfile is bold)
	|/* thisfile */			      |
	|this				      |
	|this				      |
	|~				      |
	|~				      |
	|~				      |
	|				      |
	+-------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------------------+
	| estearchivo | /estearchivo/ | aquélarchivo _X| (estearchivo está
	|/* estearchivo */			       |  en negrita)
	|este					       |
	|este					       |
	|~					       |
	|~					       |
	|~					       |
	|					       |
	+----------------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put ":tab" before any Ex command that opens a window.  The window will be opened in a new tab page.  Another example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede poner «:tab» antes de cualquier orden «Ex» que abra una ventana. La ventana se abrirá en una nueva ventana. Otro ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tab help gt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tab help gt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- click with the mouse on the "X" in the top right corner
	The current tab page will be closed.  Unless there are unsaved
	changes in the current tab page.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- pulse con el ratón sobre la «X» en la esquina superior derecha.
	La pestaña actual se cerrará a menos que haya cambios sin guardar en la
	pestaña.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- double click with the mouse in the top line
	A new tab page will be created.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- doble pulsación con el ratón sobre la línea superior
	Se creará una nueva ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_02.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_02.esx*	Para Vim versión 7.3.  Último cambio: 20/6/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			    The first steps in Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Primeros pasos en Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter provides just enough information to edit a file with Vim.  Not well or fast, but you can edit.  Take some time to practice with these commands, they form the base for what follows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo ofrece suficiente información para editar un archivo con Vim.  No bien ni rápido, pero podrá editar. Tómese un tiempo para practicar estas órdenes, son la base de lo que sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|02.1|	Running Vim for the First Time
|02.2|	Inserting text
|02.3|	Moving around
|02.4|	Deleting characters
|02.5|	Undo and Redo
|02.6|	Other editing commands
|02.7|	Getting out
|02.8|	Finding help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|02.1|	Ejecutar Vim por primera vez
|02.2|	Insertar texto
|02.3|	Movimiento
|02.4|	Eliminar caracteres
|02.5|	Deshacer y rehacer
|02.6|	Otras órdenes de edición
|02.7|	Salir
|02.8|	Encontrar ayuda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_03.txt|  Moving around
 Previous chapter: |usr_01.txt|  About the manuals
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_03.esx|  Desplazamiento
  Capítulo anterior: |usr_01.esx|  Acerca de los manuales
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.1*	Running Vim for the First Time
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.1*	Ejecutar Vim por primera vez
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim file.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In UNIX you can type this at any command prompt.  If you are running Microsoft
Windows, open an MS-DOS prompt window and enter the command.
   In either case, Vim starts editing a file called file.txt.  Because this
is a new file, you get a blank window. This is what your screen will look
like:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En UNIX puede introducir esta orden en cualquier interprete de órdenes. Si está
bajo Microsoft Windows, abra una terminal de MS-DOS e introduzca la orden.
   En ambos casos, Vim se inicia con la edición de un archivo llamado file.txt.
Ya que es un archivo nuevo, obtendrá un ventana vacía. Así es como su pantalla
debería aparecer:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|#					|
	|~					|
	|~					|
	|~					|
	|~					|
	|"file.txt" [New file]			|
	+---------------------------------------+
		('#" is the cursor position.)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|#					|
	|~					|
	|~					|
	|~					|
	|~					|
	|"file.txt" [Archivo nuevo]		|
	+---------------------------------------+
		('#" es la posición del cursor.)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tilde (~) lines indicate lines not in the file.  In other words, when Vim runs out of file to display, it displays tilde lines.  At the bottom of the screen, a message line indicates the file is named file.txt and shows that you are creating a new file.  The message information is temporary and other information overwrites it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas con tilde (~) indican líneas que no se hallan en el archivo.  En otras palabras, cuando Vim se queda sin archivo que mostrar muestra líneas con tilde. En la parte inferior de la pantalla, un mensaje muestra que el archivo se llama file.txt y que está creando un archivo nuevo. La información del mensaje es temporal y otra información la sobreescribirá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gvim command causes the editor to create a new window for editing.  If you use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «gvim» hace que el editor cree una nueva ventana para editar.  Si usa la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim file.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the editing occurs inside your command window.  In other words, if you are running inside an xterm, the editor uses your xterm window.  If you are using an MS-DOS command prompt window under Microsoft Windows, the editing occurs inside this window.  The text in the window will look the same for both versions, but with gvim you have extra features, like a menu bar.  More about that later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>la edición ocurre dentro de la ventana de llamada. En otras palabras, si está dentro de una xterm, el editor usa su ventana xterm. Si está usando una terminal de MS-DOS bajo Windows, la edición tendrá lugar dentro de esta ventana.  El texto en la ventana tendrá el mismo aspecto en ambas versiones, pero con gvim tiene características extra, como una barra de menú. Volveremos a este punto posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.2*	Inserting text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.2*	Insertar texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	iA very intelligent turtle
	Found programming UNIX a hurdle
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	iA very intelligent turtle
	Found programming UNIX a hurdle
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After typing "turtle" you press the &lt;Enter&gt; key to start a new line.  Finally you press the &lt;Esc&gt; key to stop Insert mode and go back to Normal mode.  You now have two lines of text in your Vim window:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras teclear «turtle», pulse la tecla &lt;Intro&gt; para comenzar una nueva línea.  Por último, presione la tecla &lt;Esc&gt; para salir del modo Insertar y volver al modo Normal. Ahora tienes dos línea de texto en su ventana de Vim:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set showmode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set showmode
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that when typing the colon Vim moves the cursor to the last
line of the window.  That's where you type colon commands (commands that start
with a colon).  Finish this command by pressing the &lt;Enter&gt; key (all commands
that start with a colon are finished this way).
   Now, if you type the "i" command Vim will display --INSERT-- at the bottom
of the window.  This indicates you are in Insert mode.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comprobará que cuando introduce dos puntos, Vim desplaza el cursor a la
última línea de la ventana. Allí es donde introducirá órdenes con dos puntos
(órdenes que comienzan con dos puntos). Finalice la orden presionando la
tecla &lt;Intro&gt; (todas estas órdenes se finalizan de este modo).
   Si pulsase ahora la orden «i», Vim mostrará --INSERT-- en la parte
inferior de la ventana. Esto indica que está en el modo Insertar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|-- INSERT --				|
	+---------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|-- INSERT --				|
	+---------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the problems for Vim novices is mode confusion, which is caused by forgetting which mode you are in or by accidentally typing a command that switches modes.  To get back to Normal mode, no matter what mode you are in, press the &lt;Esc&gt; key.  Sometimes you have to press it twice.  If Vim beeps back at you, you already are in Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de los problemas para los que comienzan a usar Vim es la confusión de los modos, que se produce al olvidar en qué modo está o por teclear accidentalmente una orden que cambia de modo. Para volver al modo Normal, no importa el modo en el que esté,presione la tecla &lt;Esc&gt;. En algunas ocasiones, tendrá que presionarlo dos veces. Si Vim emite un pitido, entonces es que está de vuelta al modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.3*	Moving around
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.3*	Movimiento
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	h   left						*hjkl*
	j   down
	k   up
	l   right
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	h   izquierda						*hjkl*
	j   abajo
	k   arriba
	l   derecha
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At first, it may appear that these commands were chosen at random.  After all, who ever heard of using l for right? But actually, there is a very good reason for these choices: Moving the cursor is the most common thing you do in an editor, and these keys are on the home row of your right hand.  In other words, these commands are placed where you can type them the fastest (especially when you type with ten fingers).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un principio, puede parecer que estas órdenes se han elegido arbitrariamente. Después de todo, ¿quién ha visto usar l para derecha? De hecho, hay una buena razón para esto: mover el cursor es una de las cosas más comunes que hará en un editor, y estas teclas están en la fila central de su mano derecha. En otras palabras, estas órdenes se sitúan donde puede teclearlos de manera más rápida (especialmente cuando escribe con diez dedos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	You can also move the cursor by using the arrow keys.  If you do,
	however, you greatly slow down your editing because to press the arrow
	keys, you must move your hand from the text keys to the arrow keys.
	Considering that you might be doing it hundreds of times an hour, this
	can take a significant amount of time.
	   Also, there are keyboards which do not have arrow keys, or which
	locate them in unusual places; therefore, knowing the use of the hjkl
	keys helps in those situations.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	También puede mover el cursor usando las flechas. Si lo haces, sin
	embargo, ralentizará considerablemente la edición, ya que para ello
	tendrá que desplazar su mano desde las letras a las flechas del
	teclado. Teniendo en cuenta que debe hacerlo cientos de veces cada
	hora, esto puede llevar un tiempo considerable.
	   Además, hay teclados que no tienen teclas de flechas, o que las
	colocan en lugares inusuales; por lo tanto, conocer el uso de hjkl
	ayuda en esas situaciones.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to remember these commands is that h is on the left, l is on the right and j points down.  In a picture: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una manera de recordar estas órdenes es que la h está a la izquierda, l en la derecha y j apunta hacia abajo. En un esquema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		       k
		   h     l
		     j
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		      k
		   h     l
		      j
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to learn these commands is by using them.  Use the "i" command to insert some more lines of text.  Then use the hjkl keys to move around and insert a word somewhere.  Don't forget to press &lt;Esc&gt; to go back to Normal mode.  The |vimtutor| is also a nice way to learn by doing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mejor manera de aprender estas órdenes es usándolas. Use la orden «i» para insertar algunas líneas de texto más. Use entonces las teclas hjkl para moverse e insertar palabras. No se olvide de presionar &lt;Esc&gt; para volver al modo Normal. El |vimtutor| es también una práctica manera de aprender.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			Komsomolsk
			    ^
			    |
	   Huan Ho	&lt;--- ---&gt;  Los Angeles
	(Yellow river)	    |
			    v
			  Java (the island, not the programming language)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			Komsomolsk
			    ^
			    |
	   Huan Ho	&lt;--- ---&gt;  Los Angeles
	(Río amarillo)	    |
			    v
			  Java (la isla, no el lenguaje de programación)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.4*	Deleting characters
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.4*	Eliminar caracteres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a character, move the cursor over it and type "x".  (This is a throwback to the old days of the typewriter, when you deleted things by typing xxxx over them.)  Move the cursor to the beginning of the first line, for example, and type xxxxxxx (seven x's) to delete "A very ".  The result should look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar un carácter, sitúe el cursor encima de él y presione «x». (Esto es una reminiscencia de los días de las máquinas de escribir, cuando se eliminaban caracteres escribiendo xxxx sobre ellos.) Sitúe el cursor al comienzo de la primera línea, por ejemplo, y pulse xxxxxxx (siete «xx») para eliminar «A very». El resultado debería ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|intelligent turtle			|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|intelligent turtle			|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	iA young &lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	iA young &lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This begins an insert (the i), inserts the words "A young", and then exits
insert mode (the final &lt;Esc&gt;).	The result:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto inicia una inserción (la «i»), inserta las palabras «A young», y
sale del modo insertar (el &lt;Esc&gt; final). El resultado:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|A young intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|A young intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a whole line use the "dd" command.  The following line will then move up to fill the gap:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una línea entera use la orden «dd». La siguiente línea se moverá hacia arriba para rellenar el hueco:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------------+
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------------+
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|~					|
	|					|
	+---------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim you can join two lines together, which means that the line break
between them is deleted.  The "J" command does this.
   Take these two lines:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim puede unir dos líneas, lo que significa que el salto de línea entre
ellas se elimina. La orden «J» hace esto. 
   Suponga estas dos líneas:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A young intelligent ~
	turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A young intelligent ~
	turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A young intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A young intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.5*	Undo and Redo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.5*	Deshacer y rehacer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you delete too much.  Well, you can type it in again, but an easier
way exists.  The "u" command undoes the last edit.  Take a look at this in
action: After using "dd" to delete the first line, "u" brings it back.
   Another one: Move the cursor to the A in the first line:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que elimina demasiado. Puede teclearlo de nuevo, pero existe una
manera más fácil. La orden «u» deshace la última edición. Vea
esto en acción: Tras usar «dd» para eliminar la última línea, «u» la devuelve.
   Otra más: mueve el cursor a la A en la primera línea:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now type xxxxxxx to delete "A young".  The result is as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora teclee xxxxxxx para eliminar «A young».  El resultado es el siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	 intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	 intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type "u" to undo the last delete.  That delete removed the g, so the undo restores the character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee «u» para deshacer la última eliminación. Esa última eliminación quitó la g, por lo que deshacer la devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	g intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	g intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ng intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ng intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ung intelligent turtle ~
	oung intelligent turtle ~
	young intelligent turtle ~
	 young intelligent turtle ~
	A young intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ung intelligent turtle ~
	oung intelligent turtle ~
	young intelligent turtle ~
	 young intelligent turtle ~
	A young intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	If you type "u" twice, and the result is that you get the same text
	back, you have Vim configured to work Vi compatible.  Look here to fix
	this: |not-compatible|.
	   This text assumes you work "The Vim Way".  You might prefer to use
	the good old Vi way, but you will have to watch out for small
	differences in the text then.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Si teclea la «u» dos veces, y el resultado que obtendrá es el mismo
	texto de vuelta, es que tiene Vim configurado para que sea
	Vi-compatible. Véase aquí para solucionarlo: |not-compatible|.
	   Este texto asume que trabaja en «El Modo Vim». Quizá quiera usar
	el viejo modo Vi, pero entonces tendrá que observar las pequeñas
	diferencias.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you undo too many times, you can press CTRL-R (redo) to reverse the preceding command.  In other words, it undoes the undo.  To see this in action, press CTRL-R twice.  The character A and the space after it disappear:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si deshace de más, puede pulsar CTRL-R (rehacer) para revertir la orden precedente. En otras palabras, deshace el deshacer. Para ver esto en acción, presione CTRL-R dos veces. El carácter A y el espacio desaparecerían:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	young intelligent turtle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	young intelligent turtle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a special version of the undo command, the "U" (undo line) command.  The undo line command undoes all the changes made on the last line that was edited.  Typing this command twice cancels the preceding "U".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una versión especial de la orden deshacer, la orden «U» (deshacer línea).  La orden deshacer línea deshace todos los cambios realizados en la última línea editada. Si teclea esta orden dos veces, deshará la «U» precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A very intelligent turtle ~
	  xxxx				Delete very
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A very intelligent turtle ~
	  xxxx				Eliminar very
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A intelligent turtle ~
		      xxxxxx		Delete turtle
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A intelligent turtle ~
		      xxxxxx		Eliminar turtle
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A intelligent ~
					Restore line with "U"
	A very intelligent turtle ~
					Undo "U" with "u"
	A intelligent ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A intelligent ~
					Restaurar línea con «U»
	A very intelligent turtle ~
					Deshacer «U» con «u»
	A intelligent ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "U" command is a change by itself, which the "u" command undoes and CTRL-R redoes.  This might be a bit confusing.  Don't worry, with "u" and CTRL-R you can go to any of the situations you had.  More about that in section |32.2|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «U» es un cambio en sí mismo, que la orden «u» deshace y CTRL-R rehace. Esto puede resultar confuso. No se preocupe, con «u» y CTRL-R puede ir a cualquier situación anterior. Más información en la sección |32.2|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.6*	Other editing commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.6*	Otras órdenes de edición
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a large number of commands to change the text.  See |Q_in| and below.  Here are a few often used ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una larga lista de órdenes para modificar texto. Véase |Q_in| y a continuación. Aquí hay algunos de uso frecuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "i" command inserts a character before the character under the cursor.
That works fine; but what happens if you want to add stuff to the end of the
line?  For that you need to insert text after the cursor.  This is done with
the "a" (append) command.
   For example, to change the line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «i» inserta un carácter antes del carácter bajo el cursor. Esto
funciona bien; pero ¿qué ocurre si quieres añadir algo al final de la línea?
Para ello necesita insertar texto después del cursor. Esto se hace con la
orden «a» (añadir).
 Por ejemplo, para modificar la línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	and that's not saying much for the turtle. ~
to
	and that's not saying much for the turtle!!! ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	and that's not saying much for the turtle. ~
a
	and that's not saying much for the turtle!!! ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a!!!&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	a!!!&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	and that's not saying much for the turtle!!! ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	and that's not saying much for the turtle!!! ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "o" command creates a new, empty line below the cursor and puts Vim in
Insert mode.  Then you can type the text for the new line.
   Suppose the cursor is somewhere in the first of these two lines:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «o» crea una nueva línea vacía debajo del cursor y pone Vim en modo
insertar. Puede introducir el texto de la nueva línea.
   Suponga que el cursor está en algún lugar de la primera de estas líneas:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A very intelligent turtle ~
	Found programming UNIX a hurdle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A very intelligent turtle ~
	Found programming UNIX a hurdle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	oThat liked using Vim&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	oThat liked using Vim&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A very intelligent turtle ~
	That liked using Vim ~
	Found programming UNIX a hurdle ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A very intelligent turtle ~
	That liked using Vim ~
	Found programming UNIX a hurdle ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to move up nine lines.  You can type "kkkkkkkkk" or you can enter the command "9k".  In fact, you can precede many commands with a number.  Earlier in this chapter, for instance, you added three exclamation points to the end of a line by typing "a!!!&lt;Esc&gt;".  Another way to do this is to use the command "3a!&lt;Esc&gt;".  The count of 3 tells the command that follows to triple its effect.  Similarly, to delete three characters, use the command "3x".  The count always comes before the command it applies to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiera desplazarse nueve líneas hacia arriba. Puede teclear «kkkkkkkkk» o puede teclear la orden «9k». De hecho, se puede emplear el multiplicador con muchas órdenes. Anteriormente en este capítulo, añadió tres exclamaciones al final de la línea con «a!!!&lt;Esc&gt;». Otra forma de hacer esto es usar la orden «3a!&lt;Esc&gt;». El multiplicador 3 hace que la orden a continuación triplique su efecto. De igual modo, para eliminar tres caracteres, use «3x». El multiplicador siempre va delante de la orden sobre el que se aplica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.7*	Getting out
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.7*	Salir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To exit, use the "ZZ" command.  This command writes the file and exits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para salir, use la orden «ZZ». Esta orden escribe el archivo y sale.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	Unlike many other editors, Vim does not automatically make a backup
	file.  If you type "ZZ", your changes are committed and there's no
	turning back.  You can configure the Vim editor to produce backup
	files, see |07.4|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Al revés que muchos otros editores, Vim no hace un archivo de
	seguridad automático. Si escribe «ZZ», sus cambios se comprometen
	sin vuelta atrás. Puede configurar el editor Vim para que haga
	copias de seguridad, consulte |07.4|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will make a sequence of changes and suddenly realize you were better off before you started.  Not to worry; Vim has a quit-and-throw-things-away command.  It is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones se dará cuenta de que tras una serie de cambios, estaba mejor donde comenzó. No se preocupe; Vim tiene una orden para salir y descartar todos los cambios. Es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:q!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:q!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For those of you interested in the details, the three parts of this command
are the colon (:), which enters Command-line mode; the q command, which tells
the editor to quit; and the override command modifier (!).
   The override command modifier is needed because Vim is reluctant to throw
away changes.  If you were to just type ":q", Vim would display an error
message and refuse to exit:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para aquellos de vosotros interesados en los detalles, las tres partes de esta
orden son los dos puntos (:), que entra en el modo en línea de órdenes; la
orden «q», para salir; y el modificador de anulación (!).
   El modificador de anulación es necesario porque Vim se resiste a perder los
cambios. Si escribiese sólo «:q», Vim mostraría un mensaje de error y se
negaría a salir:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E37: No write since last change (use ! to override) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E37: No se ha guardado el fichero desde el último cambio
	(añada ! para forzar) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.8*	Finding help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.8*	Encontrar ayuda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything you always wanted to know can be found in the Vim help files.
Don't be afraid to ask!
   To get generic help use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo lo que quiera saber puede encontrarlo en los archivos de ayuda.
¡No tenga miedo a preguntar!
   Use la siguiente orden para obtener ayuda genérica:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also use the first function key &lt;F1&gt;.  If your keyboard has a &lt;Help&gt;
key it might work as well.
   If you don't supply a subject, ":help" displays the general help window.
The creators of Vim did something very clever (or very lazy) with the help
system: They made the help window a normal editing window.  You can use all
the normal Vim commands to move through the help information.  Therefore h, j,
k, and l move left, down, up and right.
   To get out of the help window, use the same command you use to get out of
the editor: "ZZ".  This will only close the help window, not exit Vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar la tecla &lt;F1&gt;. Si su teclado tiene tecla &lt;Ayuda&gt; puede que
funcione también.
   Si no define un tema, «:help» muestra la ventana de ayuda general.
Los creadores de Vim hicieron algo muy inteligente (o fueron muy vagos) con el
sistema de ayuda: Hicieron la ventana de ayuda una ventana normal de edición.
Puede usar todas las órdenes comunes de Vim para moverse por ella. Por lo
tanto, h, j, k, l mueven el cursor hacia la izquierda, derecha, arriba y abajo.
   Para salir de la ventana de ayuda, usa la misma orden que usas para salir
del editor: «ZZ». Esto sólo cierra la ayuda, no sale de Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help {subject}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help {subject}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help x
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help x
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help deleting
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help deleting
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help index
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help index
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to get help for a control character command (for example, CTRL-A), you need to spell it with the prefix "CTRL-". &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando necesite obtener ayuda para las órdenes de control de carácter (por ejemplo, CTRL-A), debe escribirlo con el prefijo «CTRL-». &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help CTRL-A
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help CTRL-A
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor has many different modes.  By default, the help system displays the normal-mode commands.  For example, the following command displays help for the normal-mode CTRL-H command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim tiene muchos modos diferentes. De manera predeterminada, el sistema de ayuda muestra las ordenes del modo normal. Por ejemplo, la siguiente orden muestra la ayuda para la orden CTRL-H en modo normal: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help CTRL-H
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help CTRL-H
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To identify other modes, use a mode prefix.  If you want the help for the insert-mode version of a command, use "i_".  For CTRL-H this gives you the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para identificar otros modos, se necesita un prefijo de modo. Si quiere ayuda para la versión en modo Insertar de una orden, use «i_».  Para, CTRL-H es la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help i_CTRL-H
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help i_CTRL-H
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help -t
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help -t
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor has a number of options that enable you to configure and customize the editor.  If you want help for an option, you need to enclose it in single quotation marks.  To find out what the 'number' option does, for example, use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim tiene una serie de opciones que le permiten configurar y personalizar el editor. Si quiere ayuda para una opción, tiene que escribirla entre comillas simples. Para encontrar lo que hace la opción 'number' por ejemplo, usa la orden siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help 'number'
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help 'number'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special keys are enclosed in angle brackets.  To find help on the up-arrow key in Insert mode, for instance, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las teclas especiales se escriben entre corchetes angulares. Para encontrar ayuda sobre la flecha hacia arriba en modo insertar, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help i_&lt;Up&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help i_&lt;Up&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help E37
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help E37
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*intro.txt*     For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*intro.esx*   Para Vim versión 7.3. Último cambio: 24/6/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		  VIM REFERENCE MANUAL    by Bram Moolenaar
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		MANUAL DE REFERENCIA DE VIM  por Bram Moolenar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to Vim					*ref* *reference*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introducción a Vim				*ref* *referencia* *reference*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Introduction			|intro|
2. Vim on the internet		|internet|
3. Credits			|credits|
4. Notation			|notation|
5. Modes, introduction		|vim-modes-intro|
6. Switching from mode to mode	|mode-switching|
7. The window contents		|window-contents|
8. Definitions			|definitions|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Introducción			|intro|
2. Vim en internet		|internet|
3. Créditos			|credits|
4. Notación			|notación| |notation|
5. Modos, introducción		|vim-modes-intro|
6. Cambiar de Modos		|cambiar-modo| |mode-switching|
7. El contenido de la ventana	|ventana-contenidos| |window-contents|
8. Definiciones			|definiciones| |definitions|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Introduction						*intro*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Introducción						*intro*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim stands for Vi IMproved.  It used to be Vi IMitation, but there are so many
improvements that a name change was appropriate.  Vim is a text editor which
includes almost all the commands from the Unix program "Vi" and a lot of new
ones.  It is very useful for editing programs and other plain text.
   All commands are given with the keyboard.  This has the advantage that you
can keep your fingers on the keyboard and your eyes on the screen.  For those
who want it, there is mouse support and a GUI version with scrollbars and
menus (see |gui.txt|).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim son las siglas de Vi Improved («Vi mejorado»). Solía significar Vi
IMitation, pero hay tantas mejoras que se consideró apropiado cambiar el
nombre. Vim es un editor de texto que incluye casi todas las órdenes del
programa para Unix, Vi, así como otras más. Es muy útil para la edición de
programas y archivos de formato de texto normal.
   Todas las órdenes se introducen mediante el teclado. Ésto ofrece la ventaja
de poder tener sus dedos en el teclado y sus ojos en la pantalla. Para
aquellos que lo deseen, también tiene compatibilidad con ratón y una versión
que ofrece una interfaz gráfica con barras de desplazamiento y menús (consulte
|gui.txt|).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An overview of this manual can be found in the file "help.txt", |help.txt|.
It can be accessed from within Vim with the &lt;Help&gt; or &lt;F1&gt; key and with the
|:help| command (just type ":help", without the bars or quotes).
   The 'helpfile' option can be set to the name of the help file, in case it
is not located in the default place.  You can jump to subjects like with tags:
Use CTRL-] to jump to a subject under the cursor, use CTRL-T to jump back.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrará una visión general de este manual en el archivo «help.txt»,
|help.txt|. Puede acceder a él a través de Vim con la tecla &lt;Ayuda&gt; o &lt;F1&gt; y
con la orden |:help| (sólo teclee «:help», sin las comillas o barras).
   La opción 'helpfile' se puede configurar con el nombre del archivo de ayuda
en caso de no encontrarse en la ubicación habitual. Puede saltar de un tema
a otro como si fuesen etiquetas:
Use CTRL-] para pasar al tema bajo el cursor, y CTRL-T para volver.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Throughout this manual the differences between Vi and Vim are mentioned in curly braces, like this: {Vi does not have on-line help}.  See |vi_diff.txt| for a summary of the differences between Vim and Vi.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las diferencias entre Vi y Vim se señalarán con llaves, por ejemplo: {Vi no tiene ayuda en línea}. Consulte |vi_diff.txt| para un resumen de las diferencias entre Vim y Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This manual refers to Vim on various machines.  There may be small differences between different computers and terminals.  Besides the remarks given in this document, there is a separate document for each supported system, see |sys-file-list|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este manual trata el uso de Vim en varios sistemas. Pueden existir pequeñas diferencias entre computadoras y terminales. Además de los comentarios que se ofrecen en este documento, hay un documento aparte para cada sistema compatible, consulte |sys-file-list|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*pronounce*
Vim is pronounced as one word, like Jim, not vi-ai-em.  It's written with a
capital, since it's a name, again like Jim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					*pronounce* *pronunciar*
Vim se pronuncia como una sola palabra, como Jim, no uve-a-eme. Se escribe
mayúscula, ya que es un nombre al igual que Jim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This manual is a reference for all the Vim commands and options.  This is not an introduction to the use of Vi or Vim, it gets a bit complicated here and there.  For beginners, there is a hands-on |tutor|.  To learn using Vim, read the user manual |usr_toc.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este manual es una referencia para todas las órdenes y opciones de Vim. No es una introducción al uso de Vi o Vim, y algunas secciones son complejas. Hay un tutor práctico, |tutor|. Si quiere aprender a usar Vim, consulte el manual de usuario |usr_toc.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*book*
There are many books on Vi that contain a section for beginners.  There are
two books I can recommend:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*book*
Existen muchos libros sobre Vi que contienen una sección para principiantes.
Personalmente recomiendo dos libros:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"Vim - Vi Improved" by Steve Oualline
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	«Vim - Vi Improved» por Steve Oualline
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the very first book completely dedicated to Vim.  It is very good for
beginners.  The most often used commands are explained with pictures and
examples.  The less often used commands are also explained, the more advanced
features are summarized.  There is a comprehensive index and a quick
reference.  Parts of this book have been included in the user manual
|frombook|.
Published by New Riders Publishing.  ISBN: 0735710015
For more information try one of these:
	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el primer libro completamente dedicado a Vim. Es muy bueno para
principiantes. Las órdenes más usadas se explican con imágenes y ejemplos.
También se tratan aquellas órdenes menos comunes, y las características más
avanzadas son resumidas. Tiene un completo índice y una rápida referencia.
Hay partes de este libro incluidas en el manual de usuario |frombook|.
Publicado por New Riders Publishing.  ISBN: 0735710015
Pruebe estos enlaces para más información:
	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"Learning the Vi editor" by Linda Lamb and Arnold Robbins
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	«Learning the Vi editor» por Linda Lamb y Arnold Robbins
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. Vim on the internet					*internet*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. Vim en internet					*internet*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			*www* *WWW*  *faq* *FAQ* *distribution* *download*
The Vim pages contain the most recent information about Vim.  They also
contain links to the most recent version of Vim.  The FAQ is a list of
Frequently Asked Questions.  Read this if you have problems.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>       	*www* *WWW*  *faq* *FAQ* *distribution* *download* *descargar*
Las páginas de Vim ofrecen la información más actualizada. También
contienen enlaces a la versión más reciente de Vim. El FAQ es una lista de
las preguntas más frecuentes. Consulte esa página en caso de tener problemas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	VIM home page:	  http://www.vim.org/
	VIM FAQ:	  http://vimdoc.sf.net/
	Downloading:	  ftp://ftp.vim.org/pub/vim/MIRRORS
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Página web de VIM http://www.vim.org/
	VIM FAQ:	  http://vimdoc.sf.net/
	Descargar:	  ftp://ftp.vim.org/pub/vim/MIRRORS
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usenet News group where Vim is discussed:		*news* *usenet*
	comp.editors
This group is also for other editors.  If you write about Vim, don't forget to
mention that.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Grupo de Usenet News en el que se trata Vim: 		*news* *usenet*
	comp.editors
Este grupo también trata de otros editores. Si escribe sobre Vim, no olvide
de mencionar esto último.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>						*mail-list* *maillist*
There are several mailing lists for Vim:
&lt;vim@vim.org&gt;
	For discussions about using existing versions of Vim: Useful mappings,
	questions, answers, where to get a specific version, etc.  There are
	quite a few people watching this list and answering questions, also
	for beginners.  Don't hesitate to ask your question here.
&lt;vim-dev@vim.org&gt;				*vim-dev* *vimdev*
	For discussions about changing Vim: New features, porting, patches,
	beta-test versions, etc.
&lt;vim-announce@vim.org&gt;				*vim-announce*
	Announcements about new versions of Vim; also for beta-test versions
	and ports to different systems.  This is a read-only list.
&lt;vim-multibyte@vim.org&gt;				*vim-multibyte*
	For discussions about using and improving the multi-byte aspects of
	Vim.
&lt;vim-mac@vim.org&gt;				*vim-mac*
	For discussions about using and improving the Macintosh version of
	Vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>						*mail-list* *maillist*
Existen varias listas de correo acerca de Vim:
&lt;vim@vim.org&gt;
	Para discusiones acerca del uso de varias versiones de Vim: Macros
	útiles, preguntas, respuestas, dónde obtener una versión especifica.
	Hay varias personas mirando esta lista, y que responden a
	preguntas, también para principiantes. No dude en preguntar.
&lt;vim-dev@vim.org&gt;				*vim-dev* *vimdev*
	Para la discusión de cambios en Vim: Nuevas características,
	portabilidad, parches, versiones beta, etc.
&lt;vim-announce@vim.org&gt;				*vim-announce*
	Anuncios acerca de nuevas versiones de Vim; también para versiones beta
	y la adaptación a otras arquitecturas. Lista de sólo lectura.

&lt;vim-multibyte@vim.org&gt;				*vim-multibyte*
	Discusión acerca de la mejora de la experiencia multi-byte en Vim.
&lt;vim-mac@vim.org&gt;				*vim-mac*
	Discusión acerca del uso y la mejora de la versión Macintosh de Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE:
- You can only send messages to these lists if you have subscribed!
- You need to send the messages from the same location as where you subscribed
  from (to avoid spam mail).
- Maximum message size is 40000 characters.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>NOTA:
- Sólo puede mandar mensajes a estas listas si esta suscrito.
- Debe mandar los mensajes desde la misma dirección desde la cual se
  suscribió (para evitar el spam).
- El tamaño máximo de un mensaje es de 40000 caracteres.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>						*subscribe-maillist*
If you want to join, send a message to
	&lt;vim-subscribe@vim.org&gt;
Make sure that your "From:" address is correct.  Then the list server will
give you help on how to subscribe.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					*lista-correo* *subscribe-maillist*
Si desea unirse, envie un mensaje a
	&lt;vim-subscribe@vim.org&gt;
Asegúrese de que su dirección «De:» es correcta. El servidor de la lista
le asistirá para suscribirse.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>						*maillist-archive*
For more information and archives look on the Vim maillist page:
http://www.vim.org/maillist.php
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>						*maillist-archive*
Para más información y visitar los archivos, visite la página de listas de
correo de Vim:
http://www.vim.org/maillist.php
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bug reports:				*bugs* *bug-reports* *bugreport.vim*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Informes de fallo:	*fallos* *informe-de-fallo* *bugs* *bug-reports*
							 *bugreport.vim*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will help to include information about the version of Vim you are using and
your setup.  You can get the information with this command: &gt;
   :so $VIMRUNTIME/bugreport.vim
This will create a file "bugreport.txt" in the current directory, with a lot
of information of your environment.  Before sending this out, check if it
doesn't contain any confidential information!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nos ayudaría si incluye información acerca de su configuración y versión de Vim.
Puede obtener esta información con la siguiente orden: &gt;
   :so $VIMRUNTIME/bugreport.vim
Esto creará el archivo «bugreport.txt» en el directorio presente, conteniendo
información relativa a su entorno. Antes de enviarlo, revise que no contenga
ninguna información confidencial.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim crashes, please try to find out where.  You can find help on this here: |debug.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim se cuelga, intente encontrar donde. Puede encontrar ayuda aquí: |debug.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might be a year 2038 problem, when the seconds don't fit in a 32 bit int anymore.  This depends on the compiler, libraries and operating system.  Specifically, time_t and the ctime() function are used.  And the time_t is stored in four bytes in the swap file.  But that's only used for printing a file date/time for recovery, it will never affect normal editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede aparecer un problema en el año 2038, cuando los segundos no quepan en 32 bits. Esto depende del compilador, la bibliotecas y el sistema operativo. Se usan particularmente las funciones «time_t» y «ctime()». «time_t» se guarda en cuatro bytes en el archivo de intercambio. Esto último sólo se emplea para imprimir una fecha/tiempo para la recuperación y en ningún caso afectará a la edición normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim strftime() function directly uses the strftime() system function.  localtime() uses the time() system function.  getftime() uses the time returned by the stat() system function.  If your system libraries are year 2000 compliant, Vim is too.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función de Vim «strftime()» usa directamente la función del sistema «strftime()». «localtime()» usa la función del sistema «time()». «getftime» usa el tiempo devuelto por la función del sistema «stat()». Si las bibliotecas de sus sistema son compatibles con el año 2000, Vim también lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user may create scripts for Vim that use external commands.  These might introduce Y2K problems, but those are not really part of Vim itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario puede crear scripts para Vim que usan órdenes externas. Esto puede introducir problemas Y2K, pero no son parte de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3. Credits				*credits* *author* *Bram* *Moolenaar*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3. Creditos			*credits* *créditos* *autor* *Bram* *Moolenaar*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parts of the documentation come from several Vi manuals, written by:
	W.N. Joy
	Alan P.W. Hewett
	Mark Horton
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El origen de algunas partes de la documentación nacen de varios manuales
de Vim, escritos por:
	W.N. Joy
	Alan P.W. Hewett
	Mark Horton
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor is based on Stevie and includes (ideas from) other software, worked on by the people mentioned here.  Other people helped by sending me patches, suggestions and giving feedback about what is good and bad in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim está basado en Stevie, e incluye ideas procedentes de otro software, trabajadas por la gente aquí mencionada. Otra gente me ayudó mediante parches, sugerencias y opiniones acerca de lo bueno y malo de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I wish to thank all the people that sent me bug reports and suggestions.  The list is too long to mention them all here.  Vim would not be the same without the ideas from all these people: They keep Vim alive!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quisiera dar gracias a toda la gente que envió informes de fallo y sugerencias. La lista es demasiado larga como para mencionarlos a todos aquí. Vim no sería lo mismo sin las ideas de todas esta gente: ¡Mantienen Vim vivo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this documentation there are several references to other versions of Vi:
							*Vi* *vi*
Vi	"the original".  Without further remarks this is the version
	of Vi that appeared in Sun OS 4.x.  ":version" returns
	"Version 3.7, 6/7/85".  Sometimes other versions are referred
	to.  Only runs under Unix.  Source code only available with a
	license.  More information on Vi can be found through:
		http://vi-editor.org	[doesn't currently work...]
							*Posix*
Posix	From the IEEE standard 1003.2, Part 2: Shell and utilities.
	Generally known as "Posix".  This is a textual description of
	how Vi is supposed to work.
	See |posix-compliance|.
							*Nvi*
Nvi	The "New" Vi.  The version of Vi that comes with BSD 4.4 and FreeBSD.
	Very good compatibility with the original Vi, with a few extensions.
	The version used is 1.79.  ":version" returns "Version 1.79
	(10/23/96)".  There has been no release the last few years, although
	there is a development version 1.81.
	Source code is freely available.
							*Elvis*
Elvis	Another Vi clone, made by Steve Kirkendall.  Very compact but isn't
	as flexible as Vim.
	The version used is 2.1.  It is still being developed.  Source code is
	freely available.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A lo largo de la documentación verá varias referencias a otras versiones de Vi:
							*Vi* *vi*
Vi	«El original». Sin mas detalle, esta es la versión de Vim que apareció
	en Sun Os 4.x. «:version» devuelve «Version 3.7, 6/7/85». A veces
	encontrara referencias a otras versiones. Sólo funciona bajo Unix. El
	código sólo está disponible a través de una licencia. Puede encontrar
	más información a cerca de Vi:
		http://vi-editor.org (no funciona a día de hoy...)
							*Posix*
Posix	Pertenece al estándar IEEE 1003.2. Parte 2: Consola y utilidades.
	Generalmente conocido como «Posix»,  una descripción textual de cómo
	debe funcionar Vi.
	Véase |posix-compliance|.
							*Nvi*
Nvi	El «Nuevo» Vi. La versión de Vi que ofrece BSD 4.4 y FreeBSD.
	Es muy compatible con el editor original Vi, con unas cuantas
	extensiones. La versión referida es 1.79. «:version» devuelve
	«Version 1.79 (10/23/96). No se ha publicado una nueva versión en
	los últimos años, aunque existe una versión en desarrollo 1.81.
	El código se distribuye libremente.
							*Elvis*
Elvis	Otro clon de Vi, hecho por Steve Kirkendall. Muy compacto pero
	menos flexible que Vim.
	La versión referida es 2.1. Aún está en desarrollo. El código se
	distribuye libremente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>4. Notation						*notation*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>4. Notación					*notación* *leyenda*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When syntax highlighting is used to read this, text that is not typed literally is often highlighted with the Special group.  These are items in [], {} and &lt;&gt;, and CTRL-X.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa el resaltado de sintaxis para leer esto, el texto que no se ha introducido literalmente será resaltado como perteneciente al grupo Special. Estos son los elementos [], {}, &lt;&gt; y CTRL-X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that Vim uses all possible characters in commands.  Sometimes the [], {} and &lt;&gt; are part of what you type, the context should make this clear.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que Vim utiliza todos los caracteres posibles en las órdenes. El contexto aclarará cuando los signos [], () y &lt;&gt; son parte de texto literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[]		Characters in square brackets are optional.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[]		Los caracteres entre corchetes son opcionales.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>						    *count* *[count]* *E489*
[count]		An optional number that may precede the command to multiply
		or iterate the command.  If no number is given, a count of one
		is used, unless otherwise noted.  Note that in this manual the
		[count] is not mentioned in the description of the command,
		but only in the explanation.  This was done to make the
		commands easier to look up.  If the 'showcmd' option is on,
		the (partially) entered count is shown at the bottom of the
		window.  You can use &lt;Del&gt; to erase the last digit (|N&lt;Del&gt;|).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>						   *[número]* *[count]* *E489*
		Un número opcional que puede preceder a la orden para
		multiplicar o cambiar la orden. Si no introduce un número, se
		usará uno a menos que se indique lo contrario. Tenga en cuenta]
		que en este manual, el [número no se menciona en las descripciones
		de las órdenes.
		La razón para esto es facilitar la lectura de las órdenes. Si la opción
		esta activada, el número (parcialmente) introducido se
		mostrará en la parte inferior de la ventana. Puede usar &lt;Supr&gt;
		para eliminar el último dígito (|N&lt;Supr&gt;|).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*[quotex]*
["x]		An optional register designation where text can be stored.
		See |registers|.  The x is a single character between 'a' and
		'z' or 'A' and 'Z' or '"', and in some cases (with the put
		command) between '0' and '9', '%', '#', or others.  The
		uppercase and lowercase letter designate the same register,
		but the lowercase letter is used to overwrite the previous
		register contents, while the uppercase letter is used to
		append to the previous register contents.  Without the ""x" or
		with """" the stored text is put into the unnamed register.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							 *quotex*
["x]		Un destino opcional para un registro dónde guardar el texto.
		Consulte |registers|. La x es un único carácter entre 'a'
		y 'z', o 'A' y 'Z' o '"', y en algunos casos (con la orden
		«put») entre '0' y '9', '%', '#', u otros. Las mayúsculas y
		y minúsculas designan el mismo registro, pero la minúscula se
		usa para eliminar los contenidos anteriores del registro, y
		la mayúscula para añadir contenido. El texto se almacenará
		en un registro sin nombre en caso de no usar «"x» o «""».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*{}*
{}		Curly braces denote parts of the command which must appear,
		but which can take a number of different values.  The
		differences between Vim and Vi are also given in curly braces
		(this will be clear from the context).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*{}*
{}		Las llaves indican qué partes de una orden son
		obligatorios, pero que pueden tomar distintos valores. Las
		diferencias entre Vim y Vi también se resaltan con llaves
		(el contexto aclarará esto).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*{char1-char2}*
{char1-char2}	A single character from the range char1 to char2.  For
		example: {a-z} is a lowercase letter.  Multiple ranges may be
		concatenated.  For example, {a-zA-Z0-9} is any alphanumeric
		character.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*{car1-car2}*
{car1-car2}	Un único carácter entre el rango car1 y car2. Por ejemplo:
		{a-z} simboliza un carácter en minúscula. Puede encadenar
		varios rangos. Por ejemplo, {a,zA-Z0-9} es cualquier carácter
		alfanumérico.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*&lt;character&gt;*
&lt;character&gt;	A special character from the table below, optionally with
		modifiers, or a single ASCII character with modifiers.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>						*&lt;carácter&gt;* *&lt;character&gt;*
&lt;carácter&gt;	Un carácter especial de la tabla a continuación, que acepta
		modificadores opciones, o un único carácter ASCII sin
		modificadores.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*'character'*
'c'		A single ASCII character.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*'character'*
'c'		Un único carácter ASCII.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*'option'*
'option'	An option, or parameter, that can be set to a value, is
		enclosed in single quotes.  See |options|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*'option'*
'opción'	Una opción o parámetro que puede definir con un valor
		aparecerá entre comillas simples. Consulte |options|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*quotecommandquote*
"command"	A reference to a command that you can type is enclosed in
		double quotes.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*quotecommandquote*
"orden"		Las referencias a una orden aparecerán entre comillas dobles.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>					*key-notation* *key-codes* *keycodes*
These names for keys are used in the documentation.  They can also be used
with the ":map" command (insert the key name by pressing CTRL-K and then the
key you want the name for).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				*notación-teclas* *teclas-tabla*
*leyendatabla*
Éstos son los nombres de las teclas en la documentación. También puede
usarlos con la orden «:map» (inserte el nombre de la tecla pulsando CTRL-K y
la tecla cuyo nombre desea).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>notation	meaning		    equivalent	decimal value(s)	~
-----------------------------------------------------------------------
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>notación	significado	    equivalente	    valor(es) decimal  ~
-----------------------------------------------------------------------
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Nul&gt;		zero			CTRL-@	  0 (stored as 10) *&lt;Nul&gt;*
&lt;BS&gt;		backspace		CTRL-H	  8	*backspace*
&lt;Tab&gt;		tab			CTRL-I	  9	*tab* *Tab*
							*linefeed*
&lt;NL&gt;		linefeed		CTRL-J	 10 (used for &lt;Nul&gt;)
&lt;FF&gt;		formfeed		CTRL-L	 12	*formfeed*
&lt;CR&gt;		carriage return		CTRL-M	 13	*carriage-return*
&lt;Return&gt;	same as &lt;CR&gt;				*&lt;Return&gt;*
&lt;Enter&gt;		same as &lt;CR&gt;				*&lt;Enter&gt;*
&lt;Esc&gt;		escape			CTRL-[	 27	*escape* *&lt;Esc&gt;*
&lt;Space&gt;		space				 32	*space*
&lt;lt&gt;		less-than		&lt;	 60	*&lt;lt&gt;*
&lt;Bslash&gt;	backslash		\	 92	*backslash* *&lt;Bslash&gt;*
&lt;Bar&gt;		vertical bar		|	124	*&lt;Bar&gt;*
&lt;Del&gt;		delete				127
&lt;CSI&gt;		command sequence intro  ALT-Esc 155	*&lt;CSI&gt;*
&lt;xCSI&gt;		CSI when typed in the GUI		*&lt;xCSI&gt;*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Nul&gt;		cero			CTRL-@	  0 (stored as 10) *&lt;Nul&gt;*
&lt;BS&gt;		tecla de retroceso	CTRL-H	  8	*backspace*
&lt;Tab&gt;		tabulado		CTRL-I	  9	*tab* *Tab*
							*linefeed*
&lt;NL&gt;		avanzar una línea	CTRL-J	 10 (usado por &lt;Nul&gt;)
&lt;FF&gt;		formfeed		CTRL-L	 12	*formfeed*
&lt;CR&gt;		retorno de línea	CTRL-M	 13	*carriage-return*
&lt;Return&gt;	idéntico a &lt;CR&gt;				*&lt;Return&gt;*
&lt;Enter&gt;		idéntico a &lt;CR&gt;				*&lt;Enter&gt;*
&lt;Esc&gt;		escape			CTRL-[	 27	*escape* *&lt;Esc&gt;*
&lt;Space&gt;		espacio				 32	*space*
&lt;lt&gt;		menos que		&lt;	 60	*&lt;lt&gt;*
&lt;Bslash&gt;	barra inversa		\	 92	*backslash* *&lt;Bslash&gt;*
&lt;Bar&gt;		barra vertical		|	124	*&lt;Bar&gt;*
&lt;Del&gt;		eliminar				127
&lt;CSI&gt;		command sequence intro 	ALT-Esc 155	*&lt;CSI&gt;*
&lt;xCSI&gt;		CSI tecleado en la interfaz gráfica	*&lt;xCSI&gt;*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;EOL&gt;		end-of-line (can be &lt;CR&gt;, &lt;LF&gt; or &lt;CR&gt;&lt;LF&gt;,
		depends on system and 'fileformat')	*&lt;EOL&gt;*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;EOL&gt;		«end-of-line» (fin de línea, puede ser &lt;CR&gt;, &lt;LF&gt;
		o &lt;CR&gt;&lt;LF&gt;, dependiendo del sistema y de 'fileformat')
		&lt;EOL&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: The shifted cursor keys, the help key, and the undo key are only available on a few terminals.  On the Amiga, shifted function key 10 produces a code (CSI) that is also used by key sequences.  It will be recognized only after typing another key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: Las teclas de movimiento, la tecla de ayuda y la tecla deshacer combinados con la tecla shift sólo están disponibles en algunas terminales. En Amiga, la tecla función 10 con shift produce un código (CSI) también empleado en secuencias de teclas. Sólo se reconocerá tras pulsar otra tecla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: There are two codes for the delete key.  127 is the decimal ASCII value for the delete key, which is always recognized.  Some delete keys send another value, in which case this value is obtained from the termcap entry "kD".  Both values have the same effect.  Also see |:fixdel|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: Hay dos códigos para la tecla suprimir. El valor decimal ASCII de la tecla suprime es 127, éste siempre se reconocerá. Algunas teclas suprimir envían otro valor, en cuyo caso el valor se obtiene de la entrada de termcap «kD». Ambos valores tienen el mismo efecto. Véase también |:fixdel|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: The keypad keys are used in the same way as the corresponding "normal" keys.  For example, &lt;kHome&gt; has the same effect as &lt;Home&gt;.  If a keypad key sends the same raw key code as its non-keypad equivalent, it will be recognized as the non-keypad code.  For example, when &lt;kHome&gt; sends the same code as &lt;Home&gt;, when pressing &lt;kHome&gt; Vim will think &lt;Home&gt; was pressed.  Mapping &lt;kHome&gt; will not work then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: El uso de las teclas del teclado numérico es idéntico a sus teclas «normales» correspondientes. Por ejemplo, &lt;kHome&gt; tiene el mismo efecto que &lt;Home&gt;. Si una tecla del bloque envía el mismo código que su equivalente externo al bloque numérico, será reconocido como un código que no pertenece al bloque. Por ejemplo, cuando &lt;kHome&gt; envía el mismo código que &lt;Home&gt;, Vim creerá que pulsa &lt;Home&gt; cuando en realidad pulsa &lt;kHome&gt;. De ser así, las macros con &lt;kHome&gt; no funcionarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples for mapping CTRL-H to the six characters "&lt;Home&gt;": &gt;
	:imap &lt;C-H&gt; \&lt;Home&gt;
	:imap &lt;C-H&gt; &lt;lt&gt;Home&gt;
The first one only works when the 'B' flag is not in 'cpoptions'.  The second
one always works.
To get a literal "&lt;lt&gt;" in a mapping: &gt;
	:map &lt;C-L&gt; &lt;lt&gt;lt&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplos para asignar CTRL-H a los seis caracteres «&lt;Home&gt;»: &gt;
	:imap &lt;C-H&gt; \&lt;Home&gt;
	:imap &lt;C-H&gt; &lt;lt&gt;Home&gt;
El primero sólo funciona si la opción 'B' no está en 'cpoptions'. El segundo
siempre funciona.
Para obtener un &lt;lt&gt; en una macro: &gt;
	:map &lt;C-L&gt; &lt;lt&gt;lt&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For mapping, abbreviation and menu commands you can then copy-paste the examples and use them directly.  Or type them literally, including the '&lt;' and '&gt;' characters.  This does NOT work for other commands, like ":set" and ":autocmd"!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede copiar y pegar los ejemplos directamente para las macros, abreviaturas y órdenes de menú. O también introducirlos literalmente, incluyendo los caracteres «&lt;» y «&gt;». ¡Esto NO funciona con otras órdenes, como «:set» y «:autocmd».!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>5. Modes, introduction				*vim-modes-intro* *vim-modes*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>5. Introducción a los modos	*modos-vim* *vim-modes-intro* *vim-modes*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual mode		This is like Normal mode, but the movement commands
			extend a highlighted area.  When a non-movement
			command is used, it is executed for the highlighted
			area.  See |Visual-mode|.
			If the 'showmode' option is on "-- VISUAL --" is shown
			at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Visual		Es similar al modo Normal, pero las órdenes de
			movimiento extienden un área resaltada. Cuando use
			una orden que no sea de moción, éste afectará a toda
			el área resaltada. Consulte |Visual-mode|.
			Si la opción 'showmode' está activada, verá 
			«-- VISUAL --» en la parte inferior de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select mode		This looks most like the MS-Windows selection mode.
			Typing a printable character deletes the selection
			and starts Insert mode.  See |Select-mode|.
			If the 'showmode' option is on "-- SELECT --" is shown
			at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo seleccionar		Similar al modo de selección de MS-Windows.
			Teclear un carácter imprimible elimina la selección
			e inicia el modo Insertar. Consulte |Select-mode|.
			Si la opción 'showmode' esta activada, verá
			«-- SELECT --» en la parte inferior de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode		In Insert mode the text you type is inserted into the
			buffer.  See |Insert-mode|.
			If the 'showmode' option is on "-- INSERT --" is shown
			at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Insertar		En el modo Insertar, el texto que teclee
			aparecerá en el búfer. Consulte |Insert-mode|.
			Si la opción 'showmode' esta activada, verá
			«-- INSERT --» en la parte inferior de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command-line mode	In Command-line mode (also called Cmdline mode) you
Cmdline mode		can enter one line of text at the bottom of the
			window.  This is for the Ex commands, ":", the pattern
			search commands, "?" and "/", and the filter command,
			"!".  |Cmdline-mode|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Línea de órdenes	En este modo (también llamado «Cmdline mode»)
Cmdline mode		puede introducir una línea de texto en la parte
			inferior de la ventana. Ésto es para las órdenes
			Ex, «:», las órdenes de búsqueda de patrón, «?» y
			«/», y la orden de filtrado, «!». |Cmdline-mode|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ex mode			Like Command-line mode, but after entering a command
			you remain in Ex mode.  Very limited editing of the
			command line.  |Ex-mode|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Ex			Es similar al modo Línea de órdenes, pero
			permanecerá en modo Ex después de ejecutar la orden.
			Ofrece una edición limitada de la línea de órdenes.
			|Ex-mode|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				*Operator-pending* *Operator-pending-mode*
Operator-pending mode	This is like Normal mode, but after an operator
			command has started, and Vim is waiting for a {motion}
			to specify the text that the operator will work on.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				*Operator-pending* *Operator-pending-mode*
Modo Operator-pending	Es similar al modo Normal, pero se inicia tras una
			orden de operador, tras el cual Vim esperará a un
			movimiento {motion} para especificar el texto
			afectado por el operador.

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace mode		Replace mode is a special case of Insert mode.  You
			can do the same things as in Insert mode, but for
			each character you enter, one character of the existing
			text is deleted.  See |Replace-mode|.
			If the 'showmode' option is on "-- REPLACE --" is
			shown at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Reemplazar		El modo Reemplazar es un tipo especial del modo
			Insertar. Puede hacer las mismas cosas que en el modo
			Insertar, pero sustituirá un carácter existente por
			cada carácter que inserte. Consulte |Replace-mode|.
			Si la opción 'showmode' está activada, verá
			«-- REPLACE --» en la base de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual Replace mode	Virtual Replace mode is similar to Replace mode, but
			instead of file characters you are replacing screen
			real estate.  See |Virtual-Replace-mode|.
			If the 'showmode' option is on "-- VREPLACE --" is
			shown at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Reemplazar Virtual El modo Reemplazar Virtual es similar al modo
			Reemplazar, pero en lugar de reemplazar caracteres,
			reemplaza el estado real de la pantalla.
			Consulte |Virtual-Replace-mode|.
			Si la opción 'showmode' está activada, verá
			«-- VREPLACE --» en la base de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert Select mode	Entered when starting Select mode from Insert mode.
			E.g., by dragging the mouse or &lt;S-Right&gt;.
			When the Select mode ends, Vim returns to Insert mode.
			If the 'showmode' option is on "-- (insert) SELECT --"
			is shown at the bottom of the window.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Seleccionar	Se inicia al ejecutar el modo Seleccionar a partir
de inserción		del modo Insertar. Por ejemplo, arrastrando el ratón
			o &lt;S-Derecha&gt;. Vim le devolverá al modo Insertar al
			finalizar el modo Seleccionar. Si la opción
			'showmode' está activada, verá «-- (insert) SELECT --»
			en la base de la ventana.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>6. Switching from mode to mode				*mode-switching*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>6. Cambiar de modo			*cambiar-modo*  *mode-switching*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*i_esc*
		TO mode						    ~
		Normal	Visual	Select	Insert	  Replace   Cmd-line  Ex ~
FROM mode								 ~
Normal			v V ^V	  *4	 *1	   R gR     : / ? !   Q
Visual		 *2		  ^G	 c C	    --	      :       --
Select		 *5	^O ^G		 *6	    --	      --      --
Insert		 &lt;Esc&gt;	  --	  --		  &lt;Insert&gt;    --      --
Replace		 &lt;Esc&gt;	  --	  --	&lt;Insert&gt;	      --      --
Command-line	 *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*i_esc*
		DESDE el modo					    ~
		Normal	Visual	Selección Insertar Reemplazar Línea  Ex ~
							   de órdenes
A el modo								 ~
Normal			v V ^V	  *4	 *1¿	   R gR     : / ? !   Q
Visual		 *2		  ^G	 c C	    --	      :       --
Seleccionar	 *5	^O ^G		 *6	    --	      --      --
Insertar	 &lt;Esc&gt;	  --	  --		  &lt;Insertar&gt;  --      --
Reemplazar	 &lt;Esc&gt;	  --	  --	&lt;Insertar&gt;	      --      --
Línea de órdenes *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	*CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N* *v_CTRL-\_CTRL-N*
Additionally the command CTRL-\ CTRL-N or &lt;C-\&gt;&lt;C-N&gt; can be used to go to
Normal mode from any other mode.  This can be used to make sure Vim is in
Normal mode, without causing a beep like &lt;Esc&gt; would.  However, this does not
work in Ex mode.  When used after a command that takes an argument, such as
|f| or |m|, the timeout set with 'ttimeoutlen' applies.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	*CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N* *v_CTRL-\_CTRL-N*
De forma adicional, puede usar CTRL-\ CTRL-N o &lt;C-\&gt;&lt;C-N&gt; para pasar al modo
Normal a partir de cualquier otro. Puede usar esto para asegurarse de que Vim
está en modo Normal, sin causar el pitido que &lt;Esc&gt; realiza. Por otra parte,
esto no funciona en modo Ex. Si usa esto después de una orden que toma un
argumento, como |f| o |m|, se aplicará la cuenta atrás definida con
'ttimeoutlen'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	*CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
The command CTRL-\ CTRL-G or &lt;C-\&gt;&lt;C-G&gt; can be used to go to Insert mode when
'insertmode' is set.  Otherwise it goes to Normal mode.  This can be used to
make sure Vim is in the mode indicated by 'insertmode', without knowing in
what mode Vim currently is.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	*CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
La orden CTRL-\ CTRL-G o &lt;C-\&gt;&lt;C-G&gt; se puede usar para pasar al modo Insertar
cuando 'insertmode' está definido. En caso contrario, vuelve al modo Normal.
Puede usar esto para asegurarse de que Vim está en el modo indicado por
'insertmode', sin conocer el modo actual en el que está Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7. The window contents					*window-contents*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>7. El contenido de las ventanas		*ventanas-contenido* *window-contents*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Normal mode and Insert/Replace mode the screen window will show the current
contents of the buffer: What You See Is What You Get.  There are two
exceptions:
- When the 'cpoptions' option contains '$', and the change is within one line,
  the text is not directly deleted, but a '$' is put at the last deleted
  character.
- When inserting text in one window, other windows on the same text are not
  updated until the insert is finished.
{Vi: The screen is not always updated on slow terminals}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana muestra los contenidos actuales del búfer en modo Normal y modo
Insertar/Reemplazar: lo que ve es lo que hay. Hay dos excepciones:
- Si la opción 'cppoptions' contiene «$», y el cambio se realizará dentro
  de una línea, el texto no se eliminará directamente, sino que se insertará
  «$» en el último carácter eliminado.
- Si inserta texto en una ventana, otras ventanas mostrando el mismo
  contenido no se actualizarán hasta finalizar la inserción.
{Vi: La pantalla no se refrescará siempre en terminales lentas}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lines longer than the window width will wrap, unless the 'wrap' option is off (see below).  The 'linebreak' option can be set to wrap at a blank character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas más largas que el ancho de la ventana se justificarán a menos que la opción 'wrap' esté desactivada (consulte a continuación). La opción 'linebreak' se puede configurar para justificar a partir de un carácter vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-----------------------+
	|some line		|
	|last line		|
	|~			|
	|~			|
	+-----------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-----------------------+
	|alguna línea		|
	|última línea		|
	|~			|
	|~			|
	+-----------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-----------------------+
	|first line		|
	|second line		|
	|@			|
	|@			|
	+-----------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-----------------------+
	|primera línea		|
	|segunda línea		|
	|@			|
	|@			|
	+-----------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-----------------------+
	|first line		|
	|second line		|
	|a very long line that d|
	|oesn't fit in the wi@@@|
	+-----------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-----------------------+
	|primera línea		|
	|segunda línea		|
	|una línea muy larga que|
	|no encaja en la vent@@@|
	+-----------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a single line that is too long to fit in the window, this is a special situation.  Vim will show only part of the line, around where the cursor is.  There are no special characters shown, so that you can edit all parts of this line.  {Vi: gives an "internal error" on lines that do not fit in the window}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una situación particular es cuando existe una sola línea que no encaja en la ventana. Vim mostrará solo la parte de la línea en torno al cursor. No verá caracteres especiales, para que así pueda editar esa parte de la línea. {Vi: devuelve un «error interno» en las líneas que no encajan en la ventana.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The '@' occasion in the 'highlight' option can be used to set special highlighting for the '@' and '~' characters.  This makes it possible to distinguish them from real characters in the buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La aparición de «@» en la opción 'highlight' (resaltar) se puede usar para dar un resaltado especial a los caracteres «@» y «~». Esto posibilita distinguirlos de aquellos caracteres reales en el búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All normal ASCII characters are displayed directly on the screen.  The &lt;Tab&gt; is replaced with the number of spaces that it represents.  Other non-printing characters are replaced with "^{char}", where {char} is the non-printing character with 64 added.  Thus character 7 (bell) will be shown as "^G".  Characters between 127 and 160 are replaced with "~{char}", where {char} is the character with 64 subtracted.  These characters occupy more than one position on the screen.  The cursor can only be positioned on the first one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todos los caracteres normales ASCII aparecerán directamente en la pantalla.
La tecla &lt;Tab&gt; será reemplazada por el número de espacios que representa.
Otros caracteres no imprimibles se reemplazarán por «^{char}», donde
{char} es el carácter no imprimible más la suma de 64. Por ello, el carácter
7 (campana) aparecerá como «^G». Los caracteres entre el 127 y el 160 serán
reemplazados por «~{char}», donde {char} es el carácter menos la resta de 64.
Estos caracteres tomarán más de un espacio en la pantalla. El cursor sólo
aparecerá sobre el primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you set the 'number' option, all lines will be preceded with their
number.  Tip: If you don't like wrapping lines to mix with the line numbers,
set the 'showbreak' option to eight spaces:
	":set showbreak=\ \ \ \ \ \ \ \ "
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si activa la opción 'number', todas las líneas estarán precedidas por su
número. Consejo: Si no le gusta que el justificado de línea se mezcle con
los números de línea, configure la opción 'showbreak' con 8 espacios:
	«:set showbreak=\ \ \ \ \ \ \ \ »
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you set the 'list' option, &lt;Tab&gt; characters will not be shown as several spaces, but as "^I".  A '$' will be placed at the end of the line, so you can find trailing blanks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los caracteres &lt;Tab&gt; aparecerán como ^I, en lugar de como varios espacios, en caso de activar la opción 'list'. Se insertará un «$» al final de la
línea para así poder encontrar caracteres en exceso al final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Command-line mode only the command-line itself is shown correctly.  The display of the buffer contents is updated as soon as you go back to Command mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el modo Línea de órdenes, sólo la misma línea de órdenes se mostrará correctamente. La vista de los contenidos del búfer se actualizarán tan pronto como vuelva al modo de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last line of the window is used for status and other messages.  The status messages will only be used if an option is on:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La última línea de la ventana se usa para mostrar el estado y otros mensajes. Sólo se mostrarán los mensajes de estado si activa una opción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current mode is "-- INSERT --" or "-- REPLACE --", see |'showmode'|.  The command characters are those that you typed but were not used yet.  {Vi: does not show the characters you typed or the cursor position}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo actual es «-- INSERT --» o «-- REPLACE --», consulte |'showmode|. Los caracteres de la orden son aquellos que tecleó pero que aún no ha ejectuado. {Vi: no muestra los caracteres que ha introducido, o la posición del cursor.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a slow terminal you can switch off the status messages to speed
up editing:
	:set nosc noru nosm
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desactivar los mensajes de estado para agilizar la edición si tiene una
terminal lenta:
	:set nosc noru nosm
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is an error, an error message will be shown for at least one second (in reverse video).  {Vi: error messages may be overwritten with other messages before you have a chance to read them}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de error, verá un mensaje de error durante al menos un segundo (en vídeo inverso). {Vi: puede que los mensajes de error sean sobreescritos antes de poder leerlos.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands show how many lines were affected.  Above which threshold this happens can be controlled with the 'report' option (default 2).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes muestran cuantas líneas fueron afectadas. Puede controlar el umbral a partir del cual esto ocurre con la opción 'report' (2 por omisión).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the Amiga Vim will run in a CLI window.  The name Vim and the full name of the current file name will be shown in the title bar.  When the window is resized, Vim will automatically redraw the window.  You may make the window as small as you like, but if it gets too small not a single line will fit in it.  Make it at least 40 characters wide to be able to read most messages on the last line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim se ejecutará en una ventana CLI bajo Amiga. El nombre «Vim» y el nombre completo del archivo aparecerán en la barra de título. Vim redibujará la ventana en caso de redimensionarla. Puede reducir la ventana tanto como quiera, pero no cabrá ni una línea en caso de reducirla demasiado. Haga que tenga, por lo menos, un ancho de 40 columnas para poder leer la mayoría de mensajes en la última línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On most Unix systems, resizing the window is recognized and handled correctly by Vim.  {Vi: not ok}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de sistemas Unix Vim trata adecuadamente redimensionar las ventanas. {Vi: no tan bien.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>8. Definitions						*definitions*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>8. Definiciones				 *definiciones* *definitions*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  screen		The whole area that Vim uses to work in.  This can be
			a terminal emulator window.  Also called "the Vim
			window".
  window		A view on a buffer.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  pantalla		El área completa que usa Vim. Puede ser la ventana de
			un emulador de terminal. También llamada la «ventana
			de Vim».
  ventana		El área de visión de un búfer.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------+
screen	| window 1	| window 2	|
	|		|		|
	|		|		|
	|= status line =|= status line =|
	| window 3			|
	|				|
	|				|
	|==== status line ==============|
	|command line			|
	+-------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------+
pantalla| ventana 1	| ventana 2	|
	|		|		|
	|		|		|
	|línea de estado|línea de estado|
	| ventana 3			|
	|				|
	|				|
	|==== línea de estado ==========|
	|línea de órdenes		|
	+-------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command line is also used for messages.  It scrolls up the screen when there is not enough room in the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea de órdenes se usa también para mensajes. Desplaza la pantalla hacia arriba cuando no hay suficiente espacio para la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>buffer lines	logical lines	window lines	screen lines ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>líneas de búfer	líneas lógicas	líneas de ventana	líneas de pantalla ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. one		1. one		1. +-- folded   1.  +-- folded
2. two		2. +-- folded	2. five		2.  five
3. three	3. five		3. six		3.  six
4. four		4. six		4. seven	4.  seven
5. five		5. seven			5.  === status line ===
6. six						6.  aaa
7. seven					7.  bbb
						8.  ccc ccc c
1. aaa		1. aaa		1. aaa		9.  cc
2. bbb		2. bbb		2. bbb		10. ddd
3. ccc ccc ccc	3. ccc ccc ccc	3. ccc ccc c	11. ~ 
4. ddd		4. ddd		4. cc		12. === status line ===
				5. ddd		13. (command line)
				6. ~ 
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. uno		1. uno		1. +-- plegado  1.  +-- plegado
2. dos		2. +-- plegado	2. cinco	2.  cinco
3. tres		3. cinco	3. seis		3.  seis
4. cuatro	4. seis		4. siete	4.  siete
5. cinco	5. siete			5.  === línea de estado ===
6. seis						6.  aaa
7. siete					7.  bbb
						8.  ccc ccc c
1. aaa		1. aaa		1. aaa		9.  cc
2. bbb		2. bbb		2. bbb		10. ddd
3. ccc ccc ccc	3. ccc ccc ccc	3. ccc ccc c	11. ~ 
4. ddd		4. ddd		4. cc		12. === línea de estado ===
				5. ddd		13. (línea de órdenes)
				6. ~ 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> vim:tw=78:ts=8:ft=help:norl:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> vim:tw=78:ts=8:ft=help:norl:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_21.txt*	For Vim version 7.3.  Last change: 2008 Nov 09
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_21.esx*	Para Vim version 7.3.  Último cambio: 9/11/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			   Go away and come back
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Abandonar el editor y volver
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|21.1|	Suspend and resume
|21.2|	Executing shell commands
|21.3|	Remembering information; viminfo
|21.4|	Sessions
|21.5|	Views
|21.6|	Modelines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|21.1|	Suspender y continuar
|21.2|	Ejecutar órdenes de consola
|21.3|	Recordar información; viminfo
|21.4|	Sesiones
|21.5|	Vistas
|21.6|	«Modelines»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_22.txt|  Finding the file to edit
 Previous chapter: |usr_20.txt|  Typing command-line commands quickly
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_22.esx|  Encontrar el archivo a editar
  Capítulo anterior: |usr_20.esx|  Teclear con rapidez órdenes de consola
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.1*	Suspend and resume
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.1*	Suspender y continuar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-Z
	{any sequence of shell commands}
	fg
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-Z
	{cualquier secuencia de órdenes de consola}
	fg
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only Unix has support for this.  On other systems Vim will start a shell for
you.  This also has the functionality of being able to execute shell commands.
But it's a new shell, not the one that you started Vim from.
   When you are running the GUI you can't go back to the shell where Vim was
started.  CTRL-Z will minimize the Vim window instead.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solo Unix es compatible con esta función. Vim iniciará una consola
en otros sistemas. Esto también tiene la funcionalidad de permitirle
ejecutar órdenes de consola.
Pero esta es una nueva consola, no desde la que inició Vim.
   Cuando está ejecutando la interfaz gráfica no puede volver a la consola
desde la que se inició Vim. En esta situación, CTRL-Z minimizará la ventana
de Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.2*	Executing shell commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.2*	Ejecutar órdenes de consola
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To execute a single shell command from Vim use ":!{command}".  For example, to see a directory listing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:!{orden}» para ejecutar una sola orden de consola desde Vim.  Por ejemplo, para ver el listado de un directorio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!ls
	:!dir
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!ls
	:!dir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first one is for Unix, the second one for MS-Windows.
   Vim will execute the program.  When it ends you will get a prompt to hit
&lt;Enter&gt;.  This allows you to have a look at the output from the command before
returning to the text you were editing.
   The "!" is also used in other places where a program is run.  Let's take
a look at an overview:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primero es para Unix, el segundo para MS-Windows.
  Vim ejecutará el programa. Cuando finalice, obtendrá un dialogo para
pulsar &lt;Intro&gt;. Esto le permite ver la salida de la orden antes de volver
al texto que estaba editando.
  El signo «!» también se usa en otros sitios cuando se ejecuta un programa.
Veamos com funciona esto de una manera general.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!{program}		execute {program}
	:r !{program}		execute {program} and read its output
	:w !{program}		execute {program} and send text to its input
	:[range]!{program}	filter text through {program}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!{programa}		execute {programa}
	:r !{programa}		execute {programa} y lea su salida
	:w !{programa}		execute {programa} y envíe texto a su entrada
	:[range]!{programa}	filtra texto a través de {programa}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the presence of a range before "!{program}" makes a big difference.  Without it executes the program normally, with the range a number of text lines is filtered through the program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nótese que la presencia de un rango antes de «!{programa}» marca una gran diferencia. Sin él, ejecuta el programa de manera normal, con el rango se filtran un número de líneas a través del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executing a whole row of programs this way is possible.  But a shell is much better at it.  You can start a new shell this way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es imposible ejecutar una fila de programas de esta manera. Pero una consola es mejor para estas funciones. Puede iniciar una nueva consola de la siguiente manera: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:shell
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:shell
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to using CTRL-Z to suspend Vim.  The difference is that a new shell is started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es parecido al uso de «CTRL-Z» para suspender Vim. La diferencia es que se inicia una nueva consola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the GUI the shell will be using the Vim window for its input and
output.  Since Vim is not a terminal emulator, this will not work perfectly.
If you have trouble, try toggling the 'guipty' option.  If this still doesn't
work well enough, start a new terminal to run the shell in.  For example with:
&gt;
	:!xterm&amp;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar la GUI, la consola usará la ventana de Vim para entrada y salida. Ya
que Vim no es una terminal, esto no funcionará perfectamente.
Si tiene un problema, pruebe a conmutar la opción 'guipty'. Si esto tampoco
funciona, inicie una nueva terminal para iniciar el intérprete de órdenes.
Por ejemplo, con:
&gt;
	:!xterm&amp;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.3*	Remembering information; viminfo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.3*	Recordar información; viminfo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Command-line and Search pattern history
	Text in registers
	Marks for various files
	The buffer list
	Global variables
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Histórico de la línea de órdenes y patrones de búsqueda
	Texto en registros
	Marcas para varios archivos
	La lista de búfers
	Variables globales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time you exit Vim it will store this information in a file, the viminfo file.  When Vim starts again, the viminfo file is read and the information restored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada vez que cierre Vim, este guardará esta información en un archivo, el archivo viminfo. Cuando inicie Vim otra vez, leerá el archivo viminfo y restaurará la información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'viminfo' option is set by default to restore a limited number of items.  You might want to set it to remember more information.  This is done through the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'viminfo' esta configurada por omisión para almacenar un limitado número de elementos. Puede que desee configurarlo para que recuerde más información. Esto se hace con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set viminfo=string
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set viminfo=string
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set viminfo='1000
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set viminfo='1000
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The f option controls whether global marks (A-Z and 0-9) are stored.  If this option is 0, none are stored.  If it is 1 or you do not specify an f option, the marks are stored.  You want this feature, so now you have this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «f» controla si se guardan las marcas globales (A-Z y 0-9). Si esta opción es 0, no se guarda nada. Si es 1 o no especificó una opción «f», las marcas se guardan. Desea esta función, y por ello ahora obtiene esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set viminfo='1000,f1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set viminfo='1000,f1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt; option controls how many lines are saved for each of the registers.  By default, all the lines are saved.  If 0, nothing is saved.  To avoid adding thousands of lines to your viminfo file (which might never get used and makes starting Vim slower) you use a maximum of 500 lines: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «&lt;» define el número de líneas a guardar por cada registro. Por omisión, todas las líneas se guardan. Si es 0, nada se guarda. Para evitar que se añadan miles de líneas a su archivo viminfo (que puede que nunca se usen, y ralenticen el arranque de Vim) puede usar un máximo de 500 líneas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set viminfo='1000,f1,&lt;500
&lt;
Other options you might want to use:
	:	number of lines to save from the command line history
	@	number of lines to save from the input line history
	/	number of lines to save from the search history
	r	removable media, for which no marks will be stored (can be
		used several times)
	!	global variables that start with an uppercase letter and
		don't contain lowercase letters
	h	disable 'hlsearch' highlighting when starting
	%	the buffer list (only restored when starting Vim without file
		arguments)
	c	convert the text using 'encoding'
	n	name used for the viminfo file (must be the last option)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set viminfo='1000,f1,&lt;500
&lt;
Otras opciones que puede que desee usar:
	:	número de líneas a guardar del historial de la línea
		de órdenes
	@	número de líneas a guardar de la línea de entrada del
		historial
	/	número de líneas a guardar del historial de búsquedas
	r	dispositivos extraíbles, del cual no se guardan marcas
		(se puede introducir varias veces)
	!	variables globales que comienzan con mayúscula y que no
		contienen minúsculas
	h	desactivar el resaltado de 'hlsearch' al inicio
	%	la lista de búfers (solo se restaura si inicia Vim
		sin argumentos de archivo)
	c	convertir el texto usando 'encoding'
	n	nombre usado para el archivo viminfo (tiene que ser la
		última opción)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go back to a file that you edited recently, but not when exiting Vim, there is a slightly more complicated way.  You can see a list of files by typing the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea volver a un archivo que editó recientemente, pero no al cerrar Vim, hay una manera un tanto más complicada. Puede ver una lista de archivos tecleando la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you would like to edit the second file, which is in the list preceded by "2:".  You type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora le gustaría editar el segundo archivo, que está en la lista precedido por «2:». Teclee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:e #&lt;2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:e #&lt;2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ":e" you can use any command that has a file name argument, the "#&lt;2" item works in the same place as "%" (current file name) and "#" (alternate file name).  So you can also split the window to edit the third file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de «:e», puede usar cualquier orden que tiene un nombre de archivo como argumento, el elemento «#&lt;2» funciona en el mismo lugar que «%» (nombre del archivo actual) y «#» (nombre de archivo alterno). Puede también dividir la ventana para editar el tercer archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:split #&lt;3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:split #&lt;3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That #&lt;123 thing is a bit complicated when you just want to edit a file.  Fortunately there is a simpler way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar #&lt;123 es poco complicado cuando solo quiere editar un archivo.  Afortunadamente, hay una manera más simple: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:browse oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
	-- More --
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:browse oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
	-- Más --
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get the same list of files as with |:oldfiles|.  If you want to edit "resume.txt" first press "q" to stop the listing.  You will get a prompt:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá la misma lista de archivos que con |:oldfiles|. Si desea editar «resume.txt», pulse primero «q» para detener el listado. Obtendrá un dialogo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Type number and &lt;Enter&gt; (empty cancels): ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Teclee el número y pulse &lt;Intro&gt; (vaciar cancelaciones): ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the ":wviminfo" and ":rviminfo" commands to save and restore the information while still running Vim.  This is useful for exchanging register contents between two instances of Vim, for example.  In the first Vim do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede emplear las órdenes «:wviminfo» y «:rviminfo» para guardar y restaurar la información mientras Vim se está ejecutando. Ésto es útil para intercambiar los contenidos del registro de dos instancias de Vim, por ejemplo. En el primer Vim, haga: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wviminfo! ~/tmp/viminfo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wviminfo! ~/tmp/viminfo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:rviminfo! ~/tmp/viminfo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:rviminfo! ~/tmp/viminfo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, the "w" stands for "write" and the "r" for "read".
   The ! character is used by ":wviminfo" to forcefully overwrite an existing
file.  When it is omitted, and the file exists, the information is merged into
the file.
   The ! character used for ":rviminfo" means that all the information is
used, this may overwrite existing information.  Without the ! only information
that wasn't set is used.
   These commands can also be used to store info and use it again later.  You
could make a directory full of viminfo files, each containing info for a
different purpose.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, «w» significa «write», y «r», «read».
   El caracter «!» se usa por «:wviminfo» para forzar la sobreescritura de
un archivo existente. Cuando se omite, y el archivo existe, la información
es fusionada en el archivo.
   El caracter «!» usado por «:rviminfo» significa que se usa toda la
información, y esto puede sobreescribir información ya presente. Sin «!»
sólo se usa la información que no estaba definida.
   Estas órdenes se pueden usar también para guardar info y usarlo más tarde.
Puede crear un directorio lleno de archivos «viminfo», cada uno con info
dependiendo del propósito.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.4*	Sessions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.4*	Sesiones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mksession vimbook.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mksession vimbook.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:source vimbook.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:source vimbook.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -S vimbook.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -S vimbook.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to read a specific file on startup.  The 'S' stands for session (actually, you can source any Vim script with -S, thus it might as well stand for "source").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le dice a Vim que lea un archivo en particular al inicio. La «S» significa sesión (en realidad, puede introducir cualquier script a Vim con «-S», por ello también puede significar «source», fuente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The windows that were open are restored, with the same position and size as
before.  Mappings and option values are like before.
   What exactly is restored depends on the 'sessionoptions' option.  The
default value is "blank,buffers,curdir,folds,help,options,winsize".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las ventanas que estaban abiertas se restauran, con la misma posición y
tamaño que antes. Las macros y valores de opciones son también las mismas.
   Lo que se restaura exactamente depende de la opción 'sessionoptions'. El
valor predeterminado es «blank,buffers,curdir,folds,help,options,winsize».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	blank		keep empty windows
	buffers		all buffers, not only the ones in a window
	curdir		the current directory
	folds		folds, also manually created ones
	help		the help window
	options		all options and mappings
	winsize		window sizes
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	blank		mantener ventanas vacías
	buffers		todos los «buffers», no sólo los de una ventana
	curdir		el directorio actual
	folds		pliegues, también los manualmente creados
	help			la ventana de ayuda
	options		todas las opciones y macros
	winsize		tamaño de ventanas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change this to your liking.  To also restore the size of the Vim window, for example, use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modifique esto según su convenienvia. Para también restaurar el tamaño de la ventana de Vim use, por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set sessionoptions+=resize
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set sessionoptions+=resize
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The obvious way to use sessions is when working on different projects.  Suppose you store you session files in the directory "~/.vim".  You are currently working on the "secret" project and have to switch to the "boring" project: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera obvia de usar sesiones es cuando trabaja en diferenes proyetos.  Suponga que guarda sus archivos de sesión en el directorio «~/.vim». Está trabajando actualmente en el proyecto «secreto» y tiene que cambiar al proyecto «aburrido»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wall
	:mksession! ~/.vim/secret.vim
	:source ~/.vim/boring.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wall
	:mksession! ~/.vim/secreto.vim
	:source ~/.vim/aburrido.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:source ~/.vim/boring.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:source ~/.vim/aburrido.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you have complete control over whether you want to continue next time
where you are now, by saving the current setup in a session, or keep the
session file as a starting point.
   Another way of using sessions is to create a window layout that you like to
use, and save this in a session.  Then you can go back to this layout whenever
you want.
   For example, this is a nice layout to use:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, ahora tiene un completo control sobre continuar en el mismo punto
la siguiente vez que lo abra, guardando la configuración actual en una
sesión, o mantener el archivo de sesión como un punto de partida.
   Otra manera de usar sesiones es crear una organización de ventana que le
gusta usar, y guardarla en una sesión. Después podrá volver a este orden
siempre que quiera.
   Por ejemplo, esta es una bonita organización que puede usar:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------------+
	|		   VIM - main help file  |
	|					 |
	|Move around:  Use the cursor keys, or "h|
	|help.txt================================|
	|explorer   |				 |
	|dir	    |~				 |
	|dir	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|~/=========|[No File]===================|
	|					 |
	+----------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------------+
	|		   VIM - main help file  |
	|					 |
	|Desplazarse:  Use las teclas de direcció|
	|help.txt================================|
	|explorer   |				 |
	|dir	    |~				 |
	|dir	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|~/=========|[No File]===================|
	|					 |
	+----------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This has a help window at the top, so that you can read this text.  The narrow
vertical window on the left contains a file explorer.  This is a Vim plugin
that lists the contents of a directory.  You can select files to edit there.
More about this in the next chapter.
   Create this from a just started Vim with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta tiene una ventana de ayuda en la parte superior, para que pueda leer
este texto. La estrecha ventana vertical a la izquierda contiene un
explorador de archivos. Esta es una extensión de Vim que lista los
contenidos de un directorio. Puede seleccionar qué archivos editar ahí.
Más acerca de esto en el siguiente capítulo.
   Puede crear esto con una instancia nueva de Vim con: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help
	CTRL-W w
	:vertical split ~/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help
	CTRL-W w
	:vertical split ~/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can resize the windows a bit to your liking.  Then save the session with:
&gt;
	:mksession ~/.vim/mine.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede redimensionar las ventanas a su gusto. Guarde entonces la sesión con:
&gt;
	:mksession ~/.vim/mio.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -S ~/.vim/mine.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -S ~/.vim/mio.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: To open a file you see listed in the explorer window in the empty window, move the cursor to the filename and press "O".  Double clicking with the mouse will also do this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pista: Para abrir un archivo que vea listado en la ventana del explorador en la ventana vacía, mueva el cursor al nombre del archivo y pulse «O». Pulsar dos veces con el ratón le daría el mismo resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some people have to do work on MS-Windows systems one day and on Unix another day.  If you are one of them, consider adding "slash" and "unix" to 'sessionoptions'.  The session files will then be written in a format that can be used on both systems.  This is the command to put in your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay gente que tiene que trabajar un día con sistemas MS-WINDOWS y con Unix al siguiente. Si es uno de ellos, considere añadir «slash» y «unix» a 'sessionoptions'. Los archivos de sesión se guardarán en un formato que les permita ser usados en ambos sistemas. Esta es una orden para poner en su archivo vimrc: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set sessionoptions+=unix,slash
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set sessionoptions+=unix,slash
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will use the Unix format then, because the MS-Windows Vim can read and write Unix files, but Unix Vim can't read MS-Windows format session files.  Similarly, MS-Windows Vim understands file names with / to separate names, but Unix Vim doesn't understand \.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará el formato Unix, porque Vim para MS-Windows puede leer y escribir archivos de Unix, pero Vim para Unix no puede leer los archivos de sesión con formato de MS-Windows. De manera similar, Vim para MS-Windows entiene los nombres de archivo con «/» como diferentes palabras, pero Vim para Unix no entiende «\».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sessions store many things, but not the position of marks, contents of
registers and the command line history.  You need to use the viminfo feature
for these things.
   In most situations you will want to use sessions separately from viminfo.
This can be used to switch to another session, but keep the command line
history.  And yank text into registers in one session, and paste it back in
another session.
   You might prefer to keep the info with the session.  You will have to do
this yourself then.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las sesiones guardan muchas cosas, pero no la posición de las marcas,
contenidos de registros e historiales de la línea de órdenes. Precisa emplear
«viminfo» para estas cosas.
   En la mayoría de las situaciones deseará usar sesiones separadas de
«viminfo».
Puede emplear esto para pasar a otra sesión, pero manteniendo el historial
de la línea de órdenes. También puede copiar el texto de los registros de una
sesión, y pegarlos en otra sesión diferente.
   Puede que prefiera mantener el información en la sesión. Tendrá que hacer
esto usted mismo. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mksession! ~/.vim/secret.vim
	:wviminfo! ~/.vim/secret.viminfo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mksession! ~/.vim/secreto.vim
	:wviminfo! ~/.vim/secreto.viminfo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:source ~/.vim/secret.vim
	:rviminfo! ~/.vim/secret.viminfo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:source ~/.vim/secreto.vim
	:rviminfo! ~/.vim/secreto.viminfo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.5*	Views
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.5*	Vistas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A session stores the looks of the whole of Vim.  When you want to store the
properties for one window only, use a view.
   The use of a view is for when you want to edit a file in a specific way.
For example, you have line numbers enabled with the 'number' option and
defined a few folds.  Just like with sessions, you can remember this view on
the file and restore it later.  Actually, when you store a session, it stores
the view of each window.
   There are two basic ways to use views.  The first is to let Vim pick a name
for the view file.  You can restore the view when you later edit the same
file.  To store the view for the current window: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una sesión guarda el aspecto completo de Vim. Cuando desea guardar sólo las
propiedades de una ventana, use una vista.
   El uso de una vista es útil cuando desea editar un archivo de una manera
específica.
Por ejemplo, ha activado el número de líneas con la opción 'number' y
definido algunos plegados. Al igual que con las sesiones, puede guardar esta
vista en el archivo y restaurarla más tarde. En realidad, cuando guarda una
sesión, éste guarda la vista de cada ventana.
   Hay dos maneras básicas de usar las vistas. La primera es dejar que Vim
escoja el nombre para el archivo de la vista. Puede restaurar la vista
posteriormente cuando edite el mismo archivo. Para guardar la vista de la
ventana actual: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mkview
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mkview
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will decide where to store the view.  When you later edit the same file you get the view back with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim decidirá donde guardar la vista. Cuando más tarde edite el mismo archivo puede recuperar la vista con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:loadview
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:loadview
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's easy, isn't it?
   Now you want to view the file without the 'number' option on, or with all
folds open, you can set the options to make the window look that way.  Then
store this view with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fácil, ¿no?
   Cuando quiere ver el archivo sin la opción 'number' activada, o con todos
los plegados abiertos, puede definir las opciones para que la ventana
presente ese aspecto. Una vez hecho ésto, guarde ésta vista con: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mkview 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mkview 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:loadview 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:loadview 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can switch between the two views on the file by using ":loadview" with
and without the "1" argument.
   You can store up to ten views for the same file this way, one unnumbered
and nine numbered 1 to 9.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede pasar de una vista a otra del archivo usando «:loadview» con y
sin el argumento «1».  De esta forma, puede guardar hasta diez vistas para el
mismo archivo, uno sin numerar y nueve numerados del 1 al 9.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second basic way to use views is by storing the view in a file with a name
you chose.  This view can be loaded while editing another file.  Vim will then
switch to editing the file specified in the view.  Thus you can use this to
quickly switch to editing another file, with all its options set as you saved
them.
   For example, to save the view of the current file: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda manera básica de usar las vistas se puede hacer guardando la vista
en un archivo con un nombre de su elección. Puede cargar esta vista mientras
edita un archivo distinto. Entonces, Vim pasará a editar el archivo
especificado en la vista. Por ello, puede usar ésto para pasar rápidamente
a editar otro archivo, con todas las opciones definidas tal y como las
guardó.
   Por ejemplo, para guardar la vista del archivo actual: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mkview ~/.vim/main.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mkview ~/.vim/principal.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:source ~/.vim/main.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:source ~/.vim/principal.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.6*	Modelines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.6*	«Modelines»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When editing a specific file, you might set options specifically for that
file.  Typing these commands each time is boring.  Using a session or view for
editing a file doesn't work when sharing the file between several people.
   The solution for this situation is adding a modeline to the file.  This is
a line of text that tells Vim the values of options, to be used in this file
only.
   A typical example is a C program where you make indents by a multiple of 4
spaces.  This requires setting the 'shiftwidth' option to 4.  This modeline
will do that:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al editar un archivo en particular, puede que defina opciones específicas
para ese archivo. Teclear estas órdenes es aburrido. Usar una sesión o vista
para editar un archivo no funciona cuando comparte el archivo con varias
personas.
   La solución para esta situación es añadir un «modeline» al archivo. Éste
es una línea de texto que le dice a Vim los valores de las opciones para su
uso con este archivo en particular.
   Un ejemplo típico es un programa en C en el que introduce los tabulados
como múltiplos de 4. Esto requiere que configure la opción 'shiftwidth' a 4.
Este «modeline» hará esta función:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* vim:set shiftwidth=4: */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* vim:set shiftwidth=4: */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this line as one of the first or last five lines in the file.  When
editing the file, you will notice that 'shiftwidth' will have been set to
four.  When editing another file, it's set back to the default value of eight.
   For some files the modeline fits well in the header, thus it can be put at
the top of the file.  For text files and other files where the modeline gets
in the way of the normal contents, put it at the end of the file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga esta línea como uno de las primeras o cinco últimas líneas en el
archivo. Cuando edite el archivo, notará que 'shiftwidth' se ha definido
con valor de cuatro. Cuando edite otro archivo, esta opción será devuelta
a su valor predeterminado de ocho.
   Para algunas líneas, el «modeline» encaja en la cabecera, y por ello puede
ponerlo al inicio del archivo. Para los archivos de texto y otros archivos en
los que el «modeline» se interpone en el camino de los contenidos normales,
póngala al final del archivo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'modelines' option specifies how many lines at the start and end of the file are inspected for containing a modeline.  To inspect ten lines: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «modelines» especifica cuantas líneas son inspeccionadas al inicio y final del archivo en busca de un «modeline». Para inspeccionar diez líneas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set modelines=10
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set modelines=10
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'modeline' option can be used to switch this off.  Do this when you are working as root on Unix or Administrator on MS-Windows, or when you don't trust the files you are editing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la opción 'modeline' para desactivar ésto. Haga ésto cuando trabaje como «root» en Unix, o administrador en MS-Windows; o cuando no confía en los archivos que está editando: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nomodeline
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nomodeline
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	any-text vim:set {option}={value} ... : any-text ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	any-text vim:set {opción}={valor} ... : any-text ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "any-text" indicates that you can put any text before and after the part
that Vim will use.  This allows making it look like a comment, like what was
done above with /* and */.
   The " vim:" part is what makes Vim recognize this line.  There must be
white space before "vim", or "vim" must be at the start of the line.  Thus
using something like "gvim:" will not work.
   The part between the colons is a ":set" command.  It works the same way as
typing the ":set" command, except that you need to insert a backslash before a
colon (otherwise it would be seen as the end of the modeline).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«any-text» indica que puede introducir texto antes y después de la parte
que Vim usará. Esto permite que presente el aspecto de un comentario, de la
manera en que se hizo antes con /* y */.
   La parte de «vim:» es lo que hace que Vim reconozca esta línea. Debe haber
un espacio en blanco antes de «vim», o «vim» ha de estar al inicio de la
línea. Por ello, usar algo como «gvim» no funcionaría.
   La parte entre los dos puntos es una orden «:set». Funciona de la misma
manera que teclear la orden «:set», con la excepción de que tiene que
introducir una barra inversa antes de un colon (en caso contrario, se vería
como el final de un «modeline»).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	// vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	// vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an extra backslash before the first colon, so that it's included in the ":set" command.  The text after the second colon is ignored, thus a remark can be placed there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una barra inversa extra antes del primer colon, y por ello se incluye en la orden «:set». Se ignora el texto antes del segundo colon, y por ello puede introducir aquí un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_29.txt*	For Vim version 7.3.  Last change: 2008 Jun 28
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_29.esx*	Para Vim versión 7.3.  Último cambio: 8/6/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			    Moving through programs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Moverse a través de programas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The creator of Vim is a computer programmer.  It's no surprise that Vim contains many features to aid in writing programs.  Jump around to find where identifiers are defined and used.  Preview declarations in a separate window.  There is more in the next chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El creador de Vim es un programador informático. Por ello, no sorprende que Vim integre tantas características que facilitan la edición de programas. Salte de un punto a otro para ver dónde se definen y usan los identificadores. Previsualize declaraciones en una ventana distinta. Hay aún más en el siguiente capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|29.1|	Using tags
|29.2|	The preview window
|29.3|	Moving through a program
|29.4|	Finding global identifiers
|29.5|	Finding local identifiers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|29.1|	Usar etiquetas
|29.2|	La ventana de vista previa
|29.3|	Moverse a través de un programa
|29.4|	Buscar identificadores globales
|29.5|	Buscar identificadores locales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_30.txt|  Editing programs
 Previous chapter: |usr_28.txt|  Folding
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_30.txt|  Editar programas
  Capítulo anterior: |usr_28.esx|  Plegado
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.1*	Using tags
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.1*	Usar etiquetas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ctags *.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ctags *.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	http://ctags.sf.net ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	http://ctags.sf.net ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tag startlist
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tag startlist
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i &lt; cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--&gt; |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--&gt; |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i &lt; cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--&gt; |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--&gt; |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tags
	  # TO tag	   FROM line  in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	&gt; ~
&gt;
Now to go back.  The CTRL-T command goes to the preceding tag.  In the example
above you get back to the "write_line" function, in the call to "write_char".
   This command takes a count argument that indicates how many tags to jump
back.  You have gone forward, and now back.  Let's go forward again.  The
following command goes to the tag on top of the list: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tags
	  # TO tag	   FROM line  in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	&gt; ~
&gt;
Vuelva atrás ahora. La orden «CTRL-T» se desplaza a la etiqueta precedente.
En el ejemplo anterior, vuelve a la función «write_line» al invocar
«write_char».
   Esta orden toma un argumento numérico que indica el número de etiquetas
que se desplazará hacia atrás. Ahora que ha ido hacia delante, vuelva atrás.
Vayamos otra vez hacia delante. La siguiente orden se desplaza a la etiqueta
al principio de la lista: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tag
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tag
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can prefix it with a count and jump forward that many tags.  For example:
":3tag".  CTRL-T also can be preceded with a count.
   These commands thus allow you to go down a call tree with CTRL-] and back
up again with CTRL-T.  Use ":tags" to find out where you are.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede precederlo de un número para saltar hacia delante ese número d
etiquetas. Por ejemplo:
«:3tag». También puede preceder «CTRL-T» con un número.
   Por ello, estas órdenes permiten desplazarse hacia delante con «CTRL-]»,
y hacia atrás con «CTRL-T». Use «:tags» conocer dónde se encuentra.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":tag" command replaces the file in the current window with the one
containing the new function.  But suppose you want to see not only the old
function but also the new one?  You can split the window using the ":split"
command followed by the ":tag" command.  Vim has a shorthand command that does
both: &gt;
	:stag tagname
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:tag» reemplaza el fichero en la ventana actual con el que contiene
la nueva función. Pero suponga que desea ver no sólo la función antigua, y
no sólo la nueva. Para ello, puede dividir la ventana usando la orden
«:split», seguida de la orden «:tag». Vim tiene una orden corta que realiza
ambas funciones: &gt;
	:stag tagname
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W ]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W ]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have files in many directories, you can create a tags file in each of
them.  Vim will then only be able to jump to tags within that directory.
   To find more tags files, set the 'tags' option to include all the relevant
tags files.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene varios ficheros en muchos directorios, puede crear un fichero de
etiquetas en cada uno de ellos. Vim sólo podrá saltar a etiquetas dentro de
ese directorio.
   Para encontrar más ficheros de etiquetas, defina la opción 'tags' para
incluir todos los ficheros de etiquetas relevantes. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=./tags,./../tags,./*/tags
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=./tags,./../tags,./*/tags
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds a tags file in the same directory as the current file, one
directory level higher and in all subdirectories.
   This is quite a number of tags files, but it may still not be enough.  For
example, when editing a file in "~/proj/src", you will not find the tags file
"~/proj/sub/tags".  For this situation Vim offers to search a whole directory
tree for tags files.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra un fichero de etiquetas en el mismo directorio que el
fichero actual, un nivel de directorios superiores y en todos los
subdirectorios.
   Este es un alto número de ficheros de etiquetas, pero puede que no lo
suficiente. Por ejemplo, al editar un fichero en «~/proj/src», no encontraría
el fichero de etiquetas «~/proj/sub/tags». Por ello, Vim ofrece buscar
ficheros de etiquetas en todo el árbol de directorios. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=~/proj/**/tags
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=~/proj/**/tags
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	cd ~/proj
	ctags -R .
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	cd ~/proj
	ctags -R .
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The nice thing about this is that Exuberant ctags recognizes various file
types.  Thus this doesn't work just for C and C++ programs, also for Eiffel
and even Vim scripts.  See the ctags documentation to tune this.
   Now you only need to tell Vim where your big tags file is: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo mejor de esto es que Exuberant ctags reconoce varios tipos de fichero.
Por ello, no sólo funciona con programas de C y C++, sino también para
Eiffel e incluso scripts de Vim. Consulte la documentación de ctags para
información de configuración.
   Ahora sólo tiene que decir a Vim dónde está su fichero grande de
etiquetas: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=~/proj/tags
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=~/proj/tags
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a function is defined multiple times (or a method in several classes),
the ":tag" command will jump to the first one.  If there is a match in the
current file, that one is used first.
   You can now jump to other matches for the same tag with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una función se define varias veces (o un mismo método en varias
clases), la orden «:tag» saltaría a la primera aparición. De haber una
coincidencia en el fichero actual, se usará éste en primer lugar.
   Ahora puede saltar a otras coincidencias de la misma etiqueta con: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tnext
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tnext
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeat this to find further matches.  If there are many, you can select which one to jump to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repita para encontrar más coincidencias. De haber varias, puede seleccionar a cuál saltar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tselect tagname
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tselect etiqueta
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	  # pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (&lt;CR&gt; to abort):  ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	  # pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (&lt;CR&gt; to abort):  ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now enter the number (in the first column) of the match that you would like to jump to.  The information in the other columns give you a good idea of where the match is defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede introducir el número (en la primera columna) de la coincidencia a la que desea saltar. La información en las otras columnas le dan un buena idea de dónde se define la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tfirst			go to first match
	:[count]tprevious	go to [count] previous match
	:[count]tnext		go to [count] next match
	:tlast			go to last match
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tfirst			Primera coincidencia
	:[número]tprevious	Ir a la [número] coincidencia anterior
	:[count]tnext		Ir a la [número] coincidencia siguiente
	:tlast			Ir a la última coincidencia
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line completion is a good way to avoid typing a long tag name.  Just type the first bit and press &lt;Tab&gt;: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El autocompletado de línea de órdenes es una buena manera de evitar escribir un nombre de etiqueta largo. Simplemente escriba la primera parte y pulse &lt;Tab&gt;: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tag write_&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tag write_&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tag /block
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tag /block
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use command line completion: press &lt;Tab&gt;.  Vim will find all tags that
contain "block" and use the first match.
   The "/" before a tag name tells Vim that what follows is not a literal tag
name, but a pattern.  You can use all the items for search patterns here.  For
example, suppose you want to select a tag that starts with "write_": &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora el autocompletado de línea de órdenes pulsando &lt;Tab&gt;. Vim
encontrará todas las etiquetas que contienen «block», y usará la primera
coincidencia. La «/» antes del nombre de una etiqueta le dice a Vim que lo
hay a continuación no es un nombre de etiqueta, sino un patrón. Puede usar
todos los elementos de patrones de búsqueda.
Por ejemplo, supongo que desea seleccionar una etiqueta que empieza con
«write»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tselect /^write_
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tselect /^write_
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" specifies that the tag starts with "write_".  Otherwise it would also be found halfway a tag name.  Similarly "$" at the end makes sure the pattern matches until the end of a tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «^» especifica que la etiqueta empieza con «write_». En caso contrario,
se detectaría también de estar en medio de un nombre de etiqueta. De forma
similar, el signo «$» al final asegura que el patrón sólo coincida con el
final de una etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since CTRL-] takes you to the definition of the identifier under the cursor,
you can use a list of identifier names as a table of contents.  Here is an
example.
   First create a list of identifiers (this requires Exuberant ctags): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que «CTRL-]» le lleva a la definición del identificador bajo el cursor,
puede usar un alista de nombres identificadores como una tabla de contenidos.
Aquí tiene un ejemplo.
   Primero cree una lista de identificadores (require Exuberant ctags): &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ctags --c-types=f -f functions *.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ctags --c-types=f -f functions *.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim
	:vsplit functions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim
	:vsplit functions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The window contains a list of all the functions.  There is some more stuff,
but you can ignore that.  Do ":setlocal ts=99" to clean it up a bit.
   In this window, define a mapping: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta ventana contiene todas una lista de todas las funciones. También hay
más elementos, pero los puede ignorar. Ejecute «setlocal ts=99» para
organizarlo un poco.
   Defina una macro en esta ventana: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:nnoremap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;"&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:nnoremap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;"&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'tagbsearch' option tells if the tags file is sorted or not.  The default is to assume a sorted tags file, which makes a tags search a lot faster, but doesn't work if the tags file isn't sorted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'tagbsearch' indica si el archivo de etiquetas está ordenado o no. El valor predeterminado es suponer un archivo de etiquetas ordenado, que agiliza la búsqueda de etiquetas, pero no funciona si el archivo de etiquetas no está ordenado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use the SNiFF+ program, you can use the Vim interface to it |sniff|.  SNiFF+ is a commercial program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa el programa SNiFF+, puede usar la interfaz de Vim |sniff|. SNiFF+ es un programa comercial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cscope is a free program.  It does not only find places where an identifier is declared, but also where it is used.  See |cscope|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cscope es un programa libre. No sólo encuentra los lugares dónde se declara un identificador. sino también dónde se usa. Consulte |cscope|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.2*	The preview window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.2*	La ventana de previsualización
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you edit code that contains a function call, you need to use the correct
arguments.  To know what values to pass you can look at how the function is
defined.  The tags mechanism works very well for this.  Preferably the
definition is displayed in another window.  For this the preview window can be
used.
   To open a preview window to display the function "write_char": &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edita código que contiene una llamada a una función, necesitará los
argumentos correctos. Para conocer los valores que puede introducir, puede
ver cómo se define la función. El mecanismo de etiquetas es adecuado para
esto. Preferentemente, la definición se muestra en otra ventana. Puede usar
la ventana de previsualización para esto.
   Use lo siguiente para abrir una ventana de previsualización que muestre
la función «write_char»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:ptag write_char
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:ptag write_char
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will open a window, and jumps to the tag "write_char".  Then it takes you
back to the original position.  Thus you can continue typing without the need
to use a CTRL-W command.
   If the name of a function appears in the text, you can get its definition
in the preview window with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá una ventana, y saltará a la etiqueta «write_char». A
continuación, vuelve a la posición original. Así, puede seguir escribiendo
sin necesidad de usar la orden «CTRL-W».
   Si el nombre de una función aparece en el texto, puede obtener su
definición en la ventana de previsualización con lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-W }
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-W }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a script that automatically displays the text where the word under the cursor was defined.  See |CursorHold-example|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un script que muestra el texto automáticamente dónde se definió la
palabra bajo el cursor. Consulte |CursorHold-example|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:pclose
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:pclose
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To edit a specific file in the preview window, use ":pedit".  This can be useful to edit a header file, for example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para editar un fichero específico en la ventana de previsualización, use «_pedit». Esto puede ser útil para editar la cabecera de un archivo, por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:pedit defs.h
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:pedit defs.h
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, ":psearch" can be used to find a word in the current file and any included files and display the match in the preview window.  This is especially useful when using library functions, for which you do not have a tags file.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, «:psearch» se puede utilizar para buscar una palabra en el archivo actual y cualquier archivo incluido («include») y mostrar la coincidencia en la ventana de previsualización. Esto es especialmente útil cuando se utilizan las funciones de la biblioteca para el que no tiene un archivo de etiquetas.  Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:psearch popen
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:psearch popen
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	FILE	*popen __P((const char *, const char *)); ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	FILE	*popen __P((const char *, const char *)); ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.3*	Moving through a program
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.3*	Moverse a través de un programa
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since a program is structured, Vim can recognize items in it.  Specific
commands can be used to move around.
   C programs often contain constructs like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a que un programa está estructurado, Vim puede reconocer elementos en
él. Puede usar órdenes específicas para desplazarse.
   Los programas en C habitualmente contienen construcciones como esta:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But then much longer, and possibly nested.  Position the cursor on the
"#ifdef" and press %.  Vim will jump to the "#else".  Pressing % again takes
you to the "#endif".  Another % takes you to the "#ifdef" again.
   When the construct is nested, Vim will find the matching items.  This is a
good way to check if you didn't forget an "#endif".
   When you are somewhere inside a "#if" - "#endif", you can jump to the start
of it with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero también más largo, y posiblemente anidado. Posicione el cursor sobre
«#ifdef» y pulse «%». Vim saltará al siguiente «#else». Pulsar «%» otra vez
le devuelve a «#endif». Otro «%» le llevaría a «#ifdef» otra vez.
    Cuando una construcción está anidada, Vim encontrará los elementos
coincidentes. Esta es una buena forma de comprobar si se ha olvidado de
insertar un «#endif».
   Cuando está en algún punto dentro de un «#if - #endif», puede saltar al
principio con lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[#
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[#
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not after a "#if" or "#ifdef" Vim will beep.  To jump forward to the next "#else" or "#endif" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no está después de un «#if» o «#ifdef» Vim emitirá un sonido. Para saltar hacia adelante al siguiente «#else» o «#endif» use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	]#
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	]#
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two commands skip any "#if" - "#endif" blocks that they encounter.  Example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas dos órdenes omiten cualquier bloque «#if - #endif» que se encuentran. Ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the cursor in the last line, "[#" moves to the first line.  The "#ifdef" - "#endif" block in the middle is skipped.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con el cursor en la última línea, «[#» le lleva a la primera línea. El bloque «#ifdef - #endif» en el centro se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C code blocks are enclosed in {}.  These can get pretty long.  To move to
the start of the outer block use the "[[" command.  Use "][" to find the end.
This assumes that the "{" and "}" are in the first column.
   The "[{" command moves to the start of the current block.  It skips over
pairs of {} at the same level.  "]}" jumps to the end.
   An overview:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los bloques de código C están limitados por {}. Esto puede ser muy largo.
Para saltar al principio del bloque exterior use la orden «[[». Use «][»
para encontrar el final.
Esto supone que «{» y «}» están en la primera columna.
   La orden «[{» le lleva al principio del bloque actual. Omite las parejas
de «{}» en el mismo nivel. «]}» salta al final.
   Una vista general:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			function(int a)
	   +-&gt;		{
	   |		    if (a)
	   |	   +-&gt;	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +-&gt;	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 &lt;-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       &lt;-+	 |
			}				       &lt;-+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			function(int a)
	   +-&gt;		{
	   |		    if (a)
	   |	   +-&gt;	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +-&gt;	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 &lt;-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       &lt;-+	 |
			}				       &lt;-+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing C++ or Java, the outer {} block is for the class.  The next level of {} is for a method.  When somewhere inside a class use "[m" to find the previous start of a method.  "]m" finds the next start of a method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al escribir en C++ o Java, el bloque exterior «{}» es para la clase. El siguiente nivel de «{}» es para un método. Si se encuentra dentro de una clase, use «[m» para encontrar el inicio previo de un método. «]m» encuentra el siguiente inicio de un método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, "[]" moves backward to the end of a function and "]]" moves forward to the start of the next function.  The end of a function is defined by a "}" in the first column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además, «[]» se mueve hacia atrás al final de la función, y «]]» se mueve hacia adelante, al inicio de la siguiente función. El final de la función está definido con un «}» al principio de la primera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				int func1(void)
				{
					return 1;
		  +----------&gt;  }
		  |
	      []  |		int func2(void)
		  |	   +-&gt;	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +-&gt;	}
	      ]]  |
		  |		int func3(void)
		  +----------&gt;	{
					return 3;
				}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				int func1(void)
				{
					return 1;
		  +----------&gt;  }
		  |
	      []  |		int func2(void)
		  |	   +-&gt;	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +-&gt;	}
	      ]]  |
		  |		int func3(void)
		  +----------&gt;	{
					return 3;
				}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget you can also use "%" to move between matching (), {} and [].  That also works when they are many lines apart.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se olvido de que también puede usar «%» para desplazarase entre parejas  de «()», «{}» y «[]». También funciona cuando están separados por varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[(" and "])" commands work similar to "[{" and "]}", except that they
work on () pairs instead of {} pairs.
&gt;
				  [(
&lt;		    &lt;--------------------------------
			      &lt;-------
		if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y) ~
				  --------------&gt;
			  --------------------------------&gt; &gt;
				       ])
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes  «[(» y «])» funcionan de manera similar a «[{» y «]}», con
la excepción de que funcionan con parejas de «()» en lugar de «{}».
&gt;
				  [(
&lt;		    &lt;--------------------------------
			      &lt;-------
		if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y) ~
				  --------------&gt;
			  --------------------------------&gt; &gt;
				       ])
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move back to the start of a comment use "[/".  Move forward to the end of a comment with "]/".  This only works for /* - */ comments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «[/» para volver al principio de un comentario. Puede moverse hacia adelante al final de un comentario con «]/». Sólo funciona con comentarios /* - */.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	  +-&gt;	  +-&gt; /*
	  |    [/ |    * A comment about      --+
       [/ |	  +--  * wonderful life.	| ]/
	  |	       */		      &lt;-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* a short comment */  &lt;-+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	  +-&gt;	  +-&gt; /*
	  |    [/ |    * Comentario sobre la  --+
       [/ |	  +--  * maravillosa vida.      | ]/
	  |	       */		      &lt;-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* Comentario corto */ &lt;-+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.4*	Finding global identifiers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.4* Buscar identificadores globales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[I
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[I
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will list the matching lines it can find.  Not only in the current file, but also in all included files (and files included in them, etc.).  The result looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VIM enumerará las líneas coincidentes que puede encontrar. No sólo en el archivo actual, sino también en todos los archivos incluidos (y archivos incluidos en ellos, etc..). El resultado tiene el siguiente aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   Vim will find included files in the places specified with the 'path'
option.  If a directory is missing, some include files will not be found.  You
can discover this with this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   Vim encontrará ficheros incluidos en los lugares definidos con la opción
'path'. Si falta un directorio puede que no se encuentren todos los archivos
incluidos. Puede descubrirlo con la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:checkpath
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:checkpath
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will list the include files that could not be found.  Also files included by the files that could be found.  An example of the output:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto lista todos los archivos incluidos que no pudo encontrar. También incluye archivos incluidos por los ficheros no encontrados. Un ejemplo de la salida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	--- Included files not found in path --- ~
	&lt;io.h&gt; ~
	vim.h --&gt; ~
	  &lt;functions.h&gt; ~
	  &lt;clib/exec_protos.h&gt; ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	--- Included files not found in path --- ~
	&lt;io.h&gt; ~
	vim.h --&gt; ~
	  &lt;functions.h&gt; ~
	  &lt;clib/exec_protos.h&gt; ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "io.h" file is included by the current file and can't be found.  "vim.h" can be found, thus ":checkpath" goes into this file and checks what it includes.  The "functions.h" and "clib/exec_protos.h" files, included by "vim.h" are not found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo «io.h» está incluido en el archivo actual y no se puede encontrar. Se puede encontrar «vim.h», y por ello «:checkpath» acude a ese archivo y compruebe qué incluye. Los archivos «functions.h» y «clib/exec_protos.h», incluidos por «vim.h» no se pueden encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	Vim is not a compiler.  It does not recognize "#ifdef" statements.
	This means every "#include" statement is used, also when it comes
	after "#if NEVER".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Vim no es un compilador. No reconoce las declaraciones «#ifdef».
	Esto significa que se usa cada declaración «#include», incluso si
	aparece después de «#if NEVER».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fix the files that could not be found, add a directory to the 'path' option.  A good place to find out about this is the Makefile.  Look out for lines that contain "-I" items, like "-I/usr/local/X11".  To add this directory use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para arreglar los archivo no encontrados, añada el directorio a la opción 'path'. Un buen sitio para averiguar esto es el archivo «Makefile». Busque líneas que contengan elementos «-I», como «-I/usr/local/X11». Use los siguiente para añadir este directorio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set path+=/usr/local/X11
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set path+=/usr/local/X11
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are many subdirectories, you can use the "*" wildcard.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el comodín «*» cuando haya varios directorios. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set path+=/usr/*/include
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set path+=/usr/*/include
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working on a project with a whole nested tree of included files, the "**" items is useful.  This will search down in all subdirectories.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos «**» son de utilidad cuando trabaja en un proyecto con un árblo anidado de archivos incluidos. Esto busca en todos los subdirectorios. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set path+=/projects/invent/**/include
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set path+=/projects/invent/**/include
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	etc.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	etc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are even more possibilities.  Check out the 'path' option for info.
   If you want to see which included files are actually found, use this
command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay incluso más posibilidades. Para más información consulte la opción
'path'.
   Use la siguiente orden si desea ver qué archivos incluidos se
encontraron: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:checkpath!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:checkpath!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will get a (very long) list of included files, the files they include, and so on.  To shorten the list a bit, Vim shows "(Already listed)" for files that were found before and doesn't list the included files in there again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá un lista muy larga de los archivos incluidos, los que éstos incluyen, y así sucesivamente. Para acortar la lista Vim muestra «Ya está listado» para los archivos encontrados anteriormente, y no muestra los ficheros incluidos nuevamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"[I" produces a list with only one line of text.  When you want to have a closer look at the first item, you can jump to that line with the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«[I» produce una lista con una sola línea de texto. Cuando desee ver el primer elemento, salte a esa línea con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list that "[I" produces has a number at the start of each line.  When you want to jump to another item than the first one, type the number first: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La lista que «[I» produce tiene un número al principio de la línea. Cuando desee saltar a otro elemento distinto al primero, primero introduzca el número:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	3[&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	3[&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will jump to the third item in the list.  Remember that you can use CTRL-O to jump back to where you started from.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto salta al tercer elemento de la lista. Recuerde que puede usar «CTRL-O» para volver al punto desde donde empezó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[i		only lists the first match
	]I		only lists items below the cursor
	]i		only lists the first item below the cursor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[i		Lista sólo la primera coincidencia
	]I		Lista sólo elementos bajo el cursor
	]i		Lista sólo el primer elemento bajo el cursor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[I" command finds any identifier.  To find only macros, defined with "#define" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «[I» encuentra cualquier identificador. Si sólo desea usar macros definidos con «#define» use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[D
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[D
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[d		only lists the first match
	]D		only lists items below the cursor
	]d		only lists the first item below the cursor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[d		Lista sólo la primera coincidencia
	]D		Lista sólo elementos bajo el cursor
	]d		Lista sólo el primer elemento bajo el cursor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.5*	Finding local identifiers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.5* Buscar identificadores locales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[I" command searches included files.  To search in the current file only, and jump to the first place where the word under the cursor is used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «[I» busca archivos incluidos. Use lo siguiente para buscar sólo en el archivo actual y saltar al primer sitio donde se usa la palabra bajo el cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gD
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gD
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	   +-&gt;   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	   +-&gt;   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gd
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will go back to the start of the current function and find the first occurrence of the word under the cursor.  Actually, it searches backwards to an empty line above a "{" in the first column.  From there it searches forward for the identifier.  Example (cursor on "idx"):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto volvería al principio de la función actual, y buscará la primera aparición de la palabra bajo el cursor. En realidad, busca en sentido inverso una línea vacía sobre un «{» en la primera columna. A partir de ahí, busca hacia adelante el identificador. Ejemplo (cursor sobre «idx»):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		int find_entry(char *name)
		{
	   +-&gt;	    int idx;
	   |
	gd |	    for (idx = 0; idx &lt; table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		int find_entry(char *name)
		{
	   +-&gt;	    int idx;
	   |
	gd |	    for (idx = 0; idx &lt; table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_40.txt*	For Vim version 7.3.  Last change: 2006 Jun 21
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_40.esx*	Para Vim version 7.3.  Último cambio: 21/6/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Make new commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			      Crear órdenes nuevas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|40.1|	Key mapping
|40.2|	Defining command-line commands
|40.3|	Autocommands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|40.1|	Macros de teclado
|40.2|	Definir órdenes de línea de órdenes
|40.3|	Órdenes automáticas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_41.txt|  Write a Vim script
 Previous chapter: |usr_32.txt|  The undo tree
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_41.esx|  Escribir scripts para Vim
  Capítulo anterior: |usr_32.esx|  El árbol de deshacer
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.1*	Key mapping
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.1*	Crear macros
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple mapping was explained in section |05.3|.  The principle is that one
sequence of key strokes is translated into another sequence of key strokes.
This is a simple, yet powerful mechanism.
   The simplest form is that one key is mapped to a sequence of keys.  Since
the function keys, except &lt;F1&gt;, have no predefined meaning in Vim, these are
good choices to map.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |05.3| se explicaba una macro («mapping») sencilla. El principio
es que una secuencia de pulsaciones de tecla se traduce a otra secuencia de
pulsaciones de tecla. Es un mecanismo sencillo pero poderoso.
   La forma más simple es asignar una tecla a una secuencia de teclas. Debido
a que las teclas de función, a excepción de &lt;F1&gt;, no tienen un significado
predefinido para Vim, son buenas candidatas para definir macros. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows how three modes are used.  After going to the last line with "G",
the "o" command opens a new line and starts Insert mode.  The text "Date: " is
inserted and &lt;Esc&gt; takes you out of insert mode.
   Notice the use of special keys inside &lt;&gt;.  This is called angle bracket
notation.  You type these as separate characters, not by pressing the key
itself.  This makes the mappings better readable and you can copy and paste
the text without problems.
   The ":" character takes Vim to the command line.  The ":read !date" command
reads the output from the "date" command and appends it below the current
line.  The &lt;CR&gt; is required to execute the ":read" command.
   At this point of execution the text looks like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este ejemplo muestra como usar tres modos. Después de ir a la última línea
con «G», la orden «o» crea una nueva línea e inicia el modo Insertar. Se
inserta el texto «Date:», y &lt;Esc&gt; abandona el modo de inserción.
   Tenga en cuenta el uso de teclas especiales dentro de &lt;&gt;. Se llama
notación de corchetes agudos. Los teclea como caracteres distintos, y no pulsando
la tecla referida. Esto hace que las macros sean más legibles,
permitiendo copiar y pegar el texto de la misma sin problema.
   El carácter «:» inicia la línea de órdenes de Vim. La orden «:read !date»
lee la salida de la orden «date» y la añade bajo la línea actual. El
&lt;CR&gt; se requiere para ejecutar la orden «:read».
   En este punto, el texto tiene el siguiente aspecto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now "kJ" moves the cursor up and joins the lines together.
   To decide which key or keys you use for mapping, see |map-which-keys|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora «kJ» desplaza el cursor hacia arriba y une las líneas.
   Para decidir qué teclas usar para las macros, consulte |map-which-keys|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command defines remapping for keys in Normal mode.  You can also define mappings for other modes.  For example, ":imap" applies to Insert mode.  You can use it to insert a date below the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» define una macro a usar en modo Normal. También puede definir macros para otros modos. Por ejemplo, «imap» afecta al modo Insertar. Puede usarlo para insertar una fecha bajo el cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It looks a lot like the mapping for &lt;F2&gt; in Normal mode, only the start is
different.  The &lt;F2&gt; mapping for Normal mode is still there.  Thus you can map
the same key differently for each mode.
   Notice that, although this mapping starts in Insert mode, it ends in Normal
mode.  If you want it to continue in Insert mode, append an "a" to the
mapping.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se parece mucho a la macro para &lt;F2&gt; en modo Normal, sólo el
principio es diferente. La macro &lt;F2&gt; para el modo Normal aún existe.
Puede asignar la misma tecla de forma diferente según el modo.
   Tenga en cuenta que, aunque esta macro empieza en el modo Insertar,
termina en modo Normal. Si desea continuar en modo Insertar, añada una
«a» a la asignación.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map		Normal, Visual and Operator-pending
	:vmap		Visual
	:nmap		Normal
	:omap		Operator-pending
	:map!		Insert and Command-line
	:imap		Insert
	:cmap		Command-line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map		Normal, Visual y Operator-pending
	:vmap		Visual
	:nmap		Normal
	:omap		Operator-pending
	:map!		Insertar y Command-line
	:imap		Insertar
	:cmap		Línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operator-pending mode is when you typed an operator character, such as "d" or "y", and you are expected to type the motion command or a text object.  Thus when you type "dw", the "w" is entered in operator-pending mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Operator-pending es cuando introduce un carácter como operador, por ejemplo «y» o «d», y se espera a que introduzca la orden de desplazamiento o un objeto de texto. Por ello, cuando teclea «dw», la «w» es introducida en el modo Operator-pending</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose that you want to define &lt;F7&gt; so that the command d&lt;F7&gt; deletes a C program block (text enclosed in curly braces, {}).  Similarly y&lt;F7&gt; would yank the program block into the unnamed register.  Therefore, what you need to do is to define &lt;F7&gt; to select the current program block.  You can do this with the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que desea definir &lt;F7&gt; para que la orden «d&lt;F7&gt;» elimine el bloque de un programa escrito en C (el texto se cierra con llaves, {}). De forma similar «y&lt;F7&gt;» copiaría el bloque del programa al registro sin nombre. Por ello, lo que debe hacer es definir &lt;F7&gt; para seleccionar el bloque actual del programa. La siguiente orden le permite hacer esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:omap &lt;F7&gt; a{
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:omap &lt;F7&gt; a{
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This causes &lt;F7&gt; to perform a select block "a{" in operator-pending mode, just like you typed it.  This mapping is useful if typing a { on your keyboard is a bit difficult.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto provoca que &lt;F7&gt; realice una selección  de bloque «a{» en el modo Operator-pending, justo como lo escribió. Esta macro es útil si teclear «a{» en su teclado es difícil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	   _g		 :call MyGrep(1)&lt;CR&gt; ~
	v  &lt;F2&gt;		 :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	n  &lt;F2&gt;		 :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	   &lt;xHome&gt;	 &lt;Home&gt;
	   &lt;xEnd&gt;	 &lt;End&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	   _g		 :call MyGrep(1)&lt;CR&gt; ~
	v  &lt;F2&gt;		 :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	n  &lt;F2&gt;		 :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	   &lt;xHome&gt;	 &lt;Home&gt;
	   &lt;xEnd&gt;	 &lt;End&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first column of the list shows in which mode the mapping is effective.
This is "n" for Normal mode, "i" for Insert mode, etc.  A blank is used for a
mapping defined with ":map", thus effective in both Normal and Visual mode.
   One useful purpose of listing the mapping is to check if special keys in &lt;&gt;
form have been recognized (this only works when color is supported).  For
example, when &lt;Esc&gt; is displayed in color, it stands for the escape character.
When it has the same color as the other text, it is five characters.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera columna de la lista muestra el modo en el que la macro tiene
efecto. Esto es, «n» para el modo Normal, «i» para el modo Insertar, etc... Se
usa un espacio en blanco con las macros definidas mediante «:map», y por
ello, con efecto en el modo Visual y Normal.
   Un propósito útil de listar las macros es comprobar si se han reconocido
las teclas especiales con la forma &lt;&gt; (sólo funciona con compatibilidad con
color). Por ejemplo, cuando &lt;Esc&gt; se muestra en color, simboliza el carácter
de escape. Cuando tiene el mismo color que el resto del texto, simboliza
cinco caracteres.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of a mapping is inspected for other mappings in it.  For example, the mappings for &lt;F2&gt; above could be shortened to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado de una macro se inspecciona en busca de otras macros en ella. Por ejemplo, las macros para &lt;F2&gt; vistas anteriormente se pueden acortar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;F2&gt; G&lt;F3&gt;
	:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;
	:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;F2&gt; G&lt;F3&gt;
	:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;
	:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Normal mode &lt;F2&gt; is mapped to go to the last line, and then behave like &lt;F3&gt; was pressed.  In Insert mode &lt;F2&gt; stops Insert mode with &lt;Esc&gt; and then also uses &lt;F3&gt;.  Then &lt;F3&gt; is mapped to do the actual work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En modo Normal, &lt;F2&gt; tiene un macro para ir a la última línea, y después comportarse como si se hubiese pulsado &lt;F3&gt;. En modo Insertar, &lt;F2&gt; detiene el modo Insertar con &lt;Esc&gt;, y después usa también &lt;F3&gt;. Por ello, se usa la macro de &lt;F3&gt; para el trabajo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you hardly ever use Ex mode, and want to use the "Q" command to format text (this was so in old versions of Vim).  This mapping will do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que apenas usa el modo Ex, y desea usar la orden «Q» para formatear texto (este era el comportamiento en versiones anteriores de Vim). Esta macro realizará esta función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map Q gq
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map Q gq
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, in rare cases you need to use Ex mode anyway.  Let's map "gQ" to Q, so that you can still go to Ex mode: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero, en algunos casos necesita usar el modo Ex. Vamos a asignar «gQ» a «Q», para que así pueda ir la modo Ex: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map gQ Q
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map gQ Q
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens now is that when you type "gQ" it is mapped to "Q".  So far so
good.  But then "Q" is mapped to "gq", thus typing "gQ" results in "gq", and
you don't get to Ex mode at all.
   To avoid keys to be mapped again, use the ":noremap" command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que ocurre ahora es que cuando escribe «gQ», se asigna a la «Q». Por
ahora, todo bien. Pero, a continuación, asigna «Q» a «gq», y por ello escribir
«gQ» resulta en «gq», y no entra en modo Ex.
   Para evitar que las claves se asignen otra vez, utilice la orden
«:noremap»: 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:noremap gQ Q
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:noremap gQ Q
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Vim knows that the "Q" is not to be inspected for mappings that apply to it.  There is a similar command for every mode:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora Vim sabe que no se puede analizar «Q» en busca de macros que le afecten. Existe una orden similar para cada modo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:noremap	Normal, Visual and Operator-pending
	:vnoremap	Visual
	:nnoremap	Normal
	:onoremap	Operator-pending
	:noremap!	Insert and Command-line
	:inoremap	Insert
	:cnoremap	Command-line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:noremap		Normal, Visual y Operator-pending
	:vnoremap	Visual
	:nnoremap	Normal
	:onoremap	Operator-pending
	:noremap!		Insertar y Línea de órdenes
	:inoremap		Insertar
	:cnoremap	Línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a mapping triggers itself, it will run forever.  This can be used to
repeat an action an unlimited number of times.
   For example, you have a list of files that contain a version number in the
first line.  You edit these files with "vim *.txt".  You are now editing the
first file.  Define this mapping: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una macro se activa, se ejecutará indefinidamente. Puede
usar esto para repetir una acción un número ilimitado de veces.
   Por ejemplo, tiene una lista de archivos que contienen un número de
versión en la primera línea. Después, edita estos archivos con «vim.txt».
Ahora está editando el primer archivo. Defina esta macro: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove a mapping use the ":unmap" command.  Again, the mode the unmapping applies to depends on the command used:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «:unmap» para eliminar una macro. Una vez más, el modo sobre el que actúa la eliminación de la macro depende de la orden usada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unmap		Normal, Visual and Operator-pending
	:vunmap		Visual
	:nunmap		Normal
	:ounmap		Operator-pending
	:unmap!		Insert and Command-line
	:iunmap		Insert
	:cunmap		Command-line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unmap		Normal, Visual y Operator-pending
	:vunmap		Visual
	:nunmap		Normal
	:ounmap		Operator-pending
	:unmap!		Insertar y Línea de órdenes
	:iunmap		Insertar
	:cunmap		Línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a trick to define a mapping that works in Normal and Operator-pending mode, but not in Visual mode.  First define it for all three modes, then delete it for Visual mode: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dispone de un truco para definir una macro que funciona tanto modo Operator-pending como normal, pero no en modo visual. Primero, defina la macro para los tres modos, y después borre la macro del modo Visual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;C-A&gt; /---&gt;&lt;CR&gt;
	:vunmap &lt;C-A&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;C-A&gt; /---&gt;&lt;CR&gt;
	:vunmap &lt;C-A&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove all mappings use the |:mapclear| command.  You can guess the variations for different modes by now.  Be careful with this command, it can't be undone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden |:mapclear| para eliminar todas las macros. Ahora puede averiguar las variantes según el modo. Tenga cuidado con esta orden, ya que su acción no se puede deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command can be followed by another command.  A | character
separates the two commands.  This also means that a | character can't be used
inside a map command.  To include one, use &lt;Bar&gt; (five characters).  Example:
&gt;
	:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» puede ir seguida de otra orden. Un carácter «|» separa ambas
órdenes. Esto también significa que no puede usar un carácter «|» dentro
de una orden «map». Para incluir uno, use &lt;Bar&gt; (cinco caracteres). Ejemplo: &gt;
:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same problem applies to the ":unmap" command, with the addition that you
have to watch out for trailing white space.  These two commands are different:
&gt;
	:unmap a | unmap b
	:unmap a| unmap b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El mismo problema afecta a la orden «:unmap», con la adición de que debe
tener cuidado con espacio vacío adicional al final de la línea. Estas dos
órdenes son diferentes: &gt;
	:unmap a | unmap b
	:unmap a| unmap b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;Space&gt; W
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;Space&gt; W
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to put a comment directly after a mapping, because the " character is considered to be part of the mapping.  You can use |", this starts a new, empty command with a comment.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es posible insertar un comentario justo antes de una macro, ya que el carácter «"» se considera parte de la macro. Puede usar «|"», iniciando una nueva y vacía orden con un comentario. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;Space&gt; W|     " Use spacebar to move forward a word
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;Space&gt; W|     " Usa la barra espaciadora para avanzar un palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abbreviations are a lot like Insert mode mappings.  The arguments are handled
in the same way.  The main difference is the way they are triggered.  An
abbreviation is triggered by typing a non-word character after the word.  A
mapping is triggered when typing the last character.
   Another difference is that the characters you type for an abbreviation are
inserted in the text while you type them.  When the abbreviation is triggered
these characters are deleted and replaced by what the abbreviation produces.
When typing the characters for a mapping, nothing is inserted until you type
the last character that triggers it.  If the 'showcmd' option is set, the
typed characters are displayed in the last line of the Vim window.
   An exception is when a mapping is ambiguous.  Suppose you have done two
mappings: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las abreviaturas se parecen mucho a las macros del modo Insetar. Los
argumentos se tratan de la misma forma. La diferencia principal es la
forma en que se ejecutan. Una abreviatura se inicia tecleando un
carácter que no sea una palabra, a continuación de una palabra. Una
macro se inicia al teclear el último carácter.
   Otra diferencia es que los caracteres que usa para una abreviatura
se insertan en el texto mientras los teclea. Al ejecutar la abreviatura,
estos caracteres se eliminan y reemplazan por el resultado de la
abreviatura. Al teclear los caracteres de una macro, no se inserta nada
hasta que introduce el último carácter que lo inicia. Si se define la
opción 'showcmd', los caracteres tecleados se muestran en la última
línea de la ventana de Vim.
   Una excepción es cuando la macro es ambigua. Suponga que tiene
dos macros: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:imap aa foo
	:imap aaa bar
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:imap aa foo
	:imap aaa bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, when you type "aa", Vim doesn't know if it should apply the first or the second mapping.  It waits for another character to be typed.  If it is an "a", the second mapping is applied and results in "bar".  If it is a space, for example, the first mapping is applied, resulting in "foo", and then the space is inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando escribe «aa», Vim no sabe si afecta a la primera o segunda macro. Espera a que se introduzca otro carácter. Si es una «a», se ejecuta la segunda macro, y cuyo resultado es «bar». Si es un espacio, por ejemplo, se ejecuta la primera macro, resultando en «foo», para después insertar el espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;script&gt; keyword can be used to make a mapping local to a script.  See |:map-&lt;script&gt;|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la palabra clave &lt;script&gt; para hacer que una macro sea local al script. Consulte |:map-&lt;script&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;buffer&gt; keyword can be used to make a mapping local to a specific buffer.  See |:map-&lt;buffer&gt;|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;buffer&gt; se puede usar para que una macro sea local a un búfer específico. Consulte |:map-&lt;buffer&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;unique&gt; keyword can be used to make defining a new mapping fail when it already exists.  Otherwise a new mapping simply overwrites the old one.  See |:map-&lt;unique&gt;|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;unique&gt; se puede usar para que definir una macro nueva falle cuando ya existe. En caso contrario, una nueva macro sencillamente sobreescribe el antiguo. Consulte |:map-&lt;unique&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make a key do nothing, map it to &lt;Nop&gt; (five characters).  This will make the &lt;F7&gt; key do nothing at all: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para que una tecla no haga nada, asígnelo a &lt;Nop&gt; (cinco caracteres). Lo siguiente hace que la tecla &lt;F7&gt; no tenga efecto alguno: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;F7&gt; &lt;Nop&gt;| map! &lt;F7&gt; &lt;Nop&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;F7¡&gt; &lt;Nop&gt;| map! &lt;F7&gt; &lt;Nop&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.2*	Defining command-line commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.2*	Definir órdenes de línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor enables you to define your own commands.  You execute these
commands just like any other Command-line mode command.
   To define a command, use the ":command" command, as follows: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim le permite crear sus propias órdenes. Puede ejecutar estas
órdenes como cualquier otra orden del modo Línea de órdenes.
   Para definir una orden, use la orden «:command» de la siguiente
forma: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command DeleteFirst 1delete
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command DeleteFirst 1delete
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	User-defined commands must start with a capital letter.  You cannot
	use ":X", ":Next" and ":Print".  The underscore cannot be used!  You
	can use digits, but this is discouraged.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Las órdenes definidas por el usuario deben comenzar con una letra
	mayúscula. No puede usar «:X», «:Next» y «:Print». ¡No puede usar el
	guión bajo. Puede usar dígitos, pero no se recomienda.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with the builtin commands, the user defined commands can be abbreviated.  You need to type just enough to distinguish the command from another.  Command line completion can be used to get the full name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al igual que las órdenes integradas, las órdenes definidas por el usuario se pueden abreviar. Necesita teclear lo justo para distinguir una orden de otra. El autocompletado de línea de órdenes se puede usar para obtener el nombre completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-defined commands can take a series of arguments.  The number of arguments must be specified by the -nargs option.  For instance, the example :DeleteFirst command takes no arguments, so you could have defined it as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes definidas por el usuario aceptan una serie de argumentos. El número de argumentos se debe especificar con la opción «-nargs». Por ejemplo, la orden de ejemplo «DeleteFirst» no permite argumentos, así que lo debe definir del siguiente modo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -nargs=0 DeleteFirst 1delete
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -nargs=0 DeleteFirst 1delete
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, because zero arguments is the default, you do not need to add "-nargs=0".  The other values of -nargs are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, ya que cero argumentos es el comportamiento predeterminado, no necesita añadir «-nargs=0». A continuación puede ver los otros valores de «-nargs»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	-nargs=0	No arguments
	-nargs=1	One argument
	-nargs=*	Any number of arguments
	-nargs=?	Zero or one argument
	-nargs=+	One or more arguments
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	-nargs=0	Sin argumentos
	-nargs=1	Un argumento
	-nargs=*	Cualquier número de argumentos
	-nargs=?	Cero o más argumentos
	-nargs=+	Uno o más argumentos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the command definition, the arguments are represented by the &lt;args&gt; keyword.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dentro de la definición de la orden, los argumentos se representan con la palabra clave &lt;args&gt;. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -nargs=+ Say :echo "&lt;args&gt;"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -nargs=+ Say :echo "&lt;args&gt;"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Say Hello World
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Say Hello World
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim echoes "Hello World".  However, if you add a double quote, it won't work.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim muestra «Hello World». Sin embargo, no funcionará si añade una comilla doble. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Say he said "hello"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Say he said "hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -nargs=+ Say :echo &lt;q-args&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -nargs=+ Say :echo &lt;q-args&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo "he said \"hello\""
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo "he said \"hello\""
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;f-args&gt; keyword contains the same information as the &lt;args&gt; keyword,
except in a format suitable for use as function call arguments.  For example:
&gt;
	:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)
	:DoIt a b c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;f-args&gt; contiene la misma información que la palabra
clave &lt;args&gt;, pero en un formato adecuado para usar argumentos que
invocan funciones. Por ejemplo: &gt;
	:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)
	:DoIt a b c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:call AFunction("a", "b", "c")
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:call AFunction("a", "b", "c")
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands take a range as their argument.  To tell Vim that you are defining such a command, you need to specify a -range option.  The values for this option are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes toman un rango como argumento. Para indicar a Vim que está definiendo una orden así, debe especificar una opción «-range». A continuación puede ver los valores de esta opción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	-range		Range is allowed; default is the current line.
	-range=%	Range is allowed; default is the whole file.
	-range={count}	Range is allowed; the last number in it is used as a
			single number whose default is {count}.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	-range		El rango está permitido, el valor
				predeterminado es la línea actual.
	-range=%	El rango está permitido, el valor
				predeterminado es el archivo completo.
	-range={número}	El rango está permitido, el último número
				presente se usa como un sólo número cuyo valor
				predeterminado es {número}.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a range is specified, the keywords &lt;line1&gt; and &lt;line2&gt; get the values of the first and last line in the range.  For example, the following command defines the SaveIt command, which writes out the specified range to the file "save_file": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando un rango se especifica, las palabras clave &lt;line1&gt; y &lt;line2&gt; obtienen el valor de la primera y última línea del rango. Por ejemplo, la siguiente orden define la orden «SaveIt», que escribe el rango especificado al archivo «save_file»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, you have the &lt;lt&gt; keyword.  It stands for the character &lt;.  Use this to escape the special meaning of the &lt;&gt; items mentioned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, tiene la palabra clave &lt;lt&gt;. Simboliza el carácter «&lt;». Úselo para escapar el significado especial de los elementos &lt;&gt; mencionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -nargs=+ Say :echo "&lt;args&gt;"
	:command! -nargs=+ Say :echo &lt;q-args&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -nargs=+ Say :echo "&lt;args&gt;"
	:command! -nargs=+ Say :echo &lt;q-args&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a user command use ":delcommand".  It takes a single argument, which is the name of the command.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:delcommand» para eliminar una orden de usuario. Toma un único argumento, el nombre de la orden. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:delcommand SaveIt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:delcommand SaveIt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:comclear
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:comclear
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.3*	Autocommands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.3*	Autocommands
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An autocommand is a command that is executed automatically in response to some
event, such as a file being read or written or a buffer change.  Through the
use of autocommands you can train Vim to edit compressed files, for example.
That is used in the |gzip| plugin.
   Autocommands are very powerful.  Use them with care and they will help you
avoid typing many commands.  Use them carelessly and they will cause a lot of
trouble.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una orden automática (Autocommand) es una orden a ejecutar en respuesta otro
evento, un archivo siendo leído y editado o un cambio en un búfer, por
ejemplo. Por ejemplo, Vim puede editar archivos comprimidos a través de las
órdenes automáticas.
La extensión |gzip| hace uso de esto.
   Las órdenes automáticas son muy potentes. Úselos con cuidado, y le ayudarán
a disminuir el número de órdenes que introduce. Úselos sin cuidado, y
generarán un gran número de problemas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to replace a datestamp on the end of a file every time it is written.  First you define a function: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que desea reemplazar una marca de tiempo al final del archivo cada vez que se escriba. Primero, define una función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want this function to be called each time, just before a file is written.  This will make that happen: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea que esta función se invoque justo antes de guardar un archivo.  Lo siguiente lo logra este objetivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd FileWritePre *  call DateInsert()
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd FileWritePre *  call DateInsert()
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd [group] {events} {file_pattern} [nested] {command}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd [grupo] {eventos} {patrón_archivo} [anidado] {orden}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The [group] name is optional.  It is used in managing and calling the commands
(more on this later).  The {events} parameter is a list of events (comma
separated) that trigger the command.
   {file_pattern} is a filename, usually with wildcards.  For example, using
"*.txt" makes the autocommand be used for all files whose name end in ".txt".
The optional [nested] flag allows for nesting of autocommands (see below), and
finally, {command} is the command to be executed.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento [grupo] es opcional. Se usa al gestionar e invocar las órdenes
(más información más adelante). El parámetro {eventos} es una lista separada
 por comas de eventos que inician la orden.
  {patrón_archivo} es un nombre de archivo, a menudo con comodines. Por
ejemplo, usar «*.txt» provoca que la orden automática afecte a todos los
archivos cuyo nombre termina en «.txt».
La elemento opcional [anidado] permite anidar órdenes automáticas (a
continuación), y, por último, {orden} es la orden a ejecutar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the most useful events is BufReadPost.  It is triggered after a new file is being edited.  It is commonly used to set option values.  For example, you know that "*.gsm" files are GNU assembly language.  To get the syntax file right, define this autocommand: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de los eventos más útiles es «BufReadPost». Se inicia después de editar un nuevo archivo. Se usa habitualmente para definir valores para opciones. Por ejemplo, sabe que los archivos «.gsm» están escritos en lenguaje ensamblador de GNU. Especifique esta orden para obtener la adecuada sintaxis de archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufReadPost *.gsm  set filetype=asm
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufReadPost *.gsm  set filetype=asm
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim is able to detect the type of file, it will set the 'filetype' option for you.  This triggers the Filetype event.  Use this to do something when a certain type of file is edited.  For example, to load a list of abbreviations for text files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim es capaz de detectar el tipo de archivo, definirá la opción 'filetype' automáticamente. Los siguiente incia el evento «Filetype». Puede usarlo para iniciar una acción al editar un tipo de archivo en particular. Por ejemplo, para cargar una lista de abreviaturas de archivos de texto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd Filetype text  source ~/.vim/abbrevs.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd Filetype text  source ~/.vim/abbrevs.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {file_pattern} argument can actually be a comma-separated list of file
patterns.  For example: "*.c,*.h" matches files ending in ".c" and ".h".
   The usual file wildcards can be used.  Here is a summary of the most often
used ones:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento {patrón_archivo] puede ser una lista separada por comas de
patrones de archivo. Por ejemplo, "*.c,*.h" coincide con los archivos
terminados en «.c» y «.h».
   Puede usar los comodines de archivo habituales. Aquí tiene un resumen
de los más usados:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	*		Match any character any number of times
	?		Match any character once
	[abc]		Match the character a, b or c
	.		Matches a dot
	a{b,c}		Matches "ab" and "ac"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	*		Busca cualquier caracteres cualquier número de veces
	?		Busca cualquier carácter una vez
	[abc]		Busca el carácter a, b o c
	.		Busca un punto
	a{b,c}		Busca «ab» y «ac»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	When working on a system that uses a backslash as file separator, such
	as MS-Windows, you still use forward slashes in autocommands.  This
	makes it easier to write the pattern, since a backslash has a special
	meaning.  It also makes the autocommands portable.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Al trabajar con un sistema que usa la barra inversa como separador de
	archivos, como MS-Windows, necesita una barra inclinada en las
	órdenes automáticas. Esto facilita escribir un patrón, ya que la barra
	inversa tiene un significado especial. También hace portables las
	órdenes automáticas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete an autocommand, use the same command as what it was defined with, but leave out the {command} at the end and use a !.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una orden automática, use la misma orden con la que se definió, pero omitiendo la {orden} al final y usando «!». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd! FileWritePre *
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd! FileWritePre *
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list can be very long, especially when filetype detection is used.  To list only part of the commands, specify the group, event and/or pattern.  For example, to list all BufNewFile autocommands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta lista puede ser muy largo, en particular si se utiliza la detección de tipo de archivo. Para listar sólo parte de las órdenes, especifique el grupo, evento y/o patrón. Por ejemplo, para listar todas las órdenes automáticas para «BufNewFile»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufNewFile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufNewFile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd * *.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd * *.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "*" for the event will list all the events.  To list all autocommands for the cprograms group: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «*» como el evento lista todos los eventos. Para listar todas las órdenes automáticas del grupo cprograms: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd cprograms
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd cprograms
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {group} item, used when defining an autocommand, groups related autocommands
together.  This can be used to delete all the autocommands in a certain group,
for example.
   When defining several autocommands for a certain group, use the ":augroup"
command.  For example, let's define autocommands for C programs: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento {grupo}, usado al definir una orden automática, agrupa
órdenes automáticas relacionadas. Se puede usar para eliminar todas las
órdenes automáticas en un grupo particular, por ejemplo.
   Al definir varias órdenes automáticas para un grupo particular, use la
orden «:augroup». Por ejemplo, vamos a definir unas órdenes automáticas
para programas C: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd! cprograms
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd! cprograms
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally, commands executed as the result of an autocommand event will not trigger any new events.  If you read a file in response to a FileChangedShell event, it will not trigger the autocommands that would set the syntax, for example.  To make the events triggered, add the "nested" argument: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, las órdenes ejecutadas como resultado de un evento de orden automática no iniciarán ningún evento nuevo. Si lee un archivo como respuesta a un evento «FileChangedShell», no iniciará las órdenes automáticas que definirían la sintaxis, por ejemplo. Para que se los eventos se inicien, añada el argumento «nested»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd FileChangedShell * nested  edit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd FileChangedShell * nested  edit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to trigger an autocommand by pretending an event has occurred.  This is useful to have one autocommand trigger another one.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible iniciar una orden automática simulando un evento. Es útil para que una orden automática inicie otra. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines an autocommand that is triggered when a new file has been edited.  The file name must end in ".new".  The ":execute" command uses expression evaluation to form a new command and execute it.  When editing the file "tryout.c.new" the executed command will be: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto define una orden automática que se inicia al editar un nuevo archivo. El nombre de archivo debe terminar con «.new». La orden «:execute» usa expresiones de evaluación para formar una nueva orden y ejecutarla. La orden ejecutada al editar el archivo «prueba.c.new» sería: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:doautocmd BufReadPost tryout.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:doautocmd BufReadPost tryout.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":doautocmd" executes on the current buffer.  The ":doautoall" command works like "doautocmd" except it executes on all the buffers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:doautocmd» se ejecuta en el búfer actual. La orden «:doautoall» funciona como «doautocmd», con la diferencia de que afecta a todos los búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands executed by an autocommand are Command-line commands.  If you want to use a Normal mode command, the ":normal" command can be used.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes ejecutadas por una orden automática son órdenes del modo Línea de órdenes. Si desea usar una orden del modo normal, puede usar la orden «:normal». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufReadPost *.log normal G
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufReadPost *.log normal G
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make the cursor jump to the last line of *.log files when you start
to edit it.
   Using the ":normal" command is a bit tricky.  First of all, make sure its
argument is a complete command, including all the arguments.  When you use "i"
to go to Insert mode, there must also be a &lt;Esc&gt; to leave Insert mode again.
If you use a "/" to start a search pattern, there must be a &lt;CR&gt; to execute
it.
   The ":normal" command uses all the text after it as commands.  Thus there
can be no | and another command following.  To work around this, put the
":normal" command inside an ":execute" command.  This also makes it possible
to pass unprintable characters in a convenient way.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que el cursor salte a la última línea de archivos «*.log» cuando
empieza a editarlo.
   Usar la orden «:normal» es un poco difícil. Primero, compruebe que su
argumento es una orden completa, incluyendo todos los argumentos.
Cuando usa una «i» para entrar el modo Insertar, también debe tener un
&lt;Esc&gt; para abandonar el modo Insertar. Si usa «/» para iniciar una búsqueda
de un patrón, debe usar &lt;CR&gt; para ejecutarlo.
   La orden «:normal» usa todo el texto a continuación como órdenes. Por
ello, no debe estar presente «|» y una orden a continuación. Para solucionar
este problema, ubique la orden «:normal» dentro de una orden «:execute».
También posibilita pasar caracteres no imprimibles de una forma
cómoda. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |
		\ 1read !date
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |
		\ 1read !date
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also shows the use of a backslash to break a long command into more lines.  This can be used in Vim scripts (not at the command line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también muestra el usa de la barra inversa para dividir una orden en varias líneas. Se puede usar en scripts de Vim (no en la línea de órdenes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want the autocommand do something complicated, which involves jumping around in the file and then returning to the original position, you may want to restore the view on the file.  See |restore-position| for an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que la orden automática haga algo más complicado, que incluya saltar de un punto a otro en el archivo para volver finalmente a la posición inicial, puede que desee restaurar la vista del archivo. Para un ejemplo, consulte |restore-position|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At times, you will not want to trigger an autocommand.  The 'eventignore' option contains a list of events that will be totally ignored.  For example, the following causes events for entering and leaving a window to be ignored: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces, no querrá iniciar una orden automática. La opción 'eventignore' contiene una lista de eventos a ignorar. Por ejemplo, lo siguiente provoca que se ignoren los siguientes eventos iniciados al entrar y salir de un programa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set eventignore=WinEnter,WinLeave
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set eventignore=WinEnter,WinLeave
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set eventignore=all
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set eventignore=all
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set eventignore=
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set eventignore=
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_11.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_11.esx*	Para Vim versión 7.3.  Último cambio: 20/6/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			   Recovering from a crash
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Recuperarse de un fallo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|11.1|	Basic recovery
|11.2|	Where is the swap file?
|11.3|	Crashed or not?
|11.4|	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|11.1|	Recuperación básica
|11.2|	¿Dónde está el archivo de intercambio?
|11.3|	¿Se ha colgado o no?
|11.4|	Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_12.txt|  Clever tricks
 Previous chapter: |usr_10.txt|  Making big changes
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_12.esx|  Trucos
  Capítulo anterior: |usr_10.esx|  Realizar grandes cambios
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.1*	Basic recovery
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.1*	Recuperación básica
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most cases recovering a file is quite simple, assuming you know which file you were editing (and the harddisk is still working).  Start Vim on the file, with the "-r" argument added: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de los casos, recuperar un archivo es bastante sencillo, si suponemos que sabe qué archivo estaba editando (y el disco duro aún funciona). Inicie Vim con el archivo y el argumento «-r»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -r help.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -r ayuda.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will read the swap file (used to store text you were editing) and may read bits and pieces of the original file.  If Vim recovered your changes you will see these messages (with different file names, of course):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim leerá el archivo de intercambio (empleado para almacenar el texto editado) y puede que lea bits y porciones del texto original. Verá los siguientes mensajes si todo ha ido bien (con nombres de fichero diferentes, por supuesto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. You should check if everything is OK. ~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. You should check if everything is OK. ~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write help.txt.recovered
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write ayuda.txt.recuperado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compare the file with the original file to check if you ended up with what you expected.  Vimdiff is very useful for this |08.7|.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compare el archivo con el original para ver si obtuvo lo que esperaba. Vimdiff es muy útil para esta tarea |08.7|. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write help.txt.recovered
	:edit #
	:diffsp help.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write help.txt.recovered
	:edit #
	:diffsp help.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out for the original file to contain a more recent version (you saved
the file just before the computer crashed).  And check that no lines are
missing (something went wrong that Vim could not recover).
   If Vim produces warning messages when recovering, read them carefully.
This is rare though.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compruebe que el archivo original no contenga una versión más reciente
(guardó el archivo justo antes de que el sistema diese un fallo).
Compruebe también que no se ha omitido ninguna línea (algo ha ido mal
y Vim no pudo recuperar).
   Si Vim genera mensajes de advertencia al recuperar un archivo, lea
éstos cuidadosamente. Aún así, es poco habitual.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. Buffer contents equals file contents. ~
	You may want to delete the .swp file now. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Using swap file ".help.txt.swp" ~
	Original file "~/vim/runtime/doc/help.txt" ~
	Recovery completed. Buffer contents equals file contents. ~
	You may want to delete the .swp file now. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This usually happens if you already recovered your changes, or you wrote the file after making changes.  It is safe to delete the swap file now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, esto ocurre si ya ha recuperado los cambios, o si editó el archivo después de realizar cambios. En este momento ya puede eliminar el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is normal that the last few changes can not be recovered.  Vim flushes the changes to disk when you don't type for about four seconds, or after typing about two hundred characters.  This is set with the 'updatetime' and 'updatecount' options.  Thus when Vim didn't get a chance to save itself when the system went down, the changes after the last flush will be lost.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es normal que los últimos cambios no se puedan recuperar. Vim vuelca los cambios al disco duro cuando no teclea durante cuatro segundos, o tras escribir unos doscientos caracteres. Esto se puede modificar con las opciones 'updatetime' y 'updatecount'. De esta forma, cuando Vim no tiene posibilidad de guardar cuando el sistema cae, tendrá los cambios del último volcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -r ""
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -r ""
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.2*	Where is the swap file?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.2* 	¿Dónde está el archivo de intercambio?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can store the swap file in several places.  Normally it is in the same directory as the original file.  To find it, change to the directory of the file, and use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede guardar el archivo de intercambio en distintos lugares.  Normalmente se encuentra en el mismo directorio que el archivo original.  Para encontrarlo, cambie al directorio del archivo y escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -r
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -r
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will list the swap files that it can find.  It will also look in other
directories where the swap file for files in the current directory may be
located.  It will not find swap files in any other directories though, it
doesn't search the directory tree.
   The output could look like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará una lista de archivos de intercambio que ha encontrado. También
buscará en otros directorios donde los archivos de intercambio para archivos
en el actual puedan encontrarse. No buscará archivos de intercambio en
otros directorios, ni siquiera en los subdirectorios.
   La salida se parecerá a esto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Swap files found: ~
	   In current directory: ~
	1.    .main.c.swp ~
		  owned by: mool   dated: Tue May 29 21:00:25 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: YES ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12525 ~
	   In directory ~/tmp: ~
	      -- none -- ~
	   In directory /var/tmp: ~
	      -- none -- ~
	   In directory /tmp: ~
	      -- none -- ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Swap files found: ~
	   In current directory: ~
	1.    .main.c.swp ~
		  owned by: mool   dated: Tue May 29 21:00:25 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: YES ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12525 ~
	   In directory ~/tmp: ~
	      -- none -- ~
	   In directory /var/tmp: ~
	      -- none -- ~
	   In directory /tmp: ~
	      -- none -- ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are several swap files that look like they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use.  Carefully look at the dates to decide
which one you want to use.
   In case you don't know which one to use, just try them one by one and check
the resulting files if they are what you expected.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay varios archivos de intercambio que parecen ser el que quiere
usar, se mostrará una lista y se requerirá que introduzcas el número del que
quiere seleccionar. Observe con cuidado las fechas para decidir cuál
quieres usar.
   En caso de que no sepa cuál seleccionar, pruébelos uno a uno y compruebe
que los archivos resultantes son el que deseas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you know which swap file needs to be used, you can recover by giving the swap file name.  Vim will then finds out the name of the original file from the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sabe qué archivo de intercambio quiere usar, puede realizar la intercambio dando como argumento el nombre de este archivo. Vim encontrará el nombre del archivo original del cuál éste es el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example: &gt;
	vim -r .help.txt.swo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo: &gt;
	vim -r .help.txt.swo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also handy when the swap file is in another directory than expected.  Vim recognizes files with the pattern *.s[uvw][a-z] as swap files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto resulta útil cuando el archivo de intercambio está en otro directorio diferente al esperado. Vim reconoce los archivos con el patrón *.s[uvw][a-z] como archivos de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this still does not work, see what file names Vim reports and rename the files accordingly.  Check the 'directory' option to see where Vim may have put the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto tampoco funciona, compruebe los nombres de archivo que Vim reporta y renombre los archivos acordemente. Compruebe la opción 'directory' para ver dónde ha podido poner Vim el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.3*	Crashed or not?					*ATTENTION* *E325*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.3*	¿Se ha colgado o no?					*ATTENTION* *E325*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim tries to protect you from doing stupid things.  Suppose you innocently start editing a file, expecting the contents of the file to show up.  Instead, Vim produces a very long message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intenta protegerle de cometer estupideces. Suponga que inocentemente comienza la edición de un archivo, a la espera de que los contenidos se muestren. En su lugar, Vim produce un mensaje muy largo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		E325: ATTENTION ~
	Found a swap file by the name ".main.c.swp" ~
		  owned by: mool   dated: Tue May 29 21:09:28 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: no ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12559 (still running) ~
	While opening file "main.c" ~
		     dated: Tue May 29 19:46:12 2001 ~
 ~
	(1) Another program may be editing the same file. ~
	    If this is the case, be careful not to end up with two ~
	    different instances of the same file when making changes. ~
	    Quit, or continue with caution. ~
 ~
	(2) An edit session for this file crashed. ~
	    If this is the case, use ":recover" or "vim -r main.c" ~
	    to recover the changes (see ":help recovery"). ~
	    If you did this already, delete the swap file ".main.c.swp" ~
	    to avoid this message. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		E325: ATENCIÓN ~
Se ha encontrado un archivo de intercambio con el nombre ".main.c.swp" ~
		propiedad de: mool   de fecha: Tue May 29 21:09:28 2001 ~
		nombre del archivo: ~mool/vim/vim6/src/main.c ~
		modificado: no ~
		nombre del usuario: mool   host name: masaka.moolenaar.net ~
		ID del proceso: 12559 (aún en ejecución) ~
		al abrir el archivo "main.c" ~
		de fecha: Tue May 29 19:46:12 2001 ~
 ~
	(1)  Puede que otro programa esté editando el mismo archivo. ~
	    De ser así, tenga cuidado de no acabar con dos ~
	    ejemplares diferentes del mismo archivo al hacer cambios. ~
	    Salga del programa o continúe con precaución. ~
 ~
	(2) Falló una sesión de edición de este archivo. ~
	    Si es así, use \":recover\" o \"vim -r  main.c" ~
	    para recuperar los cambios (véa \":help recovery\"). ~
	    Si Ud. ya ha hecho esto, borre el archivo de intercambio ".main.c.swp" ~
	    para evitar este mensaje. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get this message, because, when starting to edit a file, Vim checks if a swap file already exists for that file.  If there is one, there must be something wrong.  It may be one of these two situations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ha recibido este mensaje porque cuando comienza a editar un archivo, Vim comprueba que exista un archivo de intercambio para este archivo. Si hay uno, algo debe estar pasando. Puede ocurrir cualquiera de estas situaciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Another edit session is active on this file.  Look in the message for the
   line with "process ID".  It might look like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Hay otra sesión de edición activa en este archivo. Busque en el
   mensaje la línea con «ID del proceso». Puede parecerse a esto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		process ID: 12559 (still running) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		process ID: 12559 ((aún en ejecución) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   The text "(still running)" indicates that the process editing this file
   runs on the same computer.  When working on a non-Unix system you will not
   get this extra hint.  When editing a file over a network, you may not see
   the hint, because the process might be running on another computer.  In
   those two cases you must find out what the situation is yourself.
      If there is another Vim editing the same file, continuing to edit will
   result in two versions of the same file.  The one that is written last will
   overwrite the other one, resulting in loss of changes.  You better quit
   this Vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   El texto «(still running)» indica que el proceso que edita este archivo
está corriendo en el mismo ordenador. Cuando estés bajo un sistema no
Unix, no obtendrá esta información extra. Cuando edite un archivo a través
de red, seguramente no verá esta información, porque el proceso estará en otro
   ordenador. Tendrá que averiguarlo por su cuenta.
      Si hay otro Vim editando el mismo archivo, continuar editándolo
   conllevará a que tenga dos versiones del mismo archivo. La última que
   guarde sobreescribirá a la otra, con la consecuente pérdida de los
   cambios. Mejor salir de este Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. The swap file might be the result from a previous crash of Vim or the
   computer.  Check the dates mentioned in the message.  If the date of the
   swap file is newer than the file you were editing, and this line appears:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. El archivo de intercambio puede ser el resultado de un cuelgue anterior
   de Vim o del ordenador. Revise las fechas mencionadas en el mensaje. Si la
   fecha del archivo de intercambio es más reciente que la del archivo que
   está editando, y aparece esta línea:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		modified: YES ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		modificado: YES ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   Then you very likely have a crashed edit session that is worth recovering.
      If the date of the file is newer than the date of the swap file, then
   either it was changed after the crash (perhaps you recovered it earlier,
   but didn't delete the swap file?), or else the file was saved before the
   crash but after the last write of the swap file (then you're lucky: you
   don't even need that old swap file).  Vim will warn you for this with this
   extra line:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   Entonces es muy probable que haya ocurrido algo con la sesión.
      Si la fecha del archivo es posterior a la fecha del archivo de
   intercambio, es que o cambiado tras el cuelgue (quizá la recuperó antes
   y no eliminó el archivo de intercambio), o es que el archivo fue
   guardado después de la última grabación del archivo de intercambio
   (entonces tienes suerte: no necesita ni ese viejo archivo de
   intercambio). Vim le advertirá de esto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>      NEWER than swap file! ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>      MÁS NUEVO que el archivo de intercambio! ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	[cannot be read] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	[no se puede leer] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will appear under the name of the swap file.  This can be good or bad, depending on circumstances.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>aparecerá bajo el nombre del archivo de intercambio. Esto puede ser bueno o malo dependiendo de las circunstancias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is good if a previous editing session crashed without having made any changes to the file.  Then a directory listing of the swap file will show that it has zero bytes.  You may delete it and proceed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Son buenas noticias si la sesión anterior se colgó sin haber hecho ningún cambio al archivo. En tal caso un listado de archivos del directorio mostrará que tiene cero bytes. Tal vez quiera eliminarla y continuar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is slightly bad if you don't have read permission for the swap file.  You may want to view the file read-only, or quit.  On multi-user systems, if you yourself did the last changes under a different login name, a logout followed by a login under that other name might cure the "read error".  Or else you might want to find out who last edited (or is editing) the file and have a talk with them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No son muy buenas noticias si lo que ocurre es que no tiene permisos de lectura del archivo de intercambio. Tal vez desee ver el archivo en modo sólo lectura o salir. En sistemas multiusuario, si empleó otro usuario, salir y volver a identificarte tal vez resuelva el «error de lectura». O en su defecto quizá quiera encontrar quien lo editó por última vez (o está editándolo ahora mismo) y hablar con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very bad if it means there is a physical read error on the disk containing the swap file.  Fortunately, this almost never happens.  You may want to view the file read-only at first (if you can), to see the extent of the changes that were "forgotten".  If you are the one in charge of that file, be prepared to redo your last changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Son muy malas noticias si significa que hay un error de lectura a nivel físico del disco duro. Afortunadamente, esto no ocurre casi nunca. Quizá quiera ver el archivo en modo sólo lectura inicialmente (si puede), para ver el alcance de los cambios que fueron «olvidados». Si eres el que está a cargo del archivo, prepárate para rehacer los últimos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WHAT TO DO?					*swap-exists-choices*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿QUÉ HACER?					*swap-exists-choices*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  Swap file ".main.c.swp" already exists! ~
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  Swap file ".main.c.swp" already exists! ~
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O  Abrir el archivo en modo sólo lectura. Use esto cuando sólo desee ver el
   archivo y no necesite recuperarlo. Tal vez quiera usar esto cuando sepa
   que alguien está usando el archivo y usted sólo quiera echar un vistazo sin
   hacer cambios.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E  Editar el archivo igualmente. ¡Use esto con cuidado! Si el archivo está
   siendo utilizado por otro Vim, terminará con dos versiones del archivo.
   Vim intentará advertirte si esto va a ocurrir, pero más vale prevenir.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>R  Recuperar el archivo del archivo de intercambio. Emplee esto si sabe que
   el archivo de intercambio contiene los cambios que desea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A  Abortar. Como salir (Q), pero también aborta las órdenes posteriores.
   Esto es útil cuando cargue un script que edita varios archivos, como una
   sesión con múltiples ventanas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>D  Eliminar el archivo de intercambio. Use esto cuando esté seguro de que
   no lo necesita. Por ejemplo, cuando no contenga cambios o cuando el
   archivo en sí sea más nuevo que el archivo de intercambio.
      En Unix esta opción sólo se ofrece cuando el proceso que creó el archivo
   de intercambio no parece que estar en ejecución.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not get the dialog (you are running a version of Vim that does not support it), you will have to do it manually.  To recover the file, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no ve el diálogo (está ejecutando una versión de Vim que no lo soporta, tendrá que hacerlo a mano. Para recuperar el archivo, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:recover
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:recover
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim cannot always detect that a swap file already exists for a file.  This is the case when the other edit session puts the swap files in another directory or when the path name for the file is different when editing it on different machines.  Therefore, don't rely on Vim always warning you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no puede siempre detectar cuando ya existe un archivo de intercambio para un archivo. Este es el caso cuando otras sesiones de edición ponen los archivos en otro directorio o cuando una ruta de archivo difiere en máquinas distintas.  Por lo tanto, no confíe en que Vim siempre le vaya a alertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really don't want to see this message, you can add the 'A' flag to the 'shortmess' option.  But it's very unusual that you need this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente no quiere ver este mensaje, puede añadir la opción 'A' a la opción 'shortmess'. Pero es poco habitual que lo necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.4*	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.4*	Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|swap-file|	An explanation about where the swap file will be created and
		what its name is.
|:preserve|	Manually flushing the swap file to disk.
|:swapname|	See the name of the swap file for the current file.
'updatecount'	Number of key strokes after which the swap file is flushed to
		disk.
'updatetime'	Timeout after which the swap file is flushed to disk.
'swapsync'	Whether the disk is synced when the swap file is flushed.
'directory'	List of directory names where to store the swap file.
'maxmem'	Limit for memory usage before writing text to the swap file.
'maxmemtot'	Same, but for all files in total.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|swap-file|	Una explicación sobre dónde se creará el archivo de
		intercambio y cuál es su nombre.
|:preserve|	Volcado manual de un archivo de intercambio al disco.
|:swapname|	Ver el nombre del archivo de intercambio para el actual.
'updatecount'	Número de pulsación tras las cuales el archivo de intercambio
		es volcado al disco.
'updatetime'	Temporizador tras el cuál se producirá el volcado a disco.
'swapsync'	Si se debe sincornizar el disco duro tras el volcado.
'directory'	Listado de directorios para el archivo de intercambio.
'maxmem'	Limitar el uso de memoria antes de hacer el volcado.
'maxmemtot'	Lo mismo pero incluyendo todos los archivos en total.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_22.txt*	For Vim version 7.3.  Last change: 2010 Feb 21
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_22.esx*	Para Vim version 7.3.  Último cambio: 21/2/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			   Finding the file to edit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			Encontrar el archivo a editar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|22.1|	The file browser
|22.2|	The current directory
|22.3|	Finding a file
|22.4|	The buffer list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|22.1|	El explorador de archivos
|22.2|	El directorio actual
|22.3|	Encontrar un archivo
|22.4|	La lista de búfers
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_23.txt|  Editing other files
 Previous chapter: |usr_21.txt|  Go away and come back
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_23.esx|  Editar otros archivos
  Capítulo anterior: |usr_21.est|  Abandonar el editor y volver
Tabla de contenidos: |usr_toc.est|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.1*	The file browser
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.1*	El explorador de archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a plugin that makes it possible to edit a directory.  Try this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una extensión que permita editar un directorio. Pruebe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit .
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit .
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Through the magic of autocommands and Vim scripts, the window will be filled with the contents of the directory.  It looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mediante la magia de las autoórdenes y de scripts de Vim, la pantalla mostrará los contenidos del directorio. Tiene este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" ============================================================================ ~
" Netrw Directory Listing                                        (netrw v109) ~
"   Sorted by      name ~
"   Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$ ~
"   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec ~
" ============================================================================ ~
../ ~
./ ~
check/ ~
Makefile ~
autocmd.txt ~
change.txt ~
eval.txt~ ~
filetype.txt~ ~
help.txt.info ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" ============================================================================ ~
" Netrw Directory Listing                                        (netrw v109) ~
"   Sorted by      name ~
"   Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$ ~
"   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec ~
" ============================================================================ ~
../ ~
./ ~
check/ ~
Makefile ~
autocmd.txt ~
change.txt ~
eval.txt~ ~
filetype.txt~ ~
help.txt.info ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.  The name of the browsing tool and its version number
2.  The name of the browsing directory
3.  The method of sorting (may be by name, time, or size)
4.  How names are to be sorted (directories first, then *.h files,
    *.c files, etc)
5.  How to get help (use the &lt;F1&gt; key), and an abbreviated listing
    of available commands
6.  A listing of files, including "../", which allows one to list
    the parent directory.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1.  El nombre de la herramienta de exploración y su número de versión
2.  El nombre del directorio presente
3.  La directriz de ordenación (puede ser por nombre, tiempo o tamaño)
4.  El orden de aparición de los nombres (primero directorios, después 
    archivos *.h, archivos *.c, etc)
5.  Cómo obtener ayuda (use la tecla &lt;F1&gt;), y una lista abreviada
    de las órdenes disponibles
6.  Una lista de archivos, incluyendo «../», que permite acceder al
    al directorio padre.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use Normal mode Vim commands to move around in the text.  For example, move the cursor atop a file and press &lt;Enter&gt;; you will then be editing that file.  To go back to the browser use ":edit ." again, or use ":Explore".  CTRL-O also works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar las órdenes de Vim en el modo normal para desplazarse a a través del texto. Por ejemplo, mueva el cursor al inicio del archivo y pulse &lt;Intro&gt;; estará ahora editando ese archivo. Para volver al explorador, use «:edit» otra vez, o use «:Explore». CTRL-O también funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try using &lt;Enter&gt; while the cursor is atop a directory name.  The result is that the file browser moves into that directory and displays the items found there.  Pressing &lt;Enter&gt; on the first directory "../" moves you one level higher.  Pressing "-" does the same thing, without the need to move to the "../" item first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use &lt;Intro&gt; mientras el cursor está sobre un nombre de directorio. El el resultado es que el explorador de archivos entra en ese directorio y muestra los elementos que ahí se encuentran. Si pulsa &lt;Intro&gt; en el primer directorio «../», se desplazará al nivel superior. Pulsar «-» realiza la misma acción, sin la necesidad de posicionarse primero sobre el elemento «../».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can press &lt;F1&gt; to get help on the things you can do in the netrw file browser.  This is what you get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener ayuda pulsando &lt;F1&gt; referente a las acciones que puede realizar en el explorador de archivos netrw. A continuación verá lo que obtiene.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    9. Directory Browsing	 netrw-browse   netrw-dir   netrw-list   netrw-help 
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    9. Directory Browsing	 netrw-browse   netrw-dir   netrw-list   netrw-help 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    MAPS								 netrw-maps 
     	 &lt;F1&gt;.............Help.......................................|netrw-help|
     	 &lt;cr&gt;.............Browsing...................................|netrw-cr|
     	 &lt;del&gt;............Deleting Files or Directories..............|netrw-delete|
     	 -................Going Up...................................|netrw--|
     	 a................Hiding Files or Directories................|netrw-a|
     	 mb...............Bookmarking a Directory....................|netrw-mb|
     	 gb...............Changing to a Bookmarked Directory.........|netrw-gb|
     	 c................Make Browsing Directory The Current Dir....|netrw-c|
     	 d................Make A New Directory.......................|netrw-d|
     	 D................Deleting Files or Directories..............|netrw-D|
     	 &lt;c-h&gt;............Edit File/Directory Hiding List............|netrw-ctrl-h|
     	 i................Change Listing Style.......................|netrw-i|
     	 &lt;c-l&gt;............Refreshing the Listing.....................|netrw-ctrl-l|
     	 o................Browsing with a Horizontal Split...........|netrw-o|
     	 p................Use Preview Window.........................|netrw-p|
     	 P................Edit in Previous Window....................|netrw-p|
     	 q................Listing Bookmarks and History..............|netrw-q|
     	 r................Reversing Sorting Order....................|netrw-r|
&lt;    	(etc)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    MAPS								 netrw-maps 
     	 &lt;F1&gt;.............Ayuda......................................|netrw-help|
     	 &lt;cr&gt;.............Explorar...................................|netrw-cr|
     	 &lt;del&gt;............Borrar archivos o directorios..............|netrw-delete|
     	 -................Subir......................................|netrw--|
     	 a................Ocultar archivos o directorios.............|netrw-a|
     	 mb...............Marcar un directorio como favorito.........|netrw-mb|
     	 gb...............Pasar a un directorio favorito.............|netrw-gb|
     	 c................Hacer del directorio explorado el actual...|netrw-c|
     	 d................Crear un directorio........................|netrw-d|
     	 D................Borrar archivos o directorios..............|netrw-D|
     	 &lt;c-h&gt;............Editar la lista de archivos/dir ocultos....|netrw-ctrl-h|
     	 i................Cambiar el estilo de la lista..............|netrw-i|
     	 &lt;c-l&gt;............Refrescar la lista.........................|netrw-ctrl-l|
     	 o................Explorar con una división horizontal.......|netrw-o|
     	 p................Usar la ventana de previsualización........|netrw-p|
     	 P................Editar en la anterior ventana..............|netrw-p|
     	 q................Listar favoritos y el histório.............|netrw-q|
     	 r................Invertir el orden de agrupación............|netrw-r|
&lt;    	(etc)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;F1&gt; key thus brings you to a netrw directory browsing contents help page.  It's a regular help page; use the usual |CTRL-]| to jump to tagged help items and |CTRL-O| to jump back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;F1&gt; le lleva un directorio netrw explorando los contenidos de la página de ayuda. Ésta es una página de ayuda normal; use |CTRL-]| para saltar entre los elementos de ayuda etiquetados, y |CTRL-O| para volver atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&lt;enter&gt;		Open the file in the current window.	   |netrw-cr|
	o		Horizontally split window and display file |netrw-o|
	v		Vertically split window and display file   |netrw-v|
	p		Use the |preview-window| 		   |netrw-p|
	P		Edit in the previous window		   |netrw-P|
	t		Open file in a new tab			   |netrw-t|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&lt;enter&gt;		Abrir el archivo en la ventana actual.	   |netrw-cr|
	o		Dividir la ventana horizontalmente y mostrar el archivo |netrw-o|
	v		Dividir la ventana verticalmente y mostrar el archivo   |netrw-v|
	p		Usar la |preview-window| (ventana de previsualización)		  |netrw-p|
	P		Editar en la ventana anterior		   |netrw-P|
	t		Abrir el archivo en una nueva pestaña			   |netrw-t|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	i		Controls listing style (thin, long, wide, and tree).
			The long listing includes size and date information.
	s		Repeatedly pressing s will change the way the files
			are sorted; one may sort on name, modification time,
			or size.
	r		Reverse the sorting order.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	i		Control el formato de la lista (estrecho, largo, ancho, y árbol).
			El formato de lista largo incluye información de tamaño y fecha.
	s		Pulsar «s» repetidas veces modifica la manera en que se organizan
			los archivos; una para ordenar por nombre, fecha de modificación,
			o tamaño.
	r		Invertir el orden de presentación.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	c		Change Vim's notion of the current directory to be
			the same as the browser directory.  (see
			|g:netrw_keepdir| to control this, too)
	R		Rename the file or directory under the cursor; a
			prompt will be issued for the new name.
	D		Delete the file or directory under the cursor; a
			confirmation request will be issued.
	mb gb		Make bookmark/goto bookmark
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	c		Cambiar la noción de directorio actual de Vim, para
			coincidir con el directorio del navegador. (Véase
			|g:netrw_keepdir| para controlare esto también.)
	R		Renombrar el archivo o directorio bajo el cursor; verá
			una ventana de dialogo para introducir el nombre nuevo.
	D		Borrar el archivo o directorio bajo el cursor; un
			dialogo le pedirá confirmación.
	mb gb		Crear marcador/ir a bookmark
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Explore [directory]	Browse specified/current directory
	:NetrwSettings		A comprehensive list of your current netrw
				settings with help linkage.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Explore [directory]	Explorar el directorio actual o especificado
	:NetrwSettings		Una completa lista de su configuración actual de
				netrw, con enlaces de ayuda.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The netrw browser is not limited to just your local machine; one may use
urls such as:    (that trailing / is important)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El explorador netrw no esta limitado al sistema local; puede usar
direcciones url tales como:    (espacio en blanco / es importante).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Explore ftp://somehost/path/to/dir/
	:e scp://somehost/path/to/dir/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Explore ftp://sistema_anfitrión/ruta/al/directorio/
	:e scp://sistema_anfitrión/ruta/al/directorio/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.2*	The current directory
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.2*	El directorio actual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit VeryLongFileName/file1.txt
	:edit VeryLongFileName/file2.txt
	:edit VeryLongFileName/file3.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit Nombre_Largo_de_Directorio/archivo1.txt
	:edit Nombre_Largo_de_Directorio/archivo2.txt
	:edit Nombre_Largo_de_Directorio/archivo3.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cd VeryLongFileName
	:edit file1.txt
	:edit file2.txt
	:edit file3.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cd Nombre_Largo_de_Directorio
	:edit archivo1.txt
	:edit archivo2.txt
	:edit archivo3.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":cd" command changes the current directory.  You can see what the current directory is with the ":pwd" command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:cd» le permite cambiar a otro directorio. Puede ver cual es el directorio actual con la orden «:pwd»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:pwd
	/home/Bram/VeryLongFileName
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:pwd
	/home/Bram/Nombre_Largo_de_Directorio
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim remembers the last directory that you used.  Use "cd -" to go back to it.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim recuerda el último directorio que usó. Use «cd -» para volver a él. Ejemplo: &gt;()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:pwd
	/home/Bram/VeryLongFileName
	:cd /etc
	:pwd
	/etc
	:cd -
	:pwd
	/home/Bram/VeryLongFileName
	:cd -
	:pwd
	/etc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:pwd
	/home/Bram/Nombre_Largo_de_Directorio
	:cd /etc
	:pwd
	/etc
	:cd -
	:pwd
	/home/Bram/Nombre_Largo_de_Directorio
	:cd -
	:pwd
	/etc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you split a window, both windows use the same current directory.  When you want to edit a number of files somewhere else in the new window, you can make it use a different directory, without changing the current directory in the other window.  This is called a local directory. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando divide una ventana, ambas ventanas usan el mismo directorio actual. Cuando desea editar un nombre de archivos en otra ubicación en la ventana nueva, puede usar un directorio diferente, sin cambiar el directorio actual en la otra ventana. A esto se le llama el directorio local. &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:pwd
	/home/Bram/VeryLongFileName
	:split
	:lcd /etc
	:pwd
	/etc
	CTRL-W w
	:pwd
	/home/Bram/VeryLongFileName
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:pwd
	/home/Bram/Nombre_Largo_de_Archivo
	:split
	:lcd /etc
	:pwd
	/etc
	CTRL-W w
	:pwd
	/home/Bram/Nombre_Largo_de_Archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So long as no ":lcd" command has been used, all windows share the same current
directory.  Doing a ":cd" command in one window will also change the current
directory of the other window.
   For a window where ":lcd" has been used a different current directory is
remembered.  Using ":cd" or ":lcd" in other windows will not change it.
   When using a ":cd" command in a window that uses a different current
directory, it will go back to using the shared directory.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mientras no use ninguna orden «:lcd», todas las ventanas comparten
el directorio actual. Ejecutar una orden «:cd» en una ventana cambiará
también el directorio de la otra ventana.
   Si se usa con «:lcd» con una ventana, se recordará otro directorio
actual. Usar «:cd» o «:lcd» en otras ventanas no modificará esta.
  Cuando use la orden «:cd» en una ventana que usa un directorio actual
diferente, esta volverá al directorio compartido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.3*	Finding a file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.3*	Encontrar un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#include "inits.h" ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#include "inits.h" ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to see what is in that "inits.h" file.  Move the cursor on the name of the file and type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea ver el contenido del archivo «inits.h». Desplace el cursor al nombre del archivo y teclee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gf
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gf
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find the file and edit it.
   What if the file is not in the current directory?  Vim will use the 'path'
option to find the file.  This option is a list of directory names where to
look for your file.
   Suppose you have your include files located in "c:/prog/include".  This
command will add it to the 'path' option: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encontrará el archivo y lo editará.
   ¿Y en el caso de que el archivo no está en el directorio actual? Vim
usará la opción 'path' (ruta) para encontrar el archivo. Esta opción es una
lista de nombres de directorio donde buscar su archivo.
   Suponga que tiene sus archivos include en «c:/prog/include». Esta orden
la añadiría a la opción 'path': &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set path+=c:/prog/include
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set path+=c:/prog/include
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This directory is an absolute path.  No matter where you are, it will be the
same place.  What if you have located files in a subdirectory, below where the
file is?  Then you can specify a relative path name.  This starts with a dot:
&gt;
	:set path+=./proto
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este directorio es una ruta absoluta. No importa donde esté, tendrá
la misma ubicación. ¿Y en el caso de que tiene archivos ubicados en un
subdirectorio, debajo de donde está el archivo? Puede especificar en este
caso un nombre de ruta relativo. Esto empieza con un punto:
&gt;
	:set path+=./proto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to look in the directory "proto", below the directory where the
file in which you use "gf" is.  Thus using "gf" on "inits.h" will make Vim
look for "proto/inits.h", starting in the directory of the file.
   Without the "./", thus "proto", Vim would look in the "proto" directory
below the current directory.  And the current directory might not be where the
file that you are editing is located.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim mire en el directorio «proto», debajo del
directorio en el que está el archivo sobre el que usa «gf». Por ello, usar
«gf» con «inits.h» hace que Vim busque «proto/inits.h», empezando por el
directorio del archivo.
   Sin el «./», en este caso «proto», Vim buscará en el directorio «proto»
por debajo del directorio actual. Y puede que el directorio actual no sea
en el que se ubica el archivo que está editando.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'path' option allows specifying the directories where to search for files
in many more ways.  See the help on the 'path' option.
   The 'isfname' option is used to decide which characters are included in the
file name, and which ones are not (e.g., the " character in the example
above).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'path' permite especificar de muchas más maneras los directorios
donde buscar los archivos. Véase la ayuda de la opción 'path'.
   La opción 'isfname' se usa para decidir qué caracteres están incluidos
en el nombre del archivo, y cuales no lo están (p. ej., el carácter «"» en
el ejemplo anterior).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:find inits.h
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:find inits.h
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will then use the 'path' option to try and locate the file.  This is the same as the ":edit" command, except for the use of 'path'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará entonces la opción 'path' para buscar y ubicar el archivo.  Esto equivale a la orden «:edit», excepto por el uso de 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim "+find stdio.h"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim "+find stdio.h"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds the file "stdio.h" in your value of 'path'.  The quotes are necessary to have one argument |-+c|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra el archivo «stdio.h» en su valor de 'path'. Las comillas son necesarias para tener un argumento |-+c|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.4*	The buffer list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.4*	La lista de búfers.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor uses the term buffer to describe a file being edited.  Actually, a buffer is a copy of the file that you edit.  When you finish changing the buffer, you write the contents of the buffer to the file.  Buffers not only contain file contents, but also all the marks, settings, and other stuff that goes with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim usa el término búfer para describir un archivo en edición. En realidad, un búfer es una copia del archivo que edita. Cuando termina de modificar el búfer, escribe los contenidos del búfer en el archivo. Los búfers no solo contienen los contenidos de al archivo, sino también las marcas, configuraciones y otros elementos que lo acompañan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:hide edit two.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:hide edit dos.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The buffer "one.txt" disappears from the screen, but Vim still knows that you
are editing this buffer, so it keeps the modified text.  This is called a
hidden buffer: The buffer contains text, but you can't see it.
   The argument of ":hide" is another command.  ":hide" makes that command
behave as if the 'hidden' option was set.  You could also set this option
yourself.  The effect is that when any buffer is abandoned, it becomes hidden.
   Be careful!  When you have hidden buffers with changes, don't exit Vim
without making sure you have saved all the buffers.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El búfer «uno.txt» desaparece de la pantalla, pero Vim sabe aún sabe que
esté editando el búfer, así que guarda el texto modificado. A esto se le
llama un búfer oculto: El búfer contiene texto, pero no puede verlo.
   El argumento de «:hide» es otra orden. «:hide» hace que una orden se
comporte como si la opción 'hidden' estuviese activada. También podría
configurar usted mismo esta opción. El efecto que esto tiene es que cuando
cualquier búfer, éste se ocultará.
¡Cuidado! Cuando tenga búfers ocultos con cambios, no cierre Vim antes de
asegurarse de haber guardado todos los búfers.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   When a buffer has been used once, Vim remembers some information about it.
When it is not displayed in a window and it is not hidden, it is still in the
buffer list.  This is called an inactive buffer.  Overview:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si un búfer se ha usado una vez, Vim recordará alguna información del búfer.
Cuando no está activa en una ventana y no oculta, aún se encontrará en la
lista de búfers. A esto se le llama un búfer inactivo. Vista general:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   Active		Appears in a window, text loaded.
   Hidden		Not in a window, text loaded.
   Inactive		Not in a window, no text loaded.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   Activo		Aparece en una ventana, texto cargado.
   Hidden		No aparece en una ventana, texto cargado.
   Inactive		No aparece en una ventana, texto no cargado.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:buffers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:buffers
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:ls
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:ls
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output could look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida puede presentar este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  1 #h	"help.txt"			line 62 ~
  2 %a+	"usr_21.txt"			line 1 ~
  3	"usr_toc.txt"			line 1 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  1 #h	"help.txt"			línea 62 ~
  2 %a+	"usr_21.txt"			línea 1 ~
  3	"usr_toc.txt"			línea 1 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first column contains the buffer number.  You can use this to edit the
buffer without having to type the name, see below.
   After the buffer number come the flags.  Then the name of the file
and the line number where the cursor was the last time.
   The flags that can appear are these (from left to right):
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera columna contiene el número de búfer. Puede usar esto para
editar el búfer sin tener que introducir el nombre, explicado a
continuación.
   Después del número aparecen las opciones. Por último, el nombre del
archivo y el número de línea en el que estaba el cursor al última vez.
   Se permiten las siguientes opciones (de izquierda a derecha):
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	u	Buffer is unlisted |unlisted-buffer|.
	 %	Current buffer.
	 #	Alternate buffer.
	  a	Buffer is loaded and displayed.
	  h	Buffer is loaded but hidden.
	   =	Buffer is read-only.
	   -	Buffer is not modifiable, the 'modifiable' option is off.
	    +	Buffer has been modified.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	u	Buffer no está listado |unlisted-buffer|.
	 %	Búfer actual.
	 #	Búfer alternativo.
	  a	El búfer está cargado y visible.
	  h	El búfer está cargado pero oculto.
	   =	El búfer es de sólo lectura.
	   -	El búfer no es modificable, la opción 'modifiable' está desactivada.
	    +	El búfer se ha modificado.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can edit a buffer by its number.  That avoids having to type the file name: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede editar un búfer por su número. Esto evita tener que introducir el nombre del archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:buffer 2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:buffer 2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the only way to know the number is by looking in the buffer list.  You can use the name, or part of it, instead: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero la única manera de saber el número es a través de la lista de de búfers. En lugar de esto, puede usar el nombre, o parte de él: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:buffer help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:buffer help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find the best match for the name you type.  If there is only one
buffer that matches the name, it will be used.  In this case "help.txt".
   To open a buffer in a new window: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim mostrará la coincidencia más cercana al nombre que introduzca. De
sólo haber un búfer que coincida con el nombre, este se usará. En este caso,
«help.txt». Use lo siguiente para abrir un búfer en una nueva ventana: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:sbuffer 3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:sbuffer 3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:bnext		go to next buffer
	:bprevious	go to previous buffer
	:bfirst		go to the first buffer
	:blast		go to the last buffer
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:bnext		Ir al siguiente búfer
	:bprevious	Ir al búfer anterior
	:bfirst		Ir al primer búfer
	:blast		Ir al último búfer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:bdelete 3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:bdelete 3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, this also works with a name.
   If you delete a buffer that was active (visible in a window), that window
will be closed.  If you delete the current buffer, the current window will be
closed.  If it was the last window, Vim will find another buffer to edit.  You
can't be editing nothing!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, esto también funciona con un nombre.
   Si elimina un búfer que estaba activo (visible en una ventana), esa
ventana se cerrará. Si elimina el búfer actual, se cerrará la ventana
actual. Si era la última ventana, Vim encontrará otro búfer que editar. ¡No
puede editar la nada!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	Even after removing the buffer with ":bdelete" Vim still remembers it.
	It's actually made "unlisted", it no longer appears in the list from
	":buffers".  The ":buffers!" command will list unlisted buffers (yes,
	Vim can do the impossible).  To really make Vim forget about a buffer,
	use ":bwipe".  Also see the 'buflisted' option.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Aún después de eliminar un búfer con «:bdelete», Vim aún lo recuerda.
	En realidad, pasa a no «unlisted» (no listado), ya que no aparece en la
	lista de «:buffers». La orden «:buffers!» muestra los búfers no listados
	(sí, Vim es capaz de lo imposible). Para hacer que Vim olvide
	completamente un búfer, use «:bwipe». Véase también la opción	'buflisted'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_90.txt*	For Vim version 7.3.  Last change: 2008 Sep 10
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_90.esx*	Para Vim versión 7.3.  Último cambio: 10/09/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				Installing Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				Instalar Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>								*install*
Before you can use Vim you have to install it.  Depending on your system it's
simple or easy.  This chapter gives a few hints and also explains how
upgrading to a new version is done.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*instalar* *install*
Antes de usar Vim, tiene que instalarlo. Es sencillo o fácil
dependiendo de su sistema. Este capítulo ofrece algunas
indicaciones y explica cómo se actualiza a una nueva versión.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|90.1|	Unix
|90.2|	MS-Windows
|90.3|	Upgrading
|90.4|	Common installation issues
|90.5|	Uninstalling Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|90.1|	Unix
|90.2|	MS-Windows
|90.3|	Actualizar
|90.4|	Problemas de instalación habituales
|90.5|	Desinstalar Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> Previous chapter: |usr_45.txt|  Select your language
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_45.esx|  Seleccione su idioma
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.1*	Unix
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.1*	Unix
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you have to decide if you are going to install Vim system-wide or for a
single user.  The installation is almost the same, but the directory where Vim
is installed in differs.
   For a system-wide installation the base directory "/usr/local" is often
used.  But this may be different for your system.  Try finding out where other
packages are installed.
   When installing for a single user, you can use your home directory as the
base.  The files will be placed in subdirectories like "bin" and "shared/vim".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero debe decidir si va a instalar Vim para uno o todos los usuarios. La
instalación es muy similar, pero difiere el directorio de instalación de Vim.
   Para una instalación de sistema (todos los usuarios), a menudo se usa
el directorio base «/usr/local». Pero puede ser distinto en su sistema.
Intente averiguar dónde se instalan los otros paquetes.
   Cuando realiza una instalación para un sólo usuario, puede usar su
directorio personal como base. Los ficheros se ubicarań en subdirectorios
como «bin» y «shared/vim».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get precompiled binaries for many different UNIX systems.  There is a long list with links on this page:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener binarios precompilados para muchos sistemas UNIX diferentes. En esta página hay una larga lista con enlaces:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	http://www.vim.org/binaries.html ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	http://www.vim.org/binaries.html ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Volunteers maintain the binaries, so they are often out of date.  It is a good idea to compile your own UNIX version from the source.  Also, creating the editor from the source allows you to control which features are compiled.  This does require a compiler though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los responsables de los binarios son voluntarios, por lo que a menudo están obsoletos. Es una buena idea compilar su propia versión UNIX desde las fuentes. Así mismo, crear el editor desde las fuentes le permite controlar las características a compilar. Por otra parte, esto requiere un compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a Linux distribution, the "vi" program is probably a minimal version of Vim.  It doesn't do syntax highlighting, for example.  Try finding another Vim package in your distribution, or search on the web site.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene una distribución de Linux, el programa vi es probablemente una versión mínima de Vim. No ejecuta el resaltado de sintaxis, por ejemplo. Intente buscar otro paquete de Vim en su distribución, o busque en la página web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	-  A C compiler (GCC preferred)
	-  The GZIP program (you can get it from www.gnu.org)
	-  The Vim source and runtime archives
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	-  Un compilador C (preferentemente GCC)
	-  El programa GZIP (puede obtenerlo en www.gnu.org)
	-  Los archivos de Vim fuente y de tiempo de ejecución
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ftp://ftp.vim.org/pub/vim/MIRRORS ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ftp://ftp.vim.org/pub/vim/MIRRORS ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use the home site ftp.vim.org, if you think it's fast enough.  Go to the
"unix" directory and you'll find a list of files there.  The version number is
embedded in the file name.  You will want to get the most recent version.
   You can get the files for Unix in two ways: One big archive that contains
everything, or four smaller ones that each fit on a floppy disk.  For version
6.1 the single big one is called:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O use la página oficial ftp.vim.org, si cree que es suficientemente rápida.
Vaya al directorio «unix», y encontrará una serie de archivos. El
número de versión está integrado en el nombre del archivo. Querrá obtener
la versión más reciente.
   Puede obtener los archivos para Unix de dos formas: Un único archivo
grande que contiene todo, o cuatro más pequeños que caben en un
disquete. El archivo de la versión 6.1 se llama:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim-6.1.tar.bz2 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim-6.1.tar.bz2 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need the bzip2 program to uncompress it.  If you don't have it, get the four smaller files, which can be uncompressed with gzip.  For Vim 6.1 they are called:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita el programa bzip2 para descomprimirlo. Si no lo tiene, descargue los cuatro archivos más pequeños, que se pueden descomprimir con gzip. Para Vim 6.1, se llaman:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim-6.1-src1.tar.gz ~
	vim-6.1-src2.tar.gz ~
	vim-6.1-rt1.tar.gz ~
	vim-6.1-rt2.tar.gz ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim-6.1-src1.tar.gz ~
	vim-6.1-src2.tar.gz ~
	vim-6.1-rt1.tar.gz ~
	vim-6.1-rt2.tar.gz ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mkdir ~/vim
	cd ~/vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mkdir ~/vim
	cd ~/vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then unpack the archives there.  If you have the one big archive, you unpack it like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Descomprima los archivos en esa ubicación. Si tiene el archivo único grande, lo puede desempaquetar de la siguiente forma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	bzip2 -d -c path/vim-6.1.tar.bz2 | tar xf -
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	bzip2 -d -c ruta/vim-6.1.tar.bz2 | tar xf -
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gzip -d -c path/vim-6.1-src1.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-src2.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-rt1.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-rt2.tar.gz | tar xf -
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gzip -d -c ruta/vim-6.1-src1.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-src2.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-rt1.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-rt2.tar.gz | tar xf -
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	cd vim61/src
	make
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	cd vim61/src
	make
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The make program will run configure and compile everything.  Further on we
will explain how to compile with different features.
   If there are errors while compiling, carefully look at the error messages.
There should be a hint about what went wrong.  Hopefully you will be able to
correct it.  You might have to disable some features to make Vim compile.
Look in the Makefile for specific hints for your system.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El programa «make» ejecutará «configure» y compilará todo. Más adelante
explicaremos como compilar con diferentes funcionalidades.
   Si detecta errores durante la compilación, mire con detenimiento los
mensajes de error. Debería haber una indicación de qué falló. Con suerte,
podrá corregirlos. Puede que tenga que desactivar algunas funcionalidades
para poder compilar Vim. Consulte el archivo «Makefile» para ver
indicaciones específicas a su sistema.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	make test
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	make test
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run a sequence of test scripts to verify that Vim works as expected.  Vim will be started many times and all kinds of text and messages flash by.  If it is alright you will finally see:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ejecutará una secuencia de scripts de prueba para comprobar que Vim funciona de la manera esperada. Se iniciará Vim varias veces, y aparecerán rápidamente todo tipo de texto y mensajes. Si todo es correcto, verá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	test results: ~
	ALL DONE ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	test results: ~
	ALL DONE ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you get "TEST FAILURE" some test failed.  If there are one or two messages about failed tests, Vim might still work, but not perfectly.  If you see a lot of error messages or Vim doesn't finish until the end, there must be something wrong.  Either try to find out yourself, or find someone who can solve it.  You could look in the |maillist-archive| for a solution.  If everything else fails, you could ask in the vim |maillist| if someone can help you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si le devuelve «TEST FAILURE», es que ha fallado alguna prueba. Si existen uno o más mensajes de pruebas fallidas, puede que Vim funcione, pero no a la perfección. Si ve muchos mensajes de error o Vim no continua hasta el final, puede que exista algún problema. Puede intentar encontrarlo manualmente, o encontrar a alguien que lo puede solucionar. También puede consultar la lista de correo (|maillist-archive|) en busca de una solución. Si todo falla, puede preguntar en la lista de correo (|maillist|) de Vim si alguien le puede ayudar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>INSTALLING
							*install-home*
If you want to install in your home directory, edit the Makefile and search
for a line:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>INSTALACIÓN
							*install-home*
Si desea instalar Vim en su directorio personal (o «home»), edite el
archivo «Makefile» y busque la siguiente línea:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#prefix = $(HOME) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#prefix = $(HOME) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the # at the start of the line.
   When installing for the whole system, Vim has most likely already selected
a good installation directory for you.  You can also specify one, see below.
You need to become root for the following.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Elimine «#» al principio de la línea.
   Al instalar para todo el sistema, los más probable es que Vim haya
seleccionado un directorio de instalación adecuado. También puede
definir uno; vea a continuación. Necesita ser el administrador para
poder realizar lo siguiente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	make install
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	make install
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That should move all the relevant files to the right place.  Now you can try running vim to verify that it works.  Use two simple tests to check if Vim can find its runtime files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto debería mover todos los archivos relevantes al sitio adecuado. Ahora puede intentar ejecutar Vim para comprobar que funciona. Use dos pruebas sencillas para comprobar que Vim puede encontrar sus archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help
	:syntax enable
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help
	:syntax enable
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo $VIMRUNTIME
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo $VIMRUNTIME
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget that the user manual assumes you Vim in a certain way.  After installing Vim, follow the instructions at |not-compatible| to make Vim work as assumed in this manual.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No olvide que el manual del usuario supone que usa Vim de una cierta manera. Tras instalar Vim, siga las instrucciones en |not-compatible| para que Vim funcione de la forma aceptada en este manual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has many ways to select features.  One of the simple ways is to edit the
Makefile.  There are many directions and examples.  Often you can enable or
disable a feature by uncommenting a line.
   An alternative is to run "configure" separately.  This allows you to
specify configuration options manually.  The disadvantage is that you have to
figure out what exactly to type.
   Some of the most interesting configure arguments follow.  These can also be
enabled from the Makefile.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece varias formas de seleccionar funcionalidades. Una de las más
sencillas es editar el archivo «Makefile». Hay muchas indicaciones y
ejemplos. Generalmente, puede activar o desactivar una funcionalidad
simplemente descomentando una línea.
   Otra alternativa es ejecutar «configure» de forma separada. Le permite
especificar opciones de configuración manualmente. La desventaja es que
tiene que averiguar qué teclear exactamente.
   A continuación tiene algunas de los argumentos más interesantes. También
se pueden activar desde el archivo «Makefile».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	--prefix={directory}		Top directory where to install Vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	--prefix={directorio}		Directorio superior donde instalar Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	--with-features=tiny		Compile with many features disabled.
	--with-features=small		Compile with some features disabled.
	--with-features=big		Compile with more features enabled.
	--with-features=huge		Compile with most features enabled.
					See |+feature-list| for which feature
					is enabled in which case.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	--with-features=tiny		Compilación con varias funcionalidades desactivadas.
	--with-features=small		Compilación con algunas funcionalidades desactivadas.
	--with-features=big		Compilación con más funcionalidades activadas.
	--with-features=huge		Compilación con la mayoría de funcionalidades activadas.
					Consulte |+feature-list| para ver qué
					funcionalidad está activa por omisión.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	--enable-perlinterp		Enable the Perl interface.  There are
					similar arguments for ruby, python and
					tcl.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	--enable-perlinterp		Activa la interfaz de Perl. Existen
					argumentos similares para Ruby,
					Python y tcl.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	--disable-gui			Do not compile the GUI interface.
	--without-x			Do not compile X-windows features.
					When both of these are used, Vim will
					not connect to the X server, which
					makes startup faster.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	--disable-gui			No compila la interfaz gráfica.
	--without-x			No compila las funcionalidades del sistema
						de ventanas X.
					Si se usan las dos, Vim no se conectará al
					servidor de X, lo cual agiliza el inicio.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	./configure --help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	./configure --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find a bit of explanation for each feature, and links for more
information here: |feature-list|.
   For the adventurous, edit the file "feature.h".  You can also change the
source code yourself!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar una explicación de cada funcionalidad y enlaces a
más información aquí: |feature-list|.
   Para los atrevido, edite el archivo «feature.h». ¡También puede
modificar el código fuente directamente!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.2*	MS-Windows
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.2*	MS-Windows
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to install the Vim program for Microsoft Windows.  You can uncompress several archives, or use a self-installing big archive.  Most users with fairly recent computers will prefer the second method.  For the first one, you will need:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen dos formas de instalar el programa Vim para Microsoft Windows. Puede descomprimir varios archivos, o usar un sólo archivo de instalación automática. La mayoría de usuarios con ordenadores relativamente recientes pueden preferir el segundo método. Se requiere lo siguiente para usar el primero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	- An archive with binaries for Vim.
	- The Vim runtime archive.
	- A program to unpack the zip files.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	- Un archivo con binarios para Vim.
	- El archivo de tiempo de ejecución («runtime) de Vim.
	- Un programa para desempaquetar los archivos zip.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use the home site ftp.vim.org, if you think it's fast enough.  Go to the "pc" directory and you'll find a list of files there.  The version number is embedded in the file name.  You will want to get the most recent version.  We will use "61" here, which is version 6.1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O use la página oficial ftp.vim.org si cree que es suficientemente rápido. Vaya al directorio «pc» y verá una lista de archivos. El número de versión se incluye en el nombre de archivo. Le recomendamos que obtenga la versión más reciente. En este documento se usará «61», la versión 6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim61.exe		The self-installing archive.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim61.exe		El archivo de instalación automática.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is all you need for the second method.  Just launch the executable, and follow the prompts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es todo lo que necesita para el segundo método. Simplemente ejecute el archivo, y siga los diálogos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the first method you must chose one of the binary archives.  These are available:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe escoger uno de los archivos binarios para realizar el primer método. Los siguientes están disponibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim61.zip		The normal MS-Windows GUI version.
	gvim61ole.zip		The MS-Windows GUI version with OLE support.
				Uses more memory, supports interfacing with
				other OLE applications.
	vim61w32.zip		32 bit MS-Windows console version.  For use in
				a Win NT/2000/XP console.  Does not work well
				on Win 95/98.
	vim61d32.zip		32 bit MS-DOS version.  For use in the
				Win 95/98 console window.
	vim61d16.zip		16 bit MS-DOS version.  Only for old systems.
				Does not support long filenames.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim61.zip		La versión de interfaz gráfica normal de MS Windows.
	gvim61ole.zip		La versión gráfica de MS Windows con compatibilidad
					con OLE.
				Usa más memoria, permite interactuar con otras
				aplicaciones OLE.
	vim61w32.zip		La versión de consola de 32 bit para MS Windows.
				Para el uso en una consola Win NT/2000/XP console.
				No funciona bien en Win 95/98.
	vim61d32.zip		Versión de 32 bit para MS-DOS. Para el uso en una
				ventana de consola de Win 95/98.
	vim61d16.zip		Versión de 16 bit para MS-DOS. Sólo para sistemas
				antiguos. No permite el uso de nombres de archivo largos.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You only need one of them.  Although you could install both a GUI and a console version.  You always need to get the archive with runtime files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo necesita uno de estos. Aunque puede instalar la versión gráfica y una versión de intérprete de órdenes. Siempre necesita obtener el archivo con los archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim61rt.zip		The runtime files.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim61rt.zip		Los archivos de tiempo de ejecución.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use your un-zip program to unpack the files.  For example, using the "unzip" program: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use su programa un-zip para descomprimir lso archivos. Por ejemplo, usando el programa «unzip»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	cd c:\
	unzip path\gvim61.zip
	unzip path\vim61rt.zip
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	cd c:\
	unzip path\gvim61.zip
	unzip path\vim61rt.zip
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will unpack the files in the directory "c:\vim\vim61".  If you already
have a "vim" directory somewhere, you will want to move to the directory just
above it.
   Now change to the "vim\vim61" directory and run the install program: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éstas órdenes desempaquetarán los ficheros en el directorio «c:\vim\vim61».
Si ya tiene un directorio «vim», puede navegar al directorio superior a él.
   Ahora, entre al directorio «vim\vim61» y ejecute el programa de
instalación: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	install
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	install
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carefully look through the messages and select the options you want to use.
If you finally select "do it" the install program will carry out the actions
you selected.
   The install program doesn't move the runtime files.  They remain where you
unpacked them.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise los mensajes con cuidado y seleccione las opciones que desea usar.
Si al final selecciona «do it», el programa de instalación llevará a cabo las
acciones seleccionadas.
   El programa de instalación no reubica los archivos de tiempo de ejecución.
Permanecerán en el lugar en el que los desempaquetó.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are not satisfied with the features included in the supplied binaries, you could try compiling Vim yourself.  Get the source archive from the same location as where the binaries are.  You need a compiler for which a makefile exists.  Microsoft Visual C works, but is expensive.  The Free Borland command-line compiler 5.5 can be used, as well as the free MingW and Cygwin compilers.  Check the file src/INSTALLpc.txt for hints.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el caso de que no esté satisfecho con las características incluidas en los binarios proporcionados, puede intentar compilar Vim. Obtenga el archivo de fuentes de la misma ubicación de los binarios. Necesitará un compilador que permita «makefiles». Microsoft Visual C funciona, pero es caro. Puede usar el compilador de línea de órdenes libre Borland 5.5, así como los compiladores libres MingW y Cygwin. Consulte el archivo «src/INSTALLpc.txt» para más indicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.3*	Upgrading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.3*	Actualizar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type "make install" the runtime files will be copied to a directory
which is specific for this version.  Thus they will not overwrite a previous
version.  This makes it possible to use two or more versions next to
each other.
   The executable "vim" will overwrite an older version.  If you don't care
about keeping the old version, running "make install" will work fine.  You can
delete the old runtime files manually.  Just delete the directory with the
version number in it and all files below it.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando teclea «make install», los ficheros de tiempo de ejecución se
copiarán un directorio específico a la versión. Por ello, no sobreescribirán
una versión anterior. Esto permite usar dos o más versiones
simultáneamente.
   El ejecutable «vim» sobreescribirá una versión anterior. Si no le
interesa preservar la versión más antigua, ejecutar «make install»
funcionará sin problemas. Puede eliminar los archivos de
tiempo de ejecución manualmente. Simplemente elimine el directorio con
el número de versión y todos los archivos contenidos en él. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	rm -rf /usr/local/share/vim/vim58
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	rm -rf /usr/local/share/vim/vim58
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are normally no changed files below this directory.  If you did change the "filetype.vim" file, for example, you better merge the changes into the new version before deleting it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, bajo este directorio no hay archivos modificados. Si ha modificado el archivo «filetype.vim», por ejemplo, será mejor que introduzca esos cambios en la versión nueva antes de eliminar el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are careful and want to try out the new version for a while before switching to it, install the new version under another name.  You need to specify a configure argument.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es cuidadoso y desea probar la nueva versión durante un tiempo antes de cambiar a ella, instale la nueva versión bajo otro nombre. Necesita especificar un argumento de configuración. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	./configure --with-vim-name=vim6
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	./configure --with-vim-name=vim6
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running "make install", you could use "make -n install" to check that
no valuable existing files are overwritten.
   When you finally decide to switch to the new version, all you need to do is
to rename the binary to "vim".  For example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debería usar «make -n install» antes de ejecutar «make install» para
comprobar que no se sobreescribirá ningún archivo valioso.
   Cuando decida pasar a la nueva versión, todo lo que necesita hacer es
renombrar el binario a «vim». Por ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mv /usr/local/bin/vim6 /usr/local/bin/vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mv /usr/local/bin/vim6 /usr/local/bin/vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Upgrading is mostly equal to installing a new version.  Just unpack the files
in the same place as the previous version.  A new directory will be created,
e.g., "vim61", for the files of the new version.  Your runtime files, vimrc
file, viminfo, etc. will be left alone.
   If you want to run the new version next to the old one, you will have to do
some handwork.  Don't run the install program, it will overwrite a few files
of the old version.  Execute the new binaries by specifying the full path.
The program should be able to automatically find the runtime files for the
right version.  However, this won't work if you set the $VIMRUNTIME variable
somewhere.
   If you are satisfied with the upgrade, you can delete the files of the
previous version.  See |90.5|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Actualizar es casi idéntico a instalar una versión nueva. Sencillamente
desempaquete los archivos en la misma ubicación de la versión anterior.
Se creará un directorio nuevo, esto es, «vim61», para los archivos de la
versión nueva. Sus archivos de tiempo de ejecución, «vimrc» y «viminfo»
no se modificarán.
   Si desea ejecutar la nueva versión junto a la antigua, tendrá que hacer
algún trabajo manual. No ejecute el programa de instalación, ya que
sobreescribirá algunos archivos de la versión antigua. Ejecute los binarios
nuevos especificando la ruta completa. El programa debería averiguar
automáticamente la ubicación de los archivos de tiempo de ejecución para
la versión adecuada. Por otra parte, no funcionará si define en algún lugar
la variable «$VIMRUNTIME».
   Si la actualización le satisface, puede eliminar los archivos de la versión
anterior. Consulte |90.5|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.4*	Common installation issues
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.4*	Problemas de instalación habituales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section describes some of the common problems that occur when installing Vim and suggests some solutions.  It also contains answers to many installation questions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta sección describe algunos de los problemas más habituales al instalar Vim, y sugiere algunas soluciones. También contiene respuestas a muchas preguntas sobre la instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: I Do Not Have Root Privileges.  How Do I Install Vim? (Unix)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: No tengo privilegios de administrador.  ¿Cómo puedo instalar Vim? (Unix)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	./configure --prefix=$HOME
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	./configure --prefix=$HOME
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This gives you a personal copy of Vim.  You need to put $HOME/bin in your path to execute the editor.  Also see |install-home|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto genera una copia personal de Vim. Necesita poner «$HOME/bin» en su ruta (variable PATH) para ejecutar el editor. Consulte también |install-home|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: The Colors Are Not Right on My Screen. (Unix)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: Los colores no son los correctos en mi pantalla. (Unix)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	echo $TERM
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	echo $TERM
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the terminal type listed is not correct, fix it.  For more hints, see |06.2|.  Another solution is to always use the GUI version of Vim, called gvim.  This avoids the need for a correct terminal setup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el tipo de terminal listado no es el correcto, corríjalo. Para más indicaciones, consulte |06.2|. Otra solución es usar siempre la versión gráfica de usuario de Vim, llamado gvim. Esto último evita la necesidad de una correcta configuración de terminal. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The definition of what key sends what code is very unclear for backspace &lt;BS&gt; and Delete &lt;Del&gt; keys.  First of all, check your $TERM setting.  If there is nothing wrong with it, try this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La definición del código que cada tecla envía no está muy clara con las teclas de retroceso &lt;BS&gt; y eliminar &lt;Del&gt;. Primero, compruebe su opción de configuración «$TERM». Si no detecta nada incorrecto: pruebe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set t_kb=^V&lt;BS&gt;
	:set t_kD=^V&lt;Del&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set t_kb=^V&lt;BS&gt;
	:set t_kD=^V&lt;Del&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first line you need to press CTRL-V and then hit the backspace key.  In the second line you need to press CTRL-V and then hit the Delete key.  You can put these lines in your vimrc file, see |05.1|.  A disadvantage is that it won't work when you use another terminal some day.  Look here for alternate solutions: |:fixdel|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera línea tiene que pulsar «CTRL-V» y después pulsar la tecla de retroceso. En la segunda, debe pulsar «CTRL-V» y pulsar la tecla de eliminar. Puede poner estas líneas en su archivo «vimrc», consulte |05.1|. Una desventaja es que no funcionará cuando use otra terminal.  Consulte aquí las posibles soluciones: |:fixdel|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: I Am Using RedHat Linux.  Can I Use the Vim That Comes with the System?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: Uso RedHat Linux. ¿Puedo usar la versión de Vim que viene con el sistema?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default RedHat installs a minimal version of Vim.  Check your RPM packages for something named "Vim-enhanced-version.rpm" and install that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, RedHat instala una versión mínima de Vim. Busque entre los paquetes RPM algo llamado «Vim-enhanced-version.rpm» e instale ese paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: How Do I Turn Syntax Coloring On? How do I make plugins work?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: ¿Como se activa el resaltado de sintaxis? ¿Como hago funcionar las extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the example vimrc script.  You can find an explanation on how to use it here: |not-compatible|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use el script de ejemplo «vimrc». Encontrará una explicación de su uso en el siguiente apartado: |not-compatible|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the Vim-online site: http://vim.sf.net.  Many users have uploaded useful Vim scripts and plugins there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Visite el sitio web de Vim: http://vim.sf.net. Muchos usuarios han enviado útiles scripts de Vim y extensiones a esta ubicación de Internet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the Vim-online site: http://vim.sf.net.  There is an archive with hints from Vim users.  You might also want to search in the |maillist-archive|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte el sitio web de Vim: http://vim.sf.net. Hay un archivo con indicaciones de usuarios de Vim. Puede que también desee buscar en el archivo de la lista de correo, |maillist-archive|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.5*	Uninstalling Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.5*	Desinstalar Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you installed Vim as a package, check your package manager to find out
how to remove the package again.
   If you installed Vim from sources you can use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha instalado Vim como un paquete, compruebe su gestor de paquetes para
averiguar cómo eliminar el paquete.
   Si ha instalado Vim a partir de las fuentes, puede usar la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	make uninstall
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	make uninstall
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you have deleted the original files or you used an archive that someone supplied, you can't do this.  Do delete the files manually, here is an example for when "/usr/local" was used as the root: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, si ha eliminado los archivos originales, o ha usado un archivo que alguien le ha proporcionado, no podrá hacer esto. Este es un ejemplo de desinstalación manual de Vim cuando «/usr/local» se ha usado como el directorio raíz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	rm -rf /usr/local/share/vim/vim61
	rm /usr/local/bin/eview
	rm /usr/local/bin/evim
	rm /usr/local/bin/ex
	rm /usr/local/bin/gview
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvimdiff
	rm /usr/local/bin/rgview
	rm /usr/local/bin/rgvim
	rm /usr/local/bin/rview
	rm /usr/local/bin/rvim
	rm /usr/local/bin/rvim
	rm /usr/local/bin/view
	rm /usr/local/bin/vim
	rm /usr/local/bin/vimdiff
	rm /usr/local/bin/vimtutor
	rm /usr/local/bin/xxd
	rm /usr/local/man/man1/eview.1
	rm /usr/local/man/man1/evim.1
	rm /usr/local/man/man1/ex.1
	rm /usr/local/man/man1/gview.1
	rm /usr/local/man/man1/gvim.1
	rm /usr/local/man/man1/gvimdiff.1
	rm /usr/local/man/man1/rgview.1
	rm /usr/local/man/man1/rgvim.1
	rm /usr/local/man/man1/rview.1
	rm /usr/local/man/man1/rvim.1
	rm /usr/local/man/man1/view.1
	rm /usr/local/man/man1/vim.1
	rm /usr/local/man/man1/vimdiff.1
	rm /usr/local/man/man1/vimtutor.1
	rm /usr/local/man/man1/xxd.1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	rm -rf /usr/local/share/vim/vim61
	rm /usr/local/bin/eview
	rm /usr/local/bin/evim
	rm /usr/local/bin/ex
	rm /usr/local/bin/gview
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvimdiff
	rm /usr/local/bin/rgview
	rm /usr/local/bin/rgvim
	rm /usr/local/bin/rview
	rm /usr/local/bin/rvim
	rm /usr/local/bin/rvim
	rm /usr/local/bin/view
	rm /usr/local/bin/vim
	rm /usr/local/bin/vimdiff
	rm /usr/local/bin/vimtutor
	rm /usr/local/bin/xxd
	rm /usr/local/man/man1/eview.1
	rm /usr/local/man/man1/evim.1
	rm /usr/local/man/man1/ex.1
	rm /usr/local/man/man1/gview.1
	rm /usr/local/man/man1/gvim.1
	rm /usr/local/man/man1/gvimdiff.1
	rm /usr/local/man/man1/rgview.1
	rm /usr/local/man/man1/rgvim.1
	rm /usr/local/man/man1/rview.1
	rm /usr/local/man/man1/rvim.1
	rm /usr/local/man/man1/view.1
	rm /usr/local/man/man1/vim.1
	rm /usr/local/man/man1/vimdiff.1
	rm /usr/local/man/man1/vimtutor.1
	rm /usr/local/man/man1/xxd.1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you installed Vim with the self-installing archive you can run
the "uninstall-gui" program located in the same directory as the other Vim
programs, e.g. "c:\vim\vim61".  You can also launch it from the Start menu if
installed the Vim entries there.  This will remove most of the files, menu
entries and desktop shortcuts.  Some files may remain however, as they need a
Windows restart before being deleted.
   You will be given the option to remove the whole "vim" directory.  It
probably contains your vimrc file and other runtime files that you created, so
be careful.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha instalado Vim el archivo de instalación automática, puede
ejecutar el programa «uninstall-gui», ubicado en el mismo directorio
de otros programas de Vim. Esto es, «c:\vim\vim61». También puede
iniciarlo desde el menú de aplicaciones si ha instalado las entradas
de Vim. Esto elimina la mayoría de los archivos, entradas de menú
y enlaces directos. Sin embargo, algunos archivos permanecerán en
el sistema, ya que necesitan un reinicio de Windows antes de su
eliminación.
   Se le dará la opción de eliminar todo el directorio «vim».
Probablemente, contiene su archivo «vimrc» y otros archivos de
tiempo de ejecución que ha creado, tenga cuidado.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui_x11.txt*   For Vim version 7.2.  Last change: 2007 Dec 09</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui_x11.txt*  Para Vim versión 7.2. Último cambio: 2007 Dec 09</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim's Graphical User Interface				*gui-x11* *GUI-X11*
							*Athena* *Motif*
1. Starting the X11 GUI		|gui-x11-start|
2. GUI Resources		|gui-resources|
3. Shell Commands		|gui-pty|
4. Various			|gui-x11-various|
5. GTK version			|gui-gtk|
6. GNOME version		|gui-gnome|
7. KDE version			|gui-kde|
8. Compiling			|gui-x11-compiling|
9. X11 selection mechanism	|x11-selection|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaz gráfica de usuario de Vim				*gui-x11* *GUI-X11*
							*Athena* *Motif*
1. Iniciar GUI para X11		|gui-x11-start|
2. Recursos de la GUI		|gui-resources|
3. Órdenes del intérprete de órdenes		|gui-pty|
4. Varios			|gui-x11-various|
5. Versión GTK			|gui-gtk|
6. Versión GNOME 		|gui-gnome|
7. Versión KDE 			|gui-kde|
8. Compilar			|gui-x11-compiling|
9. Mecanismo de selección de X11	|x11-selection|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================
1. Starting the X11 GUI					*gui-x11-start* *E665*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================
1. Iniciando la IGU de X11					*gui-x11-start* *E665*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you call the executable "gvim", or make "gvim" a link to the executable,
then the GUI version will automatically be used.  Additional characters may be
added after "gvim", for example "gvim-5".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si invoca el ejecutable «gvim», o enlaza «gvim» al ejecutable,
la interfaz gráfica se usará automáticamente. Se pueden añadir caracteres
adicionales tras «gvim», «gvim-5» por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*gui-fork*
When the GUI is started, it does a fork() and exits the current process.
When gvim was started from a shell this makes the shell accept further
commands.  If you don't want this (e.g. when using gvim for a mail program
that waits for gvim to exit), start gvim with "gvim -f", "vim -gf" or use
":gui -f".  Don't use "vim -fg", because "-fg" specifies the foreground
color.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*gui-fork*
Cuando inicia la GUI, crea un «fork()» y termina el proceso actual.
Cuando se ha iniciado gvim desde un interprete de órdenes, esto
hace que la consola pueda recibir futuras órdenes. Si no desea
esto, (p. ej., cuando usa gvim para un programa de correo que 
espera a que gvim se cierre), inicie gvim con «gvim -f», «vim -gf»
o use «:gui -f». No use «vim -fg» porque «-fg» especifica el color
en primer plano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using "gvim -f" and then ":gui", Vim will run in the foreground.  The
"-f" argument will be remembered.  To force running Vim in the background use
":gui -b".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «gvim -f», y después «:gui», Vim se ejectuará en primer plano.
El argumento «-f» se recordará. Para forzar que Vim se inicie de fondo,
use «gui -b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want the GUI to run in the foreground always, include the 'f'
flag in 'guioptions'.  |-f|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que la IGU siempre se ejecute en primer plano, incluya
la marca «f» en 'guioptions'. |-f|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================
2. GUI Resources			*gui-resources* *.Xdefaults*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================
2. Recursos de la IGU			*gui-resources* *.Xdefaults*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using the Motif or Athena version of the GUI (not for the KDE, GTK+ or Win32
version), a number of X resources are available.  You should use Vim's class
"Vim" when setting these.  They are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de que este usando la versión Motif o Athena de la IGU (no la versión 
de KDE, GTK+ o Win32), no dispondrá de una serie de recursos. Debería usar
la clase de Vim «Vim» cuando define esto. Son como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Resource name	Meaning		~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    Nombre del recurso	Significado		~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    reverseVideo	Boolean: should reverse video be used?
    background		Color of background.
    foreground		Color of normal text.
    scrollBackground	Color of trough portion of scrollbars.
    scrollForeground	Color of slider and arrow portions of scrollbars.
    menuBackground	Color of menu backgrounds.
    menuForeground	Color of menu foregrounds.
    tooltipForeground	Color of tooltip and balloon foreground.
    tooltipBackground	Color of tooltip and balloon background.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    reverseVideo	Boolean: ¿Se debe usar el vídeo inverso?
    background		Color del fondo.
    foreground		Color del texto normal.
    scrollBackground	Color de la porción pilón de las barras de desplazamiento.
    scrollForeground	Color de la barra y las porciones de flecha de las barras
		                desplazamiento.
    menuBackground	Color de fondo del menú.
    menuForeground	Color de primer plano del menú.
    tooltipForeground	Color de primer plano de las sugerencias y de los globos.
    tooltipBackground	Color de fondo de las sugerencias y de los globos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui.txt*       For Vim version 7.2.  Last change: 2008 Jun 14</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui.txt*	Para Vim version 7.2.  Último cambio: 2008 Jun 14</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Starting the GUI		|gui-start|
2. Scrollbars			|gui-scrollbars|
3. Mouse Control		|gui-mouse|
4. Making GUI Selections	|gui-selections|
5. Menus			|menus|
6. Extras			|gui-extras|
7. Shell Commands		|gui-shell|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Iniciar la GUI		|gui-start|
2. Barras de desplazamiento	|gui-scrollbars|
3. Control del ratón		|gui-mouse|
4. Seleccionar en la GUI	|gui-selections|
5. Menús		 	|menus|
6. Extras			|gui-extras|
7. Órdenes de consola		|gui-shell|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other GUI documentation:
|gui_x11.txt|	For specific items of the X11 GUI.
|gui_w32.txt|	For specific items of the Win32 GUI.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más documentación de la GUI:
|gui_x11.txt|	Para elementos específicos de la GUI bajo X11.
|gui_w32.txt|	Para elementos específicos de la GUI bajo Win32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================
1. Starting the GUI				*gui-start* *E229* *E233*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================
1. Iniciar la GUI				*gui-start* *E229* *E233*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you must make sure you actually have a version of Vim with the GUI code
included.  You can check this with the ":version" command, it says "with xxx
GUI", where "xxx" is X11-Motif, X11-Athena, Photon, GTK, GTK2, etc., or
"MS-Windows 32 bit GUI version".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asegúrese primero de que realmente tiene una versión de Vim con el código de
la GUI integrado. Puede revisar esto con la orden :version, el cual
devuelve
«con GUI xxx», donde «xxx» puede ser X11-Motif, X11-Athena, Photon, GTK, GTK2,
etc... o «versión GUI MS-Windows 32 bit».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to start the GUI depends on the system used.  Mostly you can run the
GUI version of Vim with:
    gvim [options] [files...]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como iniciar la interfaz gráfica depende del sistema que se usa.
Generalmente, puede iniciar la versión GUI de Vim con:
    gvim [opciones] [archivos...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The X11 version of Vim can run both in GUI and in non-GUI mode.  See
|gui-x11-start|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión X11 de Vim puede ejecutarse en modo gráfico o no. Véase
|gui-x11-start|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>					*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
The gvimrc file is where GUI-specific startup commands should be placed.  It
is always sourced after the |vimrc| file.  If you have one then the $MYGVIMRC
environment variable has its name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
El archivo gvimrc es donde debe escribir las órdenes de inicio específicos de
la GUI.
Siempre se lee después del archivo |vimrc|. Si tiene uno, la variable
de entorno $MYGVIMRC llevará su tal nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this happens AFTER the normal Vim initializations, like reading your
.vimrc file.  See |initialization|.
But the GUI window is only opened after all the initializations have been
carried out.  If you want some commands to be executed just after opening the
GUI window, use the |GUIEnter| autocommand event.  Example: &gt;
	:autocmd GUIEnter * winpos 100 50</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo esto ocurre despues de las órdenes de inicio de Vim, como si
leyese el archivo «.vimrc». Véase |initialization|.
La ventana de la interfaz gráfica solo se abre después de llevar a cabo
todas las órdenes de inicio. Si desea que alguna orden se ejecute justo
después de abrir la ventana de la interfaz gráfica, use el evento de
autorden |GUIEvent|. Ejemplo: &gt;
	:autocmd GUIEnter * winpos 100 50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a number of options which only have meaning in the GUI version of
Vim.  These are 'guicursor', 'guifont', 'guipty' and 'guioptions'.  They are
documented in |options.txt| with all the other options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un número de opciones que solo tienen efecto en la versión GUI
de Vim. Estos son 'guicursor', 'guifont', 'guipty' y 'guioptions'.
Están documentadas en |options.txt|, junto con el resto de opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:highlight Normal guibg=grey90</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:highlight Normal guibg=grey90</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_26.txt*	For Vim version 7.3.  Last change: 2006 Apr 24
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_26.esx*	Para Vim versión 7.3. Último cambio: 24/5/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				  Repeating
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				 Repetición
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An editing task is hardly ever unstructured.  A change often needs to be made several times.  In this chapter a number of useful ways to repeat a change will be explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Rara vez, una tarea de edición carece de estructura. A menudo tiene que realizar un cambio varias veces. En este capítulo se muestran varias maneras útiles de repetir un cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|26.1|	Repeating with Visual mode
|26.2|	Add and subtract
|26.3|	Making a change in many files
|26.4|	Using Vim from a shell script
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|26.1|	Repetir en modo Visual
|26.2|	Sumar y restar
|26.3|	Realizar un cambio en varios archivos
|26.4|	Usar Vim desde un script de intérprete de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_27.txt|  Search commands and patterns
 Previous chapter: |usr_25.txt|  Editing formatted text
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_27.esx|  Órdenes y patrones de búsqueda
  Capitulo anterior: |usr_24.esx|  Editar otros archivos
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.1*	Repeating with Visual mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.1*	Repetición en modo Visual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual mode is very handy for making a change in any sequence of lines.  You
can see the highlighted text, thus you can check if the correct lines are
changed.  But making the selection takes some typing.  The "gv" command
selects the same area again.  This allows you to do another operation on the
same text.
   Suppose you have some lines where you want to change "2001" to "2002" and
"2000" to "2001":
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Visual es útil cuando desea modificar una secuencia de líneas.
Al poder ver el texto resaltado, puede revisar si las líneas a modificar
lo han sido correctamente. Pero hacer la selección conlleva teclear. La
orden «gv» selecciona la misma área otra vez. Esto le permite realizar otra
acción sobre el texto seleccionado.
   Suponga que tiene algunas líneas en las que desea cambiar «2001» a «2002»
y «2000» a «2001»:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The financial results for 2001 are better ~
	than for 2000.  The income increased by 50%, ~
	even though 2001 had more rain than 2000. ~
			2000		2001 ~
	income		45,403		66,234 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Los resultados financieros de 2001 son mejores ~
	que para el año 2000. Los ingresos aumentaron un ~
	50%, ~ 2001, más aun cuando había más lluvia que en el 2000. ~
			2000		2001~
	ingresos	45.403		66.234 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First change "2001" to "2002".  Select the lines in Visual mode, and use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero cambie «2001» a ««2002». Seleccione las líneas en modo Visual y use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:s/2001/2002/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:s/2001/2002/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use "gv" to reselect the same text.  It doesn't matter where the cursor
is.  Then use ":s/2000/2001/g" to make the second change.
   Obviously, you can repeat these changes several times.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora «gv» para seleccionar otra vez el mismo texto. No importa donde está
el cursor. Use entonces «:s/2000/2001/g» para hacer el segundo cambio.
   Obviamente, puede repetir estos cambios varias veces.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.2*	Add and subtract
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.2*	Sumar y restar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/19[0-9][0-9]\|20[0-9][0-9]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/19[0-9][0-9]\|20[0-9][0-9]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press CTRL-A.  The year will be increased by one:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora pulse Ctrl-A. El año se incrementará en uno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The financial results for 2002 are better ~
	than for 2000.  The income increased by 50%, ~
	even though 2001 had more rain than 2000. ~
			2000		2001 ~
	income		45,403		66,234 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Los resultados financieros de 2002 son mejores ~
	que para el año 2000. Los ingresos aumentaron un ~
	50%, ~ 2001, más aun cuando había más lluvia que en el 2000. ~
			2000		2001~
	ingresos	45.403		66.234 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding more than one can be done by prepending the number to CTRL-A.  Suppose you have this list:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible añadir más de uno si prefija un número a CTRL-A.
Suponga que tiene esta lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	1.  item four ~
	2.  item five ~
	3.  item six ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	1.  cuarto elemento ~
	2.  quinto elemento ~
	3.  sexto elemento ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	3 CTRL-A
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	3 CTRL-A
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "1." will change to "4.".  Again, you can use "." to repeat this on the other numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «1.» pasará a ser «4.». Otra vez, puede usar «.» para repetir la misma acción sobre otros números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	006	foo bar ~
	007	foo bar ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	006	foo bar ~
	007	foo bar ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	007	foo bar ~
	010	foo bar ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	007	foo bar ~
	010	foo bar ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7 plus one is 10? What happened here is that Vim recognized "007" as an octal number, because there is a leading zero.  This notation is often used in C programs.  If you do not want a number with leading zeros to be handled as octal, use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿7 más 1 igual a 10? Lo que ha ocurrido es que Vim reconoció 007 como un número octal, ya que hay un cero precediendo el número. Esta notación se usa a menudo en programas C. Si no desea que un número con ceros a la izquierda se considere un número octal, use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nrformats-=octal
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nrformats-=octal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.3*	Making a change in many files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.3*	Realizar un cambio en varios archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:args *.c
&lt;
This finds all C files and edits the first one.  Now you can perform a
substitution command on all these files: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:args *.c
&lt;
Esto encuentra todos los archivos C y edita el primero. Ahora puede realizar
una orden de sustitución sobre todos estos archivos: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":argdo" command takes an argument that is another command.  That command
will be executed on all files in the argument list.
   The "%s" substitute command that follows works on all lines.  It finds the
word "x_cnt" with "\&lt;x_cnt\&gt;".  The "\&lt;" and "\&gt;" are used to match the whole
word only, and not "px_cnt" or "x_cnt2".
   The flags for the substitute command include "g" to replace all occurrences
of "x_cnt" in the same line.  The "e" flag is used to avoid an error message
when "x_cnt" does not appear in the file.  Otherwise ":argdo" would abort on
the first file where "x_cnt" was not found.
   The "|" separates two commands.  The following "update" command writes the
file only if it was changed.  If no "x_cnt" was changed to "x_counter" nothing
happens.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:argdo» toma otra orden como argumento. Esta orden se ejecutará
sobre todos los archivos en la lista de argumentos.
   La orden de sustitución «%s» a continuación afecta a todas las líneas.
Busca la palabra «x_cnt» con «\&lt;x_cnt\&gt;». Los «\&lt;» y «\&gt;» se usan para
encontrar sólo la palabra completa, y no «px_cnt» o «x_cnt2».
   Las opciones para la orden de sustitución incluyen «g» para reemplazar
todas las apariciones de «x_cnt» en la misma línea. La opción «e» se emplea
para evitar un mensaje de error cuando «x_cnt» no está presente en el
archivo. En caso contrar, «:argdo» se interrumpiría en el primer archivo en
el que no se encontrase «x_cnt».
   La «|» separa dos órdenes. La orden a continuación «update» escribe en el
archivo sólo si éste cambió. Si no se cambió ningún «x_cnt» a «x_counter»
no ocurrirá nada.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also the ":windo" command, which executes its argument in all windows.  And ":bufdo" executes its argument on all buffers.  Be careful with this, because you might have more files in the buffer list than you think.  Check this with the ":buffers" command (or ":ls").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También dispone de la orden «:windo», que ejecuta su argumento en todas las ventanas. «:bufdo» ejecuta su argumento en todos los búfers. Sea cuidadoso
con esto, porque puede que tenga más archivos de los que crea en su lista
de búfers. Revise esto con la orden «:buffers» (o «:ls»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.4*	Using Vim from a shell script
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.4*	Usar Vim desde un script de intérprete de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have a lot of files in which you need to change the string
"-person-" to "Jones" and then print it.  How do you do that?  One way is to
do a lot of typing.  The other is to write a shell script to do the work.
   The Vim editor does a superb job as a screen-oriented editor when using
Normal mode commands.  For batch processing, however, Normal mode commands do
not result in clear, commented command files; so here you will use Ex mode
instead.  This mode gives you a nice command-line interface that makes it easy
to put into a batch file.  ("Ex command" is just another name for a
command-line (:) command.)
   The Ex mode commands you need are as follows: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene que cambiar la cadena «-persona-»  a «Juan» en varios
archivos, e imprimirlo después. ¿Como se hace? Una manera es teclear mucho.
La otra es escribir un script de consola para hacer la tarea.
   El editor Vim realiza un trabajo superlativo como un editor orientado a
pantalla cuando usa las órdenes de modo Normal. Para un procesamiento en
lotes, por otra parte, las órdenes de modo Normal no finalizan correctamente
como archivos claros y comentados; para ello tiene que usar el modo Ex.
Este modo ofrece una bonita interfaz de línea de órdenes que facilita su
inserción en un archivo de lotes. («Orden Ex» es sólo otro nombre para una
orden en la línea de órdenes («:»).)
   Las órdenes del modo Ex que necesita son las siguientes: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	%s/-person-/Jones/g
	write tempfile
	quit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	%s/-persona-/Juan/g
	write archivo_temporal
	quit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You put these commands in the file "change.vim".  Now to run the editor in batch mode, use this shell script: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga estas órdenes en el archivo «change.vim». Para ejecutar el editor en modo de lotes, ese este script de consola: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	for file in *.txt; do
	  vim -e -s $file &lt; change.vim
	  lpr -r tempfile
	done
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	for file in *.txt; do
	  vim -e -s $file &lt; change.vim
	  lpr -r archivo_temporal
	done
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The for-done loop is a shell construct to repeat the two lines in between,
while the $file variable is set to a different file name each time.
   The second line runs the Vim editor in Ex mode (-e argument) on the file
$file and reads commands from the file "change.vim".  The -s argument tells
Vim to operate in silent mode.  In other words, do not keep outputting the
:prompt, or any other prompt for that matter.
   The "lpr -r tempfile" command prints the resulting "tempfile" and deletes
it (that's what the -r argument does).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El bucle for-done es una construcción de consola para repetir las dos
líneas entre ellas, mientras que la variable $file es definida con un nombre
diferente cada vez.
   La segunda línea inicia Vim en modo Ex (argumento «-e») en el archivo
$file y lee las órdenes del archivo «change.vim». El argumento «-s» le dice
a Vim que opere en modo silencioso. En otras palabras, no mostrar «:prompt»
(cuadro de diálogo interactivo), o cualquier otro diálogo.
   La orden «lpr -r archivo_temporal» muestra el «archivo_temporal»
resultante y lo elimina (esto es lo que hace el argumento «-r»).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can read text on standard input.  Since the normal way is to read commands there, you must tell Vim to read text instead.  This is done by passing the "-" argument in place of a file.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede leer texto desde la entrada estándar. Debido a que esta es la manera normal de leer órdenes, tendrá que decirle a Vim que lea texto. Esto se hace introduciendo el argumento «-» en lugar de un archivo. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ls | vim -
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ls | vim -
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to edit the output of the "ls" command, without first saving
the text in a file.
   If you use the standard input to read text from, you can use the "-S"
argument to read a script: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite editar la salida de la orden «ls», sin guardar primero el texto
en un archivo.
   Si usa la entrada estándar para leer texto, puede usar el argumento «-S»
para leer un script: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	producer | vim -S change.vim -
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	producer | vim -S change.vim -
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -s script file.txt ...
&lt;
	Note:
	"-s" has a different meaning when it is used without "-e".  Here it
	means to source the "script" as Normal mode commands.  When used with
	"-e" it means to be silent, and doesn't use the next argument as a
	file name.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -s script file.txt ...
&lt;
	Nota:
	«-s» tiene un significado diferente cuando se usa sin «-e». Aquí
	significa que tiene que cargar el script como si fueran órdenes de
	modo Normal. «-e» significa modo silencioso, y no usa el siguiente
	argumento como un nombre de archivo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands in "script" are executed like you typed them.  Don't forget that
a line break is interpreted as pressing &lt;Enter&gt;.  In Normal mode that moves
the cursor to the next line.
   To create the script you can edit the script file and type the commands.
You need to imagine what the result would be, which can be a bit difficult.
Another way is to record the commands while you perform them manually.  This
is how you do that: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes en «script» se ejecutan como los introdujo. No olvide que un 
salto de línea se interpreta como &lt;Intro&gt;. En modo Normal, desplaza el cursor
a la siguiente línea.
   Para crear el script, puede editar el archivo de script y teclear las
órdenes. Necesita imaginar el resultado final, lo cual es un poco difícil.
Otra manera es grabar las órdenes al ejecutarlas manualmente.
Así es como se hace: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -w script file.txt ...
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -w script file.txt ...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_01.txt*	For Vim version 7.3.  Last change: 2008 May 07
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_01.esx*	Para Vim versión 7.3.  Último cambio: 7/6/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      About the manuals
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			    Acerca de los manuales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter introduces the manuals available with Vim.  Read this to know the conditions under which the commands are explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo le introduce a los manuales disponibles con Vim. Lea esto para conocer las condiciones bajo las cuales se explican las órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|01.1|	Two manuals
|01.2|	Vim installed
|01.3|	Using the Vim tutor
|01.4|	Copyright
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|01.1|	Dos manuales
|01.2|	Vim instalado
|01.3|	Usar el tutor de Vim
|01.4|	Copyright
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_02.esx|  Primeros pasos en Vim
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.1*	Two manuals
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.1*	Dos manuales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. The User manual
   Task oriented explanations, from simple to complex.  Reads from start to
   end like a book.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. El manual de usuario
   Explicaciones orientadas a tareas, de las simples a las más complejas.
   Se puede leer de principio a fin, como un libro.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. The Reference manual
   Precise description of how everything in Vim works.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. El manual de referencia
   Una precisa descripción del funcionamiento de cada elemento dentro
   de Vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text contains hyperlinks between the two parts, allowing you to quickly jump between the description of an editing task and a precise explanation of the commands and options used for it.  Use these two commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto contiene hiperenlaces entre las dos partes, lo cual le permite saltar rápidamente de la descripción de una tarea de edición a una precisa explicación de las órdenes y opciones que se emplean. Use estas dos órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Press  CTRL-]  to jump to a subject under the cursor.
	Press  CTRL-O  to jump back (repeat to go further back).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Pulse «CTRL-]» para saltar al tema bajo el cursor.
	Pulse «CTRL-O» para saltar atrás (repita para volver más allá de ese
	punto).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many links are in vertical bars, like this: |bars|.  An option name, like 'number', a command in double quotes like ":write" and any other word can also be used as a link.  Try it out: Move the cursor to CTRL-] and press CTRL-] on it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay varios enlaces entre barras verticales, como este: |bars|. También puede usar como enlace un nombre de opción, como 'number', una orden entrecomillada, como «:write», o cualquier otra palabra. Pruebelo: mueva el cursor a «CTRL-]» y pulse «CTRL-]» sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.2*	Vim installed
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.2*	Vim instalado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unix: &gt;
	:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc
MS-DOS, MS-Windows, OS/2: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc
Amiga: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Unix: &gt;
	:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc
MS-DOS, MS-Windows, OS/2: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc
Amiga: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you start Vim now, the 'compatible' option should be off.  You can check it with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si inicia ahora Vim, la opción 'compatible' debería estar desactivada. Puede asegurarse con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set compatible?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set compatible?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it responds with "nocompatible" you are doing well.  If the response is "compatible" you are in trouble.  You will have to find out why the option is still set.  Perhaps the file you wrote above is not found.  Use this command to find out: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si devuelve "nocompatible", es que todo va bien. Si la respuesta es «compatible», tiene un problema. Tendrá que encontrar porqué esta opción está aún definida. Puede que no se encontrase el archivo que copió antes.  Use esta orden para ver el problema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:scriptnames
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:scriptnames
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your file is not in the list, check its location and name.  If it is in the list, there must be some other place where the 'compatible' option is switched back on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su archivo no se encuentra en la lista, revise su nombre y ubicación. Si está en la lista, debe haber algún otro sitio en el que se reactiva la opción 'compatible'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	This manual is about using Vim in the normal way.  There is an
	alternative called "evim" (easy Vim).  This is still Vim, but used in
	a way that resembles a click-and-type editor like Notepad.  It always
	stays in Insert mode, thus it feels very different.  It is not
	explained in the user manual, since it should be mostly self
	explanatory.  See |evim-keys| for details.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Este manual trata acerca del uso de Vim de la manera normal. Existe una
	alternativa llamada «evim» (easy Vim). Sigue siendo Vim, pero se usa de
	una manera parecida a un editor como Notepad. Permanece siempre
	en el modo Insertar, y por ello parece muy distinto. No se explica
	en el manual de usuario, ya que es bastante sencillo.
	Véase |evim-keys| para más detalles.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.3*	Using the Vim tutor				*tutor* *vimtutor*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.3*	Usar el tutor de Vim				*tutor* *vimtutor*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of reading the text (boring!) you can use the vimtutor to learn your first Vim commands.  This is a 30 minute tutorial that teaches the most basic Vim functionality hands-on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de leer el texto (¡aburre!), puede usar vimtutor para aprender sus primeras órdenes con Vim. Éste es un tutorial de treinta minutos que enseña las funcionalidades básicas de Vim a través de la práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix, if Vim has been properly installed, you can start it from the shell:
&gt;
	vimtutor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, si Vim se instaló adecuadamente, puede iniciar Vim desde la
consola:
&gt;
	vimtutor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-Windows you can find it in the Program/Vim menu.  Or execute vimtutor.bat in the $VIMRUNTIME directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-Windows, lo encontrará en el menú Programas/Vim. O puede ejecutar «vimtutor.bat» en el directorio $VIMRUNTIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make a copy of the tutor file, so that you can edit it without
the risk of damaging the original.
   There are a few translated versions of the tutor.  To find out if yours is
available, use the two-letter language code.  For French: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto crea una copia del archivo del tutor, para que así pueda editarlo sin
peligro de dañar el original.
   Existen unas cuantas versiones traducidas del tutor. Para ver si el suyo
está disponible, use el código de idioma de dos letras. Para el francés: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vimtutor fr
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vimtutor fr
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	@VIM:vimtutor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	@VIM:vimtutor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Copy the tutor file.  You can do this with Vim (it knows where to find it):
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w! TUTORCOPY' -c 'q'
&lt;
   This will write the file "TUTORCOPY" in the current directory.  To use a
translated version of the tutor, append the two-letter language code to the
filename.  For French:
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w! TUTORCOPY' -c 'q'
&lt;
2. Edit the copied file with Vim:
&gt;
	vim -u NONE -c "set nocp" TUTORCOPY
&lt;
   The extra arguments make sure Vim is started in a good mood.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Copie el archivo del tutor. Puede hacer esto con Vim (sabe donde
encontrarlo):
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w! TUTORCOPY' -c 'q'
&lt;
   Esto copia el archivo «TUTORCOPY» al directorio actual.  Para usar una
versión traducida del tutor, afije el código de idioma al nombre del
archivo. Para francés:
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w! TUTORCOPY' -c 'q'
&lt;
2. Edite la copia del archivo con Vim:
&gt;
	vim -u NONE -c "set nocp" TUTORCOPY
&lt;
   Los argumentos extra se aseguran de que Vim se inicie adecuadamente:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3. Delete the copied file when you are finished with it:
&gt;
	del TUTORCOPY
&lt;
==============================================================================
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3. Borrar el archivo copiado cuando haya acabado con él:
&gt;
	del TUTORCOPY
==============================================================================
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.4*	Copyright					*manual-copyright*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.4*	Copyright					*manual-copyright*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim user manual and reference manual are Copyright (c) 1988-2003 by Bram
Moolenaar.  This material may be distributed only subject to the terms and
conditions set forth in the Open Publication License, v1.0 or later.  The
latest version is presently available at:
	     http://www.opencontent.org/openpub/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de usuario y el manual de referencia están bajo el Copyright (c)
1988-2003 por Bram Moolenaar. Este material se distribuirá sólo bajo estos
términos de licencia y condiciones expuestas en la Open Publication License,
versión 1.0 o posterior. La versión más actual está ahora disponible en:
	     http://www.opencontent.org/openpub/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>People who contribute to the manuals must agree with the above copyright
notice.
							*frombook*
Parts of the user manual come from the book "Vi IMproved - Vim" by Steve
Oualline (published by New Riders Publishing, ISBN: 0735710015).  The Open
Publication License applies to this book.  Only selected parts are included
and these have been modified (e.g., by removing the pictures, updating the
text for Vim 6.0 and later, fixing mistakes).  The omission of the |frombook|
tag does not mean that the text does not come from the book.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las personas que contribuyan al manual también tienen que aceptar el
copyright expuesto anteriormente.
							*frombook*
Hay partes del manual de usuario que proceden del libro «Vi IMproved - Vim»,
por Steve Oualline (publicado por New Riders Publishing, ISBN: 0735710015).
La Open Publication License también cubre a este libro.
Sólo se incluyen partes seleccionadas, y estas se han modificado (p. ej. se
eliminaron las fotos, se actualizó el texto para Vim 6.0 y posteriores,
corrección de errata). La omisión de la etiqueta |frombook| no significa
que el texto no proceda del libro.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many thanks to Steve Oualline and New Riders for creating this book and publishing it under the OPL! It has been a great help while writing the user manual.  Not only by providing literal text, but also by setting the tone and style.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Muchas gracias a Steve Oualline y a New Riders por crear este libro, y publicarlo bajo la licencia OPL! Ha servido de gran ayuda a la hora de escribir este manual. No sólo por el texto literal, sino también al definir el tono y estilo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you make money through selling the manuals, you are strongly encouraged to donate part of the profit to help AIDS victims in Uganda.  See |iccf|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si obtiene beneficios mediante la venta de los manuales, le animamos a que done parte de los beneficios para ayudar a las victimas del SIDA en Uganda.  Véase |iccf|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_07.txt*	For Vim version 7.3.  Last change: 2006 Apr 24
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_07.esx*	Para Vim version 7.3.  Último cambio: 24/5/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			  Editing more than one file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			 Editar más de un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No matter how many files you have, you can edit them without leaving Vim.  Define a list of files to work on and jump from one to the other.  Copy text from one file and put it in another one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa cuántos archivos tenga, puede editarlos todos sin salir de Vim.  Defina una lista de archivos de trabajo y pase de uno a otro. Copie texto de un archivo a otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|07.1|	Edit another file
|07.2|	A list of files
|07.3|	Jumping from file to file
|07.4|	Backup files
|07.5|	Copy text between files
|07.6|	Viewing a file
|07.7|	Changing the file name
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|07.1|	Editar otro archivo
|07.2|	Una lista de archivos
|07.3|	Pasar de archivo a archivo
|07.4|	Copias de seguridad
|07.5|	Copiar texto entre archivos
|07.6|	Ver un archivo
|07.7|	Cambiar el nombre de archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_08.txt|  Splitting windows
 Previous chapter: |usr_06.txt|  Using syntax highlighting
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_08.esx|  Dividir en ventanas
  Capítulo anterior: |usr_06.esx|  Uso del coloreado de sintaxis
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.1*	Edit another file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.1*	Editar otro archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit foo.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit foo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any file name instead of "foo.txt".  Vim will close the current file and open the new one.  If the current file has unsaved changes, however, Vim displays an error message and does not open the new file:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar cualquier nombre de archivo en lugar de «foo.txt». Vim cerrará el archivo actual y abrirá uno nuevo. Sin embargo, si el archivo actual tiene cambios no guardados, Vim mostrará un error y no abrirá el archivo nuevo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	Vim puts an error ID at the start of each error message.  If you do
	not understand the message or what caused it, look in the help system
	for this ID.  In this case: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Vim coloca una ID de error al comienzo de cada mensaje de error.  Si
	no entiende el mensaje o su causa, puedes buscar ayuda para esta ID.
	En este caso: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		:help E37
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		:help E37
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you have a number of alternatives.  You can write the file using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este punto, dispone de una serie de alternativas. Puede escribir el archivo usando esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit! foo.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit! foo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:hide edit foo.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:hide edit foo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text with changes is still there, but you can't see it.  This is further explained in section |22.4|: The buffer list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto con los cambios está todavía aquí, pero no lo puede ver. Esto se explica con más detalle en la sección |22.4|: La lista de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.2*	A list of files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.2*	Una lista de archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start Vim to edit a sequence of files.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar Vim para editar una secuencia de archivos. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim one.c two.c three.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim uno.c dos.c tres.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command starts Vim and tells it that you will be editing three files.  Vim displays just the first file.  After you have done your thing in this file, to edit the next file you use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inicia Vim y le dice que va a editar tres archivos. Vim muestra solamente el primero. Tras haber terminado con el primero, puede editar el siguiente con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:next
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:next
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have unsaved changes in the current file, you will get an error message and the ":next" will not work.  This is the same problem as with ":edit" mentioned in the previous section.  To abandon the changes: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene cambios sin guardar en el archivo actual, obtendrá un mensaje de error y «:next» no funcionará. Este es el mismo problema mencionado con «:edit» en la sección anterior. Para abandonar los cambios: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:next!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:next!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But mostly you want to save the changes and move on to the next file.  There is a special command for this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero habitualmente querrá guardar los cambios e ir al siguiente archivo.  Hay una orden especial para esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wnext
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wnext
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write
	:next
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write
	:next
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see which file in the argument list you are editing, look in the window
title.  It should show something like "(2 of 3)".  This means you are editing
the second file out of three files.
   If you want to see the list of files, use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver qué archivo de la lista de argumentos está editando, mire en el
título de la ventana. Debería mostrar algo como «(2 de 3)». Esto significa
que está editando un segundo archivo de una lista de tres.
   Si quieres ver la lista de archivos, use esta orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:args
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:args
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is short for "arguments".  The output might look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la abreviatura de «argumentos». La salida será algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	one.c [two.c] three.c ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	uno.c [dos.c] tres.c ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the files you started Vim with.  The one you are currently editing, "two.c", is in square brackets.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos son los archivos con los que ha iniciado Vim. El que está editando actualmente, «dos.c», se encuentra entre corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:previous
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:previous
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is just like the ":next" command, except that it moves in the other direction.  Again, there is a shortcut command for when you want to write the file first: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es justo como la orden «:next», excepto que va en la otra dirección.  Una vez más, existe una orden para cuando quiera escribir el archivo primero: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:wprevious
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:wprevious
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:last
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:last
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:first
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:first
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a count for ":next" and ":previous".  To skip two files forward: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar un multiplicador para «:next» y «:previous». Para saltar dos archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:2next
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:2next
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When moving around the files and making changes, you have to remember to use ":write".  Otherwise you will get an error message.  If you are sure you always want to write modified files, you can tell Vim to automatically write them: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se mueva por los archivos y haga cambios, tiene que recordar usar «:write». En caso contrario, obtendrá mensajes de error. Si está seguro de que siempre va a escribir los archivos modificados, puede decirle a Vim que los escriba automáticamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set autowrite
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set autowrite
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set noautowrite
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set noautowrite
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can redefine the list of files without the need to exit Vim and start it again.  Use this command to edit three other files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede redefinir la lista de archivos sin la necesidad de salir de Vim y arrancarlo de nuevo. Emplee esta orden para editar otros tres archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:args five.c six.c seven.h
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:args cinco.c seis.c siete.h
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:args *.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:args *.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will take you to the first file in the list.  Again, if the current file has changes, you can either write the file first, or use ":args!" (with ! added) to abandon the changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le llevará al primer archivo en la lista. De nuevo, si el archivo actual cambia, puede tanto guardar el archivo antes como usar «:args!» (con el ! añadido) para abandonar los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DID YOU EDIT THE LAST FILE?
							*arglist-quit*
When you use a list of files, Vim assumes you want to edit them all.  To
protect you from exiting too early, you will get this error when you didn't
edit the last file in the list yet:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿HA EDITADO EL HASTA EL ÚLTIMO ARCHIVO?
							*arglist-quit*
Cuando usa una lista de archivos, Vim asume que quiere editarlos todos.
Para evitar cerrar antes de tiempo, obtendrá un error cuando no haya
editado el último archivo en la lista e intentes salir.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E173: 46 more files to edit ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E173: 46 more files to edit ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really want to exit, just do it again.  Then it will work (but not when you did other commands in between).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente desea salir, simplemente inténtelo de nuevo. Entonces funcionará (pero no si ejecuta otras órdenes durante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.3*	Jumping from file to file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.3*	Pasar de un archivo a otro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To quickly jump between two files, press CTRL-^ (on English-US keyboards the ^ is above the 6 key).  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar rápidamente entre dos archivos, pulse CTRL-^ (en teclados Inglés-EEUU el ^ se encuentra encima de la tecla 6). Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:args one.c two.c three.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:args uno.c dos.c tres.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you are in two.c.  Now use CTRL-^ to go back to one.c.  Another CTRL-^ and you are back in two.c.  Another CTRL-^ and you are in one.c again.  If you now do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora está en two.c. Use CTRL-^ para volver a uno.c. Use CTRL-^ otra vez y estará de vuelta en dos.c. Otro CTRL-^ y estará en uno.c de nuevo. Si ahora hace: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are in three.c.  Notice that the CTRL-^ command does not change the idea of where you are in the list of files.  Only commands like ":next" and ":previous" do that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Está en tres.c. Observe que la orden CTRL-^ no cambia la idea de dónde está en la lista de archivos. Sólo órdenes como «:next» y «:previous» lo hacen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file you were previously editing is called the "alternate" file.  When you just started Vim CTRL-^ will not work, since there isn't a previous file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo que haya estado editando anteriormente se llama el archivo «alterno». Hasta que no haya un archivo anterior, CTRL-^ no funcionará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	`"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	`"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This takes you to the position where the cursor was when you left the file.  Another mark that is remembered is the position where you made the last change: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le lleva a la posición en la que estaba el cursor cuando salió del archivo. Otra marca que se recuerda es la posición donde hizo el último cambio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	`.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you are editing the file "one.txt".  Somewhere halfway the file you use "x" to delete a character.  Then you go to the last line with "G" and write the file with ":w".  You edit several other files, and then use ":edit one.txt" to come back to "one.txt".  If you now use `" Vim jumps to the last line of the file.  Using `. takes you to the position where you deleted the character.  Even when you move around in the file `" and `. will take you to the remembered position.  At least until you make another change or leave the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editando el archivo «uno». En algún lugar a mitad de camino en el archivo, use «x» para eliminar un carácter. Vaya ahora a la última línea con «G» y escriba el archivo con «:w». Edite otros archivos y use «:edit uno.txt» para volver a «uno.txt». Si ahora usa `", Vim saltará a la última línea del archivo. Usar `. le llevará a la posición donde eliminó el carácter. Incluso cuando se mueva por el archivo, `" y `. le llevará a la posición recordada. Al menos hasta que realice otro cambio o salga del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	50%mF
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	50%mF
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now edit the file "bar.txt" and place the B mark (B for bar) at its last line:
&gt;
	GmB
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ahora el archivo «bar.txt» y coloque el marcador B en su última línea:
&gt;
	GmB
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the "'F" command to jump back to halfway foo.txt.  Or edit yet another file, type "'B" and you are at the end of bar.txt again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar la orden «'F» para saltar al punto marcado de foo.txt. O edite otro archivo, escriba «'B» y estará en el final de bar.txt de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file marks are remembered until they are placed somewhere else.  Thus you
can place the mark, do hours of editing and still be able to jump back to that
mark.
   It's often useful to think of a simple connection between the mark letter
and where it is placed.  For example, use the H mark in a header file, M in
a Makefile and C in a C code file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas marcas de archivo se recordarán hasta que se coloquen en algún
otro lugar. Así podrás colocar los marcadores, trabajar durante horas y aún
tendrá la posibilidad de volver al punto marcado.
   Es útil pensar en una conexión sencilla entre la letra del marcador y el
lugar donde se coloca. Por ejemplo, use la letra H para un archivo de
cabecera (*.h), M para un Makefile y C para código C.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:marks M
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:marks M
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:marks MCP
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:marks MCP
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.4*	Backup files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.4*	Copias de seguridad
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually Vim does not produce a backup file.  If you want to have one, all you need to do is execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, Vim no produce copias de seguridad. Si desea que lo haga,lo único que tiene que hacer es ejecutar la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set backup
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set backup
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the backup file is the original file with a  ~  added to the end.
If your file is named data.txt, for example, the backup file name is
data.txt~.
   If you do not like the fact that the backup files end with ~, you can
change the extension: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del archivo de seguridad es el original con un ~ añadido al
final.
Si su archivo se llama datos.txt, por ejemplo, el archivo de seguridad será
datos.txt~.
   Si no le gusta el hecho de que las copias de seguridad terminen con ~,
puedes cambiar la extensión: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set backupext=.bak
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set backupext=.bak
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will use data.txt.bak instead of data.txt~.
   Another option that matters here is 'backupdir'.  It specifies where the
backup file is written.  The default, to write the backup in the same
directory as the original file, will mostly be the right thing.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que Vim use datos.txt.bak en lugar de datos.txt~.
   Otra opción que resulta importante aquí es 'backupdir'. Especifica dónde
se guardará el archivo de seguridad. La opción por omisión, escribir la
copia de seguridad en el mismo directorio, es habitualmente la mejor.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	When the 'backup' option isn't set but the 'writebackup' is, Vim will
	still create a backup file.  However, it is deleted as soon as writing
	the file was completed successfully.  This functions as a safety
	against losing your original file when writing fails in some way (disk
	full is the most common cause; being hit by lightning might be
	another, although less common).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Cuando la opción 'backup' no está activada pero 'writebackup' lo está,
	Vim creará igualmente la copia de seguridad. Sin embargo, se
	eliminará tan pronto como se escriba el archivo con éxito. Esto
	funciona como seguridad ante la pérdida de su archivo original cuando
	la escritura falla por algún motivo (un disco lleno es el más habitual,
	un rayo puede ser otra causa aunque menos común).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are editing source files, you might want to keep the file before you
make any changes.  But the backup file will be overwritten each time you write
the file.  Thus it only contains the previous version, not the first one.
   To make Vim keep the original file, set the 'patchmode' option.  This
specifies the extension used for the first backup of a changed file.  Usually
you would do this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está editando archivos fuente, quizá desee mantener el archivo antes de
hacer ningún cambio. Pero la copia de seguridad se sobreescribirá cada vez que
escriba el archivo. Así sólo contendrá la versión previa y no la original.
   Para hacer que Vim mantenga el archivo original, activa la opción
'patchmode'. Esto especifica la extensión usada para la primera copia de
seguridad de un archivo modificado. Habitualmente harás esto: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set patchmode=.orig
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set patchmode=.orig
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now edit the file data.txt for the first time, make changes and write
the file, Vim will keep a copy of the unchanged file under the name
"data.txt.orig".
   If you make further changes to the file, Vim will notice that
"data.txt.orig" already exists and leave it alone.  Further backup files will
then be called "data.txt~" (or whatever you specified with 'backupext').
   If you leave 'patchmode' empty (that is the default), the original file
will not be kept.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite el archivo datos.txt por primera vez, haga cambios y guarde el
archivo, Vim mantendrá una copia del archivo sin cambios bajo el nombre
«datos.txt.orig».
   Si hace más cambios, Vim notará que «datos.txt.orig» ya existe y lo dejará
en paz. El resto de copias de seguridad se llamarán «datos.txt~» (o lo que
haya especificado con 'backupext').
   Si deja 'patchmode' vacío (la opción por defecto), el archivo original no
se guardará.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.5*	Copy text between files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.5*	Copiar texto entre archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit thisfile
	/This
	vjjjj$y
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit estearchivo
	/Este
	vjjjj$y
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now edit the file you want to put the text in.  Move the cursor to the
character where you want the text to appear after.  Use "p" to put the text
there. &gt;
	:edit otherfile
	/There
	p
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ahora el archivo donde desea poner el texto. Mueva el cursor al
caracter donde quiera que el texto se coloque a continuación. Use «p» para
poner el texto allí. &gt;
	:edit otroarchivo
	/Allí
	p
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course you can use many other commands to yank the text.  For example, to
select whole lines start Visual mode with "V".  Or use CTRL-V to select a
rectangular block.  Or use "Y" to yank a single line, "yaw" to yank-a-word,
etc.
   The "p" command puts the text after the cursor.  Use "P" to put the text
before the cursor.  Notice that Vim remembers if you yanked a whole line or a
block, and puts it back that way.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Naturalmente, podrás usar cualquiera otra orden de copia. Por ejemplo, para
seleccionar líneas completas, inicie el modo Visual con «V». O pulse CTRL-V
para seleccionar bloques rectangulares. Puede usar «Y» para simplemente
copiar una línea, «yaw» para pegar una palabra (yank-a-word).
   La orden «p» pone el texto después del cursor. Use «P» para pegarlo
antes del cursor. Repare en el hecho de que Vim recuerda si ha copiado una
línea completa o un bloque y lo pondrá del mismo modo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to copy several pieces of text from one file to another, having
to switch between the files and writing the target file takes a lot of time.
To avoid this, copy each piece of text to its own register.
   A register is a place where Vim stores text.  Here we will use the
registers named a to z (later you will find out there are others).  Let's copy
a sentence to the f register (f for First): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando quiera copiar diversas porciones de un texto de un archivo a otro,
tener que cambiar entre los archivos y guardarlos lleva mucho tiempo. Para
evitar esto, copie cada porción en un registro independiente.
   Un registro es un lugar donde Vim guarda texto. Aquí usaremos los
registros nombrados desde la «a» a la «z» (más tarde se percatará de que hay
otros). Vamos a copiar una frase en el registro f: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"fyas
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"fyas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "yas" command yanks a sentence like before.  It's the "f that tells Vim
the text should be place in the f register.  This must come just before the
yank command.
   Now yank three whole lines to the l register (l for line): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «yas» copia una frase. Es el «"f» el que le dice a Vim que el texto
se debe situar en el registro f. Esto debe aparecer justo antes de la orden
copiar.
   Ahora copie tres líneas completas en el registro l: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"l3Y
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"l3Y
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The count could be before the "l just as well.  To yank a block of text to the b (for block) register: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El multiplicador puede situarse también antes del «"l».  Para copiar un bloque de texto al registro b: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-Vjjww"by
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-Vjjww"by
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the register specification "b is just before the "y" command.
This is required.  If you would have put it before the "w" command, it would
not have worked.
   Now you have three pieces of text in the f, l and b registers.  Edit
another file, move around and place the text where you want it: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la especificación del registro «"b» se encuentra justo antes
de la orden «y». Esto es imprescindible. Si lo hubierse puesto antes de la
orden «w», no habría funcionado.
   Ahora tiene tres porciones de texto en los registros f, l, y b. Edite
otro archivo, desplácese por el texto y allá donde desee: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"fp
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"fp
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you delete text, you can also specify a register.  Use this to move several pieces of text around.  For example, to delete-a-word and write it in the w register: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimine texto, también puedes especificar un registro. Use esto para mover varias porciones de texto de un lado para otro. Por ejemplo, para eliminar una palabra y ponerla en el registro w (delete-a-word): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"wdaw
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"wdaw
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:write &gt;&gt; logfile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:write &gt;&gt; archivo_registro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.6*	Viewing a file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.6*	Ver un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you only want to see what a file contains, without the intention to
ever write it back.  There is the risk that you type ":w" without thinking and
overwrite the original file anyway.  To avoid this, edit the file read-only.
   To start Vim in readonly mode, use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces sólo quiere ver qué contiene un archivo, sin la intención de
guardar ningún cambio. Existe el riesgo de que escribas «:w» sin pensar y
sobreescriba el archivo original. Para evitar esto, edite el archivo como
sólo lectura.
   Para ejecutar Vim en modo sólo lectura, haga lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -R file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -R archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	view file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	view archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now editing "file" in read-only mode.  When you try using ":w" you
will get an error message and the file won't be written.
   When you try to make a change to the file Vim will give you a warning:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora está editando «archivo» en modo sólo lectura. Cuando pruebe a usar
«:w» se dará cuenta de que aparecerá un mensaje de error y no se guardará.
   Cuando intente hacer un cambio al archivo, Vim le dará un aviso:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	W10: Warning: Changing a readonly file ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	W10: Advertencia: cambiando un fichero de solo lectura ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will be done though.  This allows for formatting the file, for
example, to be able to read it easily.
   If you make changes to a file and forgot that it was read-only, you can
still write it.  Add the ! to the write command to force writing.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio se realizará igualmente. Esto permite formatear el archivo, por
ejemplo, para facilitar su lectura.
   Si intenta hacer cambios a un archivo y olvidas que era de sólo lectura,
aún podrá guardarlo. Añada «!» a la orden guardar para forzar la escritura.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -M file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -M file
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every attempt to change the text will fail.  The help files are like this, for example.  If you try to make a change you get this error message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cualquier intento de cambiar el texto fallará. Los archivos de ayuda son así, por ejemplo. Si intenta cambiar algo, obtendrá el siguiente error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E21: Cannot make changes, 'modifiable' is off ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E21: No se pueden hacer cambios, «modifiable» está desactivado ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set modifiable
	:set write
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set modifiable
	:set write
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.7*	Changing the file name
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.7*	Cambiar el nombre de un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A clever way to start editing a new file is by using an existing file that contains most of what you need.  For example, you start writing a new program to move a file.  You know that you already have a program that copies a file, thus you start with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma inteligente de comenzar la edición de un archivo nuevo es usar un archivo similar de partida que contenga algo parecido. Por ejemplo, empiece a escribir un programa para filtrar archivos. Sabe que ya tiene un código que copia archivos, así que podría comenzar con él: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit copy.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit copiar.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can delete the stuff you don't need.  Now you need to save the file under a new name.  The ":saveas" command can be used for this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede eliminar lo que no necesita. A continuación tendrá que guardar el archivo bajo un nombre distinto. La orden «:saveas» es adecuado para esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:saveas move.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:saveas filtrar.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will write the file under the given name, and edit that file.  Thus the
next time you do ":write", it will write "move.c".  "copy.c" remains
unmodified.
   When you want to change the name of the file you are editing, but don't
want to write the file, you can use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim escribirá el archivo con el nuevo nombre y editará el nuevo archivo.
Así la próxima vez que haga «:write», escribirá «filtrar.c». «copiar.c» se
mantiene sin modificaciones.
   Cuando desee cambiar el nombre del archivo que está editando pero no
quiere escribirlo, puede usar el siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:file move.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:file move.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will mark the file as "not edited".  This means that Vim knows this is not the file you started editing.  When you try to write the file, you might get this message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim marcará el archivo como «no editado». Esto significa que Vim sabe que este no es el archivo que comenzó a editar. Cuando intente guardar el archivo, puede que vea el siguiente mensaje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E13: File exists (use ! to override) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E13: El fichero ya existe (use ! para sobreescribir) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_41.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_41.esx*	Para Vim versión 7.3.  Último cambio: 20/7/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Write a Vim script
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			     Escribir scripts para Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim script language is used for the startup vimrc file, syntax files, and many other things.  This chapter explains the items that can be used in a Vim script.  There are a lot of them, thus this is a long chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El lenguaje de programación de Vim se usa en el archivo de arranque vimrc, los archivos de sintaxis, y muchas otras cosas. Este capítulo presenta y explica en detalle los elementos que componen un script de Vim. Hay muchos de ellos, por lo que éste es un capítulo largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|41.1|	Introducción
|41.2|	Variables
|41.3|	Expresiones
|41.4|	Estructuras de decisión
|41.5|	Ejecución de expresiones
|41.6|	Funciones
|41.7|	Definición de funciones
|41.8|	Listas y Diccionarios
|41.9|	Excepciones
|41.10|	Observaciones
|41.11|	Escribir extensiones
|41.12|	Escribir extensiones para tipo de archivo
|41.13|	Escribir extensiones para compiladores
|41.14|	Escribir extensiones que carguen rápidamente
|41.15|	Escribir bibliotecas
|41.16|	Distribuir scripts de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_42.esx|  Añadir menús nuevos
  Capítulo anterior: |usr_40.esx|  Crear órdenes nuevas
Tabla de contenidos: |usr_toc.txt|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.1*	Introduction				*vim-script-intro* *script*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.1*	Introducción				*vim-script-intro* *script*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let i = 1
	:while i &lt; 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
&lt;
	Note:
	The ":" characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim script file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let i = 1
	:while i &lt; 5
	:  echo "cuenta es" i
	:  let i += 1
	:endwhile
&lt;
	Nota:
	En realidad en el ejemplo de arriba los caracteres «:» no son
	necesarios. Sólo es necesario su uso al escribir una orden. En los
	archivos de script de Vim es posible omitirlos. Aquí se muestran para
	evidenciar que son órdenes de la línea de órdenes, y no órdenes del
	modo Normal.
	Nota:
	Puede probar los ejemplos que se muestran aquí copiando el texto
	correspondiente, y ejecutándolo con la orden «:@"»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	cuenta es 1 ~
	cuenta es 2 ~
	cuenta es 3 ~
	cuenta es 4 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first line the ":let" command assigns a value to a variable.  The generic form is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera línea la orden «:let» le asigna un valor a una variable. La forma genérica de hacerlo es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let {variable} = {expression}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let {variable} = {expresión}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso el nombre de la variable es «i» y la expresión es simplemente un
valor, el número uno.
   La orden «:while» inicia un ciclo. La forma genérica de esta orden es: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:while {condition}
	:  {statements}
	:endwhile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:while {condicion}
	:  {instrucciones}
	:endwhile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i &lt; 5".  This
is true when the variable i is smaller than five.
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las instrucciones hasta el «:endwhile» correspondiente se ejecutan mientras
que la {condicion} se siga cumpliendo. La condición aquí es la expresión
«i &lt; 5».  Ésta es verdadera cuando la variable i es menor a cinco.
	Nota:
	Si llega a escribir un ciclo «while» que nunca termina de ejecutarse,
	puede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":echo" command prints its arguments.  In this case the string "count is" and the value of the variable i.  Since i is one, this will print:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:echo» imprime en pantalla los argumentos que se le introduzcan. En este caso son la cadena «cuenta es» y el valor de la variable i. Como i vale uno, se imprimirá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	count is 1 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	cuenta es 1 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then there is the ":let i += 1" command.  This does the same thing as ":let i = i + 1".  This adds one to the variable i and assigns the new value to the same variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego está la orden «:let i += 1». Ésta tiene el mismo efecto que «:let i = i + 1». Le añade uno a la variable i y asigna el resultado a la misma variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for i in range(1, 4)
	:  echo "count is" i
	:endfor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for i in range(1, 4)
	:  echo "cuenta es" i
	:endfor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We won't explain how |:for| and |range()| work until later.  Follow the links if you are impatient.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El funcionamiento de |:for| y |range()| se explicará después. Siga los enlaces si no desea esperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number starts
with a zero.  "017" is decimal 15.  Careful: don't put a zero before a decimal
number, it will be interpreted as an octal number!
   The ":echo" command always prints decimal numbers.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los números pueden ser decimales, hexadecimales, u octales. Un número
hexadecimal empieza con «0x» o «0X». Por ejemplo, «0x1f» es 31 en decimal. Un
número octal empieza con cero. «017» es 15 en decimal. Tenga cuidado: no ponga
ceros al comienzo de un número decimal, ¡será interpretado como un octal!
   La orden «:echo» siempre muestra los números como decimales. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo 0x7f 036
&lt;	127 30 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo 0x7f 036
&lt;	127 30 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number is made negative with a minus sign.  This also works for hexadecimal
and octal numbers.   A minus sign is also used for subtraction.  Compare this
with the previous example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se pueden obtener números negativos añadiéndoles un signo de resta. Esto funciona
también para números octales y hexadecimales. El signo menos también se usa
para la substracción. Compare lo siguiente con el ejemplo anterior: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo 0x7f -036
&lt;	97 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo 0x7f -036
&lt;	97 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>White space in an expression is ignored.  However, it's recommended to use it for separating items, to make the expression easier to read.  For example, to avoid the confusion with a negative number above, put a space between the minus sign and the following number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En las expresiones se ignoran los espacios en blanco. Sin embargo, es recomendable usarlo para separar elementos, para hacer que las expresiones sean más legibles. Por ejemplo, para evitar confundir el ejemplo anterior con un número negativo, ponga un espacio entre el signo de resta y el número que lo sigue: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo 0x7f - 036
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo 0x7f - 036
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.2*	Variables
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.2*	Variables
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A variable name consists of ASCII letters, digits and the underscore.  It cannot start with a digit.  Valid variable names are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los nombres de variables pueden consistir de las letras del código ASCII, dígitos, y el guión bajo. No pueden empezar con dígitos. Los siguientes son nombres válidos de variables:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	contador
	_aap3
	nombre_de_variable_largo_con_guion_bajo
	FuncLongitud
	LONGITUD
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«foo+bar» y «6var» no son nombres válidos.
   Estas variables son globales. Para ver un listado de las variables
definidas actualmente, use la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let s:count = 1
	:while s:count &lt; 5
	:  source other.vim
	:  let s:count += 1
	:endwhile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let s:cuenta = 1
	:while s:cuenta &lt; 5
	:  source otro.vim
	:  let s:cuenta += 1
	:endwhile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since "s:count" is local to this script, you can be sure that sourcing the "other.vim" script will not change this variable.  If "other.vim" also uses an "s:count" variable, it will be a different copy, local to that script.  More about script-local variables here: |script-variable|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que el ámbito de «s:cuenta» es local al script, puede estar seguro de que cargar el archivo «otro.vim» no hará cambios a dicha variable. Si «otro.vim» también usa una variable «s:cuenta», será una copia distinta, local al ámbito de ese script. Puede encontrar más información acerca de las variables locales a un script en |script-variable|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are more kinds of variables, see |internal-variables|.  The most often used ones are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen más clases de variables, consulte |internal-variables|. Las que se usan más frecuentemente son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	b:nombre		variable local a un búfer
	w:nombre		variable local a una ventana
	g:nombre		variable global (incluso dentro de funciones)
	v:nombre		variable predeterminada por Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables take up memory and show up in the output of the ":let" command.  To delete a variable use the ":unlet" command.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las variables que aparecen en el listado que genera la orden «:let» consumen recursos de memoria. Para eliminar una variable use la orden «:unlet». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unlet s:count
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unlet s:cuenta
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This deletes the script-local variable "s:count" to free up the memory it uses.  If you are not sure if the variable exists, and don't want an error message when it doesn't, append !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden elimina la variable «s:count», local al script actual, para liberar la memoria que ésta usa. Si no está seguro de que una variable exista, y no quiere obtener mensajes de error si no existe, añada ! a la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unlet! s:count
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unlet! s:cuenta
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a script finishes, the local variables used there will not be automatically freed.  The next time the script executes, it can still use the old value.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando la ejecución de un script termina, no se liberan automáticamente los recursos usados por sus variables locales. La próxima vez que se ejecute el script, los valores antiguos estarán disponibles. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if !exists("s:cuenta_llamadas")
	:  let s:cuenta_llamadas = 0
	:endif
	:let s:cuenta_llamadas = s:cuenta_llamadas + 1
	:echo "llamado" s:cuenta_llamadas "veces"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "exists()" function checks if a variable has already been defined.  Its argument is the name of the variable you want to check.  Not the variable itself! If you would do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función «exists()» comprueba la existencia de una variable. Recibe como argumento el nombre de la variable a comprobar. ¡No la variable como tal! Si intenta esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if !exists(s:call_count)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if !exists(s:cuenta_llamadas)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
	Note:
	Vim automatically converts a string to a number when it is looking for
	a number.  When using a string that doesn't start with a digit the
	resulting number is zero.  Thus look out for this: &gt;
		:if "true"
&lt;	The "true" will be interpreted as a zero, thus as false!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor de «s:cuenta_llamadas» se usará como el nombre de variable que
exists() revisará. Ése no es el efecto esperado.
   El símbolo de exclamación ! niega un valor. Cuando un valor es verdadero,
se vuelve falso. Cuando es falso, se vuelve verdadero. Puede leer este símbolo
como «not» (negación lógica). Así, «if !exists()» se lee como «if not
exists()».
   Vim considera como verdadero cualquier valor distinto de cero. Cero
equivale a falso.
	Nota:
	Vim convierte las cadenas de texto a números de manera automática
	cuando se espera un número. Cuando se hace esta conversión con una
	cadena que no empieza con un dígito el número resultante es cero.
	Debido a esto, tenga cuidado con instrucciones como: &gt;
		:if "verdadero"
&lt;	en este caso, la cadena «verdadero» será interpretada como un cero, ¡y
	por tanto como falso!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora sólo se han usado números como valores de variables. También es
posible usar cadenas de texto. Los tipos básicos de variables que Vim soporta
son números y cadenas. El tipo de cada variable es dinámico, y se fija cada
vez que se asigna un valor a una variable mediante «:let». Refiérase a |41.8|
para más información acerca de tipos.
   Para asignar un valor de tipo cadena a una variable, debe usar una
constante de cadena. Hay dos tipos de estas constantes. El primero es la
cadena con comillas dobles: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let name = "peter"
	:echo name
&lt;	peter ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let nombre = "pedro"
	:echo nombre
&lt;	pedro ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let name = "\"peter\""
	:echo name
&lt;	"peter" ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let nombre = "\"pedro\""
	:echo nombre
&lt;	"pedro" ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let name = '"peter"'
	:echo name
&lt;	"peter" ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let nombre = '"pedro"'
	:echo nombre
&lt;	"pedro" ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En una cadena de comillas sencillas todos los caracteres tienen solamente su
significado literal. Sólo la comilla sencilla es especial: debe usar dos
seguidas para obtener una dentro de una cadena. La barra inversa se considera
literalmente, por lo que no es posible usarla para cambiar el significado del
carácter después de ella.
   En las cadenas de comillas dobles es posible usar caracteres especiales. A
continuación algunos de los más usados:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, line break
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, backspace
	\"		"
	\\		\, backslash
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, salto de línea
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, retroceso
	\"		"
	\\		\, barra inversa
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last two are just examples.  The  "\&lt;name&gt;" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los últimos dos sólo son ejemplos. Se puede usar la forma «\&lt;nombre&gt;» para
incluir la tecla «nombre».
   Consulte |expr-quote| para ver la lista completa de elementos especiales
en una cadena de texto.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.3*	Expressions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.3*	Expresiones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una forma expresiva, pero sencilla, de manejar expresiones. Puede
leer la definición aquí: |expression-syntax|. A continuación mostraremos
algunos de los elementos más comunes.
   Los números, cadenas, y las variables mencionadas anteriormente son
expresiones por sí mismas. Así que, en donde sea que se espere una expresión,
puede usar un número, una cadena, o una variable. Otros de los elementos
comunes en una expresión son:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	$NAME		environment variable
	&amp;name		option
	@r		register
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	$NOMBRE		variable de entorno
	&amp;nombre		opción
	@r		registro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo "The value of 'tabstop' is" &amp;ts
	:echo "Your home directory is" $HOME
	:if @a &gt; 5
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo "El valor de 'tabstop' es" &amp;ts
	:echo "Su directorio personal es" $HOME
	:if @a &gt; 5
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &amp;name form can be used to save an option value, set it to a new value, do something and restore the old value.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la forma «&amp;nombre» para guardar el valor de una opción, fijarla a un nuevo valor, hacer algo, y restaurar el valor original. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let save_ic = &amp;ic
	:set noic
	:/The Start/,$delete
	:let &amp;ic = save_ic
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let ic_orig = &amp;ic
	:set noic
	:/El Principio/,$delete
	:let &amp;ic = ic_orig
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes sure the "The Start" pattern is used with the 'ignorecase' option off.  Still, it keeps the value that the user had set.  (Another way to do this would be to add "\C" to the pattern, see |/\C|.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con esto se asegura que el patrón «El Principio» se buscará con la opción 'ignorecase' desactivada. Sin embargo, se conserva y restaura el valor que el usuario definió para la opción. (Otra forma de hacer esta búsqueda es añadir «\C» al patrón, consulte |/\C|.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It becomes more interesting if we combine these basic items.  Let's start with mathematics on numbers:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las cosas se hacen más interesantes si combinamos estos elementos básicos. Empecemos con operaciones matemáticas sobre números:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	a + b		adición
	a - b		sustracción
	a * b		multiplicación
	a / b		división
	a % b		módulo (residuo)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual precedence is used.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se maneja la precendencia de operadores usual. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo 10 + 5 * 2
&lt;	20 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo 10 + 5 * 2
&lt;	20 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping is done with braces.  No surprises here.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cambiar la precendencia de las operaciones usando paréntesis. Esto no es nada nuevo.  Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo (10 + 5) * 2
&lt;	30 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo (10 + 5) * 2
&lt;	30 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings can be concatenated with ".".  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede unir cadenas usando «.». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo "foo" . "bar"
&lt;	foobar ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo "foo" . "bar"
&lt;	foobar ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the ":echo" command gets multiple arguments, it separates them with a space.  In the example the argument is a single expression, thus no space is inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando recibe varios argumentos, la orden «:echo» los muestra en pantalla separados con espacios. En el ejemplo anterior el argumento es una única expresión, por lo que no se insertan espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a ? b : c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	a ? b : c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If "a" evaluates to true "b" is used, otherwise "c" is used.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si «a» se evalúa como verdadero, la expresión corresponderá a «b», y en caso contrario a «c». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let i = 4
	:echo i &gt; 5 ? "i is big" : "i is small"
&lt;	i is small ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let i = 4
	:echo i &gt; 5 ? "i es grande" : "i es pequeño"
&lt;	i es pequeño ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	(a) ? (b) : (c)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	(a) ? (b) : (c)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.4*	Conditionals
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.4*	Estructuras de decisión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":if" commands executes the following statements, until the matching ":endif", only when a condition is met.  The generic form is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:if» ejecuta las órdenes a continuación de ella, hasta el «:endif» correspondiente, cuando se cumple la condición especificada. La forma genérica es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if {condition}
	   {statements}
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if {condicion}
	   {instrucciones}
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the ":endif".
   You can also use ":else".  The generic form for this is:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las {instrucciones} se ejecutan únicamente cuando la expresión {condicion} es
verdadera, esto es, diferente de cero. Dichas instrucciones deben ser órdenes
válidas. Si las órdenes tienen errores de sintaxis, Vim no podrá encontrar el
«:endif» correspondiente.
   También puede usar «:else». La forma genérica es:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if {condicion}
	   {instrucciones}
	:else
	   {instrucciones}
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second {statements} is only executed if the first one isn't.
   Finally, there is ":elseif":
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El segundo grupo de {instrucciones} sólo se ejecuta si el primero no lo hace.
   Finalmente, está «:elseif»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if {condicion}
	   {instrucciones}
	:elseif {condicion}
	   {instrucciones}
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden funciona como «:else» seguido de «:if», pero tiene la ventaja de no
requerir un «:endif» adicional.
   Un ejemplo útil que podría usar en su archivo vimrc es comprobar la opción
'term' y ejecutar órdenes diferentes de acuerdo a su valor: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if &amp;term == "xterm"
	:  " Do stuff for xterm
	:elseif &amp;term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if &amp;term == "xterm"
	:  " Configuración para xterm
	:elseif &amp;term == "vt100"
	:  " Configuración para la terminal vt100
	:else
	:  " Configuración para otras terminales
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already used some of them in the examples.  These are the most often used ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya hemos usado algunas de ellas en los ejemplos anteriores. A continuación listamos las más utilizadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a == b		equal to
	a != b		not equal to
	a &gt;  b		greater than
	a &gt;= b		greater than or equal to
	a &lt;  b		less than
	a &lt;= b		less than or equal to
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	a == b		igual a
	a != b		diferente de
	a &gt;  b		mayor que
	a &gt;= b		mayor o igual a
	a &lt;  b		menor que
	a &lt;= b		menor o igual a
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is one if the condition is met and zero otherwise.  An example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es uno si la condición se cumple, y cero en caso contrario. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if v:version &gt;= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if v:version &gt;= 700
	:  echo "felicitaciones"
	:else
	:  echo "¡está usando una versión vieja, actualícese!"
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los operadores lógicos funcionan con números y con cadenas de texto. Al
comparar dos cadenas, se trabaja con la diferencia matemática de las mismas.
Esto compara valores de bytes, lo que para algunos idiomas puede no entregar
resultados correctos.
   Al comparar cadenas con números, la cadena es convertida a un número antes
de hacer la comparación. Debe tener en cuenta que, cuando el contenido de una
cadena no se asemeja a un número, se usa el número cero. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if 0 == "one"
	:  echo "yes"
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if 0 == "uno"
	:  echo "sí"
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a =~ b		matches with
	a !~ b		does not match with
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	a =~ b		coincide con
	a !~ b		no coincide con
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The left item "a" is used as a string.  The right item "b" is used as a pattern, like what's used for searching.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operando de la izquierda, «a», se trata como una cadena. El operando de la derecha, «b», se trata como un patrón para una búsqueda de texto. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if str =~ " "
	:  echo "str contiene un espacio"
	:endif
	:if str !~ '\.$'
	:  echo "str no termina con punto final"
	:endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of a single-quote string for the pattern.  This is useful, because backslashes would need to be doubled in a double-quote string and patterns tend to contain many backslashes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta el uso de una cadena de comillas sencillas como patrón de búsqueda. En este caso es útil porque las barras inversas tendrían que insertarse por partida doble en una cadena de comillas dobles, y los patrones de búsqueda suelen contener muchas barras inversas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'ignorecase' option is used when comparing strings.  When you don't want that, append "#" to match case and "?" to ignore case.  Thus "==?" compares two strings to be equal while ignoring case.  And "!~#" checks if a pattern doesn't match, also checking the case of letters.  For the full table see |expr-==|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al comparar cadenas se tiene en cuenta la opción 'ignorecase'. Si no desea este comportamiento, añada un «#» para diferenciar mayúsculas de minúsculas, o «?» para ignorar dicha diferencia. Así, «==?» compara dos cadenas sin diferenciar mayúsculas de minúsculas. «!~#» revisa la no coincidencia de un patrón, teniendo en cuenta diferencias de mayúsculas y minúsculas. Puede consultar la tabla completa de operadores de comparación en |expr-==|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":while" command was already mentioned.  Two more statements can be used in between the ":while" and the ":endwhile":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya hemos mencionado la orden «:while». Hay dos instrucciones adicionales que pueden usarse entre «:while» y el «:endwhile» correspondiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:continue		Jump back to the start of the while loop; the
				loop continues.
	:break			Jump forward to the ":endwhile"; the loop is
				discontinued.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:continue		Salta hasta el inicio del ciclo «while»; el
				ciclo continúa.
	:break			Salta hasta después del «:endwhile»; provoca
				la terminación del ciclo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:while counter &lt; 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:while contador &lt; 40
	:  call hacer_algo()
	:  if opción_omitir
	:    continue
	:  endif
	:  if opción_terminado
	:    break
	:  endif
	:  sleep 50m
	:endwhile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:sleep» hace que Vim tome una pausa. El argumento «50m» especifica una duración de 50 milisegundos. Otro ejemplo es «:sleep 4», que especifica una pausa de cuatro segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.5*	Executing an expression
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.5*	Ejecución de expresiones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora, todas las órdenes mostradas han sido ejecutadas directamente por
Vim. La orden «:execute» permite ejecutar el resultado de una expresión. Ésta
es una forma poderosa de construir y ejecutar órdenes.
   Un ejemplo es saltar a una etiqueta, cuyo nombre está almacenado en una
variable: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:execute "tag " . tag_name
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:execute "tag " . nombre_etiqueta
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." is used to concatenate the string "tag " with the value of variable "tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that will be executed is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «.» se usa para concatenar la cadena «tag » con el valor de la variable «nombre_etiqueta». Si suponemos que «nombre_etiqueta» tiene el contenido «obtener_orden», entonces la orden que se ejecutará es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:tag get_cmd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:tag obtener_orden
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":execute" command can only execute colon commands.  The ":normal" command executes Normal mode commands.  However, its argument is not an expression but the literal command characters.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:execute» sólo puede ejecutar órdenes de la línea de órdenes (órdenes Ex, que empiezan con «:»). La orden «:normal» ejecuta órdenes del modo Normal. Sin embargo, su argumento no es una expresión, sino los caracteres literales de la orden. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:normal gg=G
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:normal gg=G
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se mueve hasta la primera línea y formatea todas las líneas usando el operador
«=».
   Para usar «:normal» con el resultado de una expresión, debe combinar
«:execute» con dicha orden. Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:execute "normal " . normal_commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:execute "normal " . ordenes_modo_normal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variables «ordenes_modo_normal» debe contener órdenes para el modo Normal.
   Asegúrese de que el argumento para «:normal» es una orden completa. En caso
contrario, Vim llegará al final del argumento e interrumpirá la orden. Por
ejemplo, si inicia el modo Insertar, debe salir del mismo. Lo siguiente
funciona adecuadamente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:execute "normal Inew text \&lt;Esc&gt;"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:execute "normal Itexto nuevo \&lt;Esc&gt;"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This inserts "new text " in the current line.  Notice the use of the special key "\&lt;Esc&gt;".  This avoids having to enter a real &lt;Esc&gt; character in your script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inserta «texto nuevo» en la línea actual. Observe el uso de la tecla especial «\&lt;Esc&gt;». Así se evita la necesidad de escribir un &lt;Esc&gt; real en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let optname = "path"
	:let optval = eval('&amp;' . optname)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let nomopcion = "path"
	:let valopcion = eval('&amp;' . nomopcion)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "&amp;" character is prepended to "path", thus the argument to eval() is
"&amp;path".  The result will then be the value of the 'path' option.
   The same thing can be done with: &gt;
	:exe 'let optval = &amp;' . optname
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se antepone un «&amp;» a «path», y así el argumento para eval() es «&amp;path». El
resultado será el valor de la opción 'path'.
   Puede obtener el mismo resultado con: &gt;
	:exe 'let optval = &amp;' . optname
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.6*	Using functions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.1*	Funciones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim defines many functions and provides a large amount of functionality that way.  A few examples will be given in this section.  You can find the whole list here: |functions|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim define muchas funciones y provee bastante funcionalidad a través de este mecanismo. Aquí daremos algunos ejemplos. La referencia para la lista completa se encuentra en |functions|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function is called with the ":call" command.  The parameters are passed in between braces, separated by commas.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las funciones se llaman con la orden «:call». Los parámetros se introducen entre paréntesis, separados por comas. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:call search("Date: ", "W")
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:call search("Fecha: ", "W")
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This calls the search() function, with arguments "Date: " and "W".  The search() function uses its first argument as a search pattern and the second one as flags.  The "W" flag means the search doesn't wrap around the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se invoca a la función search(), con los argumentos «Fecha: » y «W». La función search() usa su primer argumento como patrón de búsqueda y el segundo como una serie de opciones. La opción «W» hace que la búsqueda termine al alcanzar el final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function can be called in an expression.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También es posible invocar funciones en expresiones.  Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let linea = getline(".")
	:let reempl = substitute(linea, '\a', "*", "g")
	:call setline(".", reempl)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:substitute/\a/*/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:substitute/\a/*/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FUNCTIONS						*function-list*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>FUNCIONES						*function-list*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many functions.  We will mention them here, grouped by what they are used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on the function name to jump to detailed help on it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim cuenta con muchas funciones. Las mencionaremos aquí, agrupadas de acuerdo a su funcionalidad. En |functions| se encuentra una lista de ellas ordenada alfabéticamente. Puede ubicar el cursor sobre el nombre de una función y pulsar CTRL-] para ver documentación más detallada sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in a ":substitute"
	strpart()		get part of a string
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de cadenas:				*string-functions*
	nr2char()		obtiene un carácter dado su valor ASCII
	char2nr()		obtiene el número ASCII del carácter dado
	str2nr()		convierte una cadena a Número
	str2float()		convierte una cadena a Flotante
	printf()		formatea una cadena de acuerdo a elementos %
	escape()		escapa caracteres en una cadena con '\'
	shellescape()		escapa una cadena para usarse una orden de
				consola
	fnameescape()		escapa un nombre de archivo para usar en una
				orden Vim
	tr()			traduce caracteres de un conjunto a otro
	strtrans()		traduce una cadena para que se pueda imprimir
	tolower()		convierte una cadena a minúsculas
	toupper()		convierte una cadena a mayúsculas
	match()			posición en la que un patrón coincide en una
				cadena
	matchend()		posición en la que un patrón termina en una
				cadena
	matchstr()		coincidencia de un patrón en una cadena
	matchlist()		similar a matchstr() y retorna
				subcoincidencias
	stridx()		primer índice de una cadena corta dentro de
				una larga
	strridx()		último índice de una cadena corta dentro de
				una larga
	strlen()		longitud de una cadena
	substitute()		sustituye la coincidencia de un patrón con una
				cadena
	submatch()		obtiene una subcoincidencia específica en un
				«:substitute»
	strpart()		obtiene parte de una cadena
	expand()		expande palabras clave
	iconv()			convierte texto entre distintas codificaciones
	byteidx()		índice de byte de un carácter en una cadena
	repeat()		repite una cadena múltiples veces
	eval()			evalúa una cadena como expresión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de Listas:					*list-functions*
	get()			obtiene un elemento sin generar error al usar
				índices erróneos
	len()			número de elementos en una Lista
	empty()			comprueba si una Lista está vacía
	insert()		inserta un elemento en una Lista
	add()			añade un elemento a una Lista
	extend()		añade los contenidos de una Lista a otra Lista
	remove()		elimina uno o más elementos de una lista
	copy()			hace una copia superficial de una Lista
	deepcopy()		hace una copia completa de una Lista
	filter()		elimina elementos particulares de una Lista
	map()			cambia cada elemento de una Lista
	sort()			ordena una Lista
	reverse()		invierte el orden de una Lista
	split()			divide una cadena en una Lista
	join()			une los elementos de una Lista en una cadena
	range()			retorna una Lista con una secuencia de números
	string()		representación de una Lista en una cadena
	call()			invoca una función con una Lista como argumentos
	index()			índice de un valor en una Lista
	max()			valor máximo en una Lista
	min()			valor mínimo en una Lista
	count()			cuenta la cantidad de veces que un valor
				aparece en una Lista
	repeat()		repite una Lista múltiples veces
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de Diccionarios:				*dict-functions*
	get()			obtiene una entrada sin generar error al usar
				claves erróneas
	len()			número de entradas en un Diccionario
	has_key()		comprueba si una clave aparece en un
				Diccionario
	empty()			comprueba si un Diccionario está vacío
	remove()		elimina una entrada de un Diccionario
	extend()		añade las entradas de un Diccionario a otro
	filter()		elimina entradas particulares de un
				Diccionario
	map()			cambia cada entrada de un Diccionario
	keys()			devuelve una Lista con las claves de un
				Diccionario
	values()		devuelve una Lista con los valores de un
				Diccionario
	items()			devuelve una Lista de pares clave-valor de un
				Diccionario
	copy()			hace una copia superficial de un Diccionario
	deepcopy()		hace una copia completa de un Diccionario
	string()		representación de cadena de un Diccionario
	max()			valor máximo en un Diccionario
	min()			valor mínimo en un Diccionario
	count()			cuenta la cantidad de veces que un valor
				aparece en un Diccionario
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	atan()			arc tangent
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Operaciones de punto flotante:				*float-functions*
	float2nr()		convertir Flotante a Número
	abs()			valor absoluto (también funciona para Números)
	round()			redondear
	ceil()			redondear hacia arriba (techo)
	floor()			redondear hacia abajo (piso)
	trunc()			eliminar valores después del punto decimal
	log10()			logaritmo en base 10
	pow()			valor de x elevado a la y potencia
	sqrt()			raíz cuadrada
	sin()			seno
	cos()			coseno
	atan()			arcotangente
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window &amp; tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window &amp; tab page
	garbagecollect()	possibly free memory
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Variables:						*var-functions*
	type()			tipo de una variable
	islocked()		comprueba si una variable ha sido bloqueada
	function()		obtiene una referencia a función para el
				nombre de función dado
	getbufvar()		obtiene una variable de un búfer específico
	setbufvar()		define una variable en un búfer específico
	getwinvar()		obtiene una variable de una ventana específica
	gettabvar()		obtiene una variable de una pestaña específica
	gettabwinvar()		obtiene una variable de una ventana y pestaña
				específicas
	setwinvar()		define una variable en una ventana
				específica
	settabvar()		define una variable en una pestaña
				específica
	settabwinvar()		define una variable en una ventana y pestaña
				específicas
	garbagecollect()	potencialmente libera memoria
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posición de marcas y del cursor:	*cursor-functions* *mark-functions*
	col()			número de columna del cursor o de una marca
	virtcol()		número de columna en pantalla del cursor o de
				una marca
	line()			número de línea del cursor o de una marca
	wincol()		número de columna de ventana del cursor
	winline()		número de línea de ventana del cursor
	cursor()		ubica el cursor en una linea/columna
	getpos()		obtiene la posición del cursor, marca, etc.
	setpos()		define la posición del cursor, marca, etc.
	byte2line()		obtiene el número de línea correspondiente a
				un índice en bytes
	line2byte()		índice en bytes correspondiente a una línea
				específica
	diff_filler()		obtiene la cantidad de líneas de relleno
				encima de una línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de texto en el búfer actual:		*text-functions*
	getline()		obtiene una línea o lista de líneas del búfer
	setline()		reemplaza una línea del búfer
	append()		añade una línea o lista de líneas al búfer
	indent()		sangrado de una línea específica
	cindent()		sangrado de una línea de acuerdo al estilo
				para C
	lispindent()		sangrado de una línea de acuerdo al estilo
				para Lisp
	nextnonblank()		ubica la siguiente línea no vacía
	prevnonblank()		ubica la anterior línea no vacía
	search()			ubica una coincidencia para un patrón
	searchpos()		ubica una coincidencia para un patrón
	searchpair()		ubica la parte correspondiente a un
				inicio/medio/final
	searchpairpos()	ubica la parte correspondiente a un
				inicio/medio/final
	searchdecl()		busca la declaración de un nombre
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>					*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
	getfperm()		get the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					*system-functions* *file-functions*
Funciones del sistema y manipulación de archivos:
	glob()			expande comodines
	globpath()	expande comodines en múltiples directorios
	findfile()		ubica un archivo en una lista de directorios
	finddir()		ubica un directorio en una lista de
				directorios
	resolve()		determina a dónde apunta un acceso o enlace
				directo
	fnamemodify()		modifica un nombre de archivo
	pathshorten()		abrevia nombres de directorio en una ruta
	simplify()		simplifica una ruta sin cambiar su significado
	executable()		comprueba si un programa ejecutable existe
	filereadable()		comprueba si se puede leer un archivo
	filewritable()		comprueba si se puede escribir a un archivo
	getfperm()		obtiene los permisos para un archivo
	getftype()		obtiene el tipo de un archivo
	isdirectory()		comprueba si un directorio existe
	getfsize()		obtiene el tamaño de un archivo
	getcwd()		obtiene el directorio de trabajo actual
	haslocaldir()		comprueba si se ha usado |:lcd| en la ventana
				actual
	tempname()		obtiene un nombre para un archivo temporal
	mkdir()			crea un nuevo directorio
	delete()		borra un archivo
	rename()		renombra un archivo
	system()		obtiene el resultado de una orden de consola
	hostname()		nombre del sistema
	readfile()		lee un archivo y devuelve una Lista de líneas
	writefile()		escribe una Lista de líneas a un archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fecha y Hora:				*date-functions* *time-functions*
	getftime()		obtiene la hora de la última modificación de
				un archivo
	localtime()		obtiene la hora actual en segundos
	strftime()		convierte la hora a una cadena
	reltime()		devuelve la hora actual o el tiempo
				transcurrido desde una hora
	reltimestr()		convierte el resultado de reltime() a una
				cadena
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()		get a list of lines from the specified buffer
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			*buffer-functions* *window-functions* *arg-functions*
Búferes, ventanas, y la lista de argumentos:
	argc()			número de entradas en la lista de argumentos
	argidx()		posición actual en la lista de argumentos
	argv()			obtiene un elemento de la lista de argumentos
	bufexists()		comprueba si un búfer existe
	buflisted()		comprueba si un búfer existe y está listado
	bufloaded()		comprueba si un búfer existe y está cargado
	bufname()		obtiene el nombre de un búfer específico
	bufnr()			obtiene el número de búfer de un búfer
				específico
	tabpagebuflist()	devuelve la Lista de búfers de una pestaña
	tabpagenr()		obtiene el número de una pestaña
	tabpagewinnr()		similar a winnr(), pero especificando la
				pestaña
	winnr()			obtiene el número de ventana de la ventana
				actual
	bufwinnr()		obtiene el número de ventana del búfer
				especificado
	winbufnr()		obtiene el número de búfer de una ventana
				específica
	getbufline()		obtiene una lista de líneas del búfer
				especificado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line:					*command-line-functions*
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Línea de órdenes:				*command-line-functions*
	getcmdline()		obtiene la línea de órdenes actual
	getcmdpos()		obtiene la posición del cursor en la línea de
				órdenes
	setcmdpos()		cambia la posición del cursor en la línea de
				órdenes
	getcmdtype()		devuelve el tipo de la línea de órdenes actual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Listas de corrección rápida y de ubicación:		*quickfix-functions*
	getqflist()		obtiene una lista de errores de corrección
				rápida
	setqflist()		modifica una lista de corrección rápida
	getloclist()	obtiene la lista de elementos de una lista de
				ubicación
	setloclist()		modifica una lista de ubicación
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Completado automático en modo Insertar:		*completion-functions*
	complete()		define coincidencias encontradas
	complete_add()		añade elementos a la lista de coincidencias
				encontradas
	complete_check()	comprueba si debería interrumpir el
				completado
	pumvisible()		comprueba si se está mostrando el menú
				contextual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding:					*folding-functions*
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegado:					*folding-functions*
	foldclosed()		comprueba si hay un pliegue cerrado en una
				línea específica
	foldclosedend()	similar a foldclosed() pero devuelve la última
				línea
	foldlevel()		obtiene el nivel de plegado de la línea
				especificada
	foldtext()		genera el texto mostrado en un pliegue cerrado
	foldtextresult()	obtiene el texto mostrado en un pliegue
				cerrado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sintaxis y resaltado:	  *syntax-functions* *highlighting-functions*
	clearmatches()	elimina las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	getmatches()		obtiene todas las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	hlexists()		comprueba la existencia de un grupo de
				resaltado
	hlID()			obtiene el ID de un grupo de resaltado
	synID()			obtiene el ID de sintaxis en una posición
				específica
	synIDattr()		obtiene un atributo específico correspondiente
				a un ID de sintaxis
	synIDtrans()		obtiene un ID de sintaxis traducido
	diff_hlID()		obtiene el ID de resaltado para el modo diff
				en una posición dada
	matchadd()		define un patrón a resaltar (una
				«coincidencia»)
	matcharg()		obtiene información acerca de los argumentos
				para |:match|
	matchdelete()		borra una coincidencia definida por
				|matchadd()| o una orden |:match|
	setmatches()		restaura una lista de coincidencias guardada
				por |getmatches()|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spelling:					*spell-functions*
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Corrección ortográfica:					*spell-functions*
	spellbadword()		ubica palabras mal escritas a partir de la
				posición actual del cursor
	spellsuggest()		devuelve las correcciones ortográficas
				sugeridas
	soundfold()		retorna el homófono de una palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Historia:					*history-functions*
	histadd()		añade un elemento a la historia
	histdel()		elimina un elemento a la historia
	histget()		obtiene un elemento a la historia
	histnr()		obtiene el índice más grande de la lista de una
				historia
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interacción:					*interactive-functions*
	browse()		despliega un diálogo de selección de archivos
	browsedir()		despliega un diálogo de selección de
				directorios
	confirm()		solicita al usuario hacer una elección
	getchar()		solicita un carácter al usuario
	getcharmod()		obtiene los modificadores usados en el último
				carácter digitado
	feedkeys()		inserta caracteres en la cola de inserción
	input()			solicita una línea de texto al usuario
	inputlist()		permite al usuario elegir un elemento de una
				lista
	inputsecret()		solicita una línea de texto al usuario, sin
				mostrarla
	inputdialog()		solicita una línea de texto al usuario usando
				un diálogo
	inputsave()		guarda y limpia el búfer de cola de inserción
	inputrestore()		restaura el búfer de la línea de inserción
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI:						*gui-functions*
	getfontname()		get name of current font being used
	getwinposx()		X position of the GUI Vim window
	getwinposy()		Y position of the GUI Vim window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaz gráfica:					*gui-functions*
	getfontname()		obtiene el nombre del tipo de letra actual
	getwinposx()		posición X de la ventana gráfica de Vim
	getwinposy()		posición Y de la ventana gráfica de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim server:					*server-functions*
	serverlist()		return the list of server names
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Servidor Vim:					*server-functions*
	serverlist()		devuelve una lista con nombres de servidores
	remote_send()		envía órdenes (caracteres) a un servidor Vim
	remote_expr()		evalúa una expresión en un servidor Vim
	server2client()		envía una respuesta a un cliente de un
				servidor Vim
	remote_peek()		comprueba si hay respuestas de un servidor Vim
	remote_read()		lee una respuesta de un servidor Vim
	foreground()		desplaza la ventana de Vim a primer plano
	remote_foreground()	desplaza la ventana de un servidor Vim a primer
				plano
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tamaño y posición de ventanas:			*window-size-functions*
	winheight()		obtiene la altura de una ventana específica
	winwidth()		obtiene el ancho de una ventana específica
	winrestcmd()		devuelve una orden para restaurar los tamaños
				de ventana
	winsaveview()		obtiene una vista de la ventana actual
	winrestview()		devuelve una vista almacenada en la ventana
				actual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various:					*various-functions*
	mode()			get current editing mode
	visualmode()		last visual mode used
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Varios:					*various-functions*
	mode()			obtiene el modo de edición actual
	visualmode()		último modo visual usado
	hasmapto()		comprueba la existencia de una macro
	mapcheck()		comprueba la existencia de una macro que
				coincida con el argumento dado
	maparg()		obtiene el rhs de una macro
	exists()		comprueba si la variable, función, etc.,
				existe
	has()			comprueba si Vim cuenta con la característica
				dada
	changenr()		devuelve el número correspondiente al cambio
				más reciente
	cscope_connection()	comprueba si hay una conexión a cscope
	did_filetype()		comprueba si se ha usado una orden automática
				FileType
	eventhandler()		comprueba si se ha sido invocado desde un
				manejador de eventos
	getpid()		obtiene el ID de proceso de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	libcall()		call a function in an external library
	libcallnr()		idem, returning a number
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	libcall()		llama a una función en una biblioteca externa
	libcallnr()		idéntica, pero devuelve un número en vez de una
				cadena
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	getreg()		obtiene el contenido de un registro
	getregtype()		obtiene el tipo de un registro
	setreg()		asigna el tipo y contenido de un registro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	taglist()		get list of matching tags
	tagfiles()		get a list of tags files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	taglist()		obtiene una lista de etiquetas coincidentes
	tagfiles()		obtiene una lista de archivos de etiquetas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mzeval()		evaluate |MzScheme| expression
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mzeval()		evalúa una expresión |MzScheme|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.7*	Defining a function
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.7*	Definición de funciones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to define your own functions.  The basic function declaration begins as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim permite definir nuevas funciones. La definición básica de una función corresponde a lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
&lt;
	Note:
	Function names must begin with a capital letter.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function {nombre}({var1}, {var2}, ...)
	:  {instrucciones}
	:endfunction
&lt;
	Nota:
	Los nombres de funciones deben empezar con una letra mayúscula.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define a short function to return the smaller of two numbers.  It starts with this line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a definir una función pequeña que retorne el más pequeño de dos números. Su definición empieza con esta línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Min(num1, num2)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Min(num1, num2)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
   &gt;
	:  if a:num1 &lt; a:num2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta le indica a Vim que la función se llama «Min» y que recibe dos
argumentos: «num1» y «num2».
   El primer paso es comprobar qué número es el más pequeño:
   &gt;
	:   if a:num1 &lt; a:num2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The special prefix "a:" tells Vim that the variable is a function argument.  Let's assign the variable "smaller" the value of the smallest number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El prefijo especial «a:» le indica a Vim que la variable es un argumento de la función. Asignemos ahora a la variable «menor» el valor del menor número: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "smaller" is a local variable.  Variables used inside a function are local unless prefixed by something like "g:", "a:", or "s:".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable «menor» es una variable local. Las variables usadas dentro de una función son locales a menos que tengan un prefijo como «g:», «a:», o «s:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.  Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Para usar una variable global dentro de una función debe anteponer
	«g:» a su nombre. Dentro de una función, «g:hoy» corresponde a la
	variable global «hoy», y «hoy» es otra variable, local respecto a la
	función.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now use the ":return" statement to return the smallest number to the user.  Finally, you end the function: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora usamos la instrucción «:return» para devolver el menor de los dos números al usuario. Finalmente, terminamos la función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:  return smaller
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:  return menor
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
	:  return menor
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A user defined function is called in exactly the same way as a built-in function.  Only the name is different.  The Min function can be used like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las funciones definidas por el usuario se invocan exactamente de la misma forma que las funciones internas. La única diferencia es el nombre. Puede usar la función Min como sigue: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo Min(5, 8)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo Min(5, 8)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only now will the function be executed and the lines be interpreted by Vim.  If there are mistakes, like using an undefined variable or function, you will now get an error message.  When defining the function these errors are not detected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo en este momento se ejecutará la función y Vim interpretará las instrucciones que la componen. Si hay errores, como usar una variable o función no definida, se mostrará un mensaje de error. Al definir una función estos errores no son detectados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function!  Min(num1, num2, num3)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function!  Min(num1, num2, num3)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:call» puede recibir un rango de líneas. Este rango puede tener dos
significados. Cuando la definición de una función tiene la palabra clave
«range», ésta se hará cargo del rango de líneas.
   La función recibirá las variables «a:firstline» y «a:lastline». Éstas
contendrán los números de línea del rango con el cual se invoca la función.
Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Contar_palabras() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "encontradas " . n . " palabras"
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:10,30call Count_words()
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:10,30call Contar_palabras()
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función se ejecutará una vez, y mostrará en la pantalla el número de
palabras.
   La otra forma de usar un rango de líneas es definiendo una función sin la
palabra clave «range». Se invocará la función una vez por cada línea en el
rango, y el cursor estará en la línea correspondiente a cada invocación.
Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function  Numero()
	:  echo "la línea " . line(".") . " contiene: " . getline(".")
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:10,15call Number()
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:10,15call Numero()
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to define functions that have a variable number of arguments.  The following command, for instance, defines a function that must have 1 argument (start) and can have up to 20 additional arguments: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim permite la definición de funciones que reciben una cantidad variable de argumentos. Por ejemplo, la siguiente orden define una función que debe recibir un argumento (inicio) y puede recibir hasta 20 argumentos adicionales: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Show(start, ...)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Mostrar(inicio, ...)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable «a:1» contiene el primer argumento opcional, «a:2» contiene el
segundo, y así sucesivamente. La variable «a:0» contiene la cantidad de
argumentos adicionales.
   Por ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index &lt;= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function Mostrar(inicio, ...)
	:  echohl Title
	:  echo "inicio es " . a:inicio
	:  echohl None
	:  let indice = 1
	:  while indice &lt;= a:0
	:    echo "  Arg " . indice . " is " . a:{indice}
	:    let indice = indice + 1
	:  endwhile
	:  echo ""
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses the ":echohl" command to specify the highlighting used for the following ":echo" command.  ":echohl None" stops it again.  The ":echon" command works like ":echo", but doesn't output a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí se usa la orden «:echohl», que especifica el resaltado a usar en la siguiente orden «:echo». «:echohl None» hace que no se use resaltado alguno. La orden  «:echon» es similar a «:echo» pero no imprime el cambio de línea final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function
&lt;	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function
&lt;	function Mostrar(inicio, ...) ~
	function ObtenerSangradoVim() ~
	function DefinirSintaxis(nombre) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function SetSyn
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:name ~
	3     endif ~
	   endfunction ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function DefinirSintaxis
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:nombre ~
	3     endif ~
	   endfunction ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El número de línea de una instrucción es información útil cuando aparece un
mensaje de error o al depurar scripts. Acerca del modo de depurado,
consulte |debug-scripts|.
   Puede darle un valor de 12 o más a la opción 'verbose' para ver todas las
invocaciones a funciones. Con un valor de 15 o más verá cada línea ejecutada.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:delfunction Show
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:delfunction Mostrar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it can be useful to have a variable point to one function or another.  You can do it with the function() function.  It turns the name of a function into a reference: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones es útil que una variable pueda hacer referencia a una u otra función . Puede hacerlo usando la función function(). Ésta función convierte el nombre de una función en una referencia a la misma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
&lt;	Wrong! ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let resultado = 0		" o 1
	:function! Bien()
	:  return '¡Bien!'
	:endfunc
	:function! Mal()
	:  return '¡Mal!'
	:endfunc
	:
	:if resultado == 1
	:  let Unafunc = function('Bien')
	:else
	:  let Unafunc = function('Mal')
	:endif
	:echo call(Unafunc, [])
&lt;	¡Mal! ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que el nombre de la variable que contiene la referencia a la
función debe empezar con una letra mayúscula. En caso contrario, es posible
que se confunda con el nombre de una de las funciones integradas de Vim.
   Para invocar una función usando una variable con una referencia a función
se usa la función call(). Como primer argumento recibe la referencia a la
función, y como segundo argumento una Lista con los argumentos para la función
a invocar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.8*	Lists and Dictionaries
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.8*	Listas y Diccionarios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have used the basic types String and Number.  Vim also supports two composite types: List and Dictionary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora hemos usado los tipos básicos, Cadena de texto y Número. Vim también ofrece otros dos: Lista y Diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A List is an ordered sequence of things.  The things can be any kind of value, thus you can make a List of numbers, a List of Lists and even a List of mixed items.  To create a List with three strings: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una Lista es una secuencia ordenada de elementos. Los elementos pueden ser de cualquier tipo, así que puede crear una Lista de números, una Lista de Listas e incluso una Lista de elementos de tipos diferentes. Para crear una Lista con tres cadenas de texto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = ['aap', 'mies', 'noot']
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = ['aap', 'mies', 'noot']
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The List items are enclosed in square brackets and separated by commas.  To create an empty List: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos de la Lista se rodean con corchetes y se separan con comas. Para crear una Lista vacía: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = []
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = []
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
&lt;	['foo', 'bar'] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = []
	:call add(lista, 'foo')
	:call add(lista, 'bar')
	:echo lista
&lt;	['foo', 'bar'] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo alist + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo lista + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
&lt;	['one', 'two', 'three'] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = ['uno']
	:call extend(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', 'dos', 'tres'] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
&lt;	['one', ['two', 'three']] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = ['uno']
	:call add(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', ['dos', 'tres']] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
&lt;	one ~
	two ~
	three ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = ['uno', 'dos', 'tres']
	:for n in lista
	:  echo n
	:endfor
&lt;	uno ~
	dos ~
	tres ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will loop over each element in List "alist", assigning the value to variable "n".  The generic form of a for loop is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código mostrado iterará sobre cada elemento en la Lista «lista», asignando el valor del elemento a la variable «n». La forma genérica de un ciclo «for» es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for {varname} in {listexpression}
	:  {commands}
	:endfor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for {nombrevar} in {expresiónlista}
	:  {instrucciones}
	:endfor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To loop a certain number of times you need a List of a specific length.  The range() function creates one for you: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para iterar una cantidad determinada de veces necesita una Lista con una longitud específica. La función range() puede crearla por usted: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que el primer elemento de la Lista creada por range() es cero, y por
tanto el último elemento tiene un valor de uno menos que la longitud de la
lista.
   También puede especificar el valor máximo, y el incremento o decremento
deseado: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for line in getline(1, 20)
	:  if line =~ "Fecha: "
	:    echo matchstr(line, 'Fecha: \zs.*')
	:  endif
	:endfor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Dictionary stores key-value pairs.  You can quickly lookup a value if you know the key.  A Dictionary is created with curly braces: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un Diccionario almacena pares clave-valor. Esto le permite obtener un valor almacenado de manera rápida, si conoce la clave del mismo. Los Diccionarios se crean usando llaves: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let es2nl = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo uk2nl['two']
&lt;	twee ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo es2nl['dos']
&lt;	twee ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{&lt;key&gt; : &lt;value&gt;, ...}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{&lt;clave&gt; : &lt;valor&gt;, ...}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The possibilities with Dictionaries are numerous.  There are various functions for them as well.  For example, you can obtain a list of the keys and loop over them: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los Diccionarios ofrecen numerosas posibilidades. También dispone de varias funciones para operar sobre ellos. Por ejemplo, puede obtener una lista de las claves e iterar sobre ellas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for key in keys(uk2nl)
	:  echo key
	:endfor
&lt;	three ~
	one ~
	two ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for clave in keys(es2nl)
	:  echo clave
	:endfor
&lt;	tres ~
	uno ~
	dos ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the keys are not ordered.  You can sort the list to get a specific order: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habrá notado que las claves no están ordenadas. Puede ordenar la lista para obtener un orden específico: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
&lt;	one ~
	three ~
	two ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:for clave in sort(keys(es2nl))
	:  echo clave
	:endfor
&lt;	dos ~
	tres ~
	uno ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you can never get back the order in which items are defined.  For that you need to use a List, it stores items in an ordered sequence.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es posible recuperar el orden en el cual se definieron los elementos del Diccionario. Para eso necesita una Lista, que almacena los elementos en una secuencia ordenada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo uk2nl['one']
&lt;	een ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo es2nl['uno']
&lt;	een ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo uk2nl.one
&lt;	een ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo es2nl.uno
&lt;	een ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works for a key that is made of ASCII letters, digits and the underscore.  You can also assign a new value this way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funciona con claves compuestas de caracteres ASCII, dígitos, y el guión bajo. También puede usar esta notación para asignar valores: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let uk2nl.four = 'vier'
	:echo uk2nl
&lt;	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let es2nl.cuatro = 'vier'
	:echo es2nl
&lt;	{'tres': 'drie', 'cuatro': 'vier', 'uno': 'een', 'dos': 'twee'} ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:function es2nl.traducir(linea) dict
	:  return join(map(split(a:linea), 'get(self, v:val, "???")'))
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo uk2nl.translate('three two five one')
&lt;	drie twee ??? een ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo es2nl.traducir('tres dos cinco uno')
&lt;	drie twee ??? een ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que habrá notado primero es el «dict» al final de la línea «:function».
Así se indica que la función será usada desde un Diccionario. La variable
local «self» se referirá a dicho diccionario.
   Ahora, dividamos esa compleja instrucción de retorno: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	split(a:line)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	split(a:linea)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The split() function takes a string, chops it into white separated words and returns a list with these words.  Thus in the example it returns: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función split() toma una cadena, la divide en palabras separadas por espacios en blanco, y entrega una lista con estas palabras. En el ejemplo previo, entrega: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo split('three two five one')
&lt;	['three', 'two', 'five', 'one'] ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo split('tres dos cinco uno')
&lt;	['tres', 'dos', 'cinco', 'uno'] ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This list is the first argument to the map() function.  This will go through the list, evaluating its second argument with "v:val" set to the value of each item.  This is a shortcut to using a for loop.  This command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta lista es el primer argumento para la función map(). Dicha función analizará la lista, evaluando su segundo argumento con la variable «v:val» definida con el valor de cada elemento en la lista. Es una abreviación de un ciclo for. Esta instrucción: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = map(split(a:line), 'get(self, v:val, "???")')
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = map(split(a:linea), 'get(self, v:val, "???")')
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let lista = split(a:linea)
	:for ind in range(len(lista))
	:  let lista[ind] = get(self, lista[ind], "???")
	:endfor
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The get() function checks if a key is present in a Dictionary.  If it is, then the value is retrieved.  If it isn't, then the default value is returned, in the example it's '???'.  This is a convenient way to handle situations where a key may not be present and you don't want an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función get() comprueba si una clave existe en un Diccionario. Si existe, devuelve el valor asociado a la clave. Si no existe, devuelve el valor definido como predeterminado, que en el ejemplo es '???'. Esto permite manejar de una forma conveniente las situaciones en que una clave no existe y no desea hacer el manejo del error que provocaría dicha situación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función join() es el complemento de split(): une una lista de palabras,
separándolas con un espacio.
   La combinación de split(), map(), y join() es una forma elegante de filtrar
una cadena de palabras de manera sucinta.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que podemos guardar valores y funciones en un Diccionario, podemos usar
un Diccionario como un objeto.
   Anteriormente hicimos uso de un Diccionario para traducir texto de Holandés
a Español. Querríamos hacer lo mismo para otros idiomas. Primero crearemos un
objeto (esto es, un Diccionario) que tenga la función traducir, pero no tenga
palabras para traducir: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let dicctraductor = {}
	:function dicctraductor.traducir(linea) dict
	:  return join(map(split(a:linea),
			\ 'get(self.palabras, v:val, "???")'))
	:endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's slightly different from the function above, using 'self.words' to lookup word translations.  But we don't have a self.words.  Thus you could call this an abstract class.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La definición es ligeramente diferente de la función anterior, ya que usa 'self.words' para buscar las traducciones de palabras. Pero no hay un self.words. Por esto decir que el Diccionario es una clase abstracta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
&lt;	drie een ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let es2nl = copy(dicctraductor)
	:let es2nl.words = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
	:echo es2nl.translate('tres uno')
&lt;	drie een ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
&lt;	drei ein ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let es2de = copy(dicctraductor)
	:let es2de.words = {'uno': 'ein', 'dos': 'zwei', 'tres': 'drei'}
	:echo es2de.translate('tres uno')
&lt;	drei ein ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You see that the copy() function is used to make a copy of the "transdict" Dictionary and then the copy is changed to add the words.  The original remains the same, of course.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver que la función copy() se usa para crear una copia del Diccionario «dicctraductor» y luego se cambia la copia, añadiendo las palabras. El original, por supuesto, permanece intacto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
&lt;	een twee drie ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if $LANG =~ "de"
	:  let trad = es2de
	:else
	:  let trad = es2nl
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	een twee drie ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here "trans" refers to one of the two objects (Dictionaries).  No copy is made.  More about List and Dictionary identity can be found at |list-identity| and |dict-identity|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí «trad» se refiere a uno de dos posibles objetos (Diccionarios). No se hace ninguna copia. Puede encontrar más información acerca de la identidad de Listas y Diccionarios en |list-identity| y |dict-identity|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you might use a language that isn't supported.  You can overrule the translate() function to do nothing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que use un idioma que aún no esté incluido. Para este caso, puede redefinir la función traducir() para que no haga nada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
&lt;	three one wladiwostok ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let es2es = copy(dicctraductor)
	:function! es2es.traducir(linea)
	:  return a:linea
	:endfunction
	:echo es2es.traducir('tres one wladiwostok')
&lt;	tres uno wladiwostok ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a ! was used to overwrite the existing function reference.  Now use "uk2uk" when no recognized language is found: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Note el «!» utilizado para redefinir la referencia a función existente. Ahora puede usar «es2es» cuando no se encuentra ningún idioma reconocido: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
&lt;	one two three ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if $LANG =~ "de"
	:  let trad = es2de
	:elseif $LANG =~ "nl"
	:  let trad = es2nl
	:else
	:  let trad = es2es
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	uno dos tres ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.9*	Exceptions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.9*	Excepciones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:try
	:   read ~/plantillas/pascal.tmpl
	:catch /E484:/
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":read" command will fail if the file does not exist.  Instead of generating an error message, this code catches the error and gives the user a nice message instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:read» (leer) fallará si el archivo no existe. En vez de mostrar un mensaje de error, este código atrapa el error y le muestra al usuario un mensaje más agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the commands in between ":try" and ":endtry" errors are turned into exceptions.  An exception is a string.  In the case of an error the string contains the error message.  And every error message has a number.  In this case, the error we catch contains "E484:".  This number is guaranteed to stay the same (the text may change, e.g., it may be translated).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para las instrucciones entre «:try» y «:endtry» los errores se convierten en excepciones. Una excepción es una cadena de texto. Cuando aparece un error esta cadena contiene el mensaje de error. Y cada mensaje de error tiene un número. En este caso, el error que atrapamos contiene «E484:». Vim garantiza que este número permanece inalterado (el texto del mensaje de error puede cambiar, por ejemplo, puede haber sido traducido.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the ":read" command causes another error, the pattern "E484:" will not match in it.  Thus this exception will not be caught and result in the usual error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando la orden «:read» genera un error distinto, el patrón «E484:» no coincidirá con él. La excepción no será atrapada y aparecerá el mensaje de error habitual en esos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:try
	:   read ~/plantillas/pascal.tmpl
	:catch
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means all errors are caught.  But then you will not see errors that are useful, such as "E21: Cannot make changes, 'modifiable' is off".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta forma se atrapan todos los errores. Pero al hacerlo no verá errores que son útiles, como por ejemplo «E21: No se pudo modificar, 'modifiable' está desactivado»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This filters the lines from the cursor until the end of the file through the "filter" command, which takes a file name argument.  No matter if the filtering works, something goes wrong in between ":try" and ":finally" or the user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is always executed.  This makes sure you don't leave the temporary file behind.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí se filtran las líneas desde el cursor hasta el final del archivo usando la orden «filter», que toma como argumento un nombre de archivo. No importa si el filtrado funciona, si algo sale mal entre «:try» y «:finally», o si el usuario cancela el filtrado presionando CTRL-C, la instrucción «call delete(tmp)» siempre se ejecuta. Así se asegura de que no queden archivos temporales al acabar el proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.10*	Various remarks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.10*	Observaciones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a summary of items that apply to Vim scripts.  They are also mentioned elsewhere, but form a nice checklist.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación tiene un resumen de los elementos relevantes para escribir scripts de Vim. También se los menciona en otros lugares de la documentación, pero aquí se presentan como una conveniente lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end-of-line character depends on the system.  For Unix a single &lt;NL&gt; character is used.  For MS-DOS, Windows, OS/2 and the like, &lt;CR&gt;&lt;LF&gt; is used.  This is important when using mappings that end in a &lt;CR&gt;.  See |:source_crnl|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter de fin de línea usado depende del sistema. En sistemas Unix se usa &lt;NL&gt;. En MS-DOS, Windows, OS/2 y similares, se usa &lt;CR&gt;&lt;LF&gt;. Éste es un detalle importante a considerar al usar macros que terminan en &lt;CR&gt;. Consulte |:source_crnl|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Leading whitespace characters (blanks and TABs) are always ignored.  The whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in the example below) are reduced to one blank character and plays the role of a separator, the whitespaces after the last (visible) character may or may not be ignored depending on the situation, see below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los espacios en blanco al principio de cada línea (espacios y tabulados) siempre se ignoran. Los espacios en blanco entre parámetros (por ejemplo, entre 'set' y 'cpoptions' en el ejemplo a continuación) se reducen a un solo espacio blanco que actúa como separador, los espacios en blanco después del último carácter (visible) se pueden o no ignorar dependiendo del caso, véase a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set cpoptions    =aABceFst
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set cpoptions    =aABceFst
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the whitespace immediately before the "=" sign is ignored.  But there can be no whitespace after the "=" sign!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>se ignora el espacio en blanco inmediatamente antes del símbolo «=». ¡Pero no puede haber espacios a continuación del símbolo «=»!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=my\ nice\ file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=mi\ lindo\ archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=my nice file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=mi lindo archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tags=my
	:set nice
	:set file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tags=mi
	:set lindo
	:set archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character " (the double quote mark) starts a comment.  Everything after and including this character until the end-of-line is considered a comment and is ignored, except for commands that don't consider comments, as shown in examples below.  A comment can start on any character position on the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter " (comilla doble) marca el inicio de un comentario. Todo lo que aparece a continuación de éste carácter hasta el fin de línea, e incluyéndola, se considera un comentario y es ignorado, a excepción de las órdenes que no tienen en cuenta los comentarios, como se puede ver en ejemplos de esta sección. Un comentario puede empezar en cualquier punto de una línea de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a little "catch" with comments for some commands.  Examples: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño «pero» con los comentarios y ciertas órdenes. Ejemplos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbrev dev development		" shorthand
	:map &lt;F3&gt; o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbrev des desarrollo		" abreviación
	:map &lt;F3&gt; o#include		" insertar directiva include
	:execute orden			" ejecutar
	:!ls *.c			" listar archivos C
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of &lt;F3&gt; will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La abreviación 'dev' se expandirá a 'desarrollo     " abreviación'. La
macro &lt;F3&gt; constará en realidad de toda la línea desde 'o# ....' incluyendo
'" insertar directiva include'. La orden «execute» provocará un error. La
orden «!» enviará todos los caracteres a continuación al intérprete de
órdenes, provocando un error debido al carácter '"' sin la comilla de cierre
correspondiente.
   No pueden existir comentarios a continuación de las órdenes «:map»,
«:abbreviate», «:execute», ni «!» (hay algunas órdenes más con esta
restricción). Para el caso de las órdenes «:map», «:abbreviate», y «:execute»
hay un truco disponible: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbrev dev development|" shorthand
	:map &lt;F3&gt; o#include|" insert include
	:execute cmd			|" do it
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbrev des desarrollo|" abreviación
	:map &lt;F3&gt; o#include|" insertar directiva include
	:execute orden			|" ejecutar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': &gt;
	:exe '!ls *.c'			|" list C files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter «|» permite separar órdenes. En este caso, la siguiente orden es
simplemente un comentario. Para la última orden hay que hacer dos cosas:
|:execute| y usar «|»: &gt;
	:exe '!ls *.c'			|" listar archivos C
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no white space before the '|' in the abbreviation and mapping.  For these commands, any character until the end-of-line or '|' is included.  As a consequence of this behavior, you don't always see that trailing whitespace is included: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que no hay espacios en blanco antes de «|» en la abreviación ni en la macro. En estas órdenes, se incluye cualquier carácter hasta el fin de línea o hasta «|». Como consecuencia de este comportamiento, no siempre es visible cuándo se incluyen espacios en blanco al final del a línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;F4&gt; o#include  
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;F4&gt; o#include  
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix there is one special way to comment a line, that allows making a Vim
script executable: &gt;
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix hay una forma especial de hacer un comentario, que permite hacer que
un script de Vim sea ejecutable: &gt;
	#!/usr/bin/env vim -S
	echo "este es un script de Vim"
	quit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "#" command by itself lists a line with the line number.  Adding an exclamation mark changes it into doing nothing, so that you can add the shell command to execute the rest of the file. |:#!| |-S|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por sí misma, la orden «#» muestra una línea junto con su número de línea. Al añadirle un símbolo de exclamación su comportamiento cambia y no tiene efecto, así que puede añadir la orden de intérprete de órdenes para ejecutar el resto del archivo. |:#!| |-S|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map ,ab o#include
	:unmap ,ab 
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map ,ab o#include
	:unmap ,ab 
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the unmap command will not work, because it tries to unmap ",ab ".  This does not exist as a mapped sequence.  An error will be issued, which is very hard to identify, because the ending whitespace character in ":unmap ,ab " is not visible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí la orden unmap no funcionará, porque trata de eliminar la macro «,ab ». Ésta no existe como secuencia de ninguna macro. Se mostrará un error, que es muy difícil de identificar, porque el carácter de espacio final en «:unmap ,ab» no es visible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unmap ,ab     " comment
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unmap ,ab     " comentario
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte correspondiente al comentario será ignorada. Sin embargo, Vim tratará
de eliminar la macro ',ab     ', que no existe. Debe reescribir la orden como:  &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unmap ,ab|    " comment
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unmap ,ab|    " comentario
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you want to make a change and go back to where cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones es deseable hacer un cambio y volver al sitio en que el cursor se
encontraba inicialmente. Recuperar la posición relativa también sería
agradable, de tal forma que la misma línea inicial aparezca al inicio de la
ventana.
   Este ejemplo copia la línea actual, la inserta antes de la primera línea en
el archivo y después restaura la vista original: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	map ,p ma"aYHmbgg"aP`bzt`a
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	map ,p ma"aYHmbgg"aP`bzt`a
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What this does: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es lo que hace: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			pone una marca en la posición actual del
				cursor
	  "aY			copia la línea actual al registro a
	     Hmb		va hasta la primera línea que se ve en la
				ventana y pone la marca b allí
		gg		va a la primera línea del archivo
		  "aP		pega la línea copiada por encima de la línea
		     `b		vuelve a la línea superior de la vista inicial
		       zt	ubica dicha línea como la primera de la
				ventana
			 `a	vuelve a la posición del cursor almacenada
				originalmente
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que los nombres de funciones que defina interfieran con
otras funciones, use el siguiente esquema:
- Anteponga una cadena única a cada nombre de función. A menudo uso una
  abreviatura. Por ejemplo, uso «OV» para las funciones relacionadas con
  opciones de ventana.
- Ponga todas las definiciones de sus funciones en un mismo archivo. Cree una
  variable global para indicar que las funciones ya fueron cargadas. Cuando
  cargue el archivo de nuevo, elimine antes las definiciones de las funciones.
Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	" This is the XXX package
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	" Este es el paquete XXX
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if exists("XXX_cargado")
	  delfun XXX_uno
	  delfun XXX_dos
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	function XXX_one(a)
		... body of function ...
	endfun
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	function XXX_uno(a)
		... cuerpo de la función ...
	endfun
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	function XXX_two(b)
		... body of function ...
	endfun
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	function XXX_dos(b)
		... cuerpo de la función ...
	endfun
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let XXX_loaded = 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let XXX_loaded = 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.11*	Writing a plugin				*write-plugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.11*	Escribir extensiones				*write-plugin*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write a Vim script in such a way that many people can use it.  This is called a plugin.  Vim users can drop your script in their plugin directory and use its features right away |add-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear un script de Vim de tal forma que lo puedan usar varias personas. Esto se llama una extensión. Los usuarios de Vim pueden copiar el script en su directorio «plugin/», y utilizarlo en el momento con |add-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section the first type is explained.  Most items are also relevant for writing filetype plugins.  The specifics for filetype plugins are in the next section |write-filetype-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta sección se describirán las extensiones globales («global plugins»). La mayoría de elementos también son necesarios para escribir extensiones de tipo de archivo («filetype plugins»). La sección a continuación, |write-filetype-plugin|, detalla las extensiones de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all you must choose a name for your plugin.  The features provided by the plugin should be clear from its name.  And it should be unlikely that someone else writes a plugin with the same name but which does something different.  And please limit the name to 8 characters, to avoid problems on old Windows systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, debe elegir un nombre para su extensión. El nombre debería mostrar las funcionalidades ofrecidas por la extensión. Así mismo, debería ser poco probable que alguien escriba una extensión con el mismo nombre pero otras funcionalidades. Por último, limite el nombre a ocho caracteres para evitar problemas en antiguos sistemas de Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A script that corrects typing mistakes could be called "typecorr.vim".  We will use it here as an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un script que corrige errores tipográficos se podría llamar «correccort.vim». Lo usaremos como ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronización
 19	let s:cuenta = 4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will probably add new corrections to the plugin and soon have several versions laying around.  And when distributing this file, people will want to know who wrote this wonderful plugin and where they can send remarks.  Therefore, put a header at the top of your plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo más probable es que añada nuevas correcciones a la extensión, y tenga en poco tiempo varias versiones de ésta. Cuando distribuya el archivo, la gente querrá saber quién escribió esta maravillosa extensión, y dónde pueden enviar comentarios. Por ello, incluya un encabezado al principio de su extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  1	" Extensión global de Vim para la corrección de errores
  2	" Último cambio:	15 de octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About copyright and licensing: Since plugins are very useful and it's hardly worth restricting their distribution, please consider making your plugin either public domain or use the Vim |license|.  A short note about this near the top of the plugin should be sufficient.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Derechos de autor y licencias: Debido a que las extensiones son útiles, y que no merece la pena restringir su distribución, considere que su extensión sea de dominio público, o use la licencia de Vim (|license|). Una breve nota cerca del inicio de la extensión debería servir. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  4	" License:	This file is placed in the public domain.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  4	" Licencia:	Este fichero pertenece al dominio público.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CONTINUACIÓN DE LÍNEA, EVITAR EFECTOS SECUNDARIOS	*use-cpo-save*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In line 18 above, the line-continuation mechanism is used |line-continuation|.  Users with 'compatible' set will run into trouble here, they will get an error message.  We can't just reset 'compatible', because that has a lot of side effects.  To avoid this, we will set the 'cpoptions' option to its Vim default value and restore it later.  That will allow the use of line-continuation and make the script work for most people.  It is done like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la línea 18 del ejemplo anterior se usa el mecanismo |line-continuation|, continuación de línea. Los usuarios que definan 'compatible' pueden encontrar problemas con esto, y se les mostraría un mensaje de error. No podemos simplemente reiniciar 'compatible' porque tiene muchos efectos secundarios. Para evitarlo, definimos la opción 'cpoptions' con el valor predeterminado de Vim para restaurarlo más tarde. Esto permite el uso de «line-continuation» y que el script funcione en la mayoría de sistemas. Se hace de la siguiente forma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..
 42	let &amp;cpo = s:save_cpo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We first store the old value of 'cpoptions' in the s:save_cpo variable.  At the end of the plugin this value is restored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero almacenamos el valor antiguo de 'cpoptions'  en la variable «s:save_cpo». El valor se restaurará al final de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a script-local variable is used |s:var|.  A global variable could already be in use for something else.  Always use script-local variables for things that are only used in the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que se usa una variable local de script, |s:var|. Puede que se esté utilizando una variable global para otra cosa. Use siempre variables locales en el script para aquello que se usa sólo en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's possible that a user doesn't always want to load this plugin.  Or the system administrator has dropped it in the system-wide plugin directory, but a user has his own plugin he wants to use.  Then the user must have a chance to disable loading this specific plugin.  This will make it possible: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible que el usuario no desee cargar la extensión en cada momento. O que el administrador del sistema lo haya copiado al directorio de extensiones del sistema, pero el usuario quiere usar el suyo propio. En ese caso, el usuario debe tener la posibilidad de desactivar cargar esta extensión en particular. Lo siguiente lo hace posible: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name is recommended to start with "loaded_" and then the file name of the plugin, literally.  The "g:" is prepended just to avoid mistakes when using the variable in a function (without "g:" it would be a variable local to the function).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda que el nombre empiece con «loaded_» y, a continuación, el nombre literal de la extensión. La «g:» se añade para evitar errores al usar la variable en una función (sin la «g:», sería una variable local a la función).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's make the plugin more interesting: We will add a mapping that adds a correction for the word under the cursor.  We could just pick a key sequence for this mapping, but the user might already use it for something else.  To allow the user to define which keys a mapping in a plugin uses, the &lt;Leader&gt; item can be used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, vamos a hacer que la extensión sea más interesante: vamos a añadir una macro que añade una corrección para la palabra bajo el cursor. Podríamos escoger una secuencia de teclas para esta macro, pero puede que el usuario la esté usando para otra cosa. Puede usar el elemento &lt;Leader&gt; para permitir que el usuario pueda definir las teclas que utiliza la macro de una extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user can set the "mapleader" variable to the key sequence that he wants this mapping to start with.  Thus if the user has done: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario puede definir la variable «mapleader» con la secuencia de teclas con la que desea iniciar esta macro. Por lo tanto, si el usuario define: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let mapleader = "_"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let mapleader = "_"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the mapping will define "_a".  If the user didn't do this, the default value will be used, which is a backslash.  Then a map for "\a" will be defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>la macro se definirá como «_a». En caso contrario se usará el valor predeterminado, que es una barra inversa. Por ello, se definiría una macro como «\a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that &lt;unique&gt; is used, this will cause an error message if the mapping already happened to exist. |:map-&lt;unique&gt;|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta se usa &lt;unique&gt;, lo que provocaría un mensaje de error si la macro ya existe.  |:map-&lt;unique&gt;|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 21	if !hasmapto('&lt;Plug&gt;CorreccortAñadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
 23	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This checks if a mapping to "&lt;Plug&gt;TypecorrAdd" already exists, and only defines the mapping from "&lt;Leader&gt;a" if it doesn't.  The user then has a chance of putting this in his vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto comprueba si ya existe una macro para «&lt;Plug&gt;CorrecortAñadir», y sólo define la macro de «&lt;Leader&gt;a» si no existe. Así, el usuario tiene la posibilidad de insertar esto en su archivo «vimrc»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	map ,c  &lt;Plug&gt;TypecorrAdd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	map ,c  &lt;Plug&gt;CorreccortAñadir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 30	function s:Anadir(desde, correccion)
 31	  let a = input("Introduzca la corrección para " . a:desde . ": ")
 32	  exe ":iabbrev " . a:desde . " " . a
 ..
 36	endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we can call the function s:Add() from within this script.  If another script also defines s:Add(), it will be local to that script and can only be called from the script it was defined in.  There can also be a global Add()  function (without the "s:"), which is again another function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora invocamos la función «s:Anadir()» desde el mismo script. Si otro script también define «s:Anadir()», será local a ese script y solo se invocará desde el script en el que se define. También puede existir una función global «Anadir()» (sin la «s:»), que es otra función distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt; can be used with mappings.  It generates a script ID, which identifies the current script.  In our typing correction plugin we use it like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar &lt;SID&gt; en una macro. Genera un identificador de script, que identifica al script actual. En nuestra extensión de corrección usaremos algo similar a esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 ..
 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAñadir  &lt;SID&gt;Añadir
 ..
 28	noremap &lt;SID&gt;Añadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	\a -&gt; &lt;Plug&gt;CorreccortAñadir -&gt; &lt;SID&gt;Añadir -&gt; :call &lt;SID&gt;Anadir()
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that instead of s:Add() we use &lt;SID&gt;Add() here.  That is because the mapping is typed by the user, thus outside of the script.  The &lt;SID&gt; is translated to the script ID, so that Vim knows in which script to look for the Add() function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que se usó «&lt;SID&gt;Anadir()» en lugar de «s:Anadir()» aquí. Eso es porque la macro es tecleada por el usuario, y por ello, se hace desde fuera del script. &lt;SID&gt; se expande al identificador del script, de forma que Vim sabe en qué script buscar la función «Anadir()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a bit complicated, but it's required for the plugin to work together with other plugins.  The basic rule is that you use &lt;SID&gt;Add() in mappings and s:Add() in other places (the script itself, autocommands, user commands).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un poco complicado, pero es necesario para que la extensión funcione adecuadamente con otras. La norma básica es que debe usar &lt;SID&gt;Anadir() en las macros y s:Anadir() en otros sitios (el mismo script, órdenes automáticas, órdenes de usuario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 26	noremenu &lt;script&gt; Plugin.Añadir\ Corrección      &lt;SID&gt;Añadir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Plugin" menu is recommended for adding menu items for plugins.  In this case only one item is used.  When adding more items, creating a submenu is recommended.  For example, "Plugin.CVS" could be used for a plugin that offers CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda el menú «Plugin» para añadir elementos de menú de extensiones. En este caso, sólo se usa un elemento. Recomendamos crear un menú secundario si añade más elementos. Por ejemplo, podría usar «Plugin.CVS» para una extensión que ofrezca operaciones CVS como «Plugin.CVS.checkin», «Plugin.CVS.checkout», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt; AND &lt;Plug&gt;					*using-&lt;Plug&gt;*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; Y &lt;Plug&gt;						*using-&lt;Plug&gt;*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both &lt;SID&gt; and &lt;Plug&gt; are used to avoid that mappings of typed keys interfere with mappings that are only to be used from other mappings.  Note the difference between using &lt;SID&gt; and &lt;Plug&gt;:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; y &lt;Plug&gt; se usan para evitar que las macros de las teclas pulsadas interfieran con macros sólo usadas desde otras macros. Note la diferencia entre &lt;SID&gt; y &lt;Plug&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Plug&gt;	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  &lt;Plug&gt; is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: &lt;Plug&gt; scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	This results in "&lt;Plug&gt;TypecorrAdd".  Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Plug&gt;	es visible fuera del script. Se usa para macros que el usuario
	pueda querer ligar a un secuencia de teclas. &lt;Plug&gt; es un código
	especial que una tecla nunca podrá producir.
	Para evitar que otras extensiones usen la misma secuencia de
	caracteres, use la estructura: &lt;Plug&gt; nombre-script nombre-macro
	En nuestro ejemplo, el nombre del script es «Correccort», y el nombre
	de la macro es «Añadir».
	El resultado es «&lt;Plug&gt;CorreccortAñadir». Solo el primer carácter de los
	nombres es mayúscula, facilitando ver el principio del nombre de la
	macro.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt;	is the script ID, a unique identifier for a script.
	Internally Vim translates &lt;SID&gt; to "&lt;SNR&gt;123_", where "123" can be any
	number.  Thus a function "&lt;SID&gt;Add()" will have a name "&lt;SNR&gt;11_Add()"
	in one script, and "&lt;SNR&gt;22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of &lt;SID&gt; in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; es el identificador (ID) del script, un número único.
	Internamente, Vim traduce &lt;SID&gt; como «&lt;SNR&gt;123_», donde «123»
	puede ser cualquier número. Por ello, la función «&lt;SID&gt;Anadir()»
	tendría el nombre «&lt;SNR&gt;11_Anadir()» en un script, y «&lt;SNR&gt;22_Anadir()»
	en otro. Puede verlo si usa la orden «:function» para obtener la lista de
	funciones.
	La traducción de &lt;SID&gt; en las macros es idéntica, y así puede invocar
	una función local de un script mediante una macro.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user command is defined only if no command with the same name already exists.  Otherwise we would get an error here.  Overriding the existing user command with ":command!" is not a good idea, this would probably make the user wonder why the command he defined himself doesn't work.  |:command|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden de usuario se define únicamente si no existe una orden con el mismo nombre. En caso contrario, provocaría un error. Sobrescribir la orden de usuario existente con «:command!» no es una buena idea, ya que haría que el usuario se pregunte porqué no funciona la orden que ha definido. |:command|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fun is that these variables can also be used in functions, autocommands and user commands that are defined in the script.  In our example we can add a few lines to count the number of corrections: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo interesante es que estas variables se pueden usar en funciones, órdenes automáticas y órdenes de usuario definidas en el script. En nuestro ejemplo, añadimos unas pocas líneas para contar el número de correcciones: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 19	let s:cuenta = 4
 ..
 30	function s:Anadir(desde, correccion)
 ..
 34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta . " correcciones en este punto"
 36	endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First s:count is initialized to 4 in the script itself.  When later the s:Add() function is called, it increments s:count.  It doesn't matter from where the function was called, since it has been defined in the script, it will use the local variables from this script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al principio, «s:cuenta» se inicializa en el mismo script con un valor de 4. Al invocar la función «Anadir()» posteriormente, incrementa la variable «s:cuenta». No importa desde dónde se ha invocado la función, ya que está definida en el script, y usará las variables locales al script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Line 33 wasn't explained yet.  It applies the new correction to the word under the cursor.  The |:normal| command is used to use the new abbreviation.  Note that mappings and abbreviations are expanded here, even though the function was called from a mapping defined with ":noremap".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún no hemos explicado la línea 33. Aplica la nueva corrección a la palabra bajo el cursor. La orden |:normal| se emplea para usar la nueva abreviatura. Tenga en cuenta que aquí se expanden las macros y abreviaturas, a pesar de que la función se ha invocado desde una macro definida con «:noremap».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before writing the file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda usar «unix» como valor para la opción 'fileformat'. De esta forma, los scripts de Vim funcionarán en cualquier sistema. Los scripts con 'fileformat' definido como «dos» no funcionarán en Unix. También puede consultar |:source_crnl|. Para asegurar que hace lo correcto, haga lo siguiente antes de escribir el archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set fileformat=unix
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set fileformat=unix
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DOCUMENTATION						*write-local-help*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DOCUMENTACIÓN   					*write-local-help*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	&lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  1	*correcort.txt*	Una extensión para corregir errores ortográficos
  2
  3	Esta extensión corrige automáticamente cualquier error ortográfico
  4	que pueda escribir.
  5
  6	Solo hay unas pocas correcciones. Puede añadir las suyas.
  7
  8	Macros:
  9	&lt;Leader&gt;a   o   &lt;Plug&gt;CorreccortAñadir
 10		Añade una corrección para la palabra bajo el cursor.
 11
 12	Órdenes:
 13	:Corregir {palabra}
 14		Añade una corrección para {palabra}.
 15
 16							*correcort-opciones*
 17	Esta extensión no tiene opciones de configuración.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first line is actually the only one for which the format matters.  It will be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of help.txt |local-additions|.  The first "*" must be in the first column of the first line.  After adding your help file do ":help" and check that the entries line up nicely.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, la primera línea es la única en la que el formato importa. Se extraerá del archivo de ayuda para su ubicación en la sección «LOCAL ADDITIONS:» de help.txt |local-additions|. El primer asterisco debe estar en la primera columna de la primera línea. Ejecute «:help» después de añadir su archivo de ayuda y compruebe que las entradas están alineadas adecuadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using references to other parts of the help in || is recommended.  This makes it easy for the user to find associated help.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda utilizar referencias a otras partes de archivos de ayuda mediante barras, ||. Esto facilita que el usuario encuentre ayuda relacionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FILETYPE DETECTION					*plugin-filetype*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIÓN DE TIPO DE ARCHIVO			*plugin-filetype*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your filetype is not already detected by Vim, you should create a filetype detection snippet in a separate file.  It is usually in the form of an autocommand that sets the filetype when the file name matches a pattern.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim no detecta su tipo de archivo, debería crear un fragmento de código de detección de tipo de archivo en un archivo separado. Habitualmente, tiene la forma de una orden automática que define el tipo de archivo cuando su nombre concuerda con un patrón. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	au BufNewFile,BufRead *.foo			set filetype=foofoo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	au BufNewFile,BufRead *.foo			set filetype=foofoo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write this single-line file as "ftdetect/foofoo.vim" in the first directory that appears in 'runtimepath'.  For Unix that would be "~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the filetype for the script name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba este archivo de una sola línea como «ftdetect/foofoo.vim» en el primer directorio que aparece en su 'runtimepath'. En Unix, sería «~/.vim/ftdetect/foofoo.vim». La convención es nombrar el script como el nombre del tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make more complicated checks if you like, for example to inspect the contents of the file to recognize the language.  Also see |new-filetype|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo desea, puede hacer comprobaciones más complejas como inspeccionar los contenidos de un archivo para reconocer el tipo del mismo. Consulte también |new-filetype|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUMMARY							*plugin-special*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>RESUMEN							*plugin-special*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>s:name			Variables local to the script.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>s:nombre		Variables locales al script.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt;			Script-ID, used for mappings and functions local to
			the script.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt;			El identificador del script (Script-ID), utilizado en
			macros y funciones locales al script.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>hasmapto()		Una función que comprueba si el usuario ya ha definido
			una macro para la funcionalidad que el script ofrece.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Leader&gt;		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Leader&gt;		El valor de «mapleader», que el usuario define como
			las teclas con las que iniciar las macros de extensiones.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;unique&gt;		Give a warning if a mapping already exists.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>::map &lt;unique&gt;		Emite un aviso si la macro ya existe.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap &lt;script&gt;	Use only mappings local to the script, not global
			mappings.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap &lt;script&gt;	Sólo usa macros locales al script, no macros globales.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exists(":Cmd")		Check if a user command already exists.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>exists(":Orden")	Comprueba la existencia de una orden de usuario.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					*write-filetype-plugin* *ftplugin*
*41.12*	Escribir extensiones de tipo de archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A filetype plugin is like a global plugin, except that it sets options and defines mappings for the current buffer only.  See |add-filetype-plugin| for how this type of plugin is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una extensión de tipo de archivo («filetype plugin») es como una extensión global, a diferencia de que define opciones y macros que solo afectan al búfer local. Para saber más acerca del uso de este tipo de extensión, consulte  |add-filetype-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First read the section on global plugins above |41.11|.  All that is said there also applies to filetype plugins.  There are a few extras, which are explained here.  The essential thing is that a filetype plugin should only have an effect on the current buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En primer lugar, consulte la sección anterior sobre extensiones globales, |41.11|. Todo lo detallado ahí también afecta a las extensiones de tipo de archivo. Hay algunos elementos adicionales, que se explican aquí. Lo esencial es que una extensión de tipo de archivo sólo debe tener efecto en el búfer actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are writing a filetype plugin to be used by many people, they need a chance to disable loading it.  Put this at the top of the plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esta escribiendo una extensión de tipo de archivo que mucha gente usará, necesitarán la capacidad de desactivar su carga. Inserte lo siguiente al principio de la extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	" Solo hace esto cuando aún no ha finalizado con este búfer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let b:did_ftplugin = 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let b:did_ftplugin = 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	setlocal textwidth=70
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	setlocal textwidth=70
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now write this in the "after" directory, so that it gets sourced after the distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be "~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set "b:did_ftplugin", but it is ignored here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba esto en el directorio «after», para que se lea después de la extensión de tipo de archivo predeterminado distribuido, «vim.vim» |after-directory|.  En sistemas Unix, sería «~/.vim/after/ftplugin/vim.vim». Tenga en cuenta que la extensión predeterminada habrá definido «b:did_ftplugin», pero aquí se ignora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:setlocal
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:setlocal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an option has a value that is a list of flags or items, consider using "+=" and "-=" to keep the existing value.  Be aware that the user may have changed an option value already.  First resetting to the default value and then changing it often a good idea.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una opción tiene un valor que es una lista de opciones o elementos, considere usar «+=» y «-=» para conservar el valor existente. Sea consciente de que puede que el usuario ya haya cambiado el valor de una opción. Es una buena idea restablecer el valor original y después cambiarlo. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:setlocal formatoptions&amp; formatoptions+=ro
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:setlocal formatoptions&amp; formatoptions+=ro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;buffer&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;buffer&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|hasmapto()| is used to check if the user has already defined a map to &lt;Plug&gt;JavaImport.  If not, then the filetype plugin defines the default mapping.  This starts with |&lt;LocalLeader&gt;|, which allows the user to select the key(s) he wants filetype plugin mappings to start with.  The default is a backslash.  "&lt;unique&gt;" is used to give an error message if the mapping already exists or overlaps with an existing mapping.  |:noremap| is used to avoid that any other mappings that the user has defined interferes.  You might want to use ":noremap &lt;script&gt;" to allow remapping mappings defined in this script that start with &lt;SID&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|hasmapto()| sirve para comprobar si el usuario ya ha definido una macro para «&lt;Plug&gt;JavaImport». Si no ha sido definida, la extensión de tipo de archivo define la macro actual. Esta empieza con |&lt;LocalLeader&gt;|, que permite al usuario seleccionar una o mas teclas con las que iniciar las macros de la extensión de tipo de archivo. El valor predeterminado es una barra inversa, «\». «&lt;unique&gt;» sirve para emitir un mensaje de error si la macro ya existe o entra en conflicto con otra. |:noremap| sirve para evitar que las macros definidas por el usuario interfieran. Puede que desee usar «:noremap &lt;script&gt;» para permitir redefinir macros en el script que comienza con &lt;SID&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user must have a chance to disable the mappings in a filetype plugin, without disabling everything.  Here is an example of how this is done for a plugin for the mail filetype: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene que ofrecer al usuario la opción de desactivar macros en una extensión de tipo de archivo, sin desactivar el resto. Aquí tiene un ejemplo de como hacerlo con una extensión para el tipo de archivo mail: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Quote text by inserting "&gt; "
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	" Añade macros, a menos que el usuario defina lo contrario.
	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Cita el texto insertando «&gt; »
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two global variables are used:
no_plugin_maps		disables mappings for all filetype plugins
no_mail_maps		disables mappings for a specific filetype
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se utilizan dos variables globales:
no_plugin_maps		desactiva las macros de todas las extensiones de tipo
			de archivo
no_mail_maps		desactiva las macros para un tipo de archivo
			particular
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a user command for a specific file type, so that it can only be used in one buffer, use the "-buffer" argument to |:command|.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-buffer» de |:command| permite añadir una orden de usuario para un tipo de archivo específico y que solo afecta al búfer local. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:command -buffer  Make  make %:r.s
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:command -buffer  Make  make %:r.s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When defining a function, this only needs to be done once.  But the filetype plugin will be sourced every time a file with this filetype will be opened.  This construct makes sure the function is only defined once: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada función necesita ser definida una sola vez. Pero la extensión de tipo de archivo se cargará cada vez que se abra un archivo del tipo correspondiente. Esta estructura asegura que la función se defina una sola vez: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
&lt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UNDO							*undo_ftplugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DESHACER 					*undo_ftplugin*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the user does ":setfiletype xyz" the effect of the previous filetype should be undone.  Set the b:undo_ftplugin variable to the commands that will undo the settings in your filetype plugin.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando el usuario hace «:setfiletype xyz», el efecto del tipo de archivo anterior debería desaparecer. Defina la variable «b:undo_ftplugin» con las órdenes que deshacen los cambios de configuración de su extensión de tipo de archivo.  Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using ":setlocal" with "&lt;" after the option name resets the option to its global value.  That is mostly the best way to reset the option value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «:setlocal» con «&lt;» después del nombre de la opción restablece la opción a su valor global. Habitualmente, es la mejor forma de restablecer el valor de una opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The filetype must be included in the file name |ftplugin-name|.  Use one of these three forms:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del archivo debe incluir el tipo de archivo |ftplugin-name|. Puede usar una de las tres formas a continuación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	.../ftplugin/algo.vim
	.../ftplugin/algo_foo.vim
	.../ftplugin/algo/bar.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUMMARY							*ftplugin-special*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>RESUMEN							*ftplugin-special*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;LocalLeader&gt;		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;LocalLeader&gt;		El valor de «maplocalleader», que el usuario define
			como la tecla que inicia las macros de extensión de
			tipo de archivo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;buffer&gt;		Define a mapping local to the buffer.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;buffer&gt;		Define una macro local al búfer.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap &lt;script&gt;	Only remap mappings defined in this script that start
			with &lt;SID&gt;.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap &lt;script&gt;	Sólo modifica macros definidas en el script que
			comienzan con &lt;SID&gt;.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal		Set an option for the current buffer only.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal		Define una opción para el búfer actual.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -buffer	Define a user command local to the buffer.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -buffer	Define una orden de usuario local al búfer.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exists("*s:Func")	Check if a function was already defined.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>exists("*s:Funcion")	Comprueba si una función ya se ha definido
			anteriormente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.13*	Writing a compiler plugin		*write-compiler-plugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.13*	Escribir extensiones para compiladores	*write-compiler-plugin*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A compiler plugin sets options for use with a specific compiler.  The user can load it with the |:compiler| command.  The main use is to set the 'errorformat' and 'makeprg' options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una extensión de compilador define opciones a usar con un compilador específico. El usuario puede cargarlo con la orden |:compiler|. El uso principal es definir las opciones 'errorformat' y 'makeprg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easiest is to have a look at examples.  This command will edit all the default compiler plugins: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo más sencillo es ver unos ejemplos. Esta orden editará todas las extensiones de compilador predeterminadas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:next $VIMRUNTIME/compiler/*.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:next $VIMRUNTIME/compiler/*.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two special items about these files.  First is a mechanism to allow a user to overrule or add to the default file.  The default files start with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos aspectos a tener en cuenta con estas extensiones. En primer lugar, deben contar con un mecanismo que permita al usuario anular o añadir cambios a la extensión. Las extensiones predeterminadas comienzan con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
							*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando escribe un archivo de compilador, y lo ubica en su directorio de
ejecución personal (esto es, «~/.vim/compiler» en sistemas Unix), debe definir
la variable «current_compiler» para que la extensión de compilador
predeterminada evite hacer cambios en la configuración.
							*:CompilerSet*
El segundo mecanismo es usar «:set» con «:compiler!», y «:setlocal» con
«:compiler». Para ello, Vim define la orden de usuario «:CompilerSet». Por
otra parte, las versiones anteriores de Vim no cuentan de ella, y por ello su
extensión debe definirlo. Aquí tiene un ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" use the default 'errorformat'
  CompilerSet makeprg=nmake
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" usa 'errorformat' predeterminado
  CompilerSet makeprg=nmake
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler plugin for the Vim distribution or for a system-wide runtime directory, use the mechanism mentioned above.  When "current_compiler" was already set by a user plugin nothing will be done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use el mecanismo mostrado aquí cuando escriba una extensión de compilador para la distribución Vim o para un directorio de tiempo de ejecución del sistema. No se hará nada si «current_compiler» ya está definido por una extensión de usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler plugin to overrule settings from a default plugin, don't check "current_compiler".  This plugin is supposed to be loaded last, thus it should be in a directory at the end of 'runtimepath'.  For Unix that could be ~/.vim/after/compiler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando escribe una extensión de compilador para cambiar las opciones definidas por una extensión predeterminada, evite comprobar «current_compiler». Esta extensión se debería cargar al final, y por ello debería estar en un directorio al final de 'runtimepath'. En sistemas Unix, podría ser «~/.vim/after/compiler».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.14*	Escribir extensiones que carguen rápidamente  *write-plugin-quickload*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A plugin may grow and become quite long.  The startup delay may become noticeable, while you hardly ever use the plugin.  Then it's time for a quickload plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que una extensión crezca, y que sea demasiado larga. Puede que el tiempo de carga empiece a hacerse notorio, y además, que usted apenas use la extensión. En este caso, hay que usar una extensión de carga rápida («quickload»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic idea is that the plugin is loaded twice.  The first time user commands and mappings are defined that offer the functionality.  The second time the functions that implement the functionality are defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La idea principal es que la extensión se carga dos veces. La primera vez, se definen las órdenes de usuario y macros que ofrecen la funcionalidad de la extensión. La segunda vez, se definen las funciones que implementan tales funcionalidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may sound surprising that quickload means loading a script twice.  What we mean is that it loads quickly the first time, postponing the bulk of the script to the second time, which only happens when you actually use it.  When you always use the functionality it actually gets slower!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que sorprenda que «carga rápida» signifique cargar una extensión dos veces.  Lo que queremos decir es que se carga rápidamente la primera, demorando la carga de la mayoría de la extensión a la segunda vez, lo que sólo ocurre cuando realmente la usa. ¡Si usa siempre la funcionalidad que provee la extensión, no obtendrá ninguna ventaja!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" License:	This file is placed in the public domain.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	" Extensión global de Vim para mostrar la carga rápida
	" Último cambio:	2005 Feb 25
	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" Licencia:	Este archivo se encuentra en el dominio público
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('algo')&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read functionality here
	endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" Funcionalidad de lectura aquí
	endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write functionality here
	endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" Funcionalidad de escritura aquí
	endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second time the script is loaded "s:did_load" exists and the commands after the "endif" are executed.  This defines the (possible long)  BufNetRead() and BufNetWrite() functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda vez que se carga, «s:did_load» existe y se ejecutan las órdenes después de «endif». Esto define las (posiblemente largas) funciones BufNetRead() y BufNetWrite().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you drop this script in your plugin directory Vim will execute it on startup.  This is the sequence of events that happens:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ubica este script en su directorio «plugin», Vim lo ejecutará al inicio. A continuación la secuencia de los eventos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. The "BNRead" command is defined and the &lt;F19&gt; key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Se define la orden «BNRead» y la tecla &lt;F19&gt; se asigna a una macro al cargar
el script al inicio. Se define una orden automática |FuncUndefined|. La orden
  «:finish» hace que el script finalice antes.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. The user types the BNRead command or presses the &lt;F19&gt; key.  The
   BufNetRead() or BufNetWrite() function will be called.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. El usuario introduce la orden «BNRead» o pulsa la tecla &lt;F19&gt;. Se
  invoca la función «BufNetRead()» o «BufNetWrite()».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "&lt;sfile&gt;" (see |expand()|).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3. Vim no puede encontrar la función y ejecuta la orden automática
  |FuncUndefined|. Ya que el patrón «BufNet*» coincide con la función invocada,
  se ejecutará la orden «source nombre-archivo». «nombre-archivo» debe ser
  igual al nombre del script, sin importar su ubicación, ya que procede de
  expandir «&lt;sfile&gt;» (consulte |expand()|).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>4. El script se carga otra vez, la variable «s:did_load» existe, y se
   definen las funciones.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the functions that are loaded afterwards match the pattern in the |FuncUndefined| autocommand.  You must make sure that no other plugin defines functions that match this pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que las funciones se cargan después de comparar el patrón en la orden automática |FuncUndefined|. Debe comprobar que ninguna otra extensión define funciones que coincidan con este patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.15*	Writing library scripts			*write-library-script*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.15*	Crear bibliotecas				*write-library-script*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some functionality will be required in several places.  When this becomes more than a few lines you will want to put it in one script and use it from many scripts.  We will call that one script a library script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas funcionalidades son necesarias en varios lugares. Cuando se trata de algo más que unos pocas líneas, querrá ubicarlo en un script, y usarlo desde varios otros. Vamos a denominar ese script como biblioteca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually loading a library script is possible, so long as you avoid loading it when it's already done.  You can do this with the |exists()| function.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cargar una biblioteca manualmente es posible, siempre que evite cargarla cuando ya lo está. Puede evitarlo con la función |exists()|. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if !exists('*MiFuncionBiblioteca')
	   runtime library/biblioteca.vim
	endif
	call MiFuncionBiblioteca(arg)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make this a bit simpler Vim offers the autoload mechanism.  Then the example looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer esto más sencillo, Vim ofrece el mecanismo «autoload» (carga automática). Así, el ejemplo tendría este aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	call mylib#myfunction(arg)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	call mibiblioteca#mifuncion(arg)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a lot simpler, isn't it? Vim will recognize the function name and when it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.  That script must define the "mylib#myfunction()" function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mucho más sencillo, ¿verdad? Vim reconoce el nombre de la función y, cuando no esté definida, la buscará el script «autoload/mibiblioteca.vim» en 'runtimepath'. El script debe definir la función «mibiblioteca#mifuncion()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put many other functions in the mylib.vim script, you are free to organize your functions in library scripts.  But you must use function names where the part before the '#' matches the script name.  Otherwise Vim would not know what script to load.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede almacenar varias funciones en el script mibiblioteca.vim, y puede organizar como desee las funciones en sus bibliotecas. Pero debe usar nombres de funciones en las que la parte que precede a «#» coincide con el nombre del script. En caso contrario, Vim no sabrá qué script cargar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you get really enthusiastic and write lots of library scripts, you may want to use subdirectories.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto le entusiasma, y escribe muchas bibliotecas, puede que quiera usar subdirectorios. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	call netlib#ftp#read('somefile')
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	call netlib#ftp#read('somefile')
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	~/.vim/autoload/netlib/ftp.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	~/.vim/autoload/netlib/ftp.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	function netlib#ftp#read(nombre_archivo)
		"  Lee al archivo mediante FTP
	endfunction
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the name the function is defined with is exactly the same as the name used for calling the function.  And the part before the last '#' exactly matches the subdirectory and script name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que el nombre con el que se define la función es idéntico al utilizado para invocar la función. Y la parte a continuación del último «#» coincide con el subdirectorio y el nombre del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let weekdays = dutch#weekdays
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let dias_semana = colombia#dias_semana
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let colombia#dias_semana = ['lunes', 'martes', 'miércoles', 'jueves',
		\ 'viernes', 'sábado', 'domingo']
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.16*	Distributing Vim scripts			*distribute-script*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.16*	Distribuir scripts de Vim			*distribute-script*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim users will look for scripts on the Vim website: http://www.vim.org.  If you made something that is useful for others, share it!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los usuarios de Vim buscarán scripts en el sitio web de Vim: http://www.vim.org. Si ha creado algo útil para otros, ¡compártalo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim scripts can be used on any system.  There might not be a tar or gzip command.  If you want to pack files together and/or compress them the "zip" utility is recommended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los scripts de Vim se pueden usar en cualquier sistema. Las órdenes tar o gzip pueden no estar disponibles en dichos sistemas. Si desea empaquetar o comprimir los archivos, se recomienda usar la herramienta «zip».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For utmost portability use Vim itself to pack scripts together.  This can be done with the Vimball utility.  See |vimball|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para obtener la máxima portabilidad use Vim para empaquetar los scripts. Puede hacer esto con la herramienta Vimball. Consulte |vimball|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's good if you add a line to allow automatic updating.  See |glvs-plugins|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es una buena idea añadir una línea para pemitir la actualización automática. Consulte |glvs-plugins|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set softtabstop=4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set softtabstop=4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_30.txt*	For Vim version 7.3.  Last change: 2007 Nov 10
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_30.esx*	Para Vim versión 7.3.  Último cambio: 10/11/2007
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Editing programs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			    Edición de programas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|30.1|	Compiling
|30.2|	Indenting C files
|30.3|	Automatic indenting
|30.4|	Other indenting
|30.5|	Tabs and spaces
|30.6|	Formatting comments
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|30.1|	Compilar
|30.2|	Sangrado en archivos C
|30.3|	Sangrado automático
|30.4|	Otros sangrados
|30.5|	Tabulados y espacios
|30.6|	Formatear comentarios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_31.txt|  Exploiting the GUI
 Previous chapter: |usr_29.txt|  Moving through programs
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_31.esx|  Sacar partido a la interfaz gráfica
  Capítulo anterior: |usr_29.esx|  Moverse a través de programas
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.1*	Compiling
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.1*	Compilar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a set of so called "quickfix" commands.  They enable you to compile a program from within Vim and then go through the errors generated and fix them (hopefully).  You can then recompile and fix any new errors that are found until finally your program compiles without any error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene un conjunto de órdenes de arreglos rápidos («quickfix»). Permiten compilar un programa desde Vim y después navegar a través de los errores generados y (posiblemente) arreglarlos. Puede después recompilar y arreglar cualquier error nuevo detectado hasta que finalmente su programa se compile sin problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:make {arguments}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:make {arguments}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If errors were generated, they are captured and the editor positions you where
the first error occurred.
   Take a look at an example ":make" session.  (Typical :make sessions generate
far more errors and fewer stupid ones.)  After typing ":make" the screen looks
like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se genera algún error, se captura y el editor le posicionará sobre el primer error.
   Este es un ejemplo de una sesión típica de «:make». (Las sesiones típicas de
«:make» generan muchos menos errores y menos errores estúpidos.) La pantalla
presentará este aspecto después de teclear «:make»:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!make | &amp;tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!make | &amp;tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From this you can see that you have errors in the file "main.c".  When you press &lt;Enter&gt;, Vim displays the file "main.c", with the cursor positioned on line 6, the first line with an error.  You did not need to specify the file or the line number, Vim knew where to go by looking in the error messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver que tiene errores en el archivo «main.c». Cuando pulse &lt;Intro&gt;, Vim mostrará el archivo «main.c», con el cursor posicionado en la línea 6, la primera con un error. No necesitó definir el archivo o el número de línea, ya que Vim sabe dónde ir analizando los mensajes de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -&gt; |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -&gt; |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cnext
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cnext
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim jumps to line 10, the last line in the file, where there is an extra '}'.
   When there is not enough room, Vim will shorten the error message.  To see
the whole message use: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim salta a la línea 10, la última línea en el archivo, donde hay un «}»
adicional.
   Cuando no hay suficiente espacio Vim acorta el mensaje de error. Para ver
el mensaje completo, use lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get an overview of all the error messages with the ":clist" command.  The output looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener una visión general de todos los mensajes de error con la orden «:clist». La salida tiene el siguiente aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:clist
&lt;	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:clist
&lt;	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the lines where Vim recognized a file name and line number are listed here.  It assumes those are the interesting lines and the rest is just boring messages.  However, sometimes unrecognized lines do contain something you want to see.  Output from the linker, for example, about an undefined function.  To see all the messages add a "!" to the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se muestran las líneas donde Vim reconoció un nombre de archivo y un número de línea. Asume que aquéllas son las líneas de interés, mientras que toma el resto como mensajes aburridos. Aún así, a veces las líneas no reconocidas contiene algo que desea ver. Por ejemplo, la salida del enlazador acerca de una función no definida. Para ver todos los mensajes, añada «!» a la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:clist!
&lt;	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡	:clist!
&lt;	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will highlight the current error.  To go back to the previous error, use:
&gt;
	:cprevious
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim resaltará el error actual. Use lo siguiente para volver al error anterior: &gt;
	:cprevious
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cfirst		to first error
	:clast		to last error
	:cc 3		to error nr 3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cfirst		primer error
	:clast		último error
	:cc 3		error número 3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the program to run when the ":make" command is executed is defined by the 'makeprg' option.  Usually this is set to "make", but Visual C++ users should set this to "nmake" by executing the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del programa a ejecutar cuando usa la orden «:make» se define con la opción 'makeprg'. Habitualmente, esto se define como «make», pero usuarios de Visual C++ deberían definir esto como «nmake» ejecutando la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set makeprg=nmake
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set makeprg=nmake
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also include arguments in this option.  Special characters need to be escaped with a backslash.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede incluir argumentos en esta opción. Los caracteres especiales se deben escapar con una barra inversa. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set makeprg=nmake\ -f\ project.mak
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set makeprg=nmake\ -f\ project.mak
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can include special Vim keywords in the command specification.  The %
character expands to the name of the current file.  So if you execute the
command: &gt;
	:set makeprg=make\ %
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede incluir palabras clave especiales de Vim al especificar la orden. El
carácter «%» se expande con el nombre del archivo actual. Así que se
ejecuta la siguiente orden: &gt;
	:set makeprg=make\ %
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	make main.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	make main.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set makeprg=make\ %:r.o
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set makeprg=make\ %:r.o
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	make main.o
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	make main.o
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you ":make" a program.  There is a warning message in one file and an error message in another.  You fix the error and use ":make" again to check if it was really fixed.  Now you want to look at the warning message.  It doesn't show up in the last error list, since the file with the warning wasn't compiled again.  You can go back to the previous error list with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que compila un programa con «:make». Hay un mensaje de aviso en un archivo y un mensaje de error en otro. Arregla el mensaje y usa «:make» otra vez para comprobar que lo ha arreglado. Ahora desea ver el mensaje de aviso. No aparece en la última lista de errores ya que aún no se ha compilado el archivo con el aviso. Puede volver a la lista de errores previa con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:colder
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:colder
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use ":clist" and ":cc {nr}" to jump to the place with the warning.
   To go forward to the next error list: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora «:clist» y «:cc {nr}» para saltar al lugar con el aviso.
   Use lo siguiente para avanzar a la siguiente lista de errores: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cnewer
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cnewer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to tell Vim what format the error messages are that your compiler produces.  This is done with the 'errorformat' option.  The syntax of this option is quite complicated and it can be made to fit almost any compiler.  You can find the explanation here: |errorformat|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene que indicar a Vim el formato de los mensajes de error que produce su compilador. Se puede hacer con la opción 'errorformat'. La sintaxis de esta opción es algo complicada, y puede hacer que encaje con prácticamente cualquier compilador. Puede encontrar la explicación aquí: |errorformat|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might be using various different compilers.  Setting the 'makeprg' option, and especially the 'errorformat' each time is not easy.  Vim offers a simple method for this.  For example, to switch to using the Microsoft Visual C++ compiler: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que esté usando varios compiladores diferentes. Definir la opción 'makeprg' y especialmente la opción 'errorformat' cada vez no es un tarea sencilla. Vim ofrece una forma sencilla de hacer esto. Por ejemplo, para cambiar al compilador Microsoft Visual C++: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:compiler msvc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:compiler msvc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will find the Vim script for the "msvc" compiler and set the appropriate
options.
   You can write your own compiler files.  See |write-compiler-plugin|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden encontrará el script de Vim para el compilador «msvc» y definirá
las opciones adecuadas.
   Puede escribir sus propios archivos de compilador. Consulte
|write-compiler-plugin|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":make" command redirects the output of the executed program to an error file.  How this works depends on various things, such as the 'shell'.  If your ":make" command doesn't capture the output, check the 'makeef' and 'shellpipe' options.  The 'shellquote' and 'shellxquote' options might also matter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:make» redirige la salida del programa ejecutado a un archivo error. El modo en que esto último funciona depende de varias cosas, tales como la consola ('shell'). Si su orden «:make» no captura la salida, compruebe las opciones 'makeef' y 'shellpipe'. Las opciones 'shellquote' y 'shellxquote' también son de importancia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you can't get ":make" to redirect the file for you, an alternative is to compile the program in another window and redirect the output into a file.  Then have Vim read this file with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el caso de que no pueda hacer que «:make» redirija la salida del archivo, una alternativa es compilar el programa en otra ventana y redirigir la salida al archivo. Después, haga que Vim lea este archivo con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:cfile {filename}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:cfile {filename}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.2*	Indenting C style text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.2*	Sangrado en archivos C
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A program is much easier to understand when the lines have been properly indented.  Vim offers various ways to make this less work.  For C or C style programs like Java or C++, set the 'cindent' option.  Vim knows a lot about C programs and will try very hard to automatically set the indent for you.  Set the 'shiftwidth' option to the amount of spaces you want for a deeper level.  Four spaces will work fine.  One ":set" command will do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un programa es mucho más fácil de entender cuando las líneas tienen un sangrado adecuado. Vim ofrece varias formas de facilitar esto. Para programas C o con estilo C como Java o C++, defina la opción 'cindent'. Vim sabe mucho acerca de programas C e intentará definir el sangrado automáticamente. Defina la opción 'shiftwidth'  con el número de espacios que desea para cada nivel de profundidad. Cuatro espacios funcionarán bien. Puede hacerlo con una orden 'set': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set cindent shiftwidth=4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set cindent shiftwidth=4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				    if (flag)
	Automatic indent   ---&gt;		do_the_work();
	Automatic unindent &lt;--	    if (other_flag) {
	Automatic indent   ---&gt;		do_file();
	keep indent			do_some_more();
	Automatic unindent &lt;--	    }
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				    if (opción)
	Sangrado automático  ---&gt;		do_the_work();
	Eliminar sangrado automático &lt;--	    if (otra_opción) {
	Sangrado automático   ---&gt;		do_file();
	Preservar el sangrado			do_some_more();
	Eliminar sangrado automático &lt;--	    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type something in curly braces ({}), the text will be indented at the start and unindented at the end.  The unindenting will happen after typing the '}', since Vim can't guess what you are going to type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando teclee algo entre llaves ({}), el texto tendrá un sangrado al inicio, pero no al final. La eliminación de sangrado («unindenting») aparecerá después de teclear '}', ya que Vim no puede adivinar qué va a escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One side effect of automatic indentation is that it helps you catch errors in
your code early.  When you type a } to finish a function, only to find that
the automatic indentation gives it more indent than what you expected, there
is probably a } missing.  Use the "%" command to find out which { matches the
} you typed.
   A missing ) and ; also cause extra indent.  Thus if you get more white
space than you would expect, check the preceding lines.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un efecto secundario del sangrado automático es que le permite encontrar
los errores en su código de manera temprana. Si teclea «}» para finalizar
una función y ve que el sangrado automático la da más del esperado,
puede que falte un «}». Use la orden «%» para encontrar qué «{»
encaja con la «}» que introdujo.
  Un «)» y «;» omitido también causan un sangrado adicional. Por ello, si
obtiene más espacios en blanco del esperado, compruebe la líneas precedentes.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have code that is badly formatted, or you inserted and deleted lines, you need to re-indent the lines.  The "=" operator does this.  The simplest form is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene código mal formateado, o si ha insertado o eliminado líneas, tendrá que sangrar las líneas nuevamente. El operador «=» hace esto. La forma más simple es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	==
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	==
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	=a{
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	=a{
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I you have really badly indented code, you can re-indent the whole file with:
&gt;
	gg=G
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene código con un pésimo sangrado, puede sangrar nuevamente el archivo
completo con: &gt;
	gg=G
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, don't do this in files that have been carefully indented manually.  The automatic indenting does a good job, but in some situations you might want to overrule it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, no lo haga en los archivos que han sido cuidadosamente sangrados manualmente.  El sangrado automático hace un buen trabajo, pero en algunas situaciones puede que desee anularlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different people have different styles of indentation.  By default Vim does a
pretty good job of indenting in a way that 90% of programmers do.  There are
different styles, however; so if you want to, you can customize the
indentation style with the 'cinoptions' option.
   By default 'cinoptions' is empty and Vim uses the default style.  You can
add various items where you want something different.  For example, to make
curly braces be placed like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Diferentes personas tienen diferentes estilos de sangrado. Por omisión,
Vim realiza un buen trabajo de sangrado de la manera en que lo hace el
90% de los programadores.
Aun así, hay diferentes estilos; así que si lo desea, puede personalizar el
estilo de sangrado con la opción 'cinoptions'.
   Por omisión, 'cinoptions' está vacío, usando Vim el estilo
 predeterminado. Puede añadir varios elementos cuando desee algo
diferente. Por ejemplo, para ubicar llaves de la siguiente forma:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if (opción) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set cinoptions+={2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set cinoptions+={2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many of these items.  See |cinoptions-values|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay muchos de estos elementos. Consulte |cinoptions-values|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.3*	Automatic indenting
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.3*	Sangrado automático
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't want to switch on the 'cindent' option manually every time you edit a C file.  This is how you make it work automatically: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No desea activar la opción 'cindent' manualmente cada vez que edite un archivo C. Esta es la forma de hacer que funcione automáticamente: &gt; </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:filetype indent on
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:filetype indent on
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, this does a lot more than switching on 'cindent' for C files.  First
of all, it enables detecting the type of a file.  That's the same as what is
used for syntax highlighting.
   When the filetype is known, Vim will search for an indent file for this
type of file.  The Vim distribution includes a number of these for various
programming languages.  This indent file will then prepare for automatic
indenting specifically for this file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, esto hace mucho más que activar 'cindent'  para archivos C.
En primer lugar, activa la detección de tipo de archivo. Es igual a lo
usado para el resaltado de sintaxis.
   Si el tipo de archivo es conocido, Vim buscará un archivo de sangrado para
este tipo de archivo. La distribución de Vim incluye un número para estos
lenguajes de programación.
Este archivo de sangrado preparará automáticamente el sangrado específico
para este archivo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:filetype indent off
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:filetype indent off
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like the indenting for one specific type of file, this is how you avoid it.  Create a file with just this one line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gusta el sangrado para un tipo específico de archivo, esta es la forma de evitarlo. Cree un archivo con sólo esta línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:let b:did_indent = 1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:let b:did_indent = 1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{directory}/indent/{filetype}.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{directorio}/indent/{tipo-de-archivo}.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {filetype} is the name of the file type, such as "cpp" or "java".  You can see the exact name that Vim detected with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El {tipo-de-archivo} es el nombre del tipo de archivo, por ejemplo, «cpp» o «java». Puede ver el nombre exacto de archivo que Vim ha detectado con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set filetype
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set filetype
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	filetype=help ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	filetype=help ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you would use "help" for {filetype}.
   For the {directory} part you need to use your runtime directory.  Look at
the output of this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, usaría «help» para {tipo-de-archivo}.
   Para la parte de {directorio}, necesita usar su directorio de tiempo de
ejecución. Mire la salida de esta orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set runtimepath
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set runtimepath
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the first item, the name before the first comma.  Thus if the output looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora use el primer elemento, el nombre que precede a la primera coma. Así, la salida tiene el siguiente aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You use "~/.vim" for {directory}.  Then the resulting file name is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «~/.vim» para el {directorio}. Entonces, el nombre del archivo resultante es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	~/.vim/indent/help.vim ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	~/.vim/indent/help.vim ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of switching the indenting off, you could write your own indent file.  How to do that is explained here: |indent-expression|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de desactivar el sangrado, podría escribir su propio archivo de sangrado. La manera de hacerlo se explica aquí: |indent-expression|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.4*	Other indenting
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.4*	Otros sangrados
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are using 'autoindent' or 'smartindent' to get the indent of the
previous line, there will be many times when you need to add or remove one
'shiftwidth' worth of indent.  A quick way to do this is using the CTRL-D and
CTRL-T commands in Insert mode.
   For example, you are typing a shell script that is supposed to look like
this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use 'autoindent' o 'smartindent' para obtener el sangrado de línea
anterior, habrá ocasiones en que necesite añadir o eliminar un 'shiftwidth'
de sangrado. La forma rápida de hacerlo es usando las órdenes «CTRL-D»
y «CTRL-T» en modo Insertar.
   Por ejemplo, está escribiendo un script de consola con el siguiente
aspecto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set autoindent shiftwidth=3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set autoindent shiftwidth=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if test -n a; then ~
	echo ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if test -n a; then ~
	echo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you see that you need an extra indent.  Type CTRL-T.  The result:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora ve que necesita un sangrado adicional. Pulse«CTRL-T». El resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if test -n a; then ~
	   echo ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if test -n a; then ~
	   echo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-T command, in Insert mode, adds one 'shiftwidth' to the indent, no
matter where in the line you are.
   You continue typing the second line, &lt;Enter&gt; and the third line.  This time
the indent is OK.  Then &lt;Enter&gt; and the last line.  Now you have this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «CTRL-T», en modo Insertar, añade un 'shiftwidth' al sangrado sin
importar en que línea está.
   Continua escribiendo en la segunda línea, &lt;Intro&gt;, y la tercera línea. Esta
vez el sangrado es correcto. Pulse &lt;Intro&gt; y salte a la última línea. Ahora
tiene lo siguiente:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove the superfluous indent in the last line press CTRL-D.  This deletes
one 'shiftwidth' worth of indent, no matter where you are in the line.
   When you are in Normal mode, you can use the "&gt;&gt;" and "&lt;&lt;" commands to
shift lines.  "&gt;" and "&lt;" are operators, thus you have the usual three ways to
specify the lines you want to indent.  A useful combination is: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar el sangrado innecesario en la última línea pulse «CTRL-D». Elimina
un 'shiftwidth' de sangrado, sin importar dónde está dentro de la línea.
   Cuando está en modo Normal, puede usar las órdenes «&gt;&gt;» y «&lt;&lt;» para cambiar
las líneas. «&gt;» y «&lt;» son operadores, y por ello tiene las tres formas
habituales de definir las líneas que desea sangrar. Una combinación útil
es la siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&gt;i{
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&gt;i{
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	original text		after "&gt;i{"		after "&gt;a{"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	texto original		después de «&gt;i{»	    después de «&gt;a{»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if (opción)		if (opción)		if (opción) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	opción = 0;		    opción = 0;		    opción = 0;  ~
	}			}			    } ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.5*	Tabs and spaces
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.5*	Tabulados y espacios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.  Use a mix of &lt;Tab&gt; and space characters.  Since a &lt;Tab&gt; takes the place of
    eight spaces, you have fewer characters in your file.  Inserting a &lt;Tab&gt;
    is quicker than eight spaces.  Backspacing works faster as well.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Use una mezcla de &lt;Tab&gt; y caracteres de espacio. Ya que &lt;Tab&gt; toma el
    el lugar de 8 espacios, tendrá menos caracteres en su archivo. Insertar un
    &lt;Tab&gt; es más rápido que 8 espacios. La tecla de retroceso también es
    más rápido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.  Use spaces only.  This avoids the trouble with programs that use a
    different tabstop value.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. Utilice espacios solamente.  Esto evita los problemas con los
    programas que utilizan un valor de «tabstop» diferente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a combination of tabs and spaces, you just edit normally.
The Vim defaults do a fine job of handling things.
   You can make life a little easier by setting the 'softtabstop' option.
This option tells Vim to make the &lt;Tab&gt; key look and feel as if tabs were set
at the value of 'softtabstop', but actually use a combination of tabs and
spaces.
   After you execute the following command, every time you press the &lt;Tab&gt; key
the cursor moves to the next 4-column boundary: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa una combinación de tabulados y espacios, puede editar con normalidad.
El comportamiento predeterminado de Vim realiza un trabajo inteligente.
   Puede facilitar su vida definiendo la opción 'softtabstop'.
Esta opción le dice a Vim que la tecla &lt;Tab&gt; tenga el comportamiento como si
los tabulados estuviesen definidos como un valor 'softtabstop', aunque use en
realidad una combinación de tabulados y espacios.
   Después de ejecutar la siguiente, orden, cada vez que pulse la tecla &lt;Tab&gt; el
cursor se moverá al siguiente límite de cuatro columnas: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you start in the first column and press &lt;Tab&gt;, you get 4 spaces inserted
in your text.  The second time, Vim takes out the 4 spaces and puts in a &lt;Tab&gt;
(thus taking you to column 8).  Thus Vim uses as many &lt;Tab&gt;s as possible, and
then fills up with spaces.
   When backspacing it works the other way around.  A &lt;BS&gt; will always delete
the amount specified with 'softtabstop'.  Then &lt;Tab&gt;s are used as many as
possible and spaces to fill the gap.
   The following shows what happens pressing &lt;Tab&gt; a few times, and then using
&lt;BS&gt;.  A "." stands for a space and "-------&gt;" for a &lt;Tab&gt;.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando empiece en la primera columna y pulse &lt;Tab&gt; obtendrá la inserción de
cuatro espacios en su texto. La segunda vez, Vim eliminará los cuatro espacios
e insertará un &lt;Tab&gt; (llevándole a la columna 8). Entonces, Vim usa tantos
&lt;Tab&gt; como sea posible, rellenándolos con espacios.
   Al usar la tecla de retroceso, funcionará al revés. Un &lt;Bs&gt; (tecla de
retroceso) siempre elimina la cantidad definida con 'softtabstop'. Entonces, se
usarán tantos &lt;Tab&gt; como sea posible, rellenando el hueco resultante
con espacios.
   Lo siguiente muestra lo que ocurre cuando pulsa &lt;Tab&gt; varias veces, y
después usando &lt;Bs&gt;. Un «.» simboliza un espacio, y «-------&gt;» un &lt;Tab&gt;.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	type			  result ~
	&lt;Tab&gt;			  ....
	&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;....
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;	  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;   ....
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	tipo			          resultado ~
	&lt;Tab&gt;			  ....
	&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;....
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;	  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;   ....
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to use the 'smarttab' option.  When it's set, Vim uses 'shiftwidth' for a &lt;Tab&gt; typed in the indent of a line, and a real &lt;Tab&gt; when typed after the first non-blank character.  However, &lt;BS&gt; doesn't work like with 'softtabstop'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una alternativa es usar la opción 'smartab'. Si se define, Vim usa 'shiftwidth' para un &lt;Tab&gt; introducida en el sangrado de una línea, y un &lt;Tab&gt; real cuando se introduce en el primer carácter no vacío. Sin embargo &lt;BS&gt; no funciona de la misma forma que con 'softtabstop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set expandtab
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set expandtab
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When this option is set, the &lt;Tab&gt; key inserts a series of spaces.  Thus you
get the same amount of white space as if a &lt;Tab&gt; character was inserted, but
there isn't a real &lt;Tab&gt; character in your file.
   The backspace key will delete each space by itself.  Thus after typing one
&lt;Tab&gt; you have to press the &lt;BS&gt; key up to eight times to undo it.  If you are
in the indent, pressing CTRL-D will be a lot quicker.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se define esta opción, la tecla &lt;Tab&gt; inserte una serie de espacios.
Por ello, obtiene el mismo espacio en blanco que un carácter &lt;Tab&gt; inserta,
aunque en realidad no hay ningún carácter &lt;Tab&gt; en su archivo.
  La tecla de retroceso eliminará cada espacio por sí mismo. Por ello,
después de teclear un &lt;Tab&gt;, tendrá que pulsar la tecla &lt;BS&gt; (retroceso)
hasta ocho veces para deshacerlo. Si está dentro de la sangría, pulsar
«CTRL-D» es mucho más rápido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting 'expandtab' does not affect any existing tabs.  In other words, any tabs in the document remain tabs.  If you want to convert tabs to spaces, use the ":retab" command.  Use these commands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir 'expandtab' no afecta a las tabulaciones existentes. En otras palabras, todas las tabulaciones del documento siguen siéndolo. Si desea convertir esas tabulaciones en espacios, use la orden «:retab». Use las siguientes órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set expandtab
	:%retab
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set expandtab
	:%retab
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Vim will have changed all indents to use spaces instead of tabs.  However, all tabs that come after a non-blank character are kept.  If you want these to be converted as well, add a !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, Vim ha cambiado todas las sangrías para que usen espacios en lugar de tabulados. Sin embargo, se respetan todos los tabulados a continuación de un carácter no vacío. Añada «!» si desea convertir éstos también: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%retab!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%retab!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a little bit dangerous, because it can also change tabs inside a string.  To check if these exist, you could use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es algo peligroso, ya que también puede cambiar los tabulados dentro de una cadena. Puede usar lo siguiente para comprobar la existencia de éstos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/"[^"\t]*\t[^"]*"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/"[^"\t]*\t[^"]*"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's recommended not to use hard tabs inside a string.  Replace them with "\t" to avoid trouble.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda no usar tabulados rígidos dentro de una cadena. Reemplácelos con «\t» para evitar problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set noexpandtab
	:%retab!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set noexpandtab
	:%retab!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.6*	Formatting comments
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.6*	Formatear comentarios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the great things about Vim is that it understands comments.  You can
ask Vim to format a comment and it will do the right thing.
   Suppose, for example, that you have the following comment:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una de las mayores virtudes de Vim es que entiende comentarios. Puede pedir
a Vim que dé formato a un comentario, y hará lo correcto.
   Suponga que tiene el siguiente comentario:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* ~
	 * Esta es una prueba ~
	 * de formateo de texto. ~
	 */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gq]/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gq]/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"gq" is the operator to format text.  "]/" is the motion that takes you to the end of a comment.  The result is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«gq» es el operador para formatear texto. «]/» es el movimiento que le lleva al final del comentario. El resultado es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* ~
	 * This is a test of the text formatting. ~
	 */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* ~
	 * Esta es una prueba de formateo de texto. ~
	 */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that Vim properly handled the beginning of each line.
  An alternative is to select the text that is to be formatted in Visual mode
and type "gq".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que Vim manipuló adecuadamente el principio de cada línea.
  Una alternativa es seleccionar el texto a formatear en modo Visual,
y teclear «gq».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a new line to the comment, position the cursor on the middle line and press "o".  The result looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para añadir una nueva línea al comentario, posicione el cursor en la línea central y pulse «o». El resultado sería el siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has automatically inserted a star and a space for you.  Now you can type the comment text.  When it gets longer than 'textwidth', Vim will break the line.  Again, the star is inserted automatically:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ha insertado un «*» y un espacio automáticamente. Ahora puede escribir el texto de comentario. Si la línea excede el valor de 'textwidth', Vim romperá la línea. Una vez más, se inserta «*» automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* ~
	 * Esto es una prueba de formateo de texto. ~
	 * Teclear mucho texto hará que Vim divida ~
	 * la línea ~
	 */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	r	insert the star when typing &lt;Enter&gt; in Insert mode
	o	insert the star when using "o" or "O" in Normal mode
	c	break comment text according to 'textwidth'
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	r	inserta «*» al pulsar &lt;Enter&gt; en modo Insertar
	o	inserta «*» a usar «o» o «O» en modo Normal
	c	rompe el texto de comentario de acuerdo a 'textwidth'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'comments' option defines what a comment looks like.  Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.
   Many single-line comments start with a specific character.  In C++ // is
used, in Makefiles #, in Vim scripts ".  For example, to make Vim understand
C++ comments: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'comments' define el aspecto de un comentario. Vim distingue
entre un comentario de una sola línea y un comentario cuyo principio, parte
central y final son distintas.
   Muchos comentarios de una sola línea empiezan con carácter específico.
En C++ se usa «//», «#» en archivos «Makefile», y «"» en scripts de Vim.
Por ejemplo, para que Vim entienda comentarios en C++: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set comments=://
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set comments=://
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The colon separates the flags of an item from the text by which the comment is recognized.  The general form of an item in 'comments' is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los dos puntos separan las opciones de un elemento del texto por el cual se reconoce un comentario. La forma habitual de un elemento en 'comments' es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{flags}:{text}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{opcio}:{texto}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set comments=n:&gt;,n:!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set comments=n:&gt;,n:!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two items, one for comments starting with "&gt;" and one for comments that start with "!".  Both use the flag "n".  This means that these comments nest.  Thus a line starting with "&gt;" may have another comment after the "&gt;".  This allows formatting a message like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos elementos, uno para los comentarios que empiezan con «&gt;» y otro para los comentarios que comienzan con «!».  Ambos usan la opción «n».  Esto significa que estos comentarios se anidan.  Por lo tanto, una línea comenzando con «&gt;» puede tener otro comentario después de «&gt;».  Esto permite dar formato a un mensaje como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&gt; ! Did you see that site? ~
	&gt; ! It looks really great. ~
	&gt; I don't like it.  The ~
	&gt; colors are terrible. ~
	What is the URL of that ~
	site? ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&gt; ! ¿Has visto esa página web? ~
	&gt; ! Tiene un buen diseño. ~
	&gt; No me gusta.  Los ~
	&gt; colores son horribles. ~
	¿Cual es la URL de esa ~
	página web? ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try setting 'textwidth' to a different value, e.g., 80, and format the text by Visually selecting it and typing "gq".  The result is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe configurando 'textwidth' con un valor diferente, de 80, y formatee el texto seleccionándolo en modo Visual y escribiendo «gq».  El resultado es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&gt; ! Did you see that site?  It looks really great. ~
	&gt; I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&gt; ! ¿Has visto esa página web? Tiene un buen diseño. ~
	&gt; No me gusta. Los colores son horribles. ~
	¿Cual es la URL de esa página web? ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that Vim did not move text from one type of comment to another.  The "I" in the second line would have fit at the end of the first line, but since that line starts with "&gt; !" and the second line with "&gt;", Vim knows that this is a different kind of comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará que Vim no desplazó el texto de un tipo de comentario a otro. El «No» en la segunda línea puede encajar al final de la primera línea, pero ya que la línea comienza con «&gt; !», y la segunda con «&gt;», Vim detectará que es otro tipo de comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A C comment starts with "/*", has "*" in the middle and "*/" at the end.  The entry in 'comments' for this looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un comentario de C empieza con «/*»,  «*» en el medio, y «/*» al final. La entrada en 'comments' tendría este aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set comments=s1:/*,mb:*,ex:*/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set comments=s1:/*,mb:*,ex:*/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The start is defined with "s1:/*".  The "s" indicates the start of a
three-piece comment.  The colon separates the flags from the text by which the
comment is recognized: "/*".  There is one flag: "1".  This tells Vim that the
middle part has an offset of one space.
   The middle part "mb:*" starts with "m", which indicates it is a middle
part.  The "b" flag means that a blank must follow the text.  Otherwise Vim
would consider text like "*pointer" also to be the middle of a comment.
   The end part "ex:*/" has the "e" for identification.  The "x" flag has a
special meaning.  It means that after Vim automatically inserted a star,
typing / will remove the extra space.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El principio se define con «s1:/*». La «s» indica el principio de un
comentario en tres partes. Los dos puntos separan las marcas del texto
por el cual se detecta que es un comentario: «/*». Hay una marca, «1». Indica
a Vim que la parte central tiene un «offset» de un espacio.
   La parte central «mb:*» comienza con «m», que indica que es la parte
central. La opción «b» indica que el texto debe ir seguido de un espacio
en blanco. En caso contrario, Vim considerará que el texto como «*pointer»
también es la parte central de un comentario.
   La parte final «ex:*/» tiene «e» como identificador. La opción «x» tiene
un significado especial. Indica que pulsar «/» eliminará el espacio
adicional después de que Vim haya insertado automáticamente un asterisco, «*».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_28.txt*	For Vim version 7.3.  Last change: 2008 Jun 14
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_28.esx*	Para Vim versión 7.3.  Último cambio: 8/2/2007
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				   Folding
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				 Plegar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|28.1|	What is folding?
|28.2|	Manual folding
|28.3|	Working with folds
|28.4|	Saving and restoring folds
|28.5|	Folding by indent
|28.6|	Folding with markers
|28.7|	Folding by syntax
|28.8|	Folding by expression
|28.9|	Folding unchanged lines
|28.10| Which fold method to use?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|28.1|	¿Qué es plegar?
|28.2|	Plegar manualmente
|28.3|	Trabajar con pliegues
|28.4|	Guardar y restaurar pliegues
|28.5|	Plegar por sangrado
|28.6|	Plegar con marcadores
|28.7|	Plegar por sintaxis
|28.8|	Plegar por expresión
|28.9|	Plegar líneas sin cambios
|28.10¿| ¿Qué método de plegar debería usar?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_29.txt|  Moving through programs
 Previous chapter: |usr_27.txt|  Search commands and patterns
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_29.esx|  Moverse a través de programas
  Capítulo anterior: |usr_27.esx|  Órdenes de búsqueda y patrones
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.1*	What is folding?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.1¿*	¿Qué es plegar?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding is used to show a range of lines in the buffer as a single line on the screen.  Like a piece of paper which is folded to make it shorter:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar se usa para mostrar un rango de líneas en un búfer como una sola línea en la pantalla. Como un trozo de papel plegado para acortarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+------------------------+
	| line 1		 |
	| line 2		 |
	| line 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / folded lines		  /
	/________________________/
	| line 12		 |
	| line 13		 |
	| line 14		 |
	+------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+------------------------+
	| línea 1		 |
	| línea 2		 |
	| línea 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / líneas plegadas	  /
	/________________________/
	| línea 12		 |
	| línea 13		 |
	| línea 14		 |
	+------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text is still in the buffer, unchanged.  Only the way lines are displayed is affected by folding.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto aún está en el búfer, sin cambios. Plegar sólo afecta a la manera en que se muestran las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.2*	Manual folding
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.2*	Plegar manualmente
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zfap
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zfap
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see that the paragraph is replaced by a highlighted line.  You have created a fold.  |zf| is an operator and |ap| a text object selection.  You can use the |zf| operator with any movement command to create a fold for the text that it moved over.  |zf| also works in Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá que una línea resaltada reemplaza al párrafo. Ha creado un pliegue. |zf| es un operando y |ap| una selección de un objeto textual. Puede usar el operando |zf| con cualquier orden de desplazamiento para crear un pliegue para el texto reemplazado. |zf| funciona también en el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the folding commands start with "z".  With some fantasy, this looks like a folded piece of paper, seen from the side.  The letter after the "z" has a mnemonic meaning to make it easier to remember the commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas las órdenes de plegado empiezan con «z». Si usa la imaginación, se asemeja a un papel plegado visto de lado. La letra a continuación de «z» tiene un significado nemónico que facilita recordar las órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zf	F-old creation
	zo	O-pen a fold
	zc	C-lose a fold
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zf	F-old creation (crear pliegue)
	zo	O-pen a fold (abrir pliegue)
	zc	C-lose a fold (cerrar pliegue)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have created several folds, and now want to view all the text.  You could go to each fold and type "zo".  To do this faster, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imagine que ha creado varios pliegues, y que ahora desea ver todo el texto. Puede ir a cada pliegue y teclear «zo». Use la siguiente orden para hacer esto mismo con rapidez: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zr
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zr
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will R-educe the folding.  The opposite is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto r_educe el plegado. Lo opuesto es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zm
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zm
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This folds M-ore.  You can repeat "zr" and "zm" to open and close nested folds of several levels.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto pliega m_ás. Puede repetir «zr» y «zm» para abrir y cerrar pliegues anidados en varios niveles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zR
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zR
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	zM
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	zM
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can quickly disable the folding with the |zn| command.  Then |zN| brings back the folding as it was.  |zi| toggles between the two.  This is a useful way of working: - create folds to get overview on your file - move around to where you want to do your work - do |zi| to look at the text and edit it - do |zi| again to go back to moving around</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desactivar el plegado rápidamente con la orden |zn|. |Zn| devuelve el plegado a su estado previo. |zi| pasa de uno a otro. Esta es una buena forma de trabajar: creación de pliegues para obtener una visión general de su archivo - desplazarse a las áreas que desea modificar - visionado y edición del texto con |zi| - repita |zi| para seguir desplazándose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.3*	Working with folds
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.3*	Trabajar con pliegues
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When some folds are closed, movement commands like "j" and "k" move over a fold like it was a single, empty line.  This allows you to quickly move around over folded text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De haber algunos pliegues cerrados, las órdenes de movimiento como «j» y «k» se desplazarán sobre el pliegue como si fuese una única línea vacía. Esto permite un desplazamiento más rápido sobre texto plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is sometimes difficult to see or remember where a fold is located, thus where a |zo| command would actually work.  To see the defined folds: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces es difícil ver o recordar la ubicación de un pliegue; la orden |zo| es de utilidad en estos caso. Para ver los pliegues definidos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldcolumn=4
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldcolumn=4
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will show a small column on the left of the window to indicate folds.  A "+" is shown for a closed fold.  A "-" is shown at the start of each open fold and "|" at following lines of the fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto muestra una pequeña columna a la izquierda de la ventana que indica los pliegues. Un «+» simboliza un pliegue cerrado. Un «-» aparece al principio de cada pliegue abierto y «|» simboliza líneas del pliegue a continuación. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the mouse to open a fold by clicking on the "+" in the foldcolumn.  Clicking on the "-" or a "|" below it will close an open fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el ratón para abrir un pliegue pulsando sobre la «+» en la columna de plegado. Pulsar sobre «-» o el «|» que aparece debajo cierra un pliegue abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To open all folds at the cursor line use |zO|.  To close all folds at the cursor line use |zC|.  To delete a fold at the cursor line use |zd|.  To delete all folds at the cursor line use |zD|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |zO| para abrir todos los pliegues en la línea del cursor. Use |zC| para cerrar todos los pliegues en la línea del cursor. Puede eliminar un pliegue en la línea del cursor con |zd|. Use |zD| para borrar todos los pliegues bajo la línea del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When in Insert mode, the fold at the cursor line is never closed.  That allows you to see what you type!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea del cursor nunca se cierra en el modo Insertar. Esto permite ver lo que teclea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folds are opened automatically when jumping around or moving the cursor left or right.  For example, the "0" command opens the fold under the cursor (if 'foldopen' contains "hor", which is the default).  The 'foldopen' option can be changed to open folds for specific commands.  If you want the line under the cursor always to be open, do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los pliegues se abren automáticamente al desplazarse o moviendo el cursor a la izquierda o a la derecha. Por ejemplo, la orden «0» abre el pliegue bajo el cursor (si 'foldopen' contiene 'hor', el valor predeterminado). Puede modificar la opción 'foldopen' para abrir los pliegues con órdenes específicas. Haga lo siguiente si desea que la línea bajo el cursor esté siempre abierta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldopen=all
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldopen=all
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Warning: You won't be able to move onto a closed fold then.  You might want to use this only temporarily and then set it back to the default: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aviso: en esta situación, no será capaz de desplazarse a un pliegue cerrado. Puede que desea usar esto temporalmente para después devolverlo al valor original: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldopen&amp;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldopen&amp;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldclose=all
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldclose=all
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will re-apply 'foldlevel' to all folds that don't contain the cursor.  You have to try it out if you like how this feels.  Use |zm| to fold more and |zr| to fold less (reduce folds).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ejecutará 'foldlevel' en todos los pliegues que no contengan el cursor. Tiene que probar para ver si le gusta. Use |zm| para plegar más, y |zr| para plegar menos (reducir los pliegues).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The folding is local to the window.  This allows you to open two windows on the same buffer, one with folds and one without folds.  Or one with all folds closed and one with all folds open.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El pliegue es local para la ventana. Esto permite abrir dos ventanas en el mismo búfer, uno con pliegues y otro sin ellos. O uno con todos los pliegues cerrados y otro con todos los pliegues abiertos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.4*	Saving and restoring folds
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.4*	Guardar y restaurar pliegues
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you abandon a file (starting to edit another one), the state of the folds is lost.  If you come back to the same file later, all manually opened and closed folds are back to their default.  When folds have been created manually, all folds are gone! To save the folds use the |:mkview| command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al cerrar un archivo para iniciar la edición de otro, el estado del pliegue es eliminado. Si vuelve al mismo archivo más tarde, todos aquellos pliegues cerrados y abiertos manualmente volverán a su estado predeterminado. ¡Perderá todos los pliegues creados manualmente. Use la orden |:mkview| para guardar el estado de los archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will store the settings and other things that influence the view on the file.  You can change what is stored with the 'viewoptions' option.  When you come back to the same file later, you can load the view again: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará la configuración y otras que cosas que modifican el visionado del archivo. Puede modificar lo guardado con  la opción 'viewoptions'. Puede cargar el mismo visionado al volver al archivo más tarde: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can store up to ten views on one file.  For example, to save the current setup as the third view and load the second view: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede guardar hasta diez visionados distintos de un archivo. Por ejemplo, para guardar la configuración actual como el tercer visionado, y cargar después el segundo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:mkview 3
	:loadview 2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:mkview 3
	:loadview 2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that when you insert or delete lines the views might become invalid.  Also check out the 'viewdir' option, which specifies where the views are stored.  You might want to delete old views now and then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que, al insertar o eliminar líneas, las vistas dejarán de ser válidas. Revise también la opción 'viewdir', que define donde se guardan los visionados. Puede que desee eliminar viejos visionados de vez en cuando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.5*	Folding by indent
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.5*	Plegar según el sangrado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining folds with |zf| is a lot of work.  If your text is structured by giving lower level items a larger indent, you can use the indent folding method.  This will create folds for every sequence of lines with the same indent.  Lines with a larger indent will become nested folds.  This works well with many programming languages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir pliegues con |zf| supone mucho trabajo. Si el texto está estructurado de forma que los elementos de un nivel inferior tienen un mayor sangrado, puede usar el método de pliegue por sangrado. Ésto crea pliegues para cada secuencia de líneas dentro del mismo sangrado. Las líneas con un sangrado mayor se convertirán en pliegues anidados. Esto funciona muy bien con varios lenguajes de programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldmethod=indent
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldmethod=indent
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use the |zm| and |zr| commands to fold more and reduce folding.  It's easy to see on this example text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede después usar las órdenes |zm| y |zr| para aumentar y reducir el plegado. Es fácil de ver con este texto de ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line is not indented
	This line is indented once
		This line is indented twice
		This line is indented twice
	This line is indented once
This line is not indented
	This line is indented once
	This line is indented once
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea no tiene sangrado
	Esta línea tiene un sangrado
		Esta línea tiene doble sangrado
		Esta línea tiene doble sangrado
	Esta línea tiene un sangrado
La línea no tiene sangrado
	Esta línea tiene un sangrado
	Esta línea tiene un sangrado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the relation between the amount of indent and the fold depth depends on the 'shiftwidth' option.  Each 'shiftwidth' worth of indent adds one to the depth of the fold.  This is called a fold level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que la relación entre la cantidad de sangrado y la profundidad del pliegue depende de la opción 'shiftwidth'. Cada 'shiftwidth' con el valor de un sangrado añade uno a la profundidad del pliegue. Este se denomina nivel de plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use the |zr| and |zm| commands you actually increase or decrease the 'foldlevel' option.  You could also set it directly: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, cuando usa las órdenes |zr| y |zm| aumento o disminuye la opción 'foldlevel'. Puede también definirlo directamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldlevel=3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldlevel=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that all folds with three times a 'shiftwidth' indent or more will be closed.  The lower the foldlevel, the more folds will be closed.  When 'foldlevel' is zero, all folds are closed.  |zM| does set 'foldlevel' to zero.  The opposite command |zR| sets 'foldlevel' to the deepest fold level that is present in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que todos los pliegues con un sangrado tres veces el valor de 'shiftwidth' se cerrarán. Cuanto más bajo es 'foldlevel', más pliegues se cerrarán. Si el valor de 'foldlevel' es cero, se cerrarán todos los pliegues. |zM| define 'foldlevel' como cero. La orden opuesta |zR| define 'foldlevel' con el valor de nivel de pliegue más bajo presente en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus there are two ways to open and close the folds:
(A) By setting the fold level.
    This gives a very quick way of "zooming out" to view the structure of the
    text, move the cursor, and "zoom in" on the text again.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, hay dos maneras de abrir y cerrar los pliegues:
(a) Definiendo el nivel de pliegue (foldlevel).
    Esto ofrece un rápida manera de alejar la vista para ver la estructura
    general del texto, desplazar el cursor, acercar la vista y de vuelta al
    texto otra vez.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(B) By using |zo| and |zc| commands to open or close specific folds.
    This allows opening only those folds that you want to be open, while other
    folds remain closed.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(B) Usando las órdenes |zo| y |zc| para abrir o cerrar pliegues específicos.
    Esto permite abrir sólo aquellos pliegues que desea abrir, manteniendo
    los otros cerrados.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be combined: You can first close most folds by using |zm| a few times and then open a specific fold with |zo|.  Or open all folds with |zR| and then close specific folds with |zc|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede combinar: primero puede cerrar la mayoría de los pliegues usando |zm| unas cuantas veces, y después abrir un pliegue en particular con |zo|. O abrir todos los pliegues con |zR| y después cerrar pliegues específicos con |zc|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.6*	Folding with markers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.6*	Plegar con marcadores
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldmethod=marker
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldmethod=marker
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the folded line will display the text before the marker.  This is very useful to tell what the fold contains.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la líena plegada mostrará el texto previo al marcador. Es útil para informar de los contenidos del pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite annoying when the markers don't pair up correctly after moving some lines around.  This can be avoided by using numbered markers.  Example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es bastante molesto cuando los marcadores no encajan correctamente tras desplazar algunas líneas. Esto se puede evitar usando marcadores numerados. Ejemplo: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* global variables {{{1 */
	int varA, varB;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* global variables {{{1 */
	int varA, varB;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At every numbered marker a fold at the specified level begins.  This will make any fold at a higher level stop here.  You can just use numbered start markers to define all folds.  Only when you want to explicitly stop a fold before another starts you need to add an end marker.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un pliegue se iniciará con el nivel definido por cada marcador numerado. Esto detiene en este punto cualquier pliegue de nivel superior. Puede usar marcadores de inicio numerados para definir todos los pliegues. Tendrá que añadir un marcador de fin sólo cuando desee detener un pliegue antes de iniciar otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.7*	Folding by syntax
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.7*	Plegar por sintaxis
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.8*	Folding by expression
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.8*	Plegar por expresión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to folding by indent, but instead of using the indent of a line a user function is called to compute the fold level of a line.  You can use this for text where something in the text indicates which lines belong together.  An example is an e-mail message where the quoted text is indicated by a "&gt;" before the line.  To fold these quotes use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es similar a plegar por sangrado pero usa una función de usuario para computar el nivel de pliegue de una línea, en lugar del sangrado. Puede usar esto con texto en el que éste indica qué líneas están juntas. Un ejemplo es un correo electrónico en el que el texto citado se indica con un «&gt;» al inicio de la línea. Use esto para plegar esas citas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^&gt;].*','',''))
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^&gt;].*','',''))
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explanation for the 'foldexpr' used in the example (inside out):
   getline(v:lnum)			gets the current line
   substitute(...,'\\s','','g')		removes all white space from the line
   substitute(...,'[^&gt;].*','','')	removes everything after leading '&gt;'s
   strlen(...)				counts the length of the string, which
					is the number of '&gt;'s found
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Explicación del 'foldexpr' usado en el ejemplo (de dentro a fuera):
   getline(v:lnum)			obtiene la línea actual
   substitute(...,'\\s','','g')		elimina los espacios blancos de la línea
   substitute(...,'[^&gt;].*','','')	elimina todo lo que '&gt; precede
   strlen(...)				cuenta la longitud de la cadena,
					el cual es el número de '&gt;'
					encontrados.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a backslash must be inserted before every space, double quote and backslash for the ":set" command.  If this confuses you, do &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que al usar la orden «:set» debe insertar una barra inversa antes de cada espacio, comilla doble y barra inversa. Si esto le confunde, haga &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldexpr
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldexpr
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to check the actual resulting value.  To correct a complicated expression, use the command-line completion: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>para revisar el valor actual resultante. Para corregir una expresión compleja, use el auto completa de línea de órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set foldexpr=&lt;Tab&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set foldexpr=&lt;Tab&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where &lt;Tab&gt; is a real Tab.  Vim will fill in the previous value, which you can then edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí, &lt;Tab&gt; es una tabulación real. Vim rellenará el valor previo, el cual puede después editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.9*	Folding unchanged lines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.9*	Plegar líneas sin cambios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful when you set the 'diff' option in the same window.  The |vimdiff| command does this for you.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil cuando define la opción 'diff' en la misma ventana. La orden |vimdiff| hace esto por usted. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this in every window that shows a different version of the same file.  You will clearly see the differences between the files, while the text that didn't change is folded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga esto en cada ventana que muestre una versión distinta del mismo archivo. Verá claramente las diferencias entre archivos, plegando a su vez aquellas líneas que no contienen cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.10* Which fold method to use?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.10* ¿Qué método de plegado debería usar?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these possibilities make you wonder which method you should choose.  Unfortunately, there is no golden rule.  Here are some hints.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas estas posibilidades le hacen preguntarse qué método escoger. Por desgracia, no existe ninguna regla de oro. Aquí tiene algunas pistas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a syntax file with folding for the language you are editing, that is probably the best choice.  If there isn't one, you might try to write it.  This requires a good knowledge of search patterns.  It's not easy, but when it's working you will not have to define folds manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De existir un archivo de sintaxis con plegado para el lenguaje en el que está editando, puede que sea la mejor opción. De no ser así, puede intentar crear uno. Esto requiere un buen conocimiento de patrones de búsqueda. No resulta sencillo, pero una vez que funciona no tendrá definir los pliegues manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing commands to manually fold regions can be used for unstructured text.  Then use the |:mkview| command to save and restore your folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede escribir órdenes para plegar manualmente ciertas regiones al tratar con un texto sin estructura. Use después la orden |:mkview| para guardar y restaurar los pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The marker method requires you to change the file.  If you are sharing the
files with other people or you have to meet company standards, you might not
be allowed to add them.
   The main advantage of markers is that you can put them exactly where you
want them.  That avoids that a few lines are missed when you cut and paste
folds.  And you can add a comment about what is contained in the fold.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El método de marcado requiere que modifique el archivo. Si comparte archivos
con más personas, o tiene que cumplir con las directrices de una compañía,
cabe que no se le permita añadirlos.
   La principal ventaja de los marcadores es que puede insertarlas
exactamente donde desee. Esto evita que se pierdan algunas líneas al copiar
y pegar pliegues. Puede después añadir un comentario acerca de los contenidos
del pliegue.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding by indent is something that works in many files, but not always very well.  Use it when you can't use one of the other methods.  However, it is very useful for outlining.  Then you specifically use one 'shiftwidth' for each nesting level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar por sangrado funciona en muchos ficheros, aunque con resultados variables. Úselo cuando no puede usar ninguno de los otros métodos. Aún así, es de utilidad con los diseños preliminares. Puede entonces usar un 'shiftwidth' en particular para cada nivel de anidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding with expressions can make folds in almost any structured text.  It is
quite simple to specify, especially if the start and end of a fold can easily
be recognized.
   If you use the "expr" method to define folds, but they are not exactly how
you want them, you could switch to the "manual" method.  This will not remove
the defined folds.  Then you can delete or add folds manually.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar con expresiones puede crear pliegues en prácticamente cualquier texto
estructurado. Es sencillo de definir, particularmente se se pueden discernir con facilidad el principio y final de un pliegue.
   Si al definir los pliegues usa el método «expr», pero no con los
resultados deseados, puede pasar al método «manual». Esto no elimina los
pliegues ya definidos. Puede entonces añadir o eliminar pliegues de
manualmente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*help.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*help.esx* *ayuda*	Para Vim versión 7.3. Último cambio: 20/7/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			VIM - main help file
									 k
      Move around:  Use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.	 j
Close this window:  Use ":q&lt;Enter&gt;".
   Get out of Vim:  Use ":qa!&lt;Enter&gt;" (careful, all changes are lost!).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			VIM - archivo principal de ayuda
							  k
     Desplazamiento: Use las teclas de dirección,	h   l
		     o «h» para ir a la izquierda,	  j
		     «j» para ir hacia abajo, «k» hacia arriba
		     y «l» a la derecha.
Cerrar esta ventana: Use «:q&lt;Intro&gt;».
       Salir de Vim: Use «:qa!&lt;Intro&gt;» (¡Atención, perderá todos
		     los cambios realizados!).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get specific help:  It is possible to go directly to whatever you want help
		    on, by giving an argument to the |:help| command.
		    It is possible to further specify the context:
							*help-context*
			  WHAT			PREPEND    EXAMPLE	~
		      Normal mode command      (nothing)   :help x
		      Visual mode command	  v_	   :help v_u
		      Insert mode command	  i_	   :help i_&lt;Esc&gt;
		      Command-line command	  :	   :help :quit
		      Command-line editing	  c_	   :help c_&lt;Del&gt;
		      Vim command argument	  -	   :help -r
		      Option			  '	   :help 'textwidth'
  Search for help:  Type ":help word", then hit CTRL-D to see matching
		    help entries for "word".
		    Or use ":helpgrep word". |:helpgrep|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtener ayuda específica:
		     Es posible acudir directamente donde necesite ayuda,
		     introduciéndolo como un argumento de la orden |:help|.
		     Es posible especificar detalladamente el contexto:
							*help-context*
			  QUÉ			ANEXAR    EJEMPLO	~
		      Orden modo Normal         (nada)    :help x
		      Orden modo Visual	           v_     :help v_u
		      Orden modo insertar	   i_	  :help i_&lt;Esc&gt;
		      Orden de línea de órdenes	   :	  :help :quit
		      Edición de línea de órdenes  c_	  :help c_&lt;Supr&gt;
		      Argumento de la orden VIM	   -	  :help -r
		      Opción			   '	  :help 'textwidth'
  Buscar ayuda:  Teclee «:help palabra» y pulse CTRL-D para ver las
		    entradas de ayuda coincidentes con «palabra».
		    O use «:helpgrep palabra». |:helpgrep|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM stands for Vi IMproved.  Most of VIM was made by Bram Moolenaar, but only
through the help of many others.  See |credits|.
------------------------------------------------------------------------------
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VIM significa «Vi IMproved» (Vi mejorado). Bram Moolenaar es el principal
creador de Vim, pero sólo con la ayuda de muchos otros. Véase |credits|.
------------------------------------------------------------------------------
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_toc.txt|	Table Of Contents
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_toc.esx|	Tabla de contenidos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REFERENCE MANUAL: These files explain every detail of Vim.	*reference_toc*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MANUAL DE REFERENCIA: Estos archivos explican cada detalle de Vim.  	*reference_toc*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>General subjects ~
|intro.txt|	general introduction to Vim; notation used in help files
|help.txt|	overview and quick reference (this file)
|helphelp.txt|	about using the help files
|index.txt|	alphabetical index of all commands
|help-tags|	all the tags you can jump to (index of tags)
|howto.txt|	how to do the most common editing tasks
|tips.txt|	various tips on using Vim
|message.txt|	(error) messages and explanations
|quotes.txt|	remarks from users of Vim
|todo.txt|	known problems and desired extensions
|develop.txt|	development of Vim
|debug.txt|	debugging Vim itself
|uganda.txt|	Vim distribution conditions and what to do with your money
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Temas generales ~
|intro.esx|	Introducción general a Vim; notación usada en los
                archivos de ayuda
|help.esx|	Información general y referencia rápida (este archivo)
|helphelp.txt|	Acerca del uso de los archivos de ayuda
|index.txt|	Índice alfabético de todas las órdenes
|help-tags|	Todas las etiquetas a las que puede saltar
		(índice de etiquetas)
|howto.txt|	Como realizar las tareas de edición más comunes
|tips.txt|	Varios consejos de uso de Vim
|message.txt|	Los mensajes de error y su explicación
|quotes.txt|	Comentarios de usuarios de Vim
|todo.txt|	Problemas conocidos y extensiones deseadas
|develop.txt|	Desarrollo de Vim
|debug.txt|	Depurando fallos de Vim
|uganda.txt|	Las condiciones de distribución de Vim
		y qué hacer con su dinero.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic editing ~
|starting.txt|	starting Vim, Vim command arguments, initialisation
|editing.txt|	editing and writing files
|motion.txt|	commands for moving around
|scroll.txt|	scrolling the text in the window
|insert.txt|	Insert and Replace mode
|change.txt|	deleting and replacing text
|indent.txt|	automatic indenting for C and other languages
|undo.txt|	Undo and Redo
|repeat.txt|	repeating commands, Vim scripts and debugging
|visual.txt|	using the Visual mode (selecting a text area)
|various.txt|	various remaining commands
|recover.txt|	recovering from a crash
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edición básica ~
|starting.txt|	Iniciar Vim, argumentos de la orden Vim, inicialización
|editing.txt|	Editar y escribir archivos
|motion.txt|	Órdenes de desplazamiento
|scroll.txt|	Desplazar el texto en una ventana
|insert.txt|	Modos insertar y reemplazar
|change.txt|	Borrar y reemplazar texto
|indent.txt|	Tabulación automática para C y otros lenguajes
|undo.txt|	Deshacer y rehacer
|repeat.txt|	Repetir órdenes, Vim scripts y depuración de fallos
|visual.txt|	Usar el modo Visual (seleccionar un área de texto)
|various.txt|	Otras órdenes restantes
|recover.txt|	Recuperar datos después de un fallo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced editing ~
|cmdline.txt|	Command-line editing
|options.txt|	description of all options
|pattern.txt|	regexp patterns and search commands
|map.txt|	key mapping and abbreviations
|tagsrch.txt|	tags and special searches
|quickfix.txt|	commands for a quick edit-compile-fix cycle
|windows.txt|	commands for using multiple windows and buffers
|tabpage.txt|	commands for using multiple tab pages
|syntax.txt|	syntax highlighting
|spell.txt|	spell checking
|diff.txt|	working with two to four versions of the same file
|autocmd.txt|	automatically executing commands on an event
|filetype.txt|	settings done specifically for a type of file
|eval.txt|	expression evaluation, conditional commands
|fold.txt|	hide (fold) ranges of lines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edición avanzada ~
|cmdline.txt|	Edición en línea de órdenes
|options.txt|	Descripción de todas las opciones
|pattern.txt|	Patrones de expresiones regulares y órdenes de búsqueda
|map.txt|	Macros y abreviaturas
|tagsrch.txt|	Etiquetas y búsquedas especiales
|quickfix.txt|	Órdenes para un rápido ciclo editar-compilar-arreglar
|windows.txt|	Órdenes de uso de múltiples ventanas y búfers
|tabpage.txt|	Órdenes de uso de múltiples pestañas
|syntax.txt|	Resaltado de sintaxis
|spell.txt|	Corrección ortográfica
|diff.txt|	Trabajar con un número de entre 2 y 4 copias del mismo archivo
|autocmd.txt|	Ejecutar órdenes de manera automática
|filetype.txt|	Configuración específica según el tipo de archivo
|eval.txt|	Evaluación de expresión, órdenes condicionales
|fold.txt|	Ocultar (plegar) rangos de líneas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI ~
|gui.txt|	Graphical User Interface (GUI)
|gui_w16.txt|	Windows 3.1 GUI
|gui_w32.txt|	Win32 GUI
|gui_x11.txt|	X11 GUI
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>GUI/IGU ~
|gui.txt|	Interfaz gráfica de usuario
|gui_w16.txt|	Interfaz gráfica de usuario de Windows 3.1
|gui_w32.txt|	Interfaz gráfica de usuario de Win32
|gui_x11.txt|	Interfaz gráfica de usuario de X11
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interfaces ~
|if_cscop.txt|	using Cscope with Vim
|if_lua.txt|	Lua interface
|if_mzsch.txt|	MzScheme interface
|if_perl.txt|	Perl interface
|if_pyth.txt|	Python interface
|if_sniff.txt|	SNiFF+ interface
|if_tcl.txt|	Tcl interface
|if_ole.txt|	OLE automation interface for Win32
|if_ruby.txt|	Ruby interface
|debugger.txt|	Interface with a debugger
|workshop.txt|	Sun Visual Workshop interface
|netbeans.txt|	NetBeans External Editor interface
|sign.txt|	debugging signs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaces ~
|if_cscop.txt|	Usar Cscope con Vim
|if_lua.txt|	Interfaz Lua
|if_mzsch.txt|	Interfaz de MzScheme
|if_perl.txt|	Interfaz de Perl
|if_pyth.txt|	Interfaz de Python
|if_sniff.txt|	Interfaz de SNiFF+
|if_tcl.txt|	Interfaz de Tcl
|if_ole.txt|	Interfaz de automatización de OLE para Win32
|if_ruby.txt|	Interfaz de Ruby
|debugger.txt|	Interfaz con un depurador de fallos
|workshop.txt|	Interfaz de Sun Visual Workshop
|netbeans.txt|	Interfaz de NetBeans External Editor (editor externo)
|sign.txt|	Signos de depuración de fallos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Versions ~
|vi_diff.txt|	Main differences between Vim and Vi
|version4.txt|	Differences between Vim version 3.0 and 4.x
|version5.txt|	Differences between Vim version 4.6 and 5.x
|version6.txt|	Differences between Vim version 5.7 and 6.x
|version7.txt|	Differences between Vim version 6.4 and 7.x
						*sys-file-list*
Remarks about specific systems ~
|os_390.txt|	OS/390 Unix
|os_amiga.txt|	Amiga
|os_beos.txt|	BeOS and BeBox
|os_dos.txt|	MS-DOS and MS-Windows NT/95 common items
|os_mac.txt|	Macintosh
|os_mint.txt|	Atari MiNT
|os_msdos.txt|	MS-DOS (plain DOS and DOS box under Windows)
|os_os2.txt|	OS/2
|os_qnx.txt|	QNX
|os_risc.txt|	RISC-OS
|os_unix.txt|	Unix
|os_vms.txt|	VMS
|os_win32.txt|	MS-Windows 95/98/NT
						*standard-plugin-list*
Standard plugins ~
|pi_getscript.txt| Downloading latest version of Vim scripts
|pi_gzip.txt|	   Reading and writing compressed files
|pi_netrw.txt|	   Reading and writing files over a network
|pi_paren.txt|	   Highlight matching parens
|pi_tar.txt|	   Tar file explorer
|pi_vimball.txt|   Create a self-installing Vim script
|pi_zip.txt|	   Zip archive explorer
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Versiones ~
|vi_diff.txt|	Diferencias principales entre Vim y Vi
|version4.txt|	Diferencias entre las versiones de Vim 3.0 y 4.x
|version5.txt|	Diferencias entre las versiones de Vim 4.6 y 5.x
|version6.txt|	Diferencias entre las versiones de Vim 5.7 y 6.x
|version7.txt|	Diferencias entre las versiones de Vim 6.4 y 7.x
						*sys-file-list*
Apuntes sobre sistemas específicos ~
|os_390.txt|	OS/390 Unix
|os_amiga.txt|	Amiga
|os_beos.txt|	BeOS and BeBox
|os_dos.txt|	Elementos comunes entre MS-DOS y MS-Windows NT/95
|os_mac.txt|	Macintosh
|os_mint.txt|	Atari MiNT
|os_msdos.txt|	MS-DOS - DOS puro y terminal de DOS bajo Windows)
|os_os2.txt|	OS/2
|os_qnx.txt|	QNX
|os_risc.txt|	RISC-OS
|os_unix.txt|	Unix
|os_vms.txt|	VMS
|os_win32.txt|	MS-Windows 95/98/NT
						*standard-plugin-list*
Extensiones estándar ~
|pi_getscript.txt| Descargar la última versión de Vim scripts
|pi_gzip.txt|	Leer y escribir archivos comprimidos
|pi_netrw.txt|	Leer y escribir archivos en una red
|pi_paren.txt|	Resaltar «parens» coincidentes
|pi_tar.txt|	Explorador de archivos Tar
|pi_vimball.txt|Crear un script de Vim autoinstalable
|pi_zip.txt|	Explorador de archivos Zip
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LOCAL ADDITIONS:				*local-additions*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ADICIONES LOCALES:				*local-additions*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>------------------------------------------------------------------------------
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>------------------------------------------------------------------------------
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*bars*		Bars example
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*bars*		Ejemplo de barras verticales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that tags are within | characters, but when highlighting is enabled these characters are hidden.  That makes it easier to read a command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que las etiquetas se encuentran entre caracteres «|», que se ocultarán si activa el resaltado. Ello hace más sencillo leer una orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg> vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_toc.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_toc.esx*	Para Vim versión 7.3.  Último cambio: 20/6/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Table Of Contents			*user-manual*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Tabla de contenidos		*manual-de-usuario* *user-manual*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference manual
|reference_toc|     More detailed information for all commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manual de referencia
|reference_toc|     Más información detallada de todas las órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user manual is available as a single, ready to print HTML and PDF file
here:
	http://vimdoc.sf.net
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de usuario está disponible en un único archivo listo para su
impresión, en formato PDF y HTML, en está ubicación:
	http://vimdoc.sf.net
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_01.txt|  About the manuals
		|01.1|	Two manuals
		|01.2|	Vim installed
		|01.3|	Using the Vim tutor
		|01.4|	Copyright
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_01.esx|  Acerca de los manuales
		|01.1|	Dos manuales
		|01.2|	Vim instalado
		|01.3|	Usar el tutor de Vim
		|01.4|	Copyright
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_02.txt|  The first steps in Vim
		|02.1|	Running Vim for the First Time
		|02.2|	Inserting text
		|02.3|	Moving around
		|02.4|	Deleting characters
		|02.5|	Undo and Redo
		|02.6|	Other editing commands
		|02.7|	Getting out
		|02.8|	Finding help
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_02.esx|  Primeros pasos en Vim
		|02.1|	Ejecutar Vim por primera vez
		|02.2|	Insertar texto
		|02.3|	Movimiento
		|02.4|	Eliminar caracteres
		|02.5|	Deshacer y rehacer
		|02.6|	Otras órdenes de edición
		|02.7|	Salir
		|02.8|	Encontrar ayuda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_03.txt|  Moving around
		|03.1|	Word movement
		|03.2|	Moving to the start or end of a line
		|03.3|	Moving to a character
		|03.4|	Matching a paren
		|03.5|	Moving to a specific line
		|03.6|	Telling where you are
		|03.7|	Scrolling around
		|03.8|	Simple searches
		|03.9|	Simple search patterns
		|03.10|	Using marks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_03.esx|  Desplazamiento
		|03.1|	Desplazarse sobre palabras
		|03.2|	Desplazarse al principio o al final de la línea
		|03.3|	Desplazarse a un carácter
		|03.4|	Emparejar un paréntesis
		|03.5|	Desplazarse a una línea específica
		|03.6|	Indicar dónde estás
		|03.7|	Desplazar el texto
		|03.8|	Búsquedas simples
		|03.9|	Patrones sencillos de búsqueda
		|03.10|	Uso de marcadores o marcas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_04.txt|  Making small changes
		|04.1|	Operators and motions
		|04.2|	Changing text
		|04.3|	Repeating a change
		|04.4|	Visual mode
		|04.5|	Moving text
		|04.6|	Copying text
		|04.7|	Using the clipboard
		|04.8|	Text objects
		|04.9|	Replace mode
		|04.10|	Conclusion
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_04.esx|  Making small changes
		|04.1|	Operadores y movimiento
		|04.2|	Cambiar texto
		|04.3|	Repetir un cambio
		|04.4|	Modo Visual
		|04.5|	Mover texto
		|04.6|	Copiar texto
		|04.7|	Uso del portapapeles
		|04.8|	Objetos de texto
		|04.9|	Modo reemplazar
		|04.10|	Conclusión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_05.txt|  Set your settings
		|05.1|	The vimrc file
		|05.2|	The example vimrc file explained
		|05.3|	Simple mappings
		|05.4|	Adding a plugin
		|05.5|	Adding a help file
		|05.6|	The option window
		|05.7|	Often used options
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_05.esx|  Configuración
		|05.1|	El archivo vimrc
		|05.2|	El archivo vimrc de ejemplo, explicado
		|05.3|	Macros sencillas
		|05.4|	Añadir una extensión
		|05.5|	Añadir un archivo de ayuda
		|05.6|	La ventana de opciones
		|05.7|	Opciones más comunes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_06.txt|  Using syntax highlighting
		|06.1|	Switching it on
		|06.2|	No or wrong colors?
		|06.3|	Different colors
		|06.4|	With colors or without colors
		|06.5|	Printing with colors
		|06.6|	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_06.esx|  Uso del resaltado de sintaxis
		|06.1|	Activar
		|06.2|	¿Colores incorrectos o ausentes?
		|06.3|	Diferentes colores
		|06.4|	Con colores o sin colores
		|06.5|	Imprimir con colores
		|06.6|	Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_07.txt|  Editing more than one file
		|07.1|	Edit another file
		|07.2|	A list of files
		|07.3|	Jumping from file to file
		|07.4|	Backup files
		|07.5|	Copy text between files
		|07.6|	Viewing a file
		|07.7|	Changing the file name
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_07.esx|  Editar más de un archivo
		|07.1|	Editar otro archivo
		|07.2|	Una lista de archivos
		|07.3|	Pasar de archivo a archivo
		|07.4|	Copias de seguridad
		|07.5|	Copiar texto entre archivos
		|07.6|	Ver un archivo
		|07.7|	Cambiar el nombre de archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_08.txt|  Splitting windows
		|08.1|	Split a window
		|08.2|	Split a window on another file
		|08.3|	Window size
		|08.4|	Vertical splits
		|08.5|	Moving windows
		|08.6|	Commands for all windows
		|08.7|	Viewing differences with vimdiff
		|08.8|	Various
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_08.esx|  Dividir en ventanas
		|08.1|	Dividir una ventana
		|08.2|	Dividir una ventana con otro archivo
		|08.3|	Tamaño de ventana
		|08.4|	Divisiones verticales
		|08.5|	Mover ventanas
		|08.6|	Órdenes sobre todas las ventanas
		|08.7|	Ver las diferencias con «vimdiff»
		|08.8|	Varios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_09.txt|  Using the GUI
		|09.1|	Parts of the GUI
		|09.2|	Using the mouse
		|09.3|	The clipboard
		|09.4|	Select mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_09.esx|  Uso de la interfaz gráfica (GUI)
		|09.1|	Partes de la interfaz gráfica
		|09.2|	Uso del ratón
		|09.3|	El portapapeles
		|09.4|	Modo Seleccionar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_10.txt|  Making big changes
		|10.1|	Record and playback commands
		|10.2|	Substitution
		|10.3|	Command ranges
		|10.4|	The global command
		|10.5|	Visual block mode
		|10.6|	Reading and writing part of a file
		|10.7|	Formatting text
		|10.8|	Changing case
		|10.9|	Using an external program
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_10.esx|  Realizar cambios grandes
		|10.1|	Órdenes de grabación y reproducción
		|10.2|	Sustitución
		|10.3|	Rangos de aplicación
		|10.4|	Las órdenes globales
		|10.5|	El modo de bloque Visual
		|10.6|	Leer y escribir parte de un archivo
		|10.7|	Formatear texto
		|10.8|	Cambiar mayúsculas y minúsculas
		|10.9|	Uso de un programa externo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_11.txt|  Recovering from a crash
		|11.1|	Basic recovery
		|11.2|	Where is the swap file?
		|11.3|	Crashed or not?
		|11.4|	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_11.esx|  Recuperarse de un fallo
		|11.1|  Recuperación básica
		|11.2|  ¿Dónde está el archivo de recuperación?
		|11.3|  ¿Se ha colgado o no?
		|11.4|  Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_12.txt|  Clever tricks
		|12.1|	Replace a word
		|12.2|	Change "Last, First" to "First Last"
		|12.3|	Sort a list
		|12.4|	Reverse line order
		|12.5|	Count words
		|12.6|	Find a man page
		|12.7|	Trim blanks
		|12.8|	Find where a word is used
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_12.esx|  Trucos
		|12.1|	Reemplazar una palabra
		|12.2|	Cambiar «Último, Primero» a «Primero Último»
		|12.3|	Ordenar una lista
		|12.4|	Invertir el orden de las líneas
		|12.5|	Contar palabras
		|12.6|	Encontrar una página de manual
		|12.7|	Eliminar espacios en blanco sobrantes
		|12.8|	Buscar dónde se emplea una palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_20.txt|  Typing command-line commands quickly
		|20.1|	Command line editing
		|20.2|	Command line abbreviations
		|20.3|	Command line completion
		|20.4|	Command line history
		|20.5|	Command line window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_20.esx|  Ser eficaz en la línea de órdenes
		|20.1|	Edición en línea de órdenes
		|20.2|	Abreviaturas en línea de órdenes
		|20.3|	Autocompletado en la línea de órdenes
		|20.4|	Histórico de la línea de órdenes
		|20.5|	Ventana de la línea de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_21.txt|  Go away and come back
		|21.1|	Suspend and resume
		|21.2|	Executing shell commands
		|21.3|	Remembering information; viminfo
		|21.4|	Sessions
		|21.5|	Views
		|21.6|	Modelines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_21.esx|  Abandonar el editor y volver
		|21.1|	Suspender y continuar
		|21.2|	Ejecutar órdenes de consola
		|21.3|	Recordar información; viminfo
		|21.4|	Sesiones
		|21.5|	Vistas
		|21.6|	«Modelines»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_22.txt|  Finding the file to edit
		|22.1|	The file explorer
		|22.2|	The current directory
		|22.3|	Finding a file
		|22.4|	The buffer list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_22.esx| Encontrar el archivo a editar
		|22.1|	El explorador de archivos
		|22.2|	El directorio actual
		|22.3|	Encontrar un archivo
		|22.4|	La lista de búfers
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_23.txt|  Editing other files
		|23.1|	DOS, Mac and Unix files
		|23.2|	Files on the internet
		|23.3|	Encryption
		|23.4|	Binary files
		|23.5|	Compressed files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_23.esx|  Editar otros archivos
		|23.1|	Archivos de DOS, Mac y Unix
		|23.2|	Archivos en Internet
		|23.3|	Cifrado
		|23.4|	Archivos binarios
		|23.5|	Archivos comprimidos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_24.txt|  Inserting quickly
		|24.1|	Making corrections
		|24.2|	Showing matches
		|24.3|	Completion
		|24.4|	Repeating an insert
		|24.5|	Copying from another line
		|24.6|	Inserting a register
		|24.7|	Abbreviations
		|24.8|	Entering special characters
		|24.9|	Digraphs
		|24.10|	Normal mode commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_24.esx|  Insertar con rapidez
		|24.1|	Corregir
|		24.2|	Mostrar coincidencias
		|24.3|	Autocompletado
		|24.4|	Repetir una inserción
		|24.5|	Copiar desde otra línea
		|24.6|	Insertar un registro
		|24.7|	Abreviaturas
		|24.8|	Introducir caracteres especiales
		|24.9|	Dígrafos
		|24.10|	Órdenes del modo Normal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_25.txt|  Editing formatted text
		|25.1|	Breaking lines
		|25.2|	Aligning text
		|25.3|	Indents and tabs
		|25.4|	Dealing with long lines
		|25.5|	Editing tables
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_25.txt|  Editar texto con formato
		|25.1|	Dividir líneas
		|25.2|	Alinear texto
		|25.3|	Sangrado y tabulación
		|25.4|	Tratar líneas largas
		|25.5|	Editar tablas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_26.txt|  Repeating
		|26.1|	Repeating with Visual mode
		|26.2|	Add and subtract
		|26.3|	Making a change in many files
		|26.4|	Using Vim from a shell script
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_26.txt|  Repetición
		|26.1|	Repetir en modo Visual
		|26.2|	Sumar y restar
		|26.3|	Realizar un cambio en varios archivos
		|26.4|	Usar Vim desde un script de intérprete de órdenes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_27.txt|  Search commands and patterns
		|27.1|	Ignoring case
		|27.2|	Wrapping around the file end
		|27.3|	Offsets
		|27.4|	Matching multiple times
		|27.5|	Alternatives
		|27.6|	Character ranges
		|27.7|	Character classes
		|27.8|	Matching a line break
		|27.9|	Examples
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		|usr_27.esx| Órdenes y patrones de búsqueda
		|27.1|	Ignorar la distinción entre mayúsculas y minúsculas
		|27.2|	Justificar el fin del archivo
		|27.3|	Dirección relativa («offsets»)
		|27.4|	Emparejar varios elementos
		|27.5|	Alternativas
		|27.6|	Rangos de caracteres
		|27.7|	Clases de caracteres
		|27.8|	Coincidir con un salto de línea
		|27.9|	Ejemplos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_28.txt|  Folding
		|28.1|	What is folding?
		|28.2|	Manual folding
		|28.3|	Working with folds
		|28.4|	Saving and restoring folds
		|28.5|	Folding by indent
		|28.6|	Folding with markers
		|28.7|	Folding by syntax
		|28.8|	Folding by expression
		|28.9|	Folding unchanged lines
		|28.10| Which fold method to use?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_28.txt|  Plegar
		|28.1|	¿Qué es plegar?
		|28.2|	Plegar manualmente
		|28.3|	Trabajar con pliegues
		|28.4|	Guardar y restaurar pliegues
		|28.5|	Plegar por sangrado
		|28.6|	Plegar con marcadores
		|28.7|	Plegar por sintaxis
		|28.8|	Plegar por expresión
		|28.9|	Plegar líneas sin cambios
		|28.10¿| ¿Qué método de plegar debería usar?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_29.txt|  Moving through programs
		|29.1|	Using tags
		|29.2|	The preview window
		|29.3|	Moving through a program
		|29.4|	Finding global identifiers
		|29.5|	Finding local identifiers
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_29.txt|  Moverse a través de programas
		|29.1|	Usar etiquetas
		|29.2|	La ventana de previsualización
		|29.3|	Moverse a través de un programa
		|29.4|	Buscar identificadores globales
		|29.5|	Buscar identificadores locales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_30.txt|  Editing programs
		|30.1|	Compiling
		|30.2|	Indenting C files
		|30.3|	Automatic indenting
		|30.4|	Other indenting
		|30.5|	Tabs and spaces
		|30.6|	Formatting comments
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_30.txt|  Editar programas
		|30.1|	Compilar
		|30.2|	Sangrado en archivos C
		|30.3|	Sangrado automático
		|30.4|	Otros sangrados
		|30.5|	Tabulados y espacios
		|30.6|	Formatear comentarios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_31.txt|  Exploiting the GUI
		|31.1|	The file browser
		|31.2|	Confirmation
		|31.3|	Menu shortcuts
		|31.4|	Vim window position and size
		|31.5|	Various
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_31.txt|  Sacar partido a la interfaz gráfica
		|31.1|	El explorador de archivos
		|31.2|	Confirmación
		|31.3|	Atajos de teclado para menús
		|31.4|	Posición y tamaño de la ventana de Vim
		|31.5|	Varios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_32.txt|  The undo tree
		|32.1|	Undo up to a file write
		|32.2|	Numbering changes
		|32.3|	Jumping around the tree
		|32.4|	Time travelling
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_32.txt|  El árbol de deshacer
		|32.1|Volver a un punto de edición anterior
		|32.2|Numerar los cambios
		|32.3|Desplazarse en el árbol
		|32.4|Viajar en el tiempo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_40.txt|  Make new commands
		|40.1|	Key mapping
		|40.2|	Defining command-line commands
		|40.3|	Autocommands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_40.txt|  Crear órdenes nuevas
		|40.1|Macros de teclado
		|40.2|Definir órdenes de línea de órdenes
		|40.3|Órdenes automáticas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_41.txt|  Write a Vim script
		|41.1|	Introduction
		|41.2|	Variables
		|41.3|	Expressions
		|41.4|	Conditionals
		|41.5|	Executing an expression
		|41.6|	Using functions
		|41.7|	Defining a function
		|41.8|	Lists and Dictionaries
		|41.9|	Exceptions
		|41.10|	Various remarks
		|41.11|	Writing a plugin
		|41.12|	Writing a filetype plugin
		|41.13|	Writing a compiler plugin
		|41.14|	Writing a plugin that loads quickly
		|41.15|	Writing library scripts
		|41.16|	Distributing Vim scripts
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_41.txt|  Escribir scripts para Vim
		|41.1|	Introducción
		|41.2|	Variables
		|41.3|	Expresiones
		|41.4|	Estructuras de decisión
		|41.5|	Ejecución de expresiones
		|41.6|	Funciones
		|41.7|	Definición de funciones
		|41.8|	Listas y Diccionarios
		|41.9|	Excepciones
		|41.10|	Observaciones
		|41.11|	Escribir extensiones
		|41.12|	Escribir extensiones para tipo de archivo		|41.13|	Escribir extensiones para compiladores		|41.14|	Escribir extensiones que carguen rápidamente
		|41.15|	Escribir bibliotecas
		|41.16|	Distribuir scripts de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_06.txt*	For Vim version 7.3.  Last change: 2009 Oct 28
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_06.esx*	Para Vim version 7.3.  Último cambio: 24/5/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			  Using syntax highlighting
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			 Uso del resaltado de sintaxis
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Black and white text is boring.  With colors your file comes to life.  This not only looks nice, it also speeds up your work.  Change the colors used for the different sorts of text.  Print your text, with the colors you see on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto en blanco y negro es aburrido. Con colores los archivos tienen más vida. No sólo adquieren mejor apariencia, si no que acelera la producción.  Cambie los colores para distintos tipos de texto. Imprima sus textos con los colores que ve en pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|06.1|	Switching it on
|06.2|	No or wrong colors?
|06.3|	Different colors
|06.4|	With colors or without colors
|06.5|	Printing with colors
|06.6|	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|06.1|	Activar
|06.2|	¿Colores incorrectos o ausentes?
|06.3|	Diferentes colores
|06.4|	Con colores o sin colores
|06.5|	Imprimir con colores
|06.6|	Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_07.txt|  Editing more than one file
 Previous chapter: |usr_05.txt|  Set your settings
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_07.esx|  Editar más de un archivo
  Capítulo anterior: |usr_05.esx|  Configuración
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.1*	Switching it on
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.1*	Activar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:syntax enable
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:syntax enable
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That should work in most situations to get color in your files.  Vim will automagically detect the type of file and load the right syntax highlighting.  Suddenly comments are blue, keywords brown and strings red.  This makes it easy to overview the file.  After a while you will find that black&amp;white text slows you down!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto debería funcionar en la mayoría de las situaciones para obtener el coloreado. Vim detectará automágicamente el tipo de archivo y cargará la sintaxis correspondiente. De repente, los comentarios, las palabras clave y las cadenas se colorean. Esto facilita una vista general del archivo.  ¡Tras usarlo un poco se dará cuenta de lo que le ralentizaba la edición el blanco y negro!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if &amp;t_Co &gt; 1
	   syntax enable
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if &amp;t_Co &gt; 1
	   syntax enable
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.2*	No or wrong colors?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.2*	¿Colores incorrectos o ausentes?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Your terminal does not support colors.
	Vim will use bold, italic and underlined text, but this doesn't look
	very nice.  You probably will want to try to get a terminal with
	colors.  For Unix, I recommend the xterm from the XFree86 project:
	|xfree-xterm|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Su terminal no soporta colores.
	Vim usará negrita, itálica y texto subrayado, pero esto no es muy
	agradable. Probablemente quiera probar una terminal con colores.
	Para Unix, se recomienda usar la xterm del proyecto XFree86:
	|xfree-xterm|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Your terminal does support colors, but Vim doesn't know this.
	Make sure your $TERM setting is correct.  For example, when using an
	xterm that supports colors: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Su terminal soporta colores, pero Vim no lo sabe.
	Asegúrese de que la variable $TERM es correcta. Por ejemplo, cuando
	use una xterm que soporte colores: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		setenv TERM xterm-color
&lt;
	or (depending on your shell): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		setenv TERM xterm-color
&lt;
	o (dependiendo de su consola): &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		TERM=xterm-color; export TERM
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		TERM=xterm-color; export TERM
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	The terminal name must match the terminal you are using.  If it
	still doesn't work, have a look at |xterm-color|, which shows a few
	ways to make Vim display colors (not only for an xterm).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	El nombre de la terminal debe coincidir con la terminal que esté
	usando. Si aún así no funciona, consulte |xterm-color|,
	donde puede ver unas cuantas maneras de hacer que se vean colores.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- The file type is not recognized.
	Vim doesn't know all file types, and sometimes it's near to impossible
	to tell what language a file uses.  Try this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El tipo de archivo no es reconocido.
	Vim no conoce todos los tipos de archivos, y a veces es casi imposible
	decir que lenguaje usa un archivo. Pruebe esta orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		:set filetype
&lt;
	If the result is "filetype=" then the problem is indeed that Vim
	doesn't know what type of file this is.  You can set the type
	manually: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		:set filetype
&lt;
	Si el resultado es «filetype=» entonces el problema es que Vim no sabe
	que de qué tipo de archivo se trata. Puede decirle el tipo de archivo
	de forma manual: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		:set filetype=fortran
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		:set filetype=fortran
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	To see which types are available, look in the directory
	$VIMRUNTIME/syntax.  For the GUI you can use the Syntax menu.
	Setting the filetype can also be done with a |modeline|, so that the
	file will be highlighted each time you edit it.  For example, this
	line can be used in a Makefile (put it near the start or end of the
	file): &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Para ver qué tipos de archivos están disponibles,  mire en el
	directorio «$VIMRUNTIME/syntax». Para la GUI puede usar el menú Syntax.
        También puede activar el tipo de archivo con un |modeline|, de forma
	que el archivo se resaltará cada vez que lo edite. Por ejemplo, puede
	emplear esta línea para los Makefiles (insértela cerca del principio o
	el final del archivo): &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		# vim: syntax=make
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		# vim: syntax=make
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	You might know how to detect the file type yourself.  Often the file
	name extension (after the dot) can be used.
	See |new-filetype| for how to tell Vim to detect that file type.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Quizá sepa cómo detectar el tipo de archivo por cuenta propia. A
	menudo se puede emplear la extensión del nombre de archivo.
	Véase |new-filetype| para ver cómo decirle a Vim que detecte el tipo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- There is no highlighting for your file type.
	You could try using a similar file type by manually setting it as
	mentioned above.  If that isn't good enough, you can write your own
	syntax file, see |mysyntaxfile|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- No hay resaltado para su tipo de archivo.
	Puede intentar usar un archivo similar activándolo manualmente como se
	explica más arriba. Si no tiene suficiente, puede escribir su propio
	archivo de sintaxis, consulte |mysyntaxfile|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- The colored text is very hard to read.
	Vim guesses the background color that you are using.  If it is black
	(or another dark color) it will use light colors for text.  If it is
	white (or another light color) it will use dark colors for text.  If
	Vim guessed wrong the text will be hard to read.  To solve this, set
	the 'background' option.  For a dark background: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El texto coloreado es muy difícil de leer.
	Vim trata de averiguar el color de fondo que está usando. Si es negro
	(u otro color oscuro) usará colores claros para el texto. Si es blanco
	(u otro color claro) usará colores oscuros para el texto. Si Vim no ha
	acertado, el texto se hará difícil de leer. Para solucionar esto,
	active la opción 'background'. Para un fondo oscuro: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		:set background=dark
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		:set background=dark
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	And for a light background: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Y para un fondo claro: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		:set background=light
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		:set background=light
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	Make sure you put this _before_ the ":syntax enable" command,
	otherwise the colors will already have been set.  You could do
	":syntax reset" after setting 'background' to make Vim set the default
	colors again.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Asegúrese de que lo pone _antes_ de «:syntax enable», en caso
	contrario, los colores ya se habrán definido. Puede hacer «:syntax
	reset» tras activar 'background' para hacer que Vim vuelva a redefinir
	los colores.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.3*	Different colors				*:syn-default-override*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.3*	Diferentes colores				*:syn-default-override*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like the default colors, you can select another color scheme.  In the GUI use the Edit/Color Scheme menu.  You can also type the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gustan los colores predeterminados, puede seleccionar otro esquema de colores. En GVim, use el menú Edit/Color. También puede usar la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:colorscheme evening
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:colorscheme evening
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"evening" is the name of the color scheme.  There are several others you might want to try out.  Look in the directory $VIMRUNTIME/colors.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«evening» es el nombre del esquema de colores. Hay muchos otros que quizá quiera probar. Mire en el directorio «$MYVIMRUNTIME/colors».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also write your own color scheme.  This is how you do it:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede escribir su propio esquema de colores. Así es que como se hace:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. Select a color scheme that comes close.  Copy this file to your own Vim
   directory.  For Unix, this should work: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. Seleccione un esquema que se parezca. Copie ese archivo a su propio
   directorio de Vim. Bajo Unix, esto debería funcionar: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	!mkdir ~/.vim/colors
	!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim
&lt;
   This is done from Vim, because it knows the value of $VIMRUNTIME.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	!mkdir ~/.vim/colors
	!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim
&lt;
   Esto se hace desde Vim, porque conoce el valor de $VIMRUNTIME.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. Edit the color scheme file.  These entries are useful:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. Editar el archivo del esquema de colores. Estas entradas son
   útiles:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	term		attributes in a B&amp;W terminal
	cterm		attributes in a color terminal
	ctermfg		foreground color in a color terminal
	ctermbg		background color in a color terminal
	gui		attributes in the GUI
	guifg		foreground color in the GUI
	guibg		background color in the GUI
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	term		atributos en una terminal B/N
	cterm		atributos en una terminal a color
	ctermfg		color frontal de una terminal a color
	ctermbg		color de fondo de una terminal a color
	gui		atributos de la GUI
	guifg		color frontal de la GUI
	guibg		color de fondo de la GUI
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   For example, to make comments green: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   Por ejemplo, para hacer los comentarios en verde: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:highlight Comment ctermfg=green guifg=green
&lt;
   Attributes you can use for "cterm" and "gui" are "bold" and "underline".
   If you want both, use "bold,underline".  For details see the |:highlight|
   command.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:highlight Comment ctermfg=green guifg=green
&lt;
   Los atributos que puede usar para «cterm» y «gui» son «bold» y «underline».
   Si quiere los dos, escriba «bold,underline». Para más detalles, consulte la
   orden |:highlight|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3. Tell Vim to always use your color scheme.  Put this line in your |vimrc|: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3.  Decir a Vim que use siempre su esquema. Incluya esto en su |vimrc|: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	colorscheme mine
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	colorscheme mine
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:runtime syntax/colortest.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:runtime syntax/colortest.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see text in various color combinations.  You can check which ones are readable and look nice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá texto en varias combinaciones de colores. Puede comprobar cuáles son legibles y que tienen un apariencia agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.4*	With colors or without colors
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.4*	Con colores o sin colores
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Displaying text in color takes a lot of effort.  If you find the displaying too slow, you might want to disable syntax highlighting for a moment: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mostrar texto en color conlleva un gran uso del procesador. Si le parece que el texto se muestra muy lentamente, puede desactivar el resaltado momentáneamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:syntax clear
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:syntax clear
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*:syn-off*
If you want to stop highlighting completely use: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*:syn-off*
Si quiere desactivar el resaltado por completo use: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:syntax off
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:syntax off
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*:syn-manual*
If you want syntax highlighting only for specific files, use this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*:syn-manual*
Si desea resaltado de sintaxis sólo para archivos específicos, use esto: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:syntax manual
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:syntax manual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will enable the syntax highlighting, but not switch it on automatically when starting to edit a buffer.  To switch highlighting on for the current buffer, set the 'syntax' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permitirá el resaltado, pero no lo activará automáticamente cuando edites un búfer. Para activarla en el búfer actual, asigne la opción 'syntax' del siguiente modo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set syntax=ON
&lt;
==============================================================================
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set syntax=ON
==============================================================================
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.5*	Printing with colors				*syntax-printing*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.5*	Imprimir con colores				*syntax-printing*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:hardcopy
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:hardcopy
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will get the usual printer dialog, where you can select the printer and a few settings.  If you have a color printer, the paper output should look the same as what you see inside Vim.  But when you use a dark background the colors will be adjusted to look good on white paper.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le aparecerá el típico diálogo de impresora, donde puede seleccionarla junto con algunas opciones. Si tiene una impresora a color, la salida impresa debe ser similar a lo que aparece en pantalla. Sin embargo, cuando tiene un fondo oscuro, los colores se ajustarán para verse bien sobre blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several options that change the way Vim prints:
	'printdevice'
	'printheader'
	'printfont'
	'printoptions'
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay diversas opciones que modifican el modo en el que Vim imprime:
	'printdevice'
	'printheader'
	'printfont'
	'printoptions'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	v100j:hardcopy
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	v100j:hardcopy
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v" starts Visual mode.  "100j" moves a hundred lines down, they will be highlighted.  Then ":hardcopy" will print those lines.  You can use other commands to move in Visual mode, of course.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«v» inicia el modo Visual. «100j» le mueve 100 líneas hacia abajo, que se resaltarán. Por último «:hardcopy» imprimirá las líneas destacadas. Puede usar otras órdenes para moverse en modo Visual, por supuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works on Unix, if you have a PostScript printer.  Otherwise, you will have to do a bit more work.  You need to convert the text to HTML first, and then print it from a web browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona en Unix si tiene una impresora PostScript. En caso contrario, tendrá que hacer un poco más de trabajo. Tendrá que convertir a HTML primero y luego imprimirlo desde un navegador web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:TOhtml
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:TOhtml
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:source $VIMRUNTIME/syntax/2html.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:source $VIMRUNTIME/syntax/2html.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see it crunching away, this can take quite a while for a large file.
Some time later another window shows the HTML code.  Now write this somewhere
(doesn't matter where, you throw it away later):
&gt;
	:write main.c.html
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo verá trabajar, esto puede llevar un buen tiempo para archivos grandes.
Un rato después otra ventana muestra el código HTML. Ahora guarde esto en algún
lugar (no importa dónde, lo eliminará en cuanto termine de imprimir):
&gt;
	:write main.c.html
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open this file in your favorite browser and print it from there.  If all goes well, the output should look exactly as it does in Vim.  See |2html.vim| for details.  Don't forget to delete the HTML file when you are done with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Abra este archivo en su navegador favorito e imprímalo desde allí. Si todo ha salido bien, la salida debe tener la misma apariencia que tenía en Vim.  Véase |2html.vim| para más detalles. No se olvide de eliminar el archivo HTML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.6*	Further reading
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.6*	Más información
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_44.txt|  Your own syntax highlighted.
|syntax|      All the details.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_44.txt|  Su propio resaltado de sintaxis.
|syntax|      Todos los detalles.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_12.txt*	For Vim version 7.3.  Last change: 2007 May 11
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_12.esx*	Para Vim versión 7.3.  Último cambio: 11/6/2007
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				Clever tricks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				Trucos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By combining several commands you can make Vim do nearly everything.  In this chapter a number of useful combinations will be presented.  This uses the commands introduced in the previous chapters and a few more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes conseguir que Vim haga casi cualquier cosa,.mediante la combinación varias órdenes. En este capítulo, presentaremos una serie de combinaciones útiles. Esto emplea las órdenes introducidos en capítulos anteriores y algunos más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|12.1|	Replace a word
|12.2|	Change "Last, First" to "First Last"
|12.3|	Sort a list
|12.4|	Reverse line order
|12.5|	Count words
|12.6|	Find a man page
|12.7|	Trim blanks
|12.8|	Find where a word is used
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|12.1|	Reemplazar una palabra
|12.2|	Cambiar «Último, Primero» a «Primero Último»
|12.3|	Ordenar una lista
|12.4|	Invertir el orden de las líneas
|12.5|	Contar palabras
|12.6|	Encontrar una página de manual
|12.7|	Eliminar espacios en blanco sobrantes
|12.8|	Buscar dónde se emplea una palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_20.txt|  Typing command-line commands quickly
 Previous chapter: |usr_11.txt|  Recovering from a crash
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_20.esx|  Ser eficaz con la línea de órdenes
  Capítulo anterior: |usr_11.esx|  Recuperarse de un fallo
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.1*	Replace a word
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.1*  Reemplazar una palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/four/4/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/cuatro/4/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\&lt;four/4/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\&lt;cuatro/4/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, this still goes wrong on "fourteen".  Use "\&gt;" to match the end of a word: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, esto también funcionará mal con «cuatrocientos». Use «\&gt;» para concordar el final de una palabra: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\&lt;four\&gt;/4/g
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\&lt;cuatro\&gt;/4/g
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are programming, you might want to replace "four" in comments, but not in the code.  Since this is difficult to specify, add the "c" flag to have the substitute command prompt you for each replacement: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está programando, quizá desee reemplazar «cuatro» en los comentarios, pero no en el código. Ya que es difícil de especificar, añada la opción «c» para que se le pida una confirmación cada vez que se vaya a reemplazar la palabra: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\&lt;four\&gt;/4/gc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\&lt;cuatro\&gt;/4/gc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to replace a word in more than one file.  You could edit each
file and type the command manually.  It's a lot faster to use record and
playback.
   Let's assume you have a directory with C++ files, all ending in ".cpp".
There is a function called "GetResp" that you want to rename to "GetAnswer".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiere reemplazar una palabra en más de un archivo. Puede
editar cada archivo y escribir la orden manualmente. Es mucho más fácil
usar la grabación y reproducción.
   Vamos a suponer que tiene un directorio con archivos C++ en el que todos
terminan en «.cpp». Quiere renombrar la función «GetResp» a «GetAnswer».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the last file you will get an error message, because ":wnext" cannot move to the next file.  This stops the execution, and everything is done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el último archivo obtendrá un mensaje de error, porque «wnext» no puede ir a un archivo siguiente. Esto parará la ejecución y todo terminará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	When playing back a recorded sequence, an error stops the execution.
	Therefore, make sure you don't get an error message when recording.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Cuando vuelva a reproducir una secuencia grabada, un error detendrá la
	ejecución. Cuide de no producir errores cuando grabes.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop.  To avoid this, add the "e" flag to the substitute command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra «GetResp», obtendrá un error y la ejecución se detendrá. Para evitar esto, añada la opción «e» a la orden de sustituir: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\&lt;GetResp\&gt;/GetAnswer/ge
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\&lt;GetResp\&gt;/GetAnswer/ge
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.2*	Change "Last, First" to "First Last"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.2*	Cambiar «Último, Primero» a «Primero Último»
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Doe, John ~
	Smith, Peter ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Pepe, Juan ~
	Amancio, Pedro ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	John Doe ~
	Peter Smith ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Juan Pepe ~
	Pedro Amancio ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\([^,]*\), \(.*\)/\2 \1/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\([^,]*\), \(.*\)/\2 \1/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's break this down in parts.  Obviously it starts with a substitute
command.  The "%" is the line range, which stands for the whole file.  Thus
the substitution is done in every line in the file.
   The arguments for the substitute command are "/from/to/".  The slashes
separate the "from" pattern and the "to" string.  This is what the "from"
pattern contains:
							\([^,]*\), \(.*\) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veámoslo por partes. Obviamente comienza con la orden «substitute».
El «%» es el rango de líneas, que se refiere al archivo completo. Por lo
tanto la sustitución se producirá en cada línea del archivo.
   Los argumentos para la orden sustituir son «/desde/a/». Las barras
separan el patrón «desde» y la cadena "hacia". Esto es lo que el patrón
«desde» contiene:
							\([^,]*\), \(.*\) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The first part between \( \) matches "Last"	\(     \)
	    match anything but a comma			  [^,]
	    any number of times				      *
	matches ", " literally					 ,
	The second part between \( \) matches "First"		   \(  \)
	    any character					     .
	    any number of times					      *
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	La primera parte entre \( \) concuerda «Último» \(     \)
	    concordar cualquier cosa excepto una coma     [^,]
	    cualquier número de veces                         *
	concuerda literalmente ", "                              ,
	La segunda parte entre \(  \) concuerda «Primero»	   \(  \)
	    cualquier carácter                                       .
	    cualquier número de veces 					     *
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the "to" part we have "\2" and "\1".  These are called backreferences.
They refer to the text matched by the "\( \)" parts in the pattern.  "\2"
refers to the text matched by the second "\( \)", which is the "First" name.
"\1" refers to the first "\( \)", which is the "Last" name.
   You can use up to nine backreferences in the "to" part of a substitute
command.  "\0" stands for the whole matched pattern.  There are a few more
special items in a substitute command, see |sub-replace-special|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la parte «a» tenemos «\2» y «\1». A esto se le llaman referencias
«inversas». Se refieren al texto encontrado por los «\( \)» del patrón. «\2» se
refiere al texto del segundo «\( \)», que es el nombre «Primero». «\1» se
refiere al primer «\( \)», que es el nombre «Último».
   Puede usar hasta nueve referencias «inversas» en la parte «a» de una
orden de sustitución. «\0x se refiere a la cadena coincidente completa. Hay
otros elementos especiales en una orden sustituir,
consulte |sub-replace-special|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.3*	Sort a list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.3*	Ordenar una lista
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Makefile you often have a list of files.  For example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A menudo, en un archivo Makefile tiene una lista de archivos. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/^OBJS
	j
	:.,/^$/-1!sort
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/^OBJS
	j
	:.,/^$/-1!sort
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This goes to the first line, where "OBJS" is the first thing in the line.
Then it goes one line down and filters the lines until the next empty line.
You could also select the lines in Visual mode and then use "!sort".  That's
easier to type, but more work when there are many lines.
   The result is this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto va a la primera línea, donde «OBJS» es lo primero que se encuentra en una
línea. Luego baja una línea y filtra las líneas hasta encontrar una línea
vacía. También podría seleccionar las líneas en modo Visual y escribir
«!sort». Es más fácil pero conlleva más trabajo cuando hay muchas líneas.
   El resultado es el siguiente:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a backslash at the end of each line is used to indicate the line
continues.  After sorting, this is wrong!  The "backup.o" line that was at
the end didn't have a backslash.  Now that it sorts to another place, it
must have a backslash.
   The simplest solution is to add the backslash with "A \&lt;Esc&gt;".  You can
keep the backslash in the last line, if you make sure an empty line comes
after it.  That way you don't have this problem again.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que una barra inversa al final de cada línea se usa para indicar
que la línea continúa. Tras ordenar, está mal puesto. La línea de «backup.o»
que estaba al final no tenía una barra inversa. Ahora que se sitúa en otro
lugar debe tener una barra inversa.
   La solución más sencilla es añadirla con «A \&lt;Esc&gt;». Puede mantener la
barra en la última línea si se asegura de que una línea en blanco viene justo
después. De este modo no tendrá este problema de nuevo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.4*	Reverse line order
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.4*	Invertir el orden de las líneas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:global| command can be combined with the |:move| command to move all the lines before the first line, resulting in a reversed file.  The command is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «|:global|» se debe combinar con la orden «|:move|» para mover todas las líneas antes de la primera línea, invirtiendo el archivo.  La orden es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:global/^/m 0
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:global/^/m 0
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:g/^/m 0
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:g/^/m 0
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" regular expression matches the beginning of the line (even if the line is blank).  The |:move| command moves the matching line to after the mythical zeroth line, so the current matching line becomes the first line of the file.  As the |:global| command is not confused by the changing line numbering, |:global| proceeds to match all remaining lines of the file and puts each as the first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La expresión regular «^» coincide con el comienzo de línea (incluso si la línea está en blanco). La orden «|:move|» mueve la línea justo después de la mítica «línea cero», de forma que se convierte en la primera línea. Como la orden «|:global|» no se confunde al cambiar la numeración de las líneas, «|:global|» procede a concordar el resto de líneas del archivo y pone cada una como la primera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works on a range of lines.  First move to above the first line and mark it with "mt".  Then move the cursor to the last line in the range and type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona sobre un rango de líneas. Vaya primero a la línea de encima de la primera y márcala con "mt".  Luego pon el cursor en la última línea del rango y escribe: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:'t+1,.g/^/m 't
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:'t+1,.g/^/m 't
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.5*	Count words
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.5*	Contar palabras
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces puede escribir un texto con un número máximo de palabras. Vim
puede contar las palabras por Ud.
   Cuando quiera usar el archivo completo para contar las palabras, use la
siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	g CTRL-G
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	g CTRL-G
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No teclee un espacio tras la «g», esto está aquí para hacer que la orden sea
fácil de leer.
   La salida tendrá este aspecto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Col 1 of 0; Línea 141 of 157; Palabra 748 of 774; Carácter 4489 of 4976 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the text is only part of a file, you could move to the start of the text, type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then use your brain to compute the difference in the word position.  That's a good exercise, but there is an easier way.  With Visual mode, select the text you want to count words in.  Then type g CTRL-G.  The result:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando el texto sea sólo una parte del archivo, puede ir al comienzo del texto, pulsar «g CTRL-G», ir al final del texto y volver a escribir «g CTRL-G» y usar la cabeza para calcular la diferencia. Es un buen ejercicio, pero hay un modo más sencillo. En el modo Visual, seleccione el texto sobre el que quiera contar las palabras. Escriba «g CTRL-G». El resultado será:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Selección 5 of 293 Líneas; 70 of 1884 Palabras; 359 of 10928 Bytes ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.6*	Find a man page					*find-manpage*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.6*	Encontrar una página de manual		*find-manpage*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	K
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	K
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will run the external "man" program on the word.  If the man page is found, it is displayed.  This uses the normal pager to scroll through the text (mostly the "more" program).  When you get to the end pressing &lt;Enter&gt; will get you back into Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ejecutará el programa externo «man» sobre la palabra. Si se encuentra la página de manual, se mostrará. Esto usa el paginador normal para desplazarse por el texto (con el programa «more»). Cuando llegue al final, presionando &lt;Intro&gt; le devolverá a Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage is that you can't see the man page and the text you are working on at the same time.  There is a trick to make the man page appear in a Vim window.  First, load the man filetype plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una desventaja es que no puede ver la página de manual y el texto en el que trabaja al mismo tiempo. Hay un truco para hacer que la página de manual aparezca en una ventana de Vim. Primero cargue la extensión del tipo de archivo man: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:runtime! ftplugin/man.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:runtime! ftplugin/man.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this command in your vimrc file if you intend to do this often.  Now you can use the ":Man" command to open a window on a man page: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga esta orden en su archivo «vimrc» si tiene la intención de hacer esto a menudo. Ahora puede usar «:Man» para ver una página man en una ventana: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Man csh
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Man csh
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can scroll around and the text is highlighted.  This allows you to find
the help you were looking for.  Use CTRL-W w to jump to the window with the
text you were working on.
   To find a man page in a specific section, put the section number first.
For example, to look in section 3 for "echo": &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desplazarse alrededor y el texto se resaltará. Esto le permite
encontrar la ayuda que estaba buscando. Use «CTRL-W w» para saltar a la
ventana con el texto en el que trabajaba.
   Para encontrar la página de manual en una sección específica, ponga el
número de sección primero. Por ejemplo, para ver «echo» en la sección 3: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:Man 3 echo
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:Man 3 echo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To jump to another man page, which is in the text with the typical form "word(1)", press CTRL-] on it.  Further ":Man" commands will use the same window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar a otra página de manual, la cuál está en el texto con la forma típica «word(1)», pulse «CTRL-]» sobre ella. Otras llamadas a «:Man» emplearán la misma ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	\K
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	\K
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If you redefined the &lt;Leader&gt;, use it instead of the backslash).  For example, you want to know the return value of "strstr()" while editing this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si ha redefinido &lt;Leader&gt;, úselo en lugar de la barra inversa). Por ejemplo, puede que quiera saber el valor que le devuelve «strstr()» mientras edita esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if ( strstr (input, "aap") == ) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if ( strstr (input, "aap") == ) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to somewhere on "strstr" and type "\K".  A window will open to display the man page for strstr().</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga el cursor en alguna parte de «strstr» y escriba «\K». Una ventana se abrirá a continuación para mostrar la página de manual de «strstr()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.7*	Trim blanks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.7*	Eliminar espacios en blanco sobrantes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some people find spaces and tabs at the end of a line useless, wasteful, and ugly.  To remove whitespace at the end of every line, execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas personas encuentran los espacios y los tabuladores al final de línea inútiles y feos. Para eliminar el espacio en blanco al final de cada línea, ejecute la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%s/\s\+$//
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%s/\s\+$//
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line range "%" is used, thus this works on the whole file.  The pattern
that the ":substitute" command matches with is "\s\+$".  This finds white
space characters (\s), 1 or more of them (\+), before the end-of-line ($).
Later will be explained how you write patterns like this |usr_27.txt|.
   The "to" part of the substitute command is empty: "//".  Thus it replaces
with nothing, effectively deleting the matched white space.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El rango de línea «%» es empleado, funcionando sobre todo en el archivo
completo. El patrón que la orden «:substitute» concuerda es el «\s\+$».
Esto encuentra los caracteres en blanco (\s), 1 o más (\+), antes del final
de línea ($).
Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.
   La parte «hacia» de la orden de sustituxión está vacía: «//». Por lo tanto
reemplaza con nada, lo que de hecho elimina el espacio en blanco.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another wasteful use of spaces is placing them before a tab.  Often these can be deleted without changing the amount of white space.  But not always! Therefore, you can best do this manually.  Use this search command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro uso desafortunado de los espacios es colocarlos antes de un tabulador. A menudo, se pueden eliminar sin cambiar la cantidad de espacio en blanco.  ¡Pero no siempre! Por lo tanto, lo mejor es que lo haga a mano. Use esta orden de búsqueda: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/ 	
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/	
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot see it, but there is a space before a tab in this command.  Thus
it's "/&lt;Space&gt;&lt;Tab&gt;".   Now use "x" to delete the space and check that the
amount of white space doesn't change.  You might have to insert a tab if it
does change.  Type "n" to find the next match.  Repeat this until no more
matches can be found.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede verlo, pero hay un espacio antes de un tabulador en esta orden. De
hecho, es «/&lt;Espacio&gt;&lt;Tabulador&gt;». Use ahora «x» para eliminar el espacio
y comprobar que la cantidad de espacio en blanco no cambia. Puede que
tenga que insertar un tabulador si cambia. Teclee «n» para encontrar la
próxima coincidencia. Repita esto hasta que no se encuentren más
concordancias.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.8*	Find where a word is used
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.8*	Buscar donde se emplea una palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.  This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.
   For example, suppose you want to edit all the C program files that contain
the word "frame_counter".  To do this you use the command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si eres un usuario de sistemas UNIX, puede usar una combinación de Vim
y «grep» para editar todos los archivos que contengan la palabra dada.
Esto es extremadamente útil si está trabajando en un programa y quiere
ver o editar todos los archivos que contienen una variable específica.
   Por ejemplo, suponga que desea editar todos los archivos C que contengan
la palabra «frame_counter». Para hacer esto, use la orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim `grep -l frame_counter *.c`
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim `grep -l frame_counter *.c`
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command only finds the files in which the word is found.  You still
have to find the word within the files.
   Vim has a built-in command that you can use to search a set of files for a
given string.  If you want to find all occurrences of "error_string" in all C
program files, for example, enter the following command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden anterior sólo dice los archivos en los cuáles se encuentra la
palabra. Todavía tendrás que encontrar la palabra entre los archivos.
   Vim tiene una orden integrada que puede usar para buscar una cadena
en un conjunto de archivos. Si desea encontrar todas las coincidencias de
«error_string» en todos los archivos C, por ejemplo, introduzca lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:grep error_string *.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:grep error_string *.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This causes Vim to search for the string "error_string" in all the specified
files (*.c).  The editor will now open the first file where a match is found
and position the cursor on the first matching line.  To go to the next
matching line (no matter in what file it is), use the ":cnext" command.  To go
to the previous match, use the ":cprev" command.  Use ":clist" to see all the
matches and where they are.
   The ":grep" command uses the external commands grep (on Unix) or findstr
(on Windows).  You can change this by setting the option 'grepprg'.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim busque la cadena «error_string» en cada uno de los
archivos especificados (*.c). El editor abrirá el primer archivo donde se
produzca una concordancia y posicionará el cursor en la primera línea
coincidente.
Para ir a la siguiente línea (no importa en que archivo se encuentre), use la
orden «:cnext». Para ir a la anterior, use «:cprev». Use «:clist» para ver
todas las coincidencias y dónde están.
  La orden «:grep"» usa la orden externa «grep» en Unix y «findstr» en
Windows.
Puedes cambiar esto modificando la opción 'grepprg'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_04.txt*	For Vim version 7.3.  Last change: 2008 Sep 06
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_04.esx*	Para Vim versión 7.3.  Último cambio: 7/6/2008
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Making small changes
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			   Hacer cambios pequeños
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter shows you several ways of making corrections and moving text around.  It teaches you the three basic ways to change text: operator-motion, Visual mode and text objects.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo le muestra diferentes formas de hacer correcciones y moverse en el texto. Le muestra los tres modos básicos de cambiar texto: operador-movimiento, modo Visual y objetos de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|04.1|	Operators and motions
|04.2|	Changing text
|04.3|	Repeating a change
|04.4|	Visual mode
|04.5|	Moving text
|04.6|	Copying text
|04.7|	Using the clipboard
|04.8|	Text objects
|04.9|	Replace mode
|04.10|	Conclusion
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|04.1|	Operadores y movimiento
|04.2|	Cambiar texto
|04.3|	Repetir un cambio
|04.4|	Modo Visual
|04.5|	Mover texto
|04.6|	Copiar texto
|04.7|	Uso del portapapeles
|04.8|	Objetos de texto
|04.9|	Modo reemplazar
|04.10|	Conclusión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_05.txt|  Set your settings
 Previous chapter: |usr_03.txt|  Moving around
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_05.esx|  Configuración
  Capítulo anterior: |usr_03.esx|  Desplazamiento
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.1*	Operators and motions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.1*	Operadores y movimiento
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 2 you learned the "x" command to delete a single character.  And
using a count: "4x" deletes four characters.
   The "dw" command deletes a word.  You may recognize the "w" command as the
move word command.  In fact, the "d" command may be followed by any motion
command, and it deletes from the current location to the place where the
cursor winds up.
   The "4w" command, for example, moves the cursor over four words.  The d4w
command deletes four words.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 2 aprendió que la orden «x» elimina un único carácter. Y
que usar un multiplicador: «4x» elimina cuatro caracteres.
   La orden «dw» elimina una palabra. Reconocerá la orden «w» como el de
movimiento sobre palabras. De hecho, la orden «d» se ha completar con
una orden de movimiento, y elimina desde la posición actual hasta donde
marque el movimiento.
   La orden «4w», por ejemplo, mueve el cursor cuatro palabras. La orden
d4w elimina cuatro palabras.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human. To really foul up you need a computer. ~
			 ------------------&gt;
				 d4w
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano.  Para liarla de verdad necesitas un ordenador. ~
			  ----------------------&gt;
				 d4w
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim only deletes up to the position where the motion takes the cursor.  That's because Vim knows that you probably don't want to delete the first character of a word.  If you use the "e" command to move to the end of a word, Vim guesses that you do want to include that last character:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim sólo elimina hasta la posición donde la orden de movimiento le lleva.  Eso es porque Vim sabe que probablemente no desea eliminar la primera letra de una palabra. Si usa la orden «ex para desplazarse hasta el final de una palabra, Vim adivina que quiere incluir el último carácter:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human. a computer. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. ordenador. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the character under the cursor is included depends on the command you used to move to that character.  The reference manual calls this "exclusive" when the character isn't included and "inclusive" when it is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El que el carácter bajo el cursor se incluya o no depende de la orden de movimiento empleado. El manual de referencia llama a esto «exclusivo» cuando el carácter no se incluye e «inclusivo» en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" command moves to the end of a line.  The "d$" command deletes from the cursor to the end of the line.  This is an inclusive motion, thus the last character of the line is included in the delete operation:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «$» le desplaza hasta el final de la línea. La orden «d$» elimina desde el cursor hasta el final de la línea. Este es un movimiento inclusivo, por lo que el último carácter de la línea se incluye en la operación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human. a computer. ~
		       ------------&gt;
			    d$
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. ordenador. ~
		       -----------&gt;
			    d$
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a pattern here: operator-motion.  You first type an operator command.  For example, "d" is the delete operator.  Then you type a motion command like "4l" or "w".  This way you can operate on any text you can move over.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sigue siempre la misma estructura: operador-movimiento. Primero introduce el operador. Por ejemplo, «d» es el operador de eliminación. Luego introduce una orden de movimiento «4l» o «w». De esta manera, puede operar sobre cualquier texto en el que se pueda desplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.2*	Changing text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.2*	Cambiar texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another operator is "c", change.  It acts just like the "d" operator, except it leaves you in Insert mode.  For example, "cw" changes a word.  Or more specifically, it deletes a word and then puts you in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro operador es «c», cambiar (change). Actúa justo como el operador «d», excepto que le deja en modo Insertar. Por ejemplo «cw» cambia una palabra.  Es decir, elimina una palabra y le deja en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human ~
	   -------&gt;
	     c2wbe&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano ~
	---------&gt;
	 c2wEl ser&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To be human ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El ser humano ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	c	the change operator
	2w	move two words (they are deleted and Insert mode started)
	be	insert this text
	&lt;Esc&gt;	back to Normal mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	c	el operador de cambio
	2w	moverse dos palabras (se eliminan y va al modo Insertar)
	El ser	inserta el siguiente texto
	&lt;Esc&gt;	de vuelta al modo Normal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have paid attention, you will have noticed something strange: The space before "human" isn't deleted.  There is a saying that for every problem there is an answer that is simple, clear, and wrong.  That is the case with the example used here for the "cw" command.  The c operator works just like the d operator, with one exception: "cw".  It actually works like "ce", change to end of word.  Thus the space after the word isn't included.  This is an exception that dates back to the old Vi.  Since many people are used to it now, the inconsistency has remained in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha prestado atención, se habrá dado cuenta de que hay algo raro: El espacio antes de «humano» no se ha eliminado. Hay un dicho: para cada problema hay una solución que es simple, clara y errónea. Este es el caso con el ejemplo usado aquí con la orden «cw». El operador «c» funciona justo como el operador «d», con una excepción: «cw». De hecho, funciona justo igual que «ce», cambiar hasta el final de la palabra. El espacio después de la palabra no se incluye. Esta excepción data de Vi. Ya que mucha gente se ha acostumbrado a ella, ha permanecido con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like "dd" deletes a whole line, "cc" changes a whole line.  It keeps the existing indent (leading white space) though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Del mismo modo que «dd» elimina una línea completa, «cc» la cambia. Además, mantiene la sangría (los espacios en blanco precedentes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like "d$" deletes until the end of the line, "c$" changes until the end of the line.  It's like doing "d$" to delete the text and then "a" to start Insert mode and append new text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así como «d$» elimina hasta el final de la línea, «c$» la cambia hasta el final.  Es como pulsar «d$» para eliminar el texto y luego «a» para activar el modo Insertar y añadir más texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	x  stands for  dl  (delete character under the cursor)
	X  stands for  dh  (delete character left of the cursor)
	D  stands for  d$  (delete to end of the line)
	C  stands for  c$  (change to end of the line)
	s  stands for  cl  (change one character)
	S  stands for  cc  (change a whole line)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	x  equivale a  dl  (eliminar carácter bajo el cursor)
	X  equivale a  dh  (eliminar carácter a la izquierda del cursor)
	D  equivale a  d$  (eliminar hasta el final de la línea)
	C  equivale a  c$  (cambiar hasta el final de la línea)
	s  equivale a  cl  (cambiar un carácter)
	S  equivale a  cc  (cambiar una única línea)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands "3dw" and "d3w" delete three words.  If you want to get really picky about things, the first command, "3dw", deletes one word three times; the command "d3w" deletes three words once.  This is a difference without a distinction.  You can actually put in two counts, however.  For example, "3d2w" deletes two words, repeated three times, for a total of six words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes «3dw» y «d3wx eliminan tres palabras. Si quiere ponerse detallista, la primera ordem, «3dw», elimina una palabra tres veces; la orden «d3w» elimina tres palabras de una vez. Esta diferencia no se puede distinguir. Sin embargo, puede poner dos multiplicadores. Por ejemplo «3d2w» elimina dos palabras y lo repite 3 veces, un total de seis palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "r" command is not an operator.  It waits for you to type a character, and will replace the character under the cursor with it.  You could do the same with "cl" or with the "s" command, but with "r" you don't have to press &lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «r» no es un operador. Espera a que introduzca un carácter, y reemplazará el carácter bajo el cursor con él. Puedes hacer lo mismo con la orden «cl» o con «s», pero con «r» no tendrá que pulsar &lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	there is somerhing grong here ~
	rT	     rt    rw
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	aquí hay algo tue esná mal ~
	rA	      rq    rt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	There is something wrong here ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Aquí hay algo que está mal ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a count with "r" causes that many characters to be replaced with the same character.  Example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar un multiplicador con «r» causa que se reemplacen muchos caracteres con el mismo carácter. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	There is something wrong here ~
			   5rx
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Aquí hay algo que está mal ~
			   5rx
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	There is something xxxxx here ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Aquí hay algo que exxxxxal ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To replace a character with a line break use "r&lt;Enter&gt;".  This deletes one character and inserts a line break.  Using a count here only applies to the number of characters deleted: "4r&lt;Enter&gt;" replaces four characters with one line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para reemplazar un carácter con un salto de línea use «r&lt;Entrar&gt;». Esto elimina un carácter e inserta un salto. Usar un multiplicador aquí sólo afecta al número de caracteres eliminados: «4r&lt;Entrar&gt;» reemplaza cuatro caracteres con un salto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.3*	Repeating a change
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.3*	Repetir un cambio
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." command is one of the most simple yet powerful commands in Vim.  It repeats the last change.  For instance, suppose you are editing an HTML file and want to delete all the &lt;B&gt; tags.  You position the cursor on the first &lt; and delete the &lt;B&gt; with the command "df&gt;".  You then go to the &lt; of the next &lt;/B&gt; and kill it using the "." command.  The "." command executes the last change command (in this case, "df&gt;").  To delete another tag, position the cursor on the &lt; and use the "." command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «.» es uno de los más sencillos pero más potentes de Vim. Repite el último cambio. Por ejemplo, suponga que está editando un archivo HTML y desea eliminar todas las etiquetas &lt;B&gt;. Para ello, coloque el cursor sobre el primer &lt; y luego elimine el &lt;B&gt; con la orden «df&gt;». Entonces va al &lt; del &lt;/B&gt; y lo elimina con la orden «.». La orden «.» ejecuta el último cambio (en este caso «df&gt;»). Para eliminar otra etiqueta, coloque el cursor sobre el &lt; y vuelve a pulsar la orden «.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      To &lt;B&gt;generate&lt;/B&gt; a table of &lt;B&gt;contents ~
	f&lt;   find first &lt;     ---&gt;
	df&gt;  delete to &gt;	 --&gt;
	f&lt;   find next &lt;	   ---------&gt;
	.    repeat df&gt;			    ---&gt;
	f&lt;   find next &lt;		       -------------&gt;
	.    repeat df&gt;					    --&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			      Para &lt;B&gt;generar&lt;/B&gt; una tabla de &lt;B&gt;contenidos ~
	f&lt;   ir al primer  &lt;    ---&gt;
	df&gt;  elimina hasta &gt;       --&gt;
	f&lt;   ir al segundo &lt;	   ----------&gt;
	.    repetir df&gt;		     ---&gt;
	f&lt;   ir al siguiente &lt;		     ------------------&gt;
	.    repetir df&gt;				       --&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example: You want to change the word "four" to "five".  It appears several times in your text.  You can do this quickly with this sequence of commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro ejemplo: Desea cambiar la palabra «cuatro» por «cinco». Aparece varias veces en su texto. Puede hacer esto rápidamente en una secuencia de órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/four&lt;Enter&gt;	find the first string "four"
	cwfive&lt;Esc&gt;	change the word to "five"
	n		find the next "four"
	.		repeat the change to "five'
	n		find the next "four"
	.		repeat the change
			etc.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/cuatro&lt;Entrar&gt;	encuentra la primera cadena «cuatro»
	cwcinco&lt;Esc&gt;	cambia la palabra a «cinco»
	n		encuentra la siguiente cadena «cuatro»
	.		repite el cambio a «cinco»
	n		encuentra la siguiente cadena «cuatro»
	.		repite el cambio
			etc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.4*	Visual mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.4*	Modo visual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete simple items the operator-motion changes work quite well.  But often it's not so easy to decide which command will move over the text you want to change.  Then you can use Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los cambios operador-movimiento funcionan bastante bien para eliminar elementos sencillos. Pero a menudo, no es fácil decidir que orden de movimiento le desplazará hasta el texto que quiere modificar.  Es el momento de usar el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start Visual mode by pressing "v".  You move the cursor over the text you
want to work on.  While you do this, the text is highlighted.  Finally type
the operator command.
   For example, to delete from halfway one word to halfway another word:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar el modo Visual pulsando «v». Puede mover el cursor sobre el
texto que desea modificar. Mientras haces esto, el texto se resalta.
Finalmente, teclee la orden del operador.
   Por ejemplo, para eliminar de la mitad de una palabra a la mitad de otra:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		This is an examination sample of visual mode ~
			       ----------&gt;
				 velllld
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		Esto es una muestra cualquiera del modo Visual ~
				 ----------&gt;
				 veehhd
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		This is an example of visual mode ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		Esto es una muestra del modo Visual ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When doing this you don't really have to count how many times you have to press "l" to end up in the right position.  You can immediately see what text will be deleted when you press "d".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hace esto, no tiene que contar cuántas veces pulsa «e» o «h» para llegar a la posición deseada. Puede verlo de forma inmediata antes de pulsar «d».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work on whole lines, use "V" to start Visual mode.  You will
see right away that the whole line is highlighted, without moving around.
When you move left or right nothing changes.  When you move up or down the
selection is extended whole lines at a time.
   For example, select three lines with "Vjj":
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere trabajar con líneas completas, use «V» para iniciar el modo
Visual. Verá que toda la línea se resalta, sin ni siquiera mover el cursor.
Cuando mueva el cursor a la izquierda o derecha, nada cambiará. Si lo mueve
hacia arriba o hacia abajo, la selección se extenderá a líneas completas.
   Por ejemplo, seleccione tres líneas con «Vjj»:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			  +------------------------+
			  | text more text	   |
		       &gt;&gt; | more text more text    | |
	selected lines &gt;&gt; | text text text	   | | Vjj
		       &gt;&gt; | text more		   | V
			  | more text more	   |
			  +------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  +------------------------+
			  | texto más texto	   |
		       &gt;&gt; | más texto más texto    | |
  líneas seleccionadas &gt;&gt; | texto texto texto	   | | Vjj
		       &gt;&gt; | texto más		   | V
			  | más texto más	   |
			  +------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work on a rectangular block of characters, use CTRL-V to start Visual mode.  This is very useful when working on tables.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea trabajar en un bloque rectangular de caracteres, use CTRL-V para iniciar el modo Visual. Esto es muy útil si trabaja con tablas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		name		Q1	Q2	Q3
		pierre		123	455	234
		john		0	90	39
		steve		392	63	334
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		nombre		Q1	Q2	Q3
		pedro		123	455	234
		juan		0	90	39
		estéban		392	63	334
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete the middle "Q2" column, move the cursor to the "Q" of "Q2".  Press CTRL-V to start blockwise Visual mode.  Now move the cursor three lines down with "3j" and to the next word with "w".  You can see the first character of the last column is included.  To exclude it, use "h".  Now press "d" and the middle column is gone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar la columna central «Q2» desplaze el cursor a la «Q» de «Q2». Pulse CTRL-V para iniciar el modo Visual de bloques. Ahora mueva el cursor tres líneas abajo con «3j» y a la siguiente palabra con «w». Puede comprobar que el primer carácter de la última columna se ha incluido. Para excluirlo, use «h».  Si ahora pulsa «d» la columna central desaparecerá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have selected some text in Visual mode, and discover that you need to change the other end of the selection, use the "o" command (Hint: o for other end).  The cursor will go to the other end, and you can move the cursor to change where the selection starts.  Pressing "o" again brings you back to the other end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha seleccionado algo de texto en modo Visual, y descubre que necesita cambiar el otro lado de la selección, use la orden «o» (Truco: o para el «otro» lado). El cursor irá hasta el otro final de la selección, y podrá modificar dónde comienza la selección. Pulsa «o» de nuevo para volver al otro lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using blockwise selection, you have four corners.  "o" only takes you to one of the other corners, diagonally.  Use "O" to move to the other corner in the same line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa el modo Visual de bloques, tiene cuatro esquinas. «o» le llevará a una de las otras líneas diagonalmente. Use «O» para moverse hacia el otro final de la misma línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.5*	Moving text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.5*	Mover texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you delete something with the "d", "x", or another command, the text is
saved.  You can paste it back by using the p command.  (The Vim name for
this is put).
   Take a look at how this works.  First you will delete an entire line, by
putting the cursor on the line you want to delete and typing "dd".  Now you
move the cursor to where you want to put the line and use the "p" (put)
command.  The line is inserted on the line below the cursor.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimina algo con «d», «x», u otra orden, el texto se guarda.
Puede pegarlo usando la orden «p».  (El nombre de Vim para esto es «poner»,
del inglés «put»).
   Échale un vistazo a cómo funciona esto. Elimine primero una línea
completa poniendo el cursor en la línea y pulsando «dd». Mueva ahora el
cursor allá donde quiera poner la línea y use la orden «p». La línea se
insertará en la línea siguiente a donde se encuentra el cursor.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a line		a line	      a line
	line 2	  dd	line 3	  p   line 3
	line 3			      line 2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	una línea	una línea     una línea
	línea 2	   dd	línea 3	   p  línea 3
	línea 3			      línea 2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because you deleted an entire line, the "p" command placed the text line below the cursor.  If you delete part of a line (a word, for instance), the "p" command puts it just after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que eliminó una línea completa, la orden «p» colocó la línea de texto debajo del cursor. Si elimina parte de una línea (una palabra, por ejemplo), la orden «px la pone justo después del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "P" command puts text like "p", but before the cursor.  When you deleted a whole line with "dd", "P" will put it back above the cursor.  When you deleted a word with "dw", "P" will put it back just before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «P» pone una línea como «p», pero antes del cursor. Cuando elimine una línea con «dd», «P» lo pondrá de vuelta sobre el cursor. Cuando elimine una palabra con «dw», «P» lo pondrá antes del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat putting as many times as you like.  The same text will be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir la orden tantas veces como quiera. Se usará el mismo texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a count with "p" and "P".  The text will be repeated as many times as specified with the count.  Thus "dd" and then "3p" puts three copies of the same deleted line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar un multiplicador con «p» y «P». El texto se repetirá tantas veces como especifique con el multiplicador. Por ejemplo, usar «dd» y luego «3p» pone tres copias de la misma línea eliminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Frequently when you are typing, your fingers get ahead of your brain (or the other way around?).  The result is a typo such as "teh" for "the".  Vim makes it easy to correct such problems.  Just put the cursor on the e of "teh" and execute the command "xp".  This works as follows: "x" deletes the character e and places it in a register.  "p" puts the text after the cursor, which is after the h.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más de una vez, mientras teclea, sus dedos irán por delante de su cerebro (¿o al revés?). El resultado es un error del tipo «uqe» en lugar de «que». Vim hace que corregir estos problemas sea sencillo. Simplemente ponga el cursor sobre la «u» de «uqe» y ejecute la orden «xp». Esto funciona del siguiente modo: «x» elimina el carácter «u» y lo coloca en un registro. «p» pone el texto después del cursor, justo después de la «q».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	teh     th     the ~
	 x       p
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	uqe     qe     que ~
	x       p
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.6*	Copying text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.6*	Copiar texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To copy text from one place to another, you could delete it, use "u" to undo
the deletion and then "p" to put it somewhere else.  There is an easier way:
yanking.  The "y" operator copies text into a register.  Then a "p" command
can be used to put it.
   Yanking is just a Vim name for copying.  The "c" letter was already used
for the change operator, and "y" was still available.  Calling this
operator "yank" made it easier to remember to use the "y" key.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para copiar texto de un lugar a otro, puede eliminarlo, usar «u» para
deshacer la eliminación y después usar «p» para colocarlo en otro lugar. Hay
un modo mejor: «yank» (dar un tirón). El operador «y» copia texto en un
registro. Puede usar una orden «p» para ponerlo.
   «Yanking» es simplemente el nombre de Vim para copiar. La letra «c» ya
estaba en uso por el operador «cambiar», y la «y» estaba aún disponible.
Llamar a este el operador «yank» hizo que fuera más fácil recordar la «y».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since "y" is an operator, you use "yw" to yank a word.  A count is possible as usual.  To yank two words use "y2w".  Example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que «y» es un operador, se usa «yw» para copiar una palabra. Se puede usar un multiplicador. Para copiar dos palabras usa «y2w». Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let sqr = LongVariable * ~
		 --------------&gt;
		       y2w
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let sqr = LongVariable * ~
		 --------------&gt;
		       y2w
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let sqr = LongVariable * ~
			       p
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let sqr = LongVariable * ~
			       p
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	let sqr = LongVariable * LongVariable ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	let sqr = LongVariable * LongVariable ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that "yw" includes the white space after a word.  If you don't want this, use "ye".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que «yw» incluye el espacio en blanco después de la palabra. Si no quiere que esto ocurra, us «ye».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "yy" command yanks a whole line, just like "dd" deletes a whole line.  Unexpectedly, while "D" deletes from the cursor to the end of the line, "Y" works like "yy", it yanks the whole line.  Watch out for this inconsistency! Use "y$" to yank to the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «yy» copia una sola línea, al igual que «dd» la elimina. Sin embargo, mientras que «D» elimina desde el cursor hasta el final de la línea, «Y» funciona como «yy», copiando la línea completa. ¡Cuidado con esta inconsistencia! Use «y$» para copiar sólo hasta el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	a text line   yy	a text line	       a text line
	line 2			line 2		p      line 2
	last line		last line	       a text line
						       last line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	línea de texto   yy	línea de texto         línea de texto
	línea 2			línea 2		p      línea 2
	última línea		última línea	       línea de texto
						       última línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.7*	Using the clipboard
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.7*	Uso del portapapeles
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have copied text to the clipboard in another application, you can paste it in Vim with the Edit/Paste menu.  This works in Normal mode and Insert mode.  In Visual mode the selected text is replaced with the pasted text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha copiado texto en el portapapeles desde otra aplicación, puede pegarlo en Vim con el menú Editar/Pegar. Esto funciona en modo Normal y en modo Insertar. En modo Visual el texto seleccionado es reemplazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Cut" menu item deletes the text before it's put on the clipboard.  The "Copy", "Cut" and "Paste" items are also available in the popup menu (only when there is a popup menu, of course).  If your Vim has a toolbar, you can also find these items there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «Cortar» del menú elimina el texto antes de ponerlo en el portapapeles. Las opciones «Cortar», «Copiar» y «Pegar» están también disponibles en el menú contextual (sólo cuando esté disponible). Si su Vim tiene barra de tareas, puede encontrar estos botones allí también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using the GUI, or if you don't like using a menu, you have to use another way.  You use the normal "y" (yank) and "p" (put) commands, but prepend "* (double-quote star) before it.  To copy a line to the clipboard: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no usa la GUI o no te gusta usar el menú, tiene otro modo. Use la orden «y» normal (copiar) y «p» (poner), pero antes escriba «"*» (comillas dobles, asterisco). Para copiar una línea en el portapapeles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"*yy
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"*yy
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"*p
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"*p
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works on versions of Vim that include clipboard support.  More about the clipboard in section |09.3| and here: |clipboard|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funciona en versiones de Vim que incluyen soporte para portapapeles.  Más sobre el portapapeles en la sección |09.3| y aquí: |clipboard|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.8*	Text objects
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.8*	Objetos de texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the cursor is in the middle of a word and you want to delete that word, you need to move back to its start before you can do "dw".  There is a simpler way to do this: "daw".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el cursor está en medio de una palabra y la quiere eliminar, tiene que desplazarse hasta su comienzo antes de que pueda hacer «dw». Hay un modo más sencillo de hacer esto: «daw».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	this is some example text. ~
		       daw
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	esto es texto de ejemplo. ~
		 daw
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	this is some text. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	esto es de ejemplo. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "d" of "daw" is the delete operator.  "aw" is a text object.  Hint: "aw" stands for "A Word".  Thus "daw" is "Delete A Word".  To be precise, the white space after the word is also deleted (the white space before the word at the end of the line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «d» de «daw» es el operador de eliminación. «aw» es el objeto de texto.  Truco: «aw» viene de «A Word». Por lo que «daw» es «Delete A Word». Para ser más precisos, el espacio después de la palabra se elimina también (el espacio antes de la palabra si ésta se encuentra al final de una línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change a whole sentence use "cis".  Take this text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para cambiar una oración completa use «cis». Suponga este texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Hello there.  This ~
	is an example.  Just ~
	some text. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	¿Qué tal?  Esto ~
	es un ejemplo.  Algo ~
	de texto. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move to the start of the second line, on "is an".  Now use "cis":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya al comienzo de la segunda línea, sobre el «es un». Ahora, use «cis»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Hello there.    Just ~
	some text. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	¿Qué tal?    Algo ~
	de texto. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is in between the blanks in the first line.  Now you type the new sentence "Another line.":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está entre los espacios de la primera línea. Escriba ahora la nueva frase «Otra línea.»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Hello there.  Another line.  Just ~
	some text. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	¿Qué tal?  Otra línea.  Algo ~
	de texto. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"cis" consists of the "c" (change) operator and the "is" text object.  This stands for "Inner Sentence".  There is also the "as" (a sentence) object.  The difference is that "as" includes the white space after the sentence and "is" doesn't.  If you would delete a sentence, you want to delete the white space at the same time, thus use "das".  If you want to type new text the white space can remain, thus you use "cis".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«cis» consiste del operador «c» (cambiar) y el objeto de texto «is». Esto viene de «Inner Sentence». También hay un objeto «as» (a sentence). La diferencia es que «as» incluye el espacio en blanco después de la frase e «is» no. Si desea eliminar la frase y quiere eliminar al mismo tiempo el espacio en blanco posterior, use entonces «das». Si quiere escribir otro texto, el espacio puede permanecer, con lo que puedes usar «cis».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use text objects in Visual mode.  It will include the text object in the Visual selection.  Visual mode continues, thus you can do this several times.  For example, start Visual mode with "v" and select a sentence with "as".  Now you can repeat "as" to include more sentences.  Finally you use an operator to do something with the selected sentences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar los objetos de texto on modo Visual. Incluirá el objeto de texto en la selección. El modo Visual permanece, así que puede hacerlo varias veces. Por ejemplo, inicie el modo Visual con «v» y seleccione una frase con «as». Ahora puede repetir «as» para incluir más frases.  Por último, use un operador para hacer algo con las frases seleccionadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.9*	Replace mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.9*	Modo reemplazar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "R" command causes Vim to enter replace mode.  In this mode, each
character you type replaces the one under the cursor.  This continues until
you type &lt;Esc&gt;.
   In this example you start Replace mode on the first "t" of "text":
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «R» hace que Vim entre en modo reemplazar. En este modo, cada
carácter que introduzca reemplaza al que está debajo del cursor. Esto
continúa hasta que pulse &lt;Esc&gt;.
   En este ejemplo, Ud. comienza el modo Reemplazar en la primera «t» de «texto»:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is text. ~
		Rinteresting.&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es texto. ~
		Rinteresante.&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is interesting. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Esto es interesante. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may have noticed that this command replaced 5 characters in the line with twelve others.  The "R" command automatically extends the line if it runs out of characters to replace.  It will not continue on the next line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que haya notado que ha reemplazado 5 caracteres en la línea con otros doce. La orden «R» extiende automáticamente la línea si se queda sin caracteres que reemplazar. Esto no ocurrirá en la siguiente línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use &lt;BS&gt; (backspace) to make correction, you will notice that the old text is put back.  Thus it works like an undo command for the last typed character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use &lt;Retroceso&gt; para hacer una corrección comprobará que el texto anterior reaparece. Por lo tanto, funciona como la orden deshacer para el último carácter tecleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.10*	Conclusion
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.10*	Conclusión
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operators, movement commands and text objects give you the possibility to make lots of combinations.  Now that you know how it works, you can use N operators with M movement commands to make N * M commands!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los operadores, órdenes de movimiento y los objetos de texto le dan múltiples posibilidades para hacer muchas combinaciones.  Ahora que sabe cómo funciona, puede usar N operadores con M órdenes de movimiento para hacer M * N órdenes!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, there are many other ways to delete pieces of text.  Here are a few often used ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, hay otras muchas maneras de eliminar porciones de texto.  Aquí tiene algunas de las más empleadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>x	delete character under the cursor (short for "dl")
X	delete character before the cursor (short for "dh")
D	delete from cursor to end of line (short for "d$")
dw	delete from cursor to next start of word
db	delete from cursor to previous start of word
diw	delete word under the cursor (excluding white space)
daw	delete word under the cursor (including white space)
dG	delete until the end of the file
dgg	delete until the start of the file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>x	elimina el carácter bajo el cursor (abreviado de "dl")
X	elimina el carácter antes del cursor (abreviado de "dh")
D	elimina desde el cursor hasta el final de línea (abreviado de "d$")
dw	elimina desde el cursor hasta el próximo comienzo de palabra
db	elimina desde el cursor hasta el anterior comienzo de palabra
diw	elimina la palabra bajo el cursor (excluyendo el espacio en blanco)
daw	elimina la palabra bajo el cursor (incluyendo el espacio en blanco)
dG	elimina hasta el final del archivo
dgg	elimina hasta el final del archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use "c" instead of "d" they become change commands.  And with "y" you yank the text.  And so forth.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «c» en lugar de «d»,estos se convierten en órdenes de cambio.  Y con «y» copias el texto. Y así en adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	~	change case of the character under the cursor, and move the
		cursor to the next character.  This is not an operator (unless
		'tildeop' is set), thus you can't use it with a motion
		command.  It does work in Visual mode and changes case for
		all the selected text then.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	~	cambia el carácter bajo el cursor de minúsculas a mayúsculas y
		al revés, moviéndose al siguiente carácter. No es un operador
		(a menos que 'tildeop' esté activado), por lo que no lo puede
		usar con un movimiento. Sí funciona en modo Visual y cambia
		todo lo que está seleccionado.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	I	Start Insert mode after moving the cursor to the first
		non-blank in the line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	I	Inicia el modo insertar y desplaza el cursor al primer
		carácter no vacío de la línea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	A	Start Insert mode after moving the cursor to the end of the
		line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	A	Inicia el modo insertar y desplaza el cursor al último
		carácter de la línea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_03.txt*	For Vim version 7.3.  Last change: 2006 Jun 21
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_03.esx*	Para Vim version 7.3.  Último cambio: 21/6/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Moving around
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			   Desplazamiento
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you can insert or delete text the cursor has to be moved to the right place.  Vim has a large number of commands to position the cursor.  This chapter shows you how to use the most important ones.  You can find a list of these commands below |Q_lr|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de que pueda insertar o eliminar texto, el cursor tiene que desplazarse al lugar adecuado. Vim tiene una gran cantidad de órdenes para situar el cursor.  Este capítulo muestra cómo usar los más importantes. Puede encontrar una lista de estas órdenes a continuación |Q_lr|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|03.1|	Word movement
|03.2|	Moving to the start or end of a line
|03.3|	Moving to a character
|03.4|	Matching a parenthesis
|03.5|	Moving to a specific line
|03.6|	Telling where you are
|03.7|	Scrolling around
|03.8|	Simple searches
|03.9|	Simple search patterns
|03.10|	Using marks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|03.1|	Desplazarse sobre palabras
|03.2|	Desplazarse al principio o al final de la línea
|03.3|	Desplazarse a un carácter
|03.4|	Emparejar un paréntesis
|03.5|	Desplazarse a una línea específica
|03.6|	Indicar dónde estás
|03.7|	Desplazar el texto
|03.8|	Búsquedas simples
|03.9|	Patrones sencillos de búsqueda
|03.10|	Uso de marcadores o marcas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_04.txt|  Making small changes
 Previous chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_04.esx|  Hacer cambios pequeños
  Capítulo anterior: |usr_02.esx|  Primeros pasos en Vim
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.1*	Word movement
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.1*	Desplazarse sobre palabras
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move the cursor forward one word, use the "w" command.  Like most Vim commands, you can use a numeric prefix to move past multiple words.  For example, "3w" moves three words.  This figure shows how it works:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para mover el cursor una palabra hacia delante, use la orden «w». Del mismo modo que la mayoría de órdenes Vim, puede usar un prefijo numérico. Por ejemplos, «3w» se mueve tres palabras. Esta figura muestra cómo funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a line with example text ~
	  ---&gt;--&gt;-&gt;-----------------&gt;
	   w  w  w    3w
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Ésta es una línea con texto de ejemplo ~
	  ---&gt;--&gt;---&gt;---------------&gt;
	   w  w  w    3w
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that "w" moves to the start of the next word if it already is at the
start of a word.
   The "b" command moves backward to the start of the previous word:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fíjese en que «w» le mueve al comienzo de la siguiente palabra si ya se
encuentra al comienzo de una palabra.
   La orden «b» le desplaza al comienzo de la palabra anterior:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a line with example text ~
	&lt;----&lt;--&lt;-&lt;---------&lt;---
	   b   b b    2b      b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Ésta es una línea con texto de ejemplo ~
	&lt;----&lt;--&lt;---&lt;---------&lt;---
	   b   b b    2b    b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	This is a line with example text ~
	   &lt;-   &lt;--- -----&gt;   ----&gt;
	   ge    ge     e       e
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Ésta es una línea con texto de ejemplo ~
	   &lt;- &lt;--- -----&gt;     ----&gt;
	   ge  ge     e        e
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A word ends at a non-word character, such as a ".", "-" or ")".  To change
what Vim considers to be a word, see the 'iskeyword' option.
   It is also possible to move by white-space separated WORDs.  This is not a
word in the normal sense, that's why the uppercase is used.  The commands for
moving by WORDs are also uppercase, as this figure shows:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una palabra termina en un carácter de separación, como «.», «-» o «)». Para
cambiar lo que Vim considera una palabra, consulte la opción 'iskeyword'.
   También es posible desplazarse por palabras separadas por espacios en
blanco. Esto no es una PALABRA en el sentido habitual, por ello se usan las
mayúsculas para designarla. Las órdenes para desplazarse por PALABRAS están
también en mayúsculas, como muestra la siguiente figura:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	       ge      b	  w				e
	       &lt;-     &lt;-	 ---&gt;			       ---&gt;
	This is-a line, with special/separated/words (and some more). ~
	   &lt;----- &lt;-----	 --------------------&gt;	       -----&gt;
	     gE      B			 W			 E
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	       ge      b	  w				e
	       &lt;-     &lt;-	 ---&gt;			       ---&gt;
	Ésta es-una línea, con palabras separadas/de forma/especial
(y algo más). ~
	   &lt;----- &lt;-----	 --------------------&gt;	       -----&gt;
	     gE      B			 W			 E
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.2*	Moving to the start or end of a line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.2*	Desplazarse al principio o al final de la línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" command moves the cursor to the end of a line.  If your keyboard has an &lt;End&gt; key it will do the same thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «$» mueve el cursor al final de la línea. Si su teclado tiene la tecla &lt;Fin&gt;, conseguirá el mismo resultado pulsándola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" command moves to the first non-blank character of the line.  The "0" command (zero) moves to the very first character of the line.  The &lt;Home&gt; key does the same thing.  In a picture:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «^» le lleva hacia el primer carácter no vacío de la línea. La orden «0» (cero) le mueve al primer carácter de la línea. La tecla &lt;Inicio&gt; hace lo mismo. En una imagen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		  ^
	     &lt;------------
	.....This is a line with example text ~
	&lt;-----------------   ---------------&gt;
		0		   $
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		  ^
	     &lt;------------
	.....Ésta es una línea con texto de ejemplo ~
	&lt;-----------------   ---------------&gt;
		0		   $
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   The "$" command takes a count, like most movement commands.  But moving to
the end of the line several times doesn't make sense.  Therefore it causes the
editor to move to the end of another line.  For example, "1$" moves you to
the end of the first line (the one you're on), "2$" to the end of the next
line, and so on.
   The "0" command doesn't take a count argument, because the "0" would be
part of the count.  Unexpectedly, using a count with "^" doesn't have any
effect.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   La orden «$» admite un multiplicador, como la mayoría de órdenes de evento.
Pero moverse hacia el final de la línea varias veces no tiene sentido. Por lo
tanto, lo que hace es moverle hacia el final de la siguiente línea. Por
ejemplo, «1$» le mueve hacia el final de la primera línea (en la que está),
«2$» te mueve al final de la siguiente línea, y así en adelante.
   La orden «0» no admite ningún multiplicador, porque el «0» podría ser parte
del número. Usar un multiplicador con «^» tampoco tiene ningún efecto.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.3*	Moving to a character
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.3*	Desplazarse a un carácter
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the most useful movement commands is the single-character search
command.  The command "fx" searches forward in the line for the single
character x.  Hint: "f" stands for "Find".
   For example, you are at the beginning of the following line.  Suppose you
want to go to the h of human.  Just execute the command "fh" and the cursor
will be positioned over the h:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de las órdenes de movimiento más útiles es la orden de búsqueda de un
único carácter. La orden «fx» busca hacia delante en la línea el carácter
x. Truco: «f» viene de «Find» (en inglés, buscar).
   Por ejemplo, está al principio de la línea siguiente. Suponga que quiere
ir a la «h» de «humano». Ejecute la orden «fh» y el cursor se posicionará
sobre la h:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human.  To really foul up you need a computer. ~
	----------&gt;---------------&gt;
	    fh		 fy
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. Para liarla de verdad necesita un ordenador. ~
	----------&gt;---------------&gt;
	    fh		 fy
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also shows that the command "fy" moves to the end of the word really.
   You can specify a count; therefore, you can go to the "l" of "foul" with
"3fl":
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también muestra que la orden «d» le lleva al comienzo de la palabra «de».
Puede especificar un multiplicador; por lo tanto, puede ir a la «r»
de «verdad» con «3fr»:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human.  To really foul up you need a computer. ~
		  ---------------------&gt;
			   3fl
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. Para liarla de verdad necesita un ordenador. ~
		  ---------------------&gt;
			   3fl
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human.  To really foul up you need a computer. ~
		  &lt;---------------------
			    Fh
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. Para liarla de verdad necesitas un ordenador. ~
		  &lt;---------------------
			    Fh
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "tx" command works like the "fx" command, except it stops one character before the searched character.  Hint: "t" stands for "To".  The backward version of this command is "Tx".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «tx» funciona como la orden «fx», salvo que para un carácter antes del buscado. Truco: «t» viene de «To». La versión inversa de esta orden es «Tx».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	To err is human.  To really foul up you need a computer. ~
		   &lt;------------  -------------&gt;
			Th		tn
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Errar es humano. Para liarla de verdad necesita un ordenador. ~
		   &lt;------------  -------------&gt;
			Th		tn
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These four commands can be repeated with ";".  "," repeats in the other direction.  The cursor is never moved to another line.  Not even when the sentence continues.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas cuatro órdenes se pueden repetir con «;». «,» repite en la otra dirección. El cursor nunca se mueve a otra línea. Ni siquiera cuando la frase continúa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will start a search, only to realize that you have typed the wrong command.  You type "f" to search backward, for example, only to realize that you really meant "F".  To abort a search, press &lt;Esc&gt;.  So "f&lt;Esc&gt;" is an aborted forward search and doesn't do anything.  Note: &lt;Esc&gt; cancels most operations, not just searches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ciertas ocasiones comenzará la búsqueda y se dará cuenta de que ha tecleado la orden errónea. Por ejemplo, pulsa «f» para buscar hacia atrás, y se da cuenta de que tenía que haber pulsado «F». Para abortar la búsqueda, pulse &lt;Esc&gt;. Por lo tanto, «f&lt;Esc&gt;» es una búsqueda abortada. Nota: &lt;Esc&gt; cancela la mayoría de las operaciones, no sólo búsquedas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.4*	Matching a parenthesis
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.4*	Emparejar un paréntesis
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing a program you often end up with nested () constructs.  Then the "%" command is very handy: It moves to the matching paren.  If the cursor is on a "(" it will move to the matching ")".  If it's on a ")" it will move to the matching "(".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al escribir código, a menudo usa constructos anidados del tipo ().  Para ello la orden «%x resulta muy útil: le desplaza hasta el paréntesis opuesto. Si el cursor está en un «(», le moverá hasta el «)». Si está en un «)» le moverá hasta el «(» correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			    %
			 &lt;-----&gt;
		if (a == (b * c) / d) ~
		   &lt;----------------&gt;
			    %
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			    %
			 &lt;-----&gt;
		if (a == (b * c) / d) ~
		   &lt;----------------&gt;
			    %
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works for [] and {} pairs.  (This can be defined with the 'matchpairs' option.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona para parejas de [] y {}. (Esto se puede definido con la opción 'matchpairs'.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		if (a == (b * c) / d) ~
		---+----------------&gt;
			   %
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		if (a == (b * c) / d) ~
		---+----------------&gt;
			   %
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.5*	Moving to a specific line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.5*	Desplazarse a una línea específica
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	prog.c:33: j   undeclared (first use in this function) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	prog.c:33: j   undeclared (first use in this function) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells you that you might want to fix something on line 33.  So how do you
find line 33?  One way is to do "9999k" to go to the top of the file and "32j"
to go down thirty two lines.  It is not a good way, but it works.  A much
better way of doing things is to use the "G" command.  With a count, this
command positions you at the given line number.  For example, "33G" puts you
on line 33.  (For a better way of going through a compiler's error list, see
|usr_30.txt|, for information on the :make command.)
   With no argument, "G" positions you at the end of the file.  A quick way to
go to the start of a file use "gg".  "1G" will do the same, but is a tiny bit
more typing.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le indica que probablemente quiera arreglar algo en la línea 33.
Entonces, ¿cómo encuentra la línea 33? Un modo es hacer «9999k» para ir a la
parte superior del archivo y «32j» para ir hacia abajo 32 líneas. Este no es
el mejor modo, pero funciona. Uno mucho mejor es usar la orden «G». Con un
multiplicador, esta orden le posiciona en la línea indicada. Por ejemplo,
«33G» le lleva a la línea 33. (Hay un modo aún mejor de ir por la lista de
errores del compilador, consulte |usr_30.txt| para información sobre «:make».)
   Sin argumentos, «G» le posiciona al final del archivo. Una forma rápida de
ir al comienzo de la línea es usar «gg». «1G» hará lo mismo, pero es una
pizca más lento de escribir.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	    |	primera línea de un archivo    ^
	    |	texto texto texto texto        |
	    |	texto texto texto texto        |  gg
	7G  |	texto texto texto texto        |
	    |	texto texto texto texto
	    |	texto texto texto texto
	    V	texto texto texto texto        |
		texto texto texto texto        |  G
		texto texto texto texto        |
		última línea de un archivo     V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to move to a line is using the "%" command with a count.  For example "50%" moves you to halfway the file.  "90%" goes to near the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera de ir a una línea es con la orden «%» y un multiplicador.  Por ejemplo «50%» le mueve a la mitad del archivo. «90%» va casi al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous assumes that you want to move to a line in the file, no matter if it's currently visible or not.  What if you want to move to one of the lines you can see? This figure shows the three commands you can use:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo anterior asume que se quiere mover a una línea en un archivo, no importa si está visible o no. Pero ¿qué pasa si se quiere mover a una de las líneas que puede ver? Esta figura le muestra las tres órdenes que puede emplear:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			+---------------------------+
		H --&gt;	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M --&gt;	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L --&gt;	| text sample text	    |
			+---------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			+---------------------------+
		H --&gt;	| texto ejemplo texto	    |
			| ejemplo texto		    |
			| texto ejemplo texto	    |
			| ejemplo texto		    |
		M --&gt;	| texto ejemplo texto	    |
			| ejemplo texto		    |
			| texto ejemplo texto	    |
			| ejemplo texto		    |
		L --&gt;	| texto ejemplo texto	    |
			+---------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.6*	Telling where you are
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.6*	Indicar donde está
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.  Use the CTRL-G command.  You get a message like this (assuming the 'ruler'
    option is off):
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1.   Use la orden CTRL-G. Obtendrá un mensaje como este (asumiendo que la
      opción 'ruler' está desactivada:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    This shows the name of the file you are editing, the line number where the
    cursor is, the total number of lines, the percentage of the way through
    the file and the column of the cursor.
       Sometimes you will see a split column number.  For example, "col 2-9".
    This indicates that the cursor is positioned on the second character, but
    because character one is a tab, occupying eight spaces worth of columns,
    the screen column is 9.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    Esto le muestra el nombre del archivo que está editando, el número de
    línea en el que se encuentra su cursor, la posición relativa (en
    porcentaje) y la columna del cursor.
       A veces verá dos números separados por guión. Por ejemplo, «col 2-9».
    Esto indica que el cursor está posicionado en el segundo carácter, pero ya
    que el primer carácter es un tabulador, ocupará ocho espacios de columnas,
    y la columna en pantalla será 9.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2.  Set the 'number' option.  This will display a line number in front of
    every line: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. Definir la opción 'number'. Esto mostrará el número de línea al
    principio de cada línea: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set number
&lt;
    To switch this off again: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set number
&lt;
    Para desactivar esto de nuevo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nonumber
&lt;
    Since 'number' is a boolean option, prepending "no" to its name has the
    effect of switching it off.  A boolean option has only these two values,
    it is either on or off.
       Vim has many options.  Besides the boolean ones there are options with
    a numerical value and string options.  You will see examples of this where
    they are used.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nonumber
&lt;
    Ya que 'number' es una opción booleana, al escribirla con el prefijo «no»
    produce el efecto de apagarla. Una opción booleana tiene sólo estos dos
    posibles valores, «apagado» o «encendido».
       Vim tiene muchas opciones. Además de las booleanas, hay opciones con un
    valor numérico y otras de cadenas de caracteres. Verá ejemplos de esto
    donde sean usados.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3.  Set the 'ruler' option.  This will display the cursor position in the
    lower right corner of the Vim window: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3.   Activar la opción 'ruler'. Esto mostrará la posición del cursor
            en la esquina inferior a la derecha de la ventana de Vim: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set ruler
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set ruler
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.7*	Scrolling around
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.7*	Desplazar el texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-U command scrolls down half a screen of text.  Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.  Thus the window moves up over the text, which is
backward in the file.  Don't worry if you have a little trouble remembering
which end is up.  Most users have the same problem.
   The CTRL-D command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-U desplaza el texto hacia abajo. Imagine que mira a
través de una ventana hacia un texto y mueve esta ventana hacia arriba una
distancia igual a la mitad de la ventana. Entonces la ventana se mueve hacia
arriba sobre el texto, lo cuál es hacia arriba en el archivo. No se preocupe
si no recuerda qué es hacia arriba. A la mayoría de los usuarios les pasa.
   La orden CTRL-D mueve la ventana de visualización media pantalla hacia
abajo, con lo que desplaza el texto hacia arriba media pantalla.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --&gt; |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D --&gt;  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>				       +----------------+
				       | un texto	|
				       | un texto	|
				       | un texto	|
	+---------------+	       | un texto	|
	| un texto	|  CTRL-U  --&gt; |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| ejemplo	|  CTRL-D --&gt;  | 7890		|
	+---------------+	       |		|
				       | ejemplo	|
				       | ejemplo	|
				       | ejemplo	|
				       | ejemplo	|
				       +----------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To scroll one line at a time use CTRL-E (scroll up) and CTRL-Y (scroll down).  Think of CTRL-E to give you one line Extra.  (If you use MS-Windows compatible key mappings CTRL-Y will redo a change instead of scroll.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para bajar una sola línea use CTRL-E (avanzar) y CTRL-Y (retroceder). Piense en CTRL-E como si le diese una línea Extra. (Si usa un mapa de teclado compatible con MS-Windows CTRL-Y rehará un cambio en lugar de desplazar el texto.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To scroll forward by a whole screen (except for two lines) use CTRL-F.  The other way is backward, CTRL-B is the command to use.  Fortunately CTRL-F is Forward and CTRL-B is Backward, that's easy to remember.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para avanzar una pantalla completa (menos dos líneas) use CTRL-F. La otra manera es hacia atrás, y se usa CTRL-B. Afortunadamente CTRL-F es Forward y CTRL-B es Backward, lo cuál lo hace fácil de recordar si sabe algo de inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+------------------+		 +------------------+
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |   zz  --&gt;	 | line with cursor |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| line with cursor |		 | some text	    |
	+------------------+		 +------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------+		 +---------------------+
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| un texto	      |  zz --&gt;  | línea con el cursor |
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| línea con el cursor |		 | un texto	       |
	+---------------------+		 +---------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "zt" command puts the cursor line at the top, "zb" at the bottom.  There are a few more scrolling commands, see |Q_sc|.  To always keep a few lines of context around the cursor, use the 'scrolloff' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «zt» pone la línea del cursor arriba, «zb» la situa en la parte inferior. Hay algunas órdenes más de desplazamiento de texto, consulte |Q_sc|. Para mantener siempre contexto alrededor del cursor, use la opción 'scrolloff'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.8*	Simple searches
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.8*	Búsquedas simples
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search for a string, use the "/string" command.  To find the word include, for example, use the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para buscar una cadena, use la orden «/cadena». Para encontrar la palabra «include», por ejemplo, use la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/include
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/include
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that when you type the "/" the cursor jumps to the last line
of the Vim window, like with colon commands.  That is where you type the word.
You can press the backspace key (backarrow or &lt;BS&gt;) to make corrections.  Use
the &lt;Left&gt; and &lt;Right&gt; cursor keys when necessary.
   Pressing &lt;Enter&gt; executes the command.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará que cuando pulsa «/» el cursor salta a la última línea de la ventana
Vim, como con la orden «:». Ahí es donde teclea la palabra. Puede pulsar
la tecla de retroceso (flecha hacia atrás o &lt;Retroceso&gt;) para corregir. Use
las teclas de cursor cuando sea necesario.
   Presione &lt;Intro&gt; para ejecutar la orden.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find the next occurrence of the same string use the "n" command.  Use this to find the first #include after the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar la próxima cadena use la orden «n». Use esto para encontrar el primer #include después del cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/#include
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/#include
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then type "n" several times.  You will move to each #include in the text.  You can also use a count if you know which match you want.  Thus "3n" finds the third match.  Using a count with "/" doesn't work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora pulse «n» varias veces. Le llevará a cada #include en el texto. Puede también usar un multiplicador si sabe qué cadenas coincidentes quiere.  Por lo tanto «3n» va a la tercera. No se puede usar con «/».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	?word
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	?word
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "N" command repeats the last search the opposite direction.  Thus using "N" after a "/" command search backwards, using "N" after "?" searches forward.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «N» repite la última búsqueda en la dirección opuesta. Por lo tanto, usar «N» después de una orden «/» busca hacia atrás, usar «N» tras «?» busca hacia delante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally you have to type exactly what you want to find.  If you don't care about upper or lowercase in a word, set the 'ignorecase' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Normalmente tiene que teclear exactamente lo que quieres encontrar. Si no le importa si los caracteres están en mayúscula/minúscula, active 'ignorecase': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set ignorecase
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set ignorecase
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now search for "word", it will also match "Word" and "WORD".  To match case again: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora busca «palabra», también le identificará «Palabra» y «PALABRA». Para concordar con mayúsculas y minúsculas de nuevo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set noignorecase
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set noignorecase
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/one
	/two
	/three
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/uno
	/dos
	/tres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's start searching by typing a simple "/" without pressing &lt;Enter&gt;.  If
you press &lt;Up&gt; (the cursor key), Vim puts "/three" on the command line.
Pressing &lt;Enter&gt; at this point searches for three.  If you do not press
&lt;Enter&gt;, but press &lt;Up&gt; instead, Vim changes the prompt to "/two".  Another
press of &lt;Up&gt; moves you to "/one".
   You can also use the &lt;Down&gt; cursor key to move through the history of
search commands in the other direction.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora comience a buscar tecleando un simple «/» sin presionar &lt;Intro&gt;. Si
presiona &lt;Arriba&gt; (la tecla de cursor), Vim introduce «tres» en la línea de
órdenes. Presionar &lt;Intro&gt; en este punto busca «tres». Si no pulsa
&lt;Intro&gt; y presiona &lt;Arriba&gt;, Vim cambia el texto a «/dos». Si pulsa de nuevo
&lt;Arriba&gt;, verá «/uno».
   Puede usar también la tecla de cursor &lt;Abajo&gt; para moverse por el historial
de órdenes de búsqueda en la otra dirección.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you know what a previously used pattern starts with, and you want to use it again, type that character before pressing &lt;Up&gt;.  With the previous example, you can type "/o&lt;Up&gt;" and Vim will put "/one" on the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sabe cómo comienza una de sus búsquedas anteriores y la quiere usar de nuevo, introduzca ese carácter antes de presionar &lt;Arriba&gt;. En el ejemplo anterior, teclea «/u&lt;Arriba&gt;» y Vim pondrá «/uno» en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands starting with ":" also have a history.  That allows you to recall a previous command and execute it again.  These two histories are separate.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes que comienzan con «:» también tienen un historial. Esto ayuda a reutilizar órdenes que ha usado antes. Estos dos historiales son independientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type "/the" it will also match "there".  To only find words that end in "the" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea «/el» también le identificará «ellos». Para buscar sólo palabras que terminen en «el», use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the\&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/el\&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "\&gt;" item is a special marker that only matches at the end of a word.  Similarly "\&lt;" only matches at the begin of a word.  Thus to search for the word "the" only: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento z\&gt;» es un marcador especial que sólo identifica el final de una palabra. De igual modo, «\&lt;» identifica el comienzo de una palabra. Por lo tanto para buscar únicamente la palabra completa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\&lt;the\&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\&lt;el\&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does not match "there" or "soothe".  Notice that the "*" and "#" commands use these start-of-word and end-of-word markers to only find whole words (you can use "g*" and "g#" to match partial words).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no encontrará «ellos» o «mantel». Fíjese en que las órdenes «*» y «#» usan estos marcadores de comienzo y final de palabra para encontrar únicamente palabras completas (puede usar «g*» y «g#» para concordancias parciales).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While editing a program you see a variable called "nr".  You want to check
where it's used.  You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.
   There is another way.  Type this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al editar un programa verá una variable llamada «nr». Quiere comprobar dónde se
usa. Puede mover el cursor a «nr» y usar la orden «*» y presionar «n» para
ir de cadena en cadena.
   Pero hay otro modo.  Teclee la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set hlsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set hlsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now search for "nr", Vim will highlight all matches.  That is a very
good way to see where the variable is used, without the need to type commands.
   To switch this off: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora busca «nr»,  Vim le destacará todas las concordancias. Este es un
método muy bueno para ver dónde se emplea la variable, sin la necesidad de «n».
   Para desactivarlo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nohlsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nohlsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to switch it on again if you want to use it for the next search command.  If you only want to remove the highlighting, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita activarlo de nuevo si quiere usarlo para la siguiente orden de búsqueda. Si sólo quiere que desaparezca, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:nohlsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:nohlsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This doesn't reset the option.  Instead, it disables the highlighting.  As soon as you execute a search command, the highlighting will be used again.  Also for the "n" and "N" commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no modifica la opción. En su lugar, quita las marcas. Tan pronto como vuelva a buscar algo, las marcas se volverán a emplear. También ocurrirá con las órdenes «n» y «N».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few options that change how searching works.  These are the
essential ones:
&gt;
	:set incsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algunas opciones que modifican el modo en el que la búsqueda se realiza.
Estas son las esenciales:
&gt;
	:set incsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes Vim display the match for the string while you are still typing it.
Use this to check if the right match will be found.  Then press &lt;Enter&gt; to
really jump to that location.  Or type more to change the search string.
&gt;
	:set nowrapscan
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim muestre la concordancia de la cadena mientras aún la teclea.
Use esto para ver si la cadena correcta será encontrada. Pulse luego &lt;Intro&gt;
para saltar a su localización. Puede también modificar la cadena.
&gt;
	:set nowrapscan
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stops the search at the end of the file.  Or, when you are searching backwards, at the start of the file.  The 'wrapscan' option is on by default, thus searching wraps around the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto detiene la búsqueda al final del archivo. O, cuando buscas hacia atrás, al comienzo del archivo. La opción 'wrapscan' se activa por omisión, por lo que buscará dando la vuelta al texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.
   Edit the file, as mentioned at |not-compatible|.  Or use this command to
find out where it is: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si le gusta alguna de las opciones mencionadas previamente, y la activa cada
vez que usa Vim, puede poner la orden en el archivo de arranque de Vim.
   Edite el archivo, como se describe en |not-compatible|. Puede usar la
siguiente orden para ver dónde se encuentra: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit ~/.vimrc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit ~/.vimrc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then add a line with the command to set the option, just like you typed it in Vim.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora añada una línea con la orden para activar la opción, del mismo modo que lo introdujo en Vim. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Go:set hlsearch&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Go:set hlsearch&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ZZ
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ZZ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.9*	Simple search patterns
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.9*	Patrones sencillos de búsqueda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern "include" matches the word include
anywhere on the line.  But the pattern "^include" matches the word include
only if it is at the beginning of a line.
   The $ character matches the end of a line.  Therefore, "was$" matches the
word was only if it is at the end of a line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter «^» identifica el comienzo de línea. En un teclado Español-España lo
encontrará a la derecha de la «p». El patrón «include» concuerda la palabra
«include» en cualquier parte de una línea. Pero el patrón «^include»
concuerda la palabra «include» sólo si se encuentra al comienzo de la línea.
   El carácter $ coincide el final de línea. Por lo tanto, "era$" concuerda
la palabra «era» sólo si esta se encuentra al final de una línea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	que este sobredicho hidalgo, los ratos que estaba ocioso (que ~
	xxx			  xxx		       xxx
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	the solder holding one of the chips melted and the ~
						       xxx
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	que este sobredicho hidalgo, los ratos que estaba ocioso (que~
						       xxx
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And with "/^the" we find this one:
	the solder holding one of the chips melted and the ~
	xxx
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y con «/^que» encontramos el siguiente:
	que este sobredicho hidalgo, los ratos que estaba ocioso (que ~
	xxx
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try searching with "/^the$", it will only match a single line consisting of "the".  White space does matter here, thus if a line contains a space after the word, like "the ", the pattern will not match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede intentar buscar con «/^que$», que sólo se emparejará con una única línea consistente en «que». El espacio en blanco se considera, por lo que si contiene un espacio tras la palabra, como «que», el patrón no coincide.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.
   If you search for "ter.", you will find these matches:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente desea coinciordar un punto, debe suprimir su significado especial
poniendo antes una barra inversa.
   Si busca «an.», obtendría las siguientes coincidencias:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.10*	Using marks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.10*	Uso de marcadores o marcas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you make a jump to a position with the "G" command, Vim remembers the position from before this jump.  This position is called a mark.  To go back where you came from, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hace un salto a una posición con la orden «G», Vim recuerda la posición antes de el salto. Esta posición se llama marca o marcador. Para volver al punto anterior del que te encuentras, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	``
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	``
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ` is a backtick or open single-quote character.
   If you use the same command a second time you will jump back again.  That's
because the ` command is a jump itself, and the position from before this jump
is remembered.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta ` es una tilde invertida o carácter de abrir comillas simples.
   Si usa esta misma orden de nuevo, volverá hacia atrás. Esto es
porque la orden «`» es un salto en si mismo, y la posición anterior al
salto también se registra.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `` command jumps back and forth, between two points.  The CTRL-O command jumps to older positions (Hint: O for older).  CTRL-I then jumps back to newer positions (Hint: I is just next to O on the keyboard).  Consider this sequence of commands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «``» salta hacia atrás y hacia delante, entre dos puntos. La orden CTRL-O salta a posiciones anteriores (Truco: O de «older», viejo). CTRL-I salta de vuelta a posiciones más recientes (Truco: la I está justo al lado de la O en el teclado). Observe esta secuencia de órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	33G
	/^The
	CTRL-O
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	33G
	/^El
	CTRL-O
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You first jump to line 33, then search for a line that starts with "The".  Then with CTRL-O you jump back to line 33.  Another CTRL-O takes you back to where you started.  If you now use CTRL-I you jump to line 33 again.  And to the match for "The" with another CTRL-I.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero salta a la línea 33, luego salta a una línea que comienza con «El».  Entonces vuelva con CTRL-O a la línea 33. Otro CTRL-O le devuelve a donde comenzó. Si ahora usa CTRL-I, volverá a la línea 33. Con otro CTRL-I vuelve al «El» identificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	     |	texto de ejemplo      ^	       |
	33G  |	texto de ejemplo      | CTRL-O | CTRL-I
	     |	texto de ejemplo      |	       |
	     V	texto de la línea 33  ^	       V
	     |	texto de ejemplo      |	       |
       /^The |	texto de ejemplo      | CTRL-O | CTRL-I
	     V	Aquí estás            |	       V
		texto de ejemplo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	CTRL-I is the same as &lt;Tab&gt;.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	CTRL-I hace lo mismo que &lt;Tab&gt;.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":jumps" command gives a list of positions you jumped to.  The entry which you used last is marked with a "&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:jumps» le da una lista de posiciones a las que ha saltado. La última entrada que ha usado está marcada con un «&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NAMED MARKS							*bookmark*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MARCADORES							*bookmark*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to place your own marks in the text.  The command "ma" marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can't see them, it's just a position that Vim remembers.
   To go to a mark, use the command `{mark}, where {mark} is the mark letter.
Thus to move to the a mark:
&gt;
	`a
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le permite colocar sus propias marcas en el texto. La orden «m» marca el
lugar sobre el que se encuentra el cursor como «a». Puede poner hasta 26
marcas (a-z). No puede verlas, son simplemente posiciones que Vim recuerda.
   Para ir a una marca, use la orden `{marca}, donde {marca} es la letra del
marcador. Para moverse a la marca «a»:
&gt;
	`a
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command 'mark (single quotation mark, or apostrophe) moves you to the beginning of the line containing the mark.  This differs from the `mark command, which moves you to marked column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden '{marca} (apóstrofe o signo de comillas simples) le lleva al comienzo de la línea que contiene la marca. Esto difiere de la orden `{marca}, que le desplaza a la columna donde se hizo la marca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.
   Move to the text at the start and place the s (start) mark there: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los marcadores pueden ser muy útiles cuando se trabaja en dos partes del archivo
relacionadas. Suponga que tiene un texto cerca del comienzo del archivo que
necesitas mirar mientras trabaja en otra parte.
   Vaya al texto del comienzo y ponga un marcador «s» (start) allí: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ms
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ms
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	me
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	me
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	's
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	's
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.
   There is nothing special about using s for start and e for end, they are
just easy to remember.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego puede usar '' para saltar de vuelta a donde estaba, o 'e para saltar al
texto donde estuvo trabajando.
   No hay nada especial en usar s para el comienzo o e para el final, son
simplemente fáciles de recordar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:marks
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:marks
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice a few special marks.  These include:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá unos cuantos marcadores especiales. Entre ellos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	'	The cursor position before doing a jump
	"	The cursor position when last editing the file
	[	Start of the last change
	]	End of the last change
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	'	La posición del cursor antes del último salto
	"	La posición del cursor antes de la última edición
	[	Comienzo del último cambio
	]	Final del último cambio
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_27.txt*	For Vim version 7.3.  Last change: 2010 Mar 28
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_27.esx*	Para Vim version 7.3.  Último cambio: 28/3/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			 Search commands and patterns
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			 Órdenes y patrones de búsqueda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|27.1|	Ignoring case
|27.2|	Wrapping around the file end
|27.3|	Offsets
|27.4|	Matching multiple times
|27.5|	Alternatives
|27.6|	Character ranges
|27.7|	Character classes
|27.8|	Matching a line break
|27.9|	Examples
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|27.1|	Ignorar la distinción entre mayúsculas y minúsculas
|27.2|	Justificar el fin del archivo
|27.3|	Dirección relativa («offsets»)
|27.4|	Emparejar varios elementos
|27.5|	Alternativas
|27.6|	Rangos de caracteres
|27.7|	Clases de caracteres
|27.8|	Coincidir con un salto de línea
|27.9|	Ejemplos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_28.txt|  Folding
 Previous chapter: |usr_26.txt|  Repeating
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_28.txt|  Plegar
  Capítulo anterior: |usr_25.esx|  Repetición
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.1*	Ignoring case
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.1*	Ignorar la distinción entre mayúsculas y minúsculas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Vim's searches are case sensitive.  Therefore, "include",
"INCLUDE", and "Include" are three different words and a search will match
only one of them.
   Now switch on the 'ignorecase' option: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim distingue entre mayúsculas y minúsculas al realizar un búsqueda de forma
predeterminada. «INCLUDE», «Include» e «include»  son por ello tres palabras
distintas, y una búsqueda encontraría sólo una de ellas.
   Active ahora la opción 'ignorecase': &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But let's keep it set, and search for "INCLUDE".  It will match exactly the same text as "include" did.  Now set the 'smartcase' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a dejar esta opción activada, y realizar una búsqueda de «INCLUDE». Encontrará el mismo texto que «include». Active ahora la opción 'smartcase': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set ignorecase smartcase
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set ignorecase smartcase
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a pattern with at least one uppercase character, the search
becomes case sensitive.  The idea is that you didn't have to type that
uppercase character, so you must have done it because you wanted case to
match.  That's smart!
    With these two options set you find the following matches:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene un patrón con al menos un carácter en mayúscula, la búsqueda no
distinguirá entre mayúsculas y minúsculas. La idea es que no necesitaba
escribir ese carácter en mayúscula, y que por ello lo que deseaba era
encontrar coincidencias con distinción entre mayúsculas y minúsculas. ¡Qué
inteligente!
   Obtendría las siguientes coincidencias de activar ambas opciones:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	pattern			matches	~
	word			word, Word, WORD, WoRd, etc.
	Word			Word
	WORD			WORD
	WoRd			WoRd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	patrón			coincidencias	~
	palabra			palabra, Palabra, PALABRA, PaLaBRa etc.
	Palabra			Palabra
	PALABRA			PALABRA
	PaLaBRa			PaLaBRa
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to ignore case for one specific pattern, you can do this by prepending the "\c" string.  Using "\C" will make the pattern to match case.  This overrules the 'ignorecase' and 'smartcase' options, when "\c" or "\C" is used their value doesn't matter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede anexar la cadena «\c» si desea ignorar esta distinción para un patrón en particular. Usar «\C» activará la distinción. Esto invalida las opciones 'ignorecase' y 'smartcase', ya que usar «\c» o «\C» obvia el valor de estas opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	pattern			matches	~
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd, etc.
	\cWord			word, Word, WORD, WoRd, etc.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	patrón			coincidencias	~
	\Cpalabra		palabra
	\CPalabra		Palabra
	\cpalabra		palabra, Palabra, PALABRA, PaLaBrA, etc.
	\cPalabra		palabra, Palabra, PALABRA, PaLaBrA, etc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A big advantage of using "\c" and "\C" is that it sticks with the pattern.  Thus if you repeat a pattern from the search history, the same will happen, no matter if 'ignorecase' or 'smartcase' was changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una enorme ventaja de usar «\c» y «\C» es que se mantienen ligadas al patrón. Por ello, si repite un patrón desde el registro de búsquedas obtendrá el mismo resultado sin importar si cualquier cambio de 'ignorecase' y 'smartcase'. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	The use of "\" items in search patterns depends on the 'magic' option.
	In this chapter we will assume 'magic' is on, because that is the
	standard and recommended setting.  If you would change 'magic', many
	search patterns would suddenly become invalid.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	El uso del elemento «\» en patrones de búsqueda depende de la opción
	'magic'.
	En estos capítulos daremos por sentado que 'magic' está activado, ya
	que es la configuración estándar y recomendad. De cambiar 'magic'
	muchos patrones de búsqueda no serían válidos.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	If your search takes much longer than you expected, you can interrupt
	it with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Si la búsqueda lleva más tiempo del esperado, puede interrumpir esta
	con CTRL-C en Unix y CTRL-Break en MS-DOS y MS-Windows.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.2*	Wrapping around the file end
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.2*	Justificar el fin del archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a forward search starts searching for the given string at the
current cursor location.  It then proceeds to the end of the file.  If it has
not found the string by that time, it starts from the beginning and searches
from the start of the file to the cursor location.
   Keep in mind that when repeating the "n" command to search for the next
match, you eventually get back to the first match.  If you don't notice this
you keep searching forever!  To give you a hint, Vim displays this message:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, una búsqueda hacia adelante se inicia buscando la cadena dada
en la ubicación presente del cursor. Después continua hasta el final del
archivo. Si no ha encontrado ninguna cadena, vuelve al inicio y busca desde
el principio del archivo.
   Tenga en cuenta que, de repetir la orden «n» para buscar la siguiente
coincidencia, al final volverá a la primera. ¡Buscará para siempre si no nota
esto! Vim le da una pista con la forma del siguiente mensaje:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	search hit BOTTOM, continuing at TOP ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	La búsqueda ha llegado al FINAL, continuando desde el PRINCIPIO ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	search hit TOP, continuing at BOTTOM ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	La búsqueda ha llegado al FINAL, continuando desde el PRINCIPIO ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Still, you don't know when you are back at the first match.  One way to see this is by switching on the 'ruler' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así,no sabe cuando vuelve a la primera coincidencia. Una forma de ver esto es activando la opción 'ruler'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will display the cursor position in the lower righthand corner of the window (in the status line if there is one).  It looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muestra siempre la posición actual en la esquina inferior derecha de la ventana (en la línea de estado, de existir). Presenta este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	101,29       84% ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	101,29       84% ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first number is the line number of the cursor.  Remember the line number where you started, so that you can check if you passed this position again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primer número es el número de la línea del cursor. Recuerde el número de la línea inicial, de manera pueda comprobar si ya pasó por esta posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nowrapscan
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nowrapscan
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E385: search hit BOTTOM without match for: forever ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E385: La búsqueda ha llegado al FINAL sin una coincidencia para:
	forever ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can find all matches by going to the start of the file with "gg" and
keep searching until you see this message.
   If you search in the other direction, using "?", you get:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, puede encontrar todas las coincidencias desplazándose al inicio del
archivo con «gg», y buscar hasta ver este mensaje.
   Si busca en otra dirección, usando, «?», obtendrá:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	E384: search hit TOP without match for: forever ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	E385: La búsqueda ha llegado al PRINCIPIO sin una coincidencia
	para: forever ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.3*	Offsets
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.3*	Dirección relativa («Offsets»)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the search command leaves the cursor positioned on the beginning of the pattern.  You can tell Vim to leave it some other place by specifying an offset.  For the forward search command "/", the offset is specified by appending a slash (/) and the offset: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, la orden de búsqueda posiciona el cursor al inicio del patrón. Puede hacer que Vim lo posicione en algún lugar especificando una dirección relativa. Para la orden de búsqueda hacia delante «/», la dirección relativa se especifica añadiendo una barra inversa («/») y la dirección relativa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/default/2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/omisión/2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command searches for the pattern "default" and then moves to the beginning of the second line past the pattern.  Using this command on the paragraph above, Vim finds the word "default" in the first line.  Then the cursor is moved two lines down and lands on "an offset".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden busca el patrón «omisión», y después se desplaza al inicio de la segunda línea, más allá del patrón. De usar esta orden en el párrafo anterior, Vim encontraría la palabra «omisión» en la primera línea. Acto seguido, el cursor se posicionaría dos líneas más abajo, para acabar en la dirección relativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the offset is a simple number, the cursor will be placed at the beginning of the line that many lines from the match.  The offset number can be positive or negative.  If it is positive, the cursor moves down that many lines; if negative, it moves up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor se posicionara al inicio de la línea presente un número n de líneas a partir de la coincidencia, si la dirección relativa es un simple número. El número de dirección relativa puede ser positivo o negativo. De ser positivo, el cursor se desplaza hacia abajo un número n de líneas; si es negativo, se desplaza hacia arriba.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "e" offset indicates an offset from the end of the match.  It moves the cursor onto the last character of the match.  The command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La dirección relativa «e» indica una dirección a partir del final de la coincidencia. Desplaza el cursor al último carácter de la coincidencia. La orden :&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/const/e
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/const/e
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>puts the cursor on the "t" of "const".
   From that position, adding a number moves forward that many characters.
This command moves to the character just after the match: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>pone el cursor sobre la «t» de «const».
   Añadir un número le desplazará hacia delante tantos caracteres desde la
posición inicial. Esta orden desplaza el carácter a la posición anterior
a la coincidencia: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/const/e+1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/const/e+1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A positive number moves the cursor to the right, a negative number moves it to the left.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un número positivo desplaza el cursor a la derecha, un número negativo lo desplaza a la izquierda. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/const/e-1
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/const/e-1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the offset begins with "b", the cursor moves to the beginning of the pattern.  That's not very useful, since leaving out the "b" does the same thing.  It does get useful when a number is added or subtracted.  The cursor then goes forward or backward that many characters.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la dirección empieza con una «b», el cursor se desplazará al inicio del patrón. No es muy útil, ya que se logra lo mismo dejando la «b». Es de utilidad al añadir o sustraer un número. Entonces, el cursor se desplaza hacia delante o atrás tantos caracteres. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/const/b+2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/const/b+2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moves the cursor to the beginning of the match and then two characters to the right.  Thus it lands on the "n".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplaza el cursor al principio de la coincidencia, dos caracteres a la derecha. Por ello, finaliza en «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/that
	//e
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/that
	//e
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/that/e
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/that/e
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"n" does the same thing.  To repeat while removing a previously used offset: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«n» hace lo mismo. Para repetir mientras elimina una dirección usada anteriormente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	//
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	//
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	?const?e-2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	?const?e-2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When starting a search, it normally starts at the cursor position.  When you specify a line offset, this can cause trouble.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al iniciar una búsqueda, generalmente comienza por la posición del cursor. Esto puede causar problemas cuando especifica un desplazamiento relativo de línea. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/const/-2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/const/-2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds the next word "const" and then moves two lines up.  If you
use "n" to search again, Vim could start at the current position and find the same
"const" match.  Then using the offset again, you would be back where you started.
You would be stuck!
   It could be worse: Suppose there is another match with "const" in the next
line.  Then repeating the forward search would find this match and move two
lines up.  Thus you would actually move the cursor back!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra la siguiente aparición de «const», y después se desplaza dos
líneas haci arriba. Si usa «n» para repetir la búsqueda, puede que Vim la
inicie en la posición actual, encontrando la misma coincidencia de «const».
Al usar el mismo desplazamiento relativo, ha vuelto al punto inicio.
¡Se quedaría atascado!
   Aún pero: supongo que existe otra aparición de «const» en la siguiente
línea. Repetir la búsqueda hacia adelante encontraría esta coincidencia,
y desplazaría el cursor dos líneas atrás. ¡Estaría desplazando el cursor
hacia atrás todo el rato!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you specify a character offset, Vim will compensate for this.  Thus the search starts a few characters forward or backward, so that the same match isn't found again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al especificar un carácter de desplazamiento relativo, Vim dará una compensación. Por ello, la búsqueda se inicia unos cuantos caracteres delante o detrás, para no encontrar otra vez la misma coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.4*	Matching multiple times
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.4*	Emparejar varios elementos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "*" item specifies that the item before it can match any number of times.  Thus: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento «*» especifica que el elemento precedente puede emparejarse un número ilimitado de veces. Por ello: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/a*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/a*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>matches "a", "aa", "aaa", etc.  But also "" (the empty string), because zero
times is included.
   The "*" only applies to the item directly before it.  Thus "ab*" matches
"a", "ab", "abb", "abbb", etc.  To match a whole string multiple times, it
must be grouped into one item.  This is done by putting "\(" before it and
"\)" after it.  Thus this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>coincide con «a», «aa», «aaa», etc. Pero también « » (una cadena vacía), ya
que se incluye por omisión cero veces.
   «*» sólo afecta al su elemento precedente. Por ello, «ab*» encuentra «a»,
«ab», «abb», «abbb», etc. Para encontrar varias apariciones de una cadena
completa, ésta ha de estar agrupada bajo un mismo elemento. Esto se hace
colocando «\(» antes de la cadena, y «\)» después. Por ello, la siguiente
orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\(ab\)*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\(ab\)*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches: "ab", "abab", "ababab", etc.  And also "".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>encuentra «ab», «abab», «ababab», etc. También « ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid matching the empty string, use "\+".  This makes the previous item match one or more times. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que coincida con una cadena vacía, use «\+». Esto encuentra una o
más apariciones del elemento precedente. &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/ab\+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/ab\+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches "ab", "abb", "abbb", etc.  It does not match "a" when no "b" follows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encuentra «ab», «abb», «abbb», etc. No coincide con «a» si no va seguido de «b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match an optional item, use "\=".  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer coincidir un elemento opcional, utilice «\=». Ejemplo:&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/folders\=
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/directorio\=
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match a specific number of items use the form "\{n,m}".  "n" and "m" are numbers.  The item before it will be matched "n" to "m" times |inclusive|.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la forma «\{n,m}» para emparejar un número específico de elementos. «n» y «m» son números. El elemento anterior a éstos se emparejará con «n» un número «m» de veces |inclusive|. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/ab\{3,5}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/ab\{3,5}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>matches "abbb", "abbbb" and "abbbbb".
  When "n" is omitted, it defaults to zero.  When "m" is omitted it defaults
to infinity.  When ",m" is omitted, it matches exactly "n" times.
Examples:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>empareja «abbb», «abbbb» y «abbbbb».
  El valor predeterminado cero en ausencia de «n». El valor predeterminado
es infinito en ausencia de «m». En ausencia de «m», se empareja
exactamente «n» veces.
Ejemplos:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	pattern		match count ~
	\{,4}		0, 1, 2, 3 or 4
	\{3,}		3, 4, 5, etc.
	\{0,1}		0 or 1, same as \=
	\{0,}		0 or more, same as *
	\{1,}		1 or more, same as \+
	\{3}		3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	patrón		número de coincidencias ~
	\{,4}		0, 1, 2, 3 o 4
	\{3,}		3, 4, 5, etc.
	\{0,1}		0 o 1, igual que \=
	\{0,}		0 o más, igual que *
	\{1,}		1 o más, igual que \+
	\{3}		3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/ab\{-1,3}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/ab\{-1,3}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will match "ab" in "abbb".  Actually, it will never match more than one b,
because there is no reason to match more.  It requires something else to force
it to match more than the lower limit.
   The same rules apply to removing "n" and "m".  It's even possible to remove
both of the numbers, resulting in "\{-}".  This matches the item before it
zero or more times, as few as possible.  The item by itself always matches
zero times.  It is useful when combined with something else.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontraría «ab» en «abbb». En realidad, nunca coincidirá con mas de una «b»,
ya que no hay razón para coincidir con más. Se precisa algo más para forzar
un número de coincidencias mayor que el límite más bajo.
   Las mismas reglas están presentes al eliminar «n» y «m». También es posible
eliminar ambos números, dejando «\{-}». Esto encuentra el elemento anterior
a él cero o más veces, pero cuantas menos posibles. El elemento en sí siempre
se empareja cero veces. Es de utilidad en combinación con algo más.
Ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/a.\{-}b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/a.\{-}b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "axb" in "axbxb".  If this pattern would be used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincide con «axb» en «axbxb». De usar este patrón &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/a.*b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/a.*b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.5*	Alternatives
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.5*	Alternativas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "or" operator in a pattern is "\|".  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operador «or» dentro de un patrón es «\|». Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/foo\|bar
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/foo\|bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "foo" or "bar".  More alternatives can be concatenated: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra «foo» o «bar». Puede concatenar más alternativas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/one\|two\|three
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/uno\|dos\|tres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches "one", "two" and "three".
   To match multiple times, the whole thing must be placed in "\(" and "\)": &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Coincide con «uno», «dos» y «tres».
   Para encontrar varias coincidencias debe insertar la cadena completa entre
«\(» y «\)»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\(foo\|bar\)\+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\(foo\|bar\)\+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "foo", "foobar", "foofoo", "barfoobar", etc.
   Another example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra «foo», «foobar», «foofoo», «barfoobar», etc.
   Otro ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/end\(if\|while\|for\)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/end\(if\|while\|for\)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A related item is "\&amp;".  This requires that both alternatives match in the same place.  The resulting match uses the last alternative.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un elemento relacionado es «\&amp;». Esto requiere que ambas alternativas coincidan en el mismo lugar. La coincidencia resultante usa la última alternativa. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/forever\&amp;...
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/forever\&amp;...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "for" in "forever".  It will not match "fortuin", for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincide on «for» en «forever». No coincide con «fortuin», por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.6*	Character ranges
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.6*	Rangos de caracteres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match "a", "b" or "c" you could use "/a\|b\|c".  When you want to match all letters from "a" to "z" this gets very long.  There is a shorter method: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «/a|b\|c» para encontrar «a», «b» o «c». Esto se extiende si desea encontrar todas las letras de la «a» a la «z». Existe una manera más corta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/[a-z]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/[a-z]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The [] construct matches a single character.  Inside you specify which characters to match.  You can include a list of characters, like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La construcción [] encuentra un sólo carácter. Especifique dentro de este los caracteres a encontrar. Puede incluir una lista larga de caracteres, como esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/[0123456789abcdef]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/[0123456789abcdef]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will match any of the characters included.  For consecutive characters you can specify the range.  "0-3" stands for "0123".  "w-z" stands for "wxyz".  Thus the same command as above can be shortened to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra cualquier carácter incluido. Puede especificar un rango para encontrar caracteres consecutivos. «0-3» significa «01234». «w-z» significa «wxyz». Por ello, puede acortar la orden anterior: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/[0-9a-f]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/[0-9a-f]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match the "-" character itself make it the first or last one in the range.  These special characters are accepted to make it easier to use them inside a [] range (they can actually be used anywhere in the search pattern):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar el carácter «-», tiene que aparecer al principio o final del rango. Estos caracteres especiales se aceptan para facilitar su uso dentro de un rango [] (en realidad, puede usarlos en cualquier lugar dentro del patrón de búsqueda):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	\e	&lt;Esc&gt;
	\t	&lt;Tab&gt;
	\r	&lt;CR&gt;
	\b	&lt;BS&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	\e	&lt;Esc&gt;
	\t	&lt;Tab&gt;
	\r	&lt;CR&gt;
	\b	&lt;BS&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid matching a specific character, use "^" at the start of the range.  The [] item then matches everything but the characters included.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «^» al principio del rango para evitar emparejar un carácter en particular. El elemento [] emparejará todo menos los caracteres incluidos. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/"[^"]*"
&lt;
	 "	  a double quote
	  [^"]	  any character that is not a double quote
	      *	  as many as possible
	       "  a double quote again
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/"[^"]*"
&lt;
	 "	  dobles comillas
	  [^"]	  todo carácter que no es una comilla doble
	      *	  tantos como sea posible
	       "  otras dobles comillas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number of ranges are used very often.  Vim provides a shortcut for these.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe un número de rangos usados a menudo. Vim ofrece accesos directos para esto. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\a
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\a
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finds alphabetic characters.  This is equal to using "/[a-zA-Z]".  Here are a few more of these:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encuentra caracteres alfabéticos. Esto equivale a usar «/[a-zA-Z]». Aquí hay más ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	item	matches			equivalent ~
	\d	digit			[0-9]
	\D	non-digit		[^0-9]
	\x	hex digit		[0-9a-fA-F]
	\X	non-hex digit		[^0-9a-fA-F]
	\s	white space		[ 	]     (&lt;Tab&gt; and &lt;Space&gt;)
	\S	non-white characters	[^ 	]     (not &lt;Tab&gt; and &lt;Space&gt;)
	\l	lowercase alpha		[a-z]
	\L	non-lowercase alpha	[^a-z]
	\u	uppercase alpha		[A-Z]
	\U	non-uppercase alpha	[^A-Z]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>       elemento coincidencias		equivalente ~
	\d	dígito			[0-9]
	\D	no-dígito		[^0-9]
	\x	dígito hexadecimal	[0-9a-fA-F]
	\X	dígito no hexadecimal	[^0-9a-fA-F]
	\s	espacio vacío		[ 	]     (&lt;Tab&gt; y &lt;Space&gt;)
	\S	caracteres no vacíos	[^ 	]     (no &lt;Tab&gt; y &lt;Space&gt;)
	\l	alfa minúscula		[a-z]
	\L	alfa no mayúscula	[^a-z]
	\u	alfa mayúscula		[A-Z]
	\U	alfa no mayúscula	[^A-Z]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	Using these predefined ranges works a lot faster than the character
	range it stands for.
	These items can not be used inside [].  Thus "[\d\l]" does NOT work to
	match a digit or lowercase alpha.  Use "\(\d\|\l\)" instead.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	El uso de estos rangos predeterminados es más rápido que el rango de
	caracteres que simbolizan.
	Estos elementos no se pueden usar dentro de []. Así, «[\d\l]» NO
	funciona para encontrar un dígito o un alfa minúscula. En lugar
	de ello, use «\(\d\|\l\)».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.7*	Character classes
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.7*	Clase de carácter
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character range matches a fixed set of characters.  A character class is
similar, but with an essential difference: The set of characters can be
redefined without changing the search pattern.
   For example, search for this pattern: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El rango de carácter empareja un conjunto específico de caracteres. Se
parece una clase de carácter, pero con una importante diferencia: puede
redefinir el conjunto de caracteres sin cambiar el patrón de búsqueda.
   Por ejemplo, busque este patrón: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\f\+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\f\+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "\f" items stands for file name characters.  Thus this matches a sequence
of characters that can be a file name.
   Which characters can be part of a file name depends on the system you are
using.  On MS-Windows, the backslash is included, on Unix it is not.  This is
specified with the 'isfname' option.  The default value for Unix is: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos «\f» simbolizan caracteres de nombre de archivo. Así, esto
empareja una secuencia de caracteres que pueden ser un nombre de archivo.
Qué caracteres pueden formar parte de un nombre de archivo dependen del
sistema que esté usando. En MS-Windows, la barra inversa está incluida, pero
no en Unix. Puede especificar esto con la opción 'isfname'. El valor por
omisión en Unix es: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For other systems the default value is different.  Thus you can make a search pattern with "\f" to match a file name, and it will automatically adjust to the system you are using it on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado depende del sistema. Así, puede crear un patrón de búsqueda con «\f» para emparejar un nombre de archivo, y ajustarse automáticamente al sistema en el que lo está usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	item	matches				option ~
	\i	identifier characters		'isident'
	\I	like \i, excluding digits
	\k	keyword characters		'iskeyword'
	\K	like \k, excluding digits
	\p	printable characters		'isprint'
	\P	like \p, excluding digits
	\f	file name characters		'isfname'
	\F	like \f, excluding digits
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>      elemento	coinicidencias			opción ~
	\i	caracteres de identificación	'isident'
	\I	como \i, excluyendo dígitos
	\k	carácter de palabra clave	'iskeyword'
	\K	como \k, excluyendo dígitos
	\p	caracteres imprimibles		'isprint'
	\P	como \p, excluyendo dígitos
	\f	caracteres de nombre de archivo	'isfname'
	\F	como \f, excluyendo dígitos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.8*	Matching a line break
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.8*	Coincidir con un salto de línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can find a pattern that includes a line break.  You need to specify where
the line break happens, because all items mentioned so far don't match a line
break.
   To check for a line break in a specific place, use the "\n" item: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede encontrar un patrón que incluye un salto de línea. Debe especificar
la aparición del salto de línea, ya que todos los elementos mencionados hasta
ahora no se emparejan con un salto de línea.
   Para comprobar si hay un salto de línea en un lugar específico, use el
elemento «\n»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the\nword
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/la\npalabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will match at a line that ends in "the" and the next line starts with "word".  To match "the word" as well, you need to match a space or a line break.  The item to use for it is "\_s": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincidiría en una línea que termina con «la», seguida de una que comienza con «palabra». Para encontrar también «la palabra», tendrá que emparejar el espacio o el salto de línea. Para ello, use el elemento «\_s»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the\_sword
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/la\_spalabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/the\_s\+word
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/la\_s\+palabra
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also matches when "the  " is at the end of a line and "   word" at the
start of the next one.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también coincide cuando «la » está al final de la línea, y «palabra» al
inicio de la siguiente.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"\s" matches white space, "\_s" matches white space or a line break.  Similarly, "\a" matches an alphabetic character, and "\_a" matches an alphabetic character or a line break.  The other character classes and ranges can be modified in the same way by inserting a "_".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«\s» coincide con espacio en blanco, «\_s» coincide con espacio en blanco o un salto de línea. De forma parecida, «\a» coincide con un carácter alfabético o un salto de línea. Las otras clases de caracteres y rangos se pueden modificar de la misma forma insertando un «_».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many other items can be made to match a line break by prepending "\_".  For example: "\_." matches any character or a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer coincidir muchos otros elementos con un salto de línea prefijando «\_». Por ejemplo, «\_.» coincide con cualquier carácter o salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	"\_.*" matches everything until the end of the file.  Be careful with
	this, it can make a search command very slow.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	«\_.*» empareja todo hasta el final del archivo. Use esto con
	cuidado, ya que puede reducir la velocidad de una orden de búsqueda.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/"\_[^"]*"
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/"\_[^"]*"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.9*	Examples
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.9*	Ejemplos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are a few search patterns you might find useful.  This shows how the items mentioned above can be combined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí dispone de unos cuantos patrones de búsqueda que puede encontrar útiles. Esto muestra cómo combinar los elementos anteriormente mencionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample license plate number is "1MGU103".  It has one digit, three uppercase letters and three digits.  Directly putting this into a search pattern: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo de un número de matrícula es «1MGU103». Tiene un dígito, tres letras mayúsculas y tres dígitos. Puede insertar esto en un patrón búsqueda de la siguiente manera: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\d\u\u\u\d\d\d
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\d\u\u\u\d\d\d
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\d\u\{3}\d\{3}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\d\u\{3}\d\{3}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/[0-9][A-Z]\{3}[0-9]\{3}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/[0-9][A-Z]\{3}[0-9]\{3}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which one of these you should use? Whichever one you can remember.  The simple way you can remember is much faster than the fancy way that you can't.  If you can remember them all, then avoid the last one, because it's both more typing and slower to execute.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Cual debería usar? Él que recuerde. La manera sencilla que puede recordar es más rápida que la compleja que no puede. Si los puede recordar todos, evite el último, ya que es más lento de teclear y de ejecutar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C programs (and many other computer languages) an identifier starts with a letter and further consists of letters and digits.  Underscores can be used too.  This can be found with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En programas C (y muchos otros lenguajes de programación), un identificador empieza con una letra seguida de letras y dígitos. Puede usar subrayados. Puede encontrar esto con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/\&lt;\h\w*\&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/\&lt;\h\w*\&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	"\&lt;" and "\&gt;" depend on the 'iskeyword' option.  If it includes "-",
	for example, then "ident-" is not matched.  In this situation use: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	«\&lt;» y «\&gt;» dependen de la opción 'iskeyword'. De incluir un «-»,
	por ejemplo, «ident-» no se encontrará. Use lo siguiente en esta
	situación: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		/\w\@&lt;!\h\w*\w\@!
&lt;
	This checks if "\w" does not match before or after the identifier.
	See |/\@&lt;!| and |/\@!|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		/\w\@&lt;!\h\w*\w\@!
&lt;
	Esto revisa se «\w» no se empareja antes o después de un
	identificador. Consulte |/\@&lt;!| and |/\@!|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_05.txt*	For Vim version 7.3.  Last change: 2009 Jun 04
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_05.esx*	Para Vim versión 7.3.  Último cambio: 4/6/2009
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Set your settings
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 			     Configuración
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|05.1|	The vimrc file
|05.2|	The example vimrc file explained
|05.3|	Simple mappings
|05.4|	Adding a plugin
|05.5|	Adding a help file
|05.6|	The option window
|05.7|	Often used options
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|05.1|	El archivo vimrc
|05.2|	Explicación del archivo vimrc de ejemplo
|05.3|	Macros sencillas
|05.4|	Añadir una extensión
|05.5|	Añadir un archivo de ayuda
|05.6|	La ventana de opciones
|05.7|	Opciones más comunes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_06.txt|  Using syntax highlighting
 Previous chapter: |usr_04.txt|  Making small changes
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_06.esx|  Uso del resaltado de sintaxis
  Capítulo anterior: |usr_04.esx|  Hacer cambios pequeños
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.1*	The vimrc file					*vimrc-intro*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.1*	El archivo «vimrc»				*vimrc-intro*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You probably got tired of typing commands that you use very often.  To start Vim with all your favorite option settings and mappings, you write them in what is called the vimrc file.  Vim executes the commands in this file when it starts up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Probablemente se haya cansado de introducir órdenes que usa muy a menudo.  Para iniciar Vim con todas sus opciones y macros favoritas, defínalos en lo que se llama el archivo «vimrc». Vim ejecuta las órdenes en este archivo al inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit $MYVIMRC
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit $MYVIMRC
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a vimrc file yet, see |vimrc| to find out where you can create a vimrc file.  Also, the ":version" command mentions the name of the "user vimrc file" Vim looks for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si todavía no tiene un archivo vimrc, consulte |vimrc| para saber dónde puede crear un archivo vimrc. La orden «:version» también menciona el nombre del «archivo vimrc de usuario» que Vim busca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	~/.vimrc ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	~/.vimrc ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	$HOME/_vimrc ~
	$VIM/_vimrc ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	$HOME/_vimrc ~
	$VIM/_vimrc ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The vimrc file can contain all the commands that you type after a colon.  The most simple ones are for setting options.  For example, if you want Vim to always start with the 'incsearch' option on, add this line you your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo vimrc puede contener todas las órdenes que se pueden teclear tras «:». Los más sencillos son los que se usan para ajustar opciones. Por ejemplo, si quiere que Vim comience siempre con la opción 'incsearch' activada, añada la siguiente línea al archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set incsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set incsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this new line to take effect you need to exit Vim and start it again.  Later you will learn how to do this without exiting Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita salir de Vim e iniciarlo otra vez para que esta nueva línea tenga efecto. Luego verá cómo hacer esto sin salir de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter only explains the most basic items.  For more information on how to write a Vim script file: |usr_41.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo sólo explica los elementos más básicos. Para más información sobre cómo escribir un archivo de script de Vim: |usr_41.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.2*	The example vimrc file explained		*vimrc_example.vim*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.2*	El archivo vimrc de ejemplo, explicado		*vimrc_example.vim*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first chapter was explained how the example vimrc (included in the Vim distribution) file can be used to make Vim startup in not-compatible mode (see |not-compatible|).  The file can be found here:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el primer capítulo se explicó como el archivo vimrc de ejemplo (incluido en la distribución de Vim) se puede emplear para iniciar Vim en modo no-compatible (ver |not-compatible|). Puede encontrar el archivo aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	$VIMRUNTIME/vimrc_example.vim ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	$VIMRUNTIME/vimrc_example.vim ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section we will explain the various commands used in this file.  This will give you hints about how to set up your own preferences.  Not everything will be explained though.  Use the ":help" command to find out more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta sección explicaremos las diferentes órdenes empleadas en este archivo. Esto le dará pistas sobre cómo preparar su propia configuración.  No todo se explicará, en cualquier caso. Use la orden ":help" e investigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set nocompatible
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set nocompatible
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the first chapter, these manuals explain Vim working in an improved way, thus not completely Vi compatible.  Setting the 'compatible' option off, thus 'nocompatible' takes care of this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como se mencionó en el primer capítulo, estos manuales explican un Vim funcionando en un modo mejorado, y por lo tanto no completamente Vi-compatible. Desactivar la opción 'compatible' o activar 'nocompatible' se encarga de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set backspace=indent,eol,start
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set backspace=indent,eol,start
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This specifies where in Insert mode the &lt;BS&gt; is allowed to delete the character in front of the cursor.  The three items, separated by commas, tell Vim to delete the white space at the start of the line, a line break and the character before where Insert mode started.  &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto especifica que se permita en el modo Insertar que &lt;Retroceso&gt; pueda eliminar el carácter delante del cursor. Los tres elementos, separados por comas, le dicen a Vim que puede eliminar el espacio en blanco al comienzo de la línea, un salto de línea y el carácter anterior a donde inició el modo Insertar.  &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set autoindent
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set autoindent
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	if has("vms")
	  set nobackup
	else
	  set backup
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	if has("vms")
	  set nobackup
	else
	  set backup
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to keep a backup copy of a file when overwriting it.  But not on the VMS system, since it keeps old versions of files already.  The backup file will have the same name as the original file with "~" added.  See |07.4| &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le dice a Vim que mantenga una copia de seguridad de un archivo cuando lo sobreescribe. Pero no en el sistema VMS, ya que éste mantiene versiones anteriores por su cuenta. El backup tendrá el mismo nombre con un «~» delante.  Véase |07.4| &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set history=50
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set history=50
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep 50 commands and 50 search patterns in the history.  Use another number if you want to remember fewer or more lines.  &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mantiene 50 órdenes y 50 patrones de búsqueda en el historial. Use otro número si quiere almacenar más o menos líneas.  &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set ruler
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set ruler
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set showcmd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set showcmd
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display an incomplete command in the lower right corner of the Vim window, left of the ruler.  For example, when you type "2f", Vim is waiting for you to type the character to find and "2f" is displayed.  When you press "w" next, the "2fw" command is executed and the displayed "2f" is removed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muestra una orden incompleta en la esquina inferior derecha de la ventana de Vim, a la izquierda del «ruler» (regla). Por ejemplo, cuando pulsa «2f», Vim está esperando que introduzcas el carácter a encontrar y muestra «2f» es mostrado.  Cuando pulse «w», la orden «2fw» es ejecutará y el «2f» se eliminará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+-------------------------------------------------+
	|text in the Vim window				  |
	|~						  |
	|~						  |
	|-- VISUAL --			2f     43,8   17% |
	+-------------------------------------------------+
	 ^^^^^^^^^^^		      ^^^^^^^^ ^^^^^^^^^^
	  'showmode'		     'showcmd'	'ruler'
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+-------------------------------------------------+
	|texto en la ventana de Vim			  |
	|~						  |
	|~						  |
	|-- VISUAL --			2f     43,8   17% |
	+-------------------------------------------------+
	 ^^^^^^^^^^^		      ^^^^^^^^ ^^^^^^^^^^
	  'showmode'		     'showcmd'	'ruler'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set incsearch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set incsearch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	map Q gq
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	map Q gq
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mapping yanks the visually selected text and searches for it in C files.  This is a complicated mapping.  You can see that mappings can be used to do quite complicated things.  Still, it is just a sequence of commands that are executed like you typed them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta macro copia el texto seleccionado visualmente y lo busca en archivos C.  Este es una macro complicado. Aquí puede ver que los macro se pueden emplear para hacer cosas realmente complicadas. En cualquier caso, es simplemente una secuencia de órdenes que se ejecutan justo como los tecleas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	if &amp;t_Co &gt; 2 || has("gui_running")
	  syntax on
	  set hlsearch
	endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	if &amp;t_Co &gt; 2 || has("gui_running")
	  syntax on
	  set hlsearch
	endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This switches on syntax highlighting, but only if colors are available.  And the 'hlsearch' option tells Vim to highlight matches with the last used search pattern.  The "if" command is very useful to set options only when some condition is met.  More about that in |usr_41.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto activa el resaltado de sintaxis, pero sólo si hay colores disponibles. Y la opción 'hlsearch' le dice a Vim que resalte las coincidencias con el último patrón de búsqueda empleado. La orden «if» es muy útil para activar opciones sólo cuando se cumple alguna condición.  Véase |usr_41.txt|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*vimrc-filetype*  &gt;
	filetype plugin indent on
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*vimrc-filetype*  &gt;
	filetype plugin indent on
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2. Using filetype plugin files
   Many different filetypes are edited with different options.  For example,
   when you edit a "c" file, it's very useful to set the 'cindent' option to
   automatically indent the lines.  These commonly useful option settings are
   included with Vim in filetype plugins.  You can also add your own, see
   |write-filetype-plugin|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2. Usar extensiones de tipo de archivo («filetype plugin»)
   Muchos tipos de archivo se editan con diferentes opciones. Por ejemplo,
   cuando edita un archivo «c», es muy útil activar la opción «cindent»
   para sangrar las líneas automáticamente. Estas opciones empleadas
   comúnmente están incluidas con Vim en las extensiones de tipos de
   archivo. También puede incluir las tuyas propias, consulte
   |write-filetype-plugin|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3. Using indent files
   When editing programs, the indent of a line can often be computed
   automatically.  Vim comes with these indent rules for a number of
   filetypes.  See |:filetype-indent-on| and 'indentexpr'.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3. Usar archivos de tabulación
   Cuando edita programas, la sangría de una línea puede a menudo ser
   computada de manera automática. Vim viene con esas reglas de sangrado
   para diversos tipos de archivo.
   Véase |:filetype-indent-on| y 'indentexpr'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	autocmd FileType text setlocal textwidth=78
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	autocmd FileType text setlocal textwidth=78
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes Vim break text to avoid lines getting longer than 78 characters.  But only for files that have been detected to be plain text.  There are actually two parts here.  "autocmd FileType text" is an autocommand.  This defines that when the file type is set to "text" the following command is automatically executed.  "setlocal textwidth=78" sets the 'textwidth' option to 78, but only locally in one file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim divida el texto para evitar que las líneas sean más largas de 78 caracteres. Pero sólo para archivos que se han identificado como de texto regular. Aqui hay dos aspectos. «autocmd FileType text» es una autoorden. Esto define que cuando el tipo de archivo sea «texto», la orden posterior se ejecute automáticamente. «setlocal textwidth=78» ajusta la opción 'textwidth' a 78, pero sólo localmente a un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*restore-cursor*  &gt;
	autocmd BufReadPost *
	    \ if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") |
	    \   exe "normal! g`\"" |
	    \ endif
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*restore-cursor*  &gt;
	autocmd BufReadPost *
	    \ if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") |
	    \   exe "normal! g`\"" |
	    \ endif
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another autocommand.  This time it is used after reading any file.  The complicated stuff after it checks if the '" mark is defined, and jumps to it if so.  The backslash at the start of a line is used to continue the command from the previous line.  That avoids a line getting very long.  See |line-continuation|.  This only works in a Vim script file, not when typing commands at the command-line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra autoorden. Esta vez se ejecuta tras leer cualquier archivo. Las cosas tan complicadas que hay después de él comprueban si la marca '" está definida, y salta hacia ella si lo está. La barra inversa al comienzo de la línea se emplea para continuarla desde la anterior. Esto ayuda a acortar las líneas.  Véase |line-continuation|. Esto funciona sólo dentro de un script de Vim, no cuando se teclean órdenes en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.3*	Simple mappings
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.3*	Macros sencillas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A mapping enables you to bind a set of Vim commands to a single key.  Suppose, for example, that you need to surround certain words with curly braces.  In other words, you need to change a word such as "amount" into "{amount}".  With the :map command, you can tell Vim that the F5 key does this job.  The command is as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una macro le permite ligar un conjunto de órdenes de Vim a una sola tecla.  Suponga, por ejemplo, que necesita poner una palabra entre llaves. En otras palabras necesita cambiar una palabra como «cantidad» a «{cantidad}». Con la orden :map, puede decirle a Vim que la tecla F5 haga precisamente eso. La orden es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;
&lt;
	Note:
	When entering this command, you must enter &lt;F5&gt; by typing four
	characters.  Similarly, &lt;Esc&gt; is not entered by pressing the &lt;Esc&gt;
	key, but by typing five characters.  Watch out for this difference
	when reading the manual!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;
&lt;
	Nota:
	Cuando introduzca esta orden, debe introducir &lt;F5&gt; tecleando
        cuatro caracteres. De igual manera, &lt;Esc&gt; no se introduce pulsando
        la tecla &lt;Esc&gt;, sino tecleando cinco caracteres. De hecho, ¡¡has de
	poner los nombres en inglés, no la versión traducida!!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's break this down:
    &lt;F5&gt;	The F5 function key.  This is the trigger key that causes the
		command to be executed as the key is pressed.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veámoslo por partes:
    &lt;F5&gt;	La tecla de función F5.  Esta es la tecla que lanzará la
                orden para que éste se ejecute al ser pulsada.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    i{&lt;Esc&gt;	Insert the { character.  The &lt;Esc&gt; key ends Insert mode.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    i{&lt;Esc&gt;	Insertar el carácter {. &lt;Esc&gt; sale del modo Insertar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    e		Move to the end of the word.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    e		Moverse al final de la palabra.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    a}&lt;Esc&gt;	Append the } to the word.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    a}&lt;Esc&gt;	Añadir el } a la palabra.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;
	:map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;
	:map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command (with no arguments) lists your current mappings.  At least the ones for Normal mode.  More about mappings in section |40.1|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» (sin argumentos) le da un listado de sus macros actuales. Al menos aquellos en el modo Normal. Más sobre macros en la sección |40.1|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.4*	Adding a plugin					*add-plugin* *plugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.4*	Añadir una extensión				*add-plugin* *plugin*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim's functionality can be extended by adding plugins.  A plugin is nothing more than a Vim script file that is loaded automatically when Vim starts.  You can add a plugin very easily by dropping it in your plugin directory.  {not available when Vim was compiled without the |+eval| feature}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La funcionalidad de Vim puede ser extendida añadiendo extensiones. Una extensiones no es nada más que un script de Vim que se carga automáticamente cuando Vim arranca. Puede añadir nuevas extensiones añadiéndolos al directorio de extensiones.  {no disponible si no se ha compilad con Vim con la opción |+eval|}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    global plugin: Used for all kinds of files
  filetype plugin: Only used for a specific type of file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>               Extensión global: Empleado para todos los tipos de archivo
   Extensión de tipo de archivo: Empleado para un tipo de archivo específico
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GLOBAL PLUGINS						*standard-plugin*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIONES GLOBALES					*standard-plugin*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you start Vim, it will automatically load a number of global plugins.  You don't have to do anything for this.  They add functionality that most people will want to use, but which was implemented as a Vim script instead of being compiled into Vim.  You can find them listed in the help index |standard-plugin-list|.  Also see |load-plugins|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando arranque Vim, verá que carga automáticamente un grupo de extensiones globales. No tiene que hacer nada al respecto. Éstos añaden funcionalidad que le interesan a la mayoría de gente, pero que se implementaron como scripts de Vim en lugar de compilarlos en Vim. Puedes verlos listados en el índice de ayuda |standard-plugin-list|. Véase también |load-plugins|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>							*add-global-plugin*
You can add a global plugin to add functionality that will always be present
when you use Vim.  There are only two steps for adding a global plugin:
1. Get a copy of the plugin.
2. Drop it in the right directory.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>							*add-global-plugin*
Puede poner un extensión global para añadir funcionalidad que deba estar
siempre presente cuando use Vim. Sólo tiene que seguir dos pasos para
añadir una extensión global:
1. Conseguir una copia de la extensión.
2. Ubicar en el directorio adecuado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can you find plugins?
- Some come with Vim.  You can find them in the directory $VIMRUNTIME/macros
  and its sub-directories.
- Download from the net.  There is a large collection on http://www.vim.org.
- They are sometimes posted in a Vim |maillist|.
- You could write one yourself, see |write-plugin|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Dónde encontrar extensiones?
- Algunos vienen con Vim. Puede encontrarlos en el directorio
  $VIMRUNTIME/macro y sus subdirectorios.
- Descargarlos de la red. Hay una buena colección en http://www.vim.org.
- Algunas veces se envían a la |maillist| de Vim.
- Puede escribir uno usted mismo, consulte |write-plugin|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some plugins come as a vimball archive, see |vimball|.  Some plugins can be updated automatically, see |getscript|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas extensiones vienen como un archivo comprimido, consulte |vimball|.  Algunas extensiones pueden ser actualizados automáticamente, consulte |getscript|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First read the text in the plugin itself to check for any special conditions.  Then copy the file to your plugin directory:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lea primero el texto en la extensión descargada para comprobar cualquier requerimiento. A continuación copielo al directorio de extensiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	system		plugin directory ~
	Unix		~/.vim/plugin/
	PC and OS/2	$HOME/vimfiles/plugin or $VIM/vimfiles/plugin
	Amiga		s:vimfiles/plugin
	Macintosh	$VIM:vimfiles:plugin
	Mac OS X	~/.vim/plugin/
	RISC-OS		Choices:vimfiles.plugin
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	sistema		directorio de extensiones  ~
	Unix		~/.vim/plugin/
	PC and OS/2	$HOME/vimfiles/plugin or $VIM/vimfiles/plugin
	Amiga		s:vimfiles/plugin
	Macintosh	$VIM:vimfiles:plugin
	Mac OS X	~/.vim/plugin/
	RISC-OS		Choices:vimfiles.plugin
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mkdir ~/.vim
	mkdir ~/.vim/plugin
	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mkdir ~/.vim
	mkdir ~/.vim/plugin
	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all! Now you can use the commands defined in this plugin to justify text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Esto es todo! Ahora puede usar las órdenes definidas en esta extensión para justificar texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of putting plugins directly into the plugin/ directory, you may better organize them by putting them into subdirectories under plugin/.  As an example, consider using "~/.vim/plugin/perl/*.vim" for all your Perl plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de poner las extensiones directamente en el directorio «plugins/», quizá prefiera organizarlos poniéndolos en subdirectorios dentro de «plugins/». Por ejemplo, ponga todas sus extensiones de Perl bajo el subdirectorio «~/.vim/plugin/perl/*.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FILETYPE PLUGINS			*add-filetype-plugin* *ftplugins*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIONES DE TIPO DE ARCHIVO		*add-filetype-plugin* *ftplugins*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:filetype plugin on
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:filetype plugin on
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all! See |vimrc-filetype|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Eso es todo. Véase |vimrc-filetype|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are missing a plugin for a filetype you are using, or you found a better one, you can add it.  There are two steps for adding a filetype plugin: 1. Get a copy of the plugin.  2. Drop it in the right directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si echa de menos una extensión para un tipo de archivo que esté usando, o encontró uno mejor, puede añadirlo. Hay dos pasos para conseguirlo: 1. Conseguir una copia de la extensión.  2. Copiar en el directorio adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find them in the same places as the global plugins.  Watch out if the type of file is mentioned, then you know if the plugin is a global or a filetype one.  The scripts in $VIMRUNTIME/macros are global ones, the filetype plugins are in $VIMRUNTIME/ftplugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrarlos en los mismos sitios que las extensiones globales.  Compruebe si el tipo de archivo se menciona o no, de ese modo puede saber si la extensión es global o de tipo de archivo. Los scripts en «$VIMRUNTIME/macros» son globales, los específicos están en «$VIMRUNTIME/ftplugin».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>USING A FILETYPE PLUGIN					*ftplugin-name*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>USAR UNA EXTENSIÓN DE TIPO DE ARCHIVO			*ftplugin-name*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a filetype plugin by dropping it in the right directory.  The name of this directory is in the same directory mentioned above for global plugins, but the last part is "ftplugin".  Suppose you have found a plugin for the "stuff" filetype, and you are on Unix.  Then you can move this file to the ftplugin directory: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir una extensión de tipo de archivo ubicándolo en el directorio adecuado. El nombre de este directorio está en el mismo directorio mencionado previamente para extensiones globales, pero la última parte es «ftplugin». Suponga que ha encontrado una extensión para el tipo de archivo «cosas» y que está bajo Unix.  Puede mover este archivo al directorio «ftplugin/»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mv thefile ~/.vim/ftplugin/stuff.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mv thefile ~/.vim/ftplugin/cosas.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If that file already exists you already have a plugin for "stuff".  You might want to check if the existing plugin doesn't conflict with the one you are adding.  If it's OK, you can give the new one another name: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ese archivo ya existe, es que ya tiene una extensión para «cosas». Tal vez desee comprobar si la extensión existente no es conflictivo con el que añade. Si no hay conflicto, puede darle otro nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mv thefile ~/.vim/ftplugin/stuff_too.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mv thefile ~/.vim/ftplugin/cosas_dos.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The underscore is used to separate the name of the filetype from the rest, which can be anything.  If you use "otherstuff.vim" it wouldn't work, it would be loaded for the "otherstuff" filetype.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El guión bajo se usa para separar el nombre del tipo de archivo del resto, que puede ser cualquier cosa. Si usa «otrascosas.vim» no funcionaría, ya que se cargaría como tipo de archivo «otrascosas».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-DOS you cannot use long filenames.  You would run into trouble if you add a second plugin and the filetype has more than six characters.  You can use an extra directory to get around this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-DOS no puede usar nombres de archivo largos. Tendrá problemas si añades una segunda extensión el tipo de archivo tiene más de seis caracteres. Puede añadir un directorio extra para evitar este problema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	mkdir $VIM/vimfiles/ftplugin/fortran
	copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	mkdir $VIM/vimfiles/ftplugin/fortran
	copy thefile $VIM/vimfiles/ftplugin/fortran/dos.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ftplugin/&lt;filetype&gt;.vim
	ftplugin/&lt;filetype&gt;_&lt;name&gt;.vim
	ftplugin/&lt;filetype&gt;/&lt;name&gt;.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ftplugin/&lt;tipo_de_archivo&gt;.vim
	ftplugin/&lt;tipo_de_archivo&gt;_&lt;nombre&gt;.vim
	ftplugin/&lt;tipo_de_archivo&gt;/&lt;nombre&gt;.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here "&lt;name&gt;" can be any name that you prefer.  Examples for the "stuff" filetype on Unix: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí, «&lt;nombre&gt;» puede ser cualquier nombre que quieras.  Ejemplos para el tipo de archivo «cosas» en Unix: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	~/.vim/ftplugin/stuff.vim
	~/.vim/ftplugin/stuff_def.vim
	~/.vim/ftplugin/stuff/header.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	~/.vim/ftplugin/cosas.vim
	~/.vim/ftplugin/cosas_def.vim
	~/.vim/ftplugin/cosas/header.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;filetype&gt; part is the name of the filetype the plugin is to be used for.  Only files of this filetype will use the settings from the plugin.  The &lt;name&gt; part of the plugin file doesn't matter, you can use it to have several plugins for the same filetype.  Note that it must end in ".vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte &lt;tipo_de_archivo&gt; es el nombre del tipo de archivo para el cuál se usa la extensión. Sólo los archivos de este tipo cargarán esta extensión.  La parte &lt;nombre&gt; de la extensión no importa, puede usarlo para tener varias extensiones del mismo tipo de archivo. Tenga en cuenta que debe terminar con la extensión «.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further reading:
|filetype-plugins|	Documentation for the filetype plugins and information
			about how to avoid that mappings cause problems.
|load-plugins|		When the global plugins are loaded during startup.
|ftplugin-overrule|	Overruling the settings from a global plugin.
|write-plugin|		How to write a plugin script.
|plugin-details|	For more information about using plugins or when your
			plugin doesn't work.
|new-filetype|		How to detect a new file type.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lecturas de ampliación:
|filetype-plugins|	Documentación para las extensiones de tipo de
			archivo e información sobre como evitar problemas
			con macros.
|load-plugins|		Cuándo las extensiones globales se cargan.
|ftplugin-overrule|	Sobreescribir las opciones de una extensión global.
|write-plugin|		Cómo escribir un script de extensión.
|plugin-details|	Para más información sobre cómo usar extensiones o
			cuando la extensión no funciona.
|new-filetype|		Cómo detectar un nuevo tipo de archivo.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.5*	Adding a help file		*add-local-help* *matchit-install*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.5*	Añadir un archivo de ayuda	*add-local-help* *matchit-install*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are lucky, the plugin you installed also comes with a help file.  We
will explain how to install the help file, so that you can easily find help
for your new plugin.
   Let us use the "matchit.vim" plugin as an example (it is included with
Vim).  This plugin makes the "%" command jump to matching HTML tags,
if/else/endif in Vim scripts, etc.  Very useful, although it's not backwards
compatible (that's why it is not enabled by default).
   This plugin comes with documentation: "matchit.txt".  Let's first copy the
plugin to the right directory.  This time we will do it from inside Vim, so
that we can use $VIMRUNTIME.  (You may skip some of the "mkdir" commands if
you already have the directory.) &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene suerte, la extensión que instaló viene con un archivo de ayuda.  Le
explicaremos cómo instalar el archivo de ayuda, para que pueda encontrar
ayuda fácilmente para su nueva extensión.
   Usemos el plugin «matchit.vim» como ejemplo (viene incluido con Vim).
Esta extensión hace que la orden «%» salte a tags emparejados de HTML,
«if/else/endif» en scripts de Vim, etc. Muy útil, pero no es compatible
con versiones anteriores (por lo que no está activado por defecto).
   Esta extensión viene con la documentación «matchit.txt». Primero
copiemos la extensión al directorio adecuado. Esta vez lo haremos desde
dentro de Vim, así podremos usar $VIMRUNTIME. (Puede omitir la orden
«mkdir» si ya tiene el directorio.) &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!mkdir ~/.vim
	:!mkdir ~/.vim/plugin
	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!mkdir ~/.vim
	:!mkdir ~/.vim/plugin
	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a "doc" directory in one of the directories in 'runtimepath'. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cree un directorio «doc» en una de los directorios de 'runtimepath'. &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!mkdir ~/.vim/doc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!mkdir ~/.vim/doc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the help file to the "doc" directory. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie el archivo de ayuda al directorio «doc». &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now comes the trick, which allows you to jump to the subjects in the new help file: Generate the local tags file with the |:helptags| command. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último el truco que le permite ir a los temas en el nuevo archivo de ayuda: Genere el archivo de tags locales con la orden |:helptags|. &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:helptags ~/.vim/doc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:helptags ~/.vim/doc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help g%
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help g%
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command to find help for "g%" in the help file you just added.  You can see an entry for the local help file when you do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>para buscar ayuda para «g%» en el archivo de ayuda que acaba de añadir.  Puede ver una entrada correspondiente al archivo local cuando escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help local-additions
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help local-additions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The title lines from the local help files are automagically added to this section.  There you can see which local help files have been added and jump to them through the tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas con los títulos de los archivos de ayuda locales son añadidos automágicamente a la sección. Allí puede ver que archivos locales se han añadido e ir a ellos a través del tag creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.6*	The option window
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.6*	La ventana de opciones
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for an option that does what you want, you can search in the help files here: |options|.  Another way is by using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si busca una opción que haga lo que quiere, puede buscarla en los archivos de ayuda aquí: |options|. Otra forma es usar la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:options
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:options
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the value of an option.  For example, move to the "displaying text" subject.  Then move the cursor down to this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cambiar el valor de una opción. Por ejemplo, vaya al tema «displaying text». Luego ponga el cursor abajo, en esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set wrap	nowrap ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set wrap	nowrap ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set nowrap	wrap ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set nowrap	wrap ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just above this line is a short description of the 'wrap' option.  Move the cursor one line up to place it in this line.  Now hit &lt;Enter&gt; and you jump to the full help on the 'wrap' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Justo sobre esta línea hay una descripción corta de la opción 'wrap'.  Ponga el cursor una línea arriba para colocarlos sobre esta línea. Ahora pulse &lt;Intro&gt; e irá hacia la descripción completa de la opción 'wrap'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For options that take a number or string argument you can edit the value.  Then press &lt;Enter&gt; to apply the new value.  For example, move the cursor a few lines up to this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para opciones que toman un número o una cadena de caracteres puede editar el valor. Pulse &lt;Intro&gt; para aplicar el nuevo valor. Por ejemplo, mueva el cursor unas cuantas líneas arriba hasta esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set so=0 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set so=0 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Position the cursor on the zero with "$".  Change it into a five with "r5".  Then press &lt;Enter&gt; to apply the new value.  When you now move the cursor around you will notice that the text starts scrolling before you reach the border.  This is what the 'scrolloff' option does, it specifies an offset from the window border where scrolling starts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posicione el cursor sobre el cero con «$». Modifiqueló a un cinco con «r5». Luego pulse &lt;Intro&gt; para aplicar el nuevo valor. Cuando mueva el cursor por un texto, notará que el texto se desplazará (scroll) antes de que llegue al borde. Esto es lo que la opción 'scrolloff' hace, especifica una compensación (offset) del punto donde comienza el desplazamiento (respecto al borde).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.7*	Often used options
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.7*	Opciones más comunes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are an awful lot of options.  Most of them you will hardly ever use.  Some of the more useful ones will be mentioned here.  Don't forget you can find more help on these options with the ":help" command, with single quotes before and after the option name.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una cantidad de opciones inmensa. Difícilmente llegará a usar gran parte de ellas. Algunas de las más comunes se citarán a continuación. No se olvide de que puede encontrar más ayuda con la orden «:help», con comillas simples alrededor del nombre de la opción. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:help 'wrap'
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:help 'wrap'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you have messed up an option value, you can set it back to the default by putting an ampersand (&amp;) after the option name.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de que haya descolocado el valor de una opción, puede devolverlo a la opción por defecto con un et (&amp;) tras el nombre de la opción.  Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword&amp;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword&amp;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim normally wraps long lines, so that you can see all of the text.  Sometimes it's better to let the text continue right of the window.  Then you need to scroll the text left-right to see all of a long line.  Switch wrapping off with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim normalmente dobla líneas largas, de forma que pueda ver todo el texto. A veces es mejor dejar que el texto continúe a la derecha de la ventana. De este modo tiene que desplazarse de izquierda a derecha para ver toda una línea larga. Puede intercambiar el valor con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set nowrap
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set nowrap
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will automatically scroll the text when you move to text that is not displayed.  To see a context of ten characters, do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim automáticamente desplazará el texto cuando se desplace hacia el texto que no se muestra en pantalla. Para ver un contexto de diez caracteres: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set sidescroll=10
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set sidescroll=10
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most commands for moving around will stop moving at the start and end of a line.  You can change that with the 'whichwrap' option.  This sets it to the default value: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría de las órdenes para desplazarse dejarán de funcionar al comienzo o al final de una línea. Puede cambiar esto con la opción 'whichwrap'. Esto la cambia al valor predeterminado: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set whichwrap=b,s
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set whichwrap=b,s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows the &lt;BS&gt; key, when used in the first position of a line, to move the cursor to the end of the previous line.  And the &lt;Space&gt; key moves from the end of a line to the start of the next one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite que la tecla &lt;Retroceso&gt;, cuando se emplea en la primera posición de una línea se mueva al final de la línea anterior. También la tecla &lt;Espacio&gt; le desplazará desde el final de una línea hasta el comienzo de la siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set whichwrap=b,s,&lt;,&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set whichwrap=b,s,&lt;,&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is still only for Normal mode.  To let &lt;Left&gt; and &lt;Right&gt; do this in Insert mode as well: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es exclusivamente en el modo Normal. Para permitir que &lt;Izq&gt; y &lt;Der&gt; haga esto en también modo Insertar, escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set whichwrap=b,s,&lt;,&gt;,[,]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set whichwrap=b,s,&lt;,&gt;,[,]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are tabs in a file, you cannot see where they are.  To make them visible: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hay pestañas en un archivo, no puede ver dónde están. Para hacerlas visibles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set list
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set list
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every tab is displayed as ^I.  And a $ is displayed at the end of each
line, so that you can spot trailing spaces that would otherwise go unnoticed.
   A disadvantage is that this looks ugly when there are many Tabs in a file.
If you have a color terminal, or are using the GUI, Vim can show the spaces
and tabs as highlighted characters.  Use the 'listchars' option: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora todas las pestañas se mostrarán como ^I. Un «$» se mostrará al final de
cada línea, permitiéndole ver espacios finales que de otra forma pasarían
desapercibidos.
   Una desventaja de esto es que tiene una apariencia desagradable cuando
hay muchas pestañas. Si tiene una terminal con colores o usa GVim, puede
ver los espacios y las pestañas como marcas de color. Use la opción
'listchars': &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set listchars=tab:&gt;-,trail:-
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set listchars=tab:&gt;-,trail:-
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every tab will be displayed as "&gt;---" (with more or less "-") and trailing white space as "-".  Looks a lot better, doesn't it?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cada pestaña se mostrará como «&gt;---» (con más o menos «-») y los espacios al final de la línea como «-».  Más agradable, o no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "@" stands for all alphabetic letters.  "48-57" stands for ASCII
characters 48 to 57, which are the numbers 0 to 9.  "192-255" are the
printable latin characters.
   Sometimes you will want to include a dash in keywords, so that commands
like "w" consider "upper-case" to be one word.  You can do it like this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «@» implica todas las letras del alfabeto. «48-57» significa los
caracteres ASCII 48 a 57, que son los números 0 a 9. «192-255» son los
caracteres latinos imprimibles.
   A veces querrá incluir un guión en las palabras clave, para que órdenes
como «w» consideren «upper-case» como una sola palabra.
Puede hacerlo así: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword+=-
	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255,- ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword+=-
	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255,- ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the new value, you will see that Vim has added a comma for you.
   To remove a character use "-=".  For example, to remove the underscore: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si miras el nuevo valor, comprobará que Vim ha añadido una coma por Ud.
   Para eliminar un carácter usa «-=». Por ejemplo, el guión bajo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set iskeyword-=_
	:set iskeyword
&lt;	  iskeyword=@,48-57,192-255,- ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set iskeyword-=_
	:set iskeyword
&lt;	  iskeyword=@,48-57,192-255,- ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Vim starts there is one line at the bottom that is used for messages.
When a message is long, it is either truncated, thus you can only see part of
it, or the text scrolls and you have to press &lt;Enter&gt; to continue.
   You can set the 'cmdheight' option to the number of lines used for
messages.  Example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando Vim arranca hay una línea en la parte de abajo que se usa para
mensajes. Cuando un mensaje es largo, o se trunca (con lo que sólo puede
ver una parte) o el texto se desplaza y tienes que pulsar &lt;Intro&gt; para
continuar.
   Puedes asignar a la opción 'cmdheight' el número de líneas usado para
mensajes. Por ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set cmdheight=3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set cmdheight=3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_32.txt*	For Vim version 7.3.  Last change: 2010 Jul 20
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_32.esx*	Para Vim versión 7.3.  Último cambio: 20/6/2010
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      The undo tree
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> 			  El árbol de deshacer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim provides multi-level undo.  If you undo a few changes and then make a new change you create a branch in the undo tree.  This text is about moving through the branches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece varios niveles de deshacer. Si deshace unos cuantos cambios y después realiza uno nuevo, creará una rama en el árbol de deshacer. El texto a continuación trata acerca de desplazarse por las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|32.1|	Undo up to a file write
|32.2|	Numbering changes
|32.3|	Jumping around the tree
|32.4|	Time travelling
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|32.1|	Volver a un punto de edición anterior
|32.2|	Numerar los cambios
|32.3|	Desplazarse en el árbol
|32.4|	Viajar en el tiempo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_40.txt|  Make new commands
 Previous chapter: |usr_31.txt|  Exploiting the GUI
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_40.esx|  Crear órdenes nuevas
  Capítulo anterior: |usr_31.esx|  Aprovechar la interfaz gráfica
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.1*	Undo up to a file write
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.1*	Volver a un punto de edición anterior
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you make several changes, and then discover you want to go back to when you have last written the file.  You can do that with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces realiza una serie de cambios, y se da cuenta que desea volver al punto en el que editó el archivo por última vez. Puede hacer esto con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:earlier 1f
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:earlier 1f
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat this command to go further back in the past.  Or use a count different from 1 to go back faster.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir esta orden para retroceder aun más. O usar un número diferente de 1 para retroceder más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:later 1f
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:later 1f
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that these commands really work in time sequence.  This matters if you made changes after undoing some changes.  It's explained in the next section.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que estas órdenes funcionan secuencialmente. Importa si realiza cambios después de deshacer otros. Se explica en la siguiente sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that we are talking about text writes here.  For writing the undo information in a file see |undo-persistence|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga también en cuenta que nos referimos a ediciones de texto. Para escribir la información de deshacer de en un archivo, consulte |undo-persistence|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.2*	Numbering changes
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.2*	Numerar los cambios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In section |02.5| we only discussed one line of undo/redo.  But it is also possible to branch off.  This happens when you undo a few changes and then make a new change.  The new changes become a branch in the undo tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |02.5| sólo tratamos una línea temporal de deshacer o rehacer. Pero también es posible crear una nueva «rama». Ocurre cuando deshace algunos cambios y después realiza un nuevo cambio. Los cambios nuevos se convierten en una rama del árbol de deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the text "one".  The first change to make is to append " too".  And then move to the first 'o' and change it into 'w'.  We then have two changes, numbered 1 and 2, and three states of the text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Empecemos con el texto «one». El primer cambio es añadir «too». Después, ir a la primera «o» y cambiarla a «w». Tenemos ahora dos cambios, 1 y 2, y tres estados del texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
		 |
	      change 2
		 |
	      one two ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
		 |
	      change 2
		 |
	      one two ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now use the |u| command to undo.  If you do this twice you get to "one".  Use |CTRL-R| to redo, and you will go to "one too".  One more |CTRL-R| takes you to "me too".  Thus undo and redo go up and down in the tree, using the branch that was last used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar la orden |u| para deshacer. Si lo hace dos veces, obtendrá «one». Use |CTRL-R| para rehacer, y obtendrá «one too».  Pulsar |CTRL-R| una vez más le lleva a  «me too». Esto es, deshacer y rehacer suben y bajan un árbol usando la rama usada por última vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What matters here is the order in which the changes are made.  Undo and redo are not considered changes in this context.  After each change you have a new state of the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que importa es el orden de las cambios. Deshacer y rehacer no se consideran cambios en este contexto. Tras cada cambio tiene un nuevo estado del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that only the changes are numbered, the text shown in the tree above has no identifier.  They are mostly referred to by the number of the change above it.  But sometimes by the number of one of the changes below it, especially when moving up in the tree, so that you know which change was just undone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que sólo se enumeran los cambios, y el texto que aparece en el árbol anterior no tiene identificador. Se hace referencia a ellos según el número del cambio por encima suyo. Pero, a veces, según el número por debajo de él, particularmente al subir el árbol, para así saber qué cambio se ha deshecho recientemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.3*	Jumping around the tree
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.3*	Desplazarse en el árbol
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So how do you get to "one two" now? You can use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Cómo podemos obtener «one two» ahora? Puede usar esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:undo 2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:undo 2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text is now "one two", you are below change 2.  You can use the |:undo| command to jump to below any change in the tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, el texto es «one two», y está bajo el cambio 2. Puede usar la orden |:undo| para saltar a cualquier cambio dentro del árbol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
	    |
	 change 4
	    |
	 not two ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
	    |
	 change 4
	    |
	 not two ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you change your mind and want to go back to "me too".  Use the |g-| command.  This moves back in time.  Thus it doesn't walk the tree upwards or downwards, but goes to the change made before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cambia de idea, y desea volver a «me too». Use la orden |g-|. Esto vuelve a un momento anterior. No se desplaza por el árbol en una dirección u otra, sino que vuelve al último cambio realizado. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat |g-| and you will see the text change:
	me too ~
	one two ~
	one too ~
	one ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir |g-| y ver como cambia el texto:
	me too ~
	one two ~
	one too ~
	one ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use |g+| to move forward in time:
	one ~
	one too ~
	one two ~
	me too ~
	not two ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |g+| para ir hacia delante en el tiempo:
	one ~
	one too ~
	one two ~
	me too ~
	not two ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using |:undo| is useful if you know what change you want to jump to.  |g-| and |g+| are useful if you don't know exactly what the change number is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar |:undo| es útil si sabe a qué cambio quiere pasar. |g-| y |g+| son útiles si no sabe exactamente el número del cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.4*	Time travelling
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.4*	Viajar en el tiempo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have been working on text for a while the tree grows to become big.  Then you may want to go to the text of some minutes ago.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando ha estado trabajando en el texto durante un rato el árbol crece hasta ser bastante grande. Así, puede que desee volver a como era el texto hace unos minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:undolist
&lt;	number changes  time ~
	     3       2  16 seconds ago
	     4       3  5 seconds ago
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:undolist
&lt;	número cambios  hora ~
	     3       2  hace 16 segundos
	     4       3  hace 5 segundos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can see the number of the leaves in each branch and when the change was made.  Assuming we are below change 4, at "not two", you can go back ten seconds with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver el número de hojas en cada rama el momento en que se realizó el cambio. Suponiendo que estamos bajo el nivel 4, en «not two», puede retroceder 10 segundos con la siguiente orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:earlier 10s
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:earlier 10s
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on how much time you took for the changes you end up at a certain position in the tree.  The |:earlier| command argument can be "m" for minutes, "h" for hours and "d" for days.  To go all the way back use a big number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dependiendo del tiempo que le tomó realizar los cambios, acabará en una posición determinada del árbol. El argumento de la orden |:earlier| puede ser «m», de minutos, «h» de horas y «d» de días. Para volver al principio use un número grande: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:earlier 100d
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:earlier 100d
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:later 1m
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:later 1m
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want even more details, or want to manipulate the information, you can use the |undotree()| function.  To see what it returns: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea más detalles, o manipular la información, puede usar la función |undotree()|. Para ver qué devuelve: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:echo undotree()
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:echo undotree()
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_25.txt*	For Vim version 7.3.  Last change: 2007 May 11
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_25.esx*	Para Vim versión 7.3.  Último cambio: 11/6/2007
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Editing formatted text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Editar texto con formato
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Text hardly ever comes in one sentence per line.  This chapter is about breaking sentences to make them fit on a page and other formatting.  Vim also has useful features for editing single-line paragraphs and tables.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto rara vez aparece como una oración por línea. Este capítulo trata acerca de formatear oraciones para su correcta apariencia en un papel, así como otros formatos. Vim también ofrece útiles características para editar párrafos de una sola línea y tablas-</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|25.1|	Breaking lines
|25.2|	Aligning text
|25.3|	Indents and tabs
|25.4|	Dealing with long lines
|25.5|	Editing tables
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|25.1|	Dividir líneas
|25.2|	Alinear texto
|25.3|	Sangrado y tabulación
|25.4|	Tratar líneas largas
|25.5|	Editar tablas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_26.txt|  Repeating
 Previous chapter: |usr_24.txt|  Inserting quickly
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Siguiente capítulo: |usr_26.txt|  Repetición
  Capítulo anterior: |usr_24.esx|  Insertar con rapidez
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.1*	Breaking lines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.1*	Dividir líneas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set textwidth=30
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set textwidth=30
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		 1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a whi ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		1	   2	     3
	12345678901234567890123456789012345
	Enseñé programación durante un ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type "l" next, this makes the line longer than the 30-character limit.  When Vim sees this, it inserts a line break and you get the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea ahora «os», la línea sobrepasaría el límite de 30 caracteres. En cuanto Vim detecta esto, inserta un salto línea, obteniendo lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		 1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a ~
	whil ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		1	   2	     3
	12345678901234567890123456789012345
	Enseñé programación durante ~
	unos ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	The 'wrap' option makes Vim display lines with a line break, but this
	doesn't insert a line break in the file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	La opción 'wrap' hace que Vim muestre las líneas con un salto de
	línea, pero no inserta realmente un salto de línea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor is not a word processor.  In a word processor, if you delete something at the beginning of the paragraph, the line breaks are reworked.  In Vim they are not; so if you delete the word "programming" from the first line, all you get is a short line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim no es un editor de documentos. En un editor de documentos, si elimina algo al inicio del párrafo, se reorganizan los saltos de línea. No es así en Vim; así que se borra la palabra «programación» en la primera línea, obtendría los siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does not look good.  To get the paragraph into shape you use the "gq"
operator.
   Let's first use this with a Visual selection.  Starting from the first
line, type: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no es elegante. Para dar formato a un párrafo puede usar el operador
«gq».
   Usemos esto primero con una selección en modo Visual. Empezando por la
primera línea, escriba: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	v4jgq
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	v4jgq
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v" to start Visual mode, "4j' to move to the end of the paragraph and then the "gq" operator.  The result is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«v» inicial el modo Visual, «4j» para desplazarse al final del párrafo, y después el operador «gq». El resultado es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"ap" stands for "a-paragraph".  This formats the text of one paragraph
(separated by empty lines).  Also the part before the cursor.
   If you have your paragraphs separated by empty lines, you can format the
whole file by typing this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«ap» significa un párrafo («a-paragraph»). Esto da formato al texto de un
párrafo (separado por líneas vacías). También el área anterior al cursor.
   Si los párrafos están separados por líneas vacías, puede dar formato a
todo el archivo con lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"gg" to move to the first line, "gqG" to format until the last line.
   Warning: If your paragraphs are not properly separated, they will be joined
together.  A common mistake is to have a line with a space or tab.  That's a
blank line, but not an empty line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«gg» para ir a la primera línea, «gqG» para dar formato hasta la última
línea.
   Aviso: si sus párrafos no están apropiadamente separados, no se unirán.
Un error común es tener una línea con un espacio o tabulación. Esa es una
línea en blanco, pero no una línea vacía.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim is able to format more than just plain text.  See |fo-table| for how to
change this.  See the 'joinspaces' option to change the number of spaces used
after a full stop.
   It is possible to use an external program for formatting.  This is useful
if your text can't be properly formatted with Vim's builtin command.  See the
'formatprg' option.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim es capaz de dar formato a más que texto. Consulte |fo-table| para ver
cómo cambiar esto. Consulte la opción 'joinspaces' para modificar el número
de espacios antes de un punto final.
   Es posible dar formato con un programa externo. Esto es útil si el texto
no puede recibir un formato adecuado con la orden integrada en Vim. Consulte
la opción 'formatprg'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.2*	Aligning text
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.2*	Alinear texto
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:{range}center [width]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:{range}center [width]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{range} is the usual command-line range.  [width] is an optional line width to
use for centering.  If [width] is not specified, it defaults to the value of
'textwidth'.  (If 'textwidth' is 0, the default is 80.)
   For example: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{range} (rango) is el valor de rango normal en la línea de órdenes. [width]
(ancho) es el valor opcional del ancho usado al centrar. De no especificar
[width], su valor por omisión será el de 'textwidth'. (Si 'textwith' es
cero, el valor será 80.)
   Por ejemplo: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:1,5center 40
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:1,5center 40
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:1,5right 37
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:1,5right 37
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:{range}left [margin]
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:{range}left [margin]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:1left 5
	:2,5left
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:1left 5
	:2,5left
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has no built-in way of justifying text.  However, there is a neat macro package that does the job.  To use this package, execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no posee una herramienta integrada para justificar texto. Por otro lado, ofrece un excelente macro que realiza esta labor. Ejecute la siguiente orden para usar este conjunto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:runtime macros/justify.vim
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:runtime macros/justify.vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This Vim script file defines a new visual command "_j".  To justify a block of
text, highlight the text in Visual mode and then execute "_j".
   Look in the file for more explanations.  To go there, do "gf" on this name:
$VIMRUNTIME/macros/justify.vim.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este archivo script de Vim define una nueva orden visual, «_j». Para
justificar un bloque de texto, resalte el texto en modo Visual y ejecute «_j».
   Consulte el archivo para una explicación más completa. Para ir a ese punto,
pulse «gf» en este nombre:
$VIMRUNTIME/macros/justify.vim.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to filter the text through an external program.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una alternativa es filtrar el texto a través de un programa externo. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%!fmt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%!fmt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.3*	Indents and tabs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.3*	Sangrado y tabulación
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indents can be used to make text stand out from the rest.  The example texts
in this manual, for example, are indented by eight spaces or a tab.  You would
normally enter this by typing a tab at the start of each line.  Take this
text:
	the first line ~
	the second line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el sangrado para destacar texto con respecto al resto. Los textos
de ejemplo en este manual, por ejemplo, están sangrados con ocho espacios, o
una tabulación. Generalmente, introduce el sangrado con una tabulación al
inicio de cada línea. Suponga este texto:
	la primera línea ~
	la segunda línea ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is entered by typing a tab, some text, &lt;Enter&gt;, tab and more text.
   The 'autoindent' option inserts indents automatically: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede introducir esto pulsando el botón de tabulado, algo de texto, &lt;Intro&gt;,
tabulado, y más texto.
   La opción 'autoindent' inserta sangrado automáticamente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set autoindent
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set autoindent
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a new line is started it gets the same indent as the previous line.  In the above example, the tab after the &lt;Enter&gt; is not needed anymore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al iniciar una nueva línea, este recibirá el mismo sangrado que la línea anterior. En el ejemplo anterior, el tabulado tras &lt;Intro&gt; ya no es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increase the amount of indent in a line, use the "&gt;" operator.  Often this
is used as "&gt;&gt;", which adds indent to the current line.
   The amount of indent added is specified with the 'shiftwidth' option.  The
default value is 8.  To make "&gt;&gt;" insert four spaces worth of indent, for
example, type this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para aumentar la cantidad de sangrado en una línea, use el operador «&gt;». A
menudo usará esto como «&gt;&gt;», que añade sangrado a la línea actual.
   La cantidad de sangrado añadida se especifica con la opción 'shiftwidth'.
El valor por omisión es 8. Para lograr que «&gt;&gt;» inserte cuatro espacios de
sangrado, por ejemplo, use lo siguiente: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	the first line ~
	    the second line ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	la primera línea ~
	    la segunda línea ~
	
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to make indents a multiple of 4, you set 'shiftwidth' to 4.  But when pressing a &lt;Tab&gt; you still get 8 spaces worth of indent.  To change this, set the 'softtabstop' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que el sangrado sea un múltiplo de 4, defina 'shiftwidth' a 4. Aún obtendría ocho espacios de sangrado al pulsar &lt;Tab&gt;. Defina la opción 'softtabstop' para modificar esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make the &lt;Tab&gt; key insert 4 spaces worth of indent.  If there are already four spaces, a &lt;Tab&gt; character is used (saving seven characters in the file).  (If you always want spaces and no tab characters, set the 'expandtab' option.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que la tecla &lt;Tab&gt; inserte 4 espacios de sangrado. EL carácter &lt;Tab&gt; se usará en caso ya existir cuatro espacios (ahorrando 7 espacios en el archivo). (Si desea siempre espacios y no caracteres de tabulado, defina la opción 'expandtab').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	You could set the 'tabstop' option to 4.  However, if you edit the
	file another time, with 'tabstop' set to the default value of 8, it
	will look wrong.  In other programs and when printing the indent will
	also be wrong.  Therefore it is recommended to keep 'tabstop' at eight
	all the time.  That's the standard value everywhere.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Puede definir la opción 'tabstop' con valor de 4. De todas formas, si
	edita el archivo en otro momento teniendo 'tabstop' su valor
	predeterminado de 8, el aspecto no será el deseado. Otros programas,
	así como imprimir el sangrado presentarán un aspecto equivocado. Por
	ello, recomendamos mantener 'tabstop' con valor de 8 en todo momento.
	Este es el valor estándar en otras aplicaciones.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set tabstop=3
	:retab 8
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set tabstop=3
	:retab 8
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":retab" command will change 'tabstop' to 8, while changing the text such
that it looks the same.  It changes spans of white space into tabs and spaces
for this.  You can now write the file.  Next time you edit it the indents will
be right without setting an option.
   Warning: When using ":retab" on a program, it may change white space inside
a string constant.  Therefore it's a good habit to use "\t" instead of a
real tab.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:retab» cambia 'tabstop' a 8, a la vez que modifica el texto para
que encaje. Para ello, modifica los tramos de espacio blanco a tabulados y
espacios. Ahora puede escribir en el archivo. La siguiente vez que lo edite,
la tabulación será la correcta sin necesidad de definir la opción.
   Aviso: Si usa «:retab» sobre un programa, cabe que modifique el espacio
en blanco dentro de una cadena entrecomillas. Por ello, es una buena
costumbre usar «\t» en lugar de un tabulado real.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.4*	Dealing with long lines
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.4*	Tratar líneas largas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set guioptions+=b
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set guioptions+=b
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a scrollbar or don't want to use it, use these commands to scroll the text.  The cursor will stay in the same place, but it's moved back into the visible text if necessary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no tiene una barra de desplazamiento o no quiere usarla, puede usar estas  órdenes para desplazar el texto. El cursor permanecerá en el mismo lugar, pero permitiendo también desplazarlo al texto visible, de ser necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's attempt to show this with one line of text.  The cursor is on the "w" of "which".  The "current window" above the line indicates the text that is currently visible.  The "window"s below the text indicate the text that is visible after the command left of it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a intentar mostrar esto con una línea de texto. El cursor está sobre la «w» de «which». La «ventana actual» sobre la línea indica el texto actualmente visible. Las «ventana» bajo el texto indican el texto visible después de ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      |&lt;-- current window --&gt;|
		some long text, part of which is visible in the window ~
	ze	  |&lt;--	   window     --&gt;|
	zH	   |&lt;--     window     --&gt;|
	4zh		  |&lt;--	   window     --&gt;|
	zh		     |&lt;--     window	 --&gt;|
	zl		       |&lt;--	window	   --&gt;|
	4zl			  |&lt;--	   window     --&gt;|
	zL				|&lt;--	 window     --&gt;|
	zs			       |&lt;--	window	   --&gt;|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			      |&lt;-- ventana actual --&gt;|
		some long text, part of which is visible in the window ~
	ze	  |&lt;--	   ventana    --&gt;|
	zH	   |&lt;--     ventana    --&gt;|
	4zh		  |&lt;--	   ventana    --&gt;|
	zh		     |&lt;--     ventana	 --&gt;|
	zl		       |&lt;--	ventana	   --&gt;|
	4zl			  |&lt;--	   ventana    --&gt;|
	zL				|&lt;--	 ventana    --&gt;|
	zs			       |&lt;--	ventana	   --&gt;|

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When 'wrap' is off and the text has scrolled horizontally, you can use the following commands to move the cursor to a character you can see.  Thus text left and right of the window is ignored.  These never cause the text to scroll:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando ha desplazado el texto horizontalmente y 'wrap' está desactivado, puede usar las siguientes órdenes para mover el cursor a un carácter que puede ver. Por ello, se ignorará el texto a la izquierda y derecha de la ventana. Esto nunca causa un desplazamiento del texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	g0		to first visible character in this line
	g^		to first non-blank visible character in this line
	gm		to middle of this line
	g$		to last visible character in this line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	g0		Desplazarse al primer carácter en esta línea
	g^		Al primer carácter que no está en blanco de la línea
	gm		Al centro de esta línea
	g$		Al ultimo carácter visible en esta línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		|&lt;--	 window    --&gt;|
	some long    text, part of which is visible ~
		 g0  g^    gm	     g$
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		  |&lt;--	 ventan    --&gt;|
	algún texto    largo, parte del cual visible ~
		   g0  g^     gm     g$
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BREAKING AT WORDS				*edit-no-break*
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DIVIDIR LÍNEAS EN PALABRAS		*edición-sin-partir* *edit-no-break*
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When preparing text for use by another program, you might have to make
paragraphs without a line break.  A disadvantage of using 'nowrap' is that you
can't see the whole sentence you are working on.  When 'wrap' is on, words are
broken halfway, which makes them hard to read.
   A good solution for editing this kind of paragraph is setting the
'linebreak' option.  Vim then breaks lines at an appropriate place when
displaying the line.  The text in the file remains unchanged.
   Without 'linebreak' text might look like this:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando prepara el texto para su uso con otro programa, puede que tenga que
crear los párrafos sin salto de línea. Una desventaja de usar 'nowrap' es
que no puede ver la oración completa sobre la que trabaja. Si 'wrap' está,
activada, las palabras se dividen por la mitad, dificultando la lectura.
   Una buena solución para editar este tipo de párrafos es definir la opción
'linebreak'. Vim dividirá las líneas en los puntos apropiados al mostrar
la línea. El texto en el archivo no se modifica.
   Sin 'linebreak', el texto presentará este aspecto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------+
	|letter generation program for a b|
	|ank.  They wanted to send out a s|
	|pecial, personalized letter to th|
	|eir richest 1000 customers.  Unfo|
	|rtunately for the programmer, he |
	+---------------------------------+
After: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------+
	|letter generation program for a b|
	|ank.  They wanted to send out a s|
	|pecial, personalized letter to th|
	|eir richest 1000 customers.  Unfo|
	|rtunately for the programmer, he |
	+---------------------------------+
Después: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set linebreak
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set linebreak
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+---------------------------------+
	|letter generation program for a  |
	|bank.  They wanted to send out a |
	|special, personalized letter to  |
	|their richest 1000 customers.    |
	|Unfortunately for the programmer,|
	+---------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+---------------------------------+
	|letter generation program for a  |
	|bank.  They wanted to send out a |
	|special, personalized letter to  |
	|their richest 1000 customers.    |
	|Unfortunately for the programmer,|
	+---------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Related options: 'breakat' specifies the characters where a break can be inserted.  'showbreak' specifies a string to show at the start of broken line.  Set 'textwidth' to zero to avoid a paragraph to be split.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Opciones relacionadas: 'breakat' especifica los caracteres donde insertar el salto de línea. 'showbreak' especifica una cadena a mostrar al principio de una línea dividida. Defina 'textwitdh' como cero para evitar dividir un párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "j" and "k" commands move to the next and previous lines.  When used on
a long line, this means moving a lot of screen lines at once.
   To move only one screen line, use the "gj" and "gk" commands.  When a line
doesn't wrap they do the same as "j" and "k".  When the line does wrap, they
move to a character displayed one line below or above.
   You might like to use these mappings, which bind these movement commands to
the cursor keys: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes «j» y «k» desplazan el cursor. Esto desplaza varias líneas en la
pantalla en caso de usarlo sobre una larga línea.
   Para desplazarse sólo una línea en la pantalla, use las órdenes «gj» y «gk».
Estas órdenes hacen lo mismo que «j» y «k» si la línea no está justificada.
De activar 'wrap', se desplazan a un carácter visible en una línea inferior
o superior.
   Puede que desee usar estas macros, que relacionan estas órdenes de
desplazamiento a las teclas de cursor: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:map &lt;Up&gt; gk
	:map &lt;Down&gt; gj
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:map &lt;Up&gt; gk
	:map &lt;Down&gt; gj
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to import text into a program like MS-Word, each paragraph should be a single line.  If your paragraphs are currently separated with empty lines, this is how you turn each paragraph into a single line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea importar texto desde un programa como MS-Word, cada párrafo debería ser una sola línea. De existir una separación entre los párrafos en forma de de líneas vacías, debe realizar lo siguiente para convertir cada párrafo en una sola línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:g/./,/^$/join
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:g/./,/^$/join
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That looks complicated.  Let's break it up in pieces:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Parece complicado. Vamos a dividirlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:g/./		A ":global" command that finds all lines that contain
			at least one character.
	     ,/^$/	A range, starting from the current line (the non-empty
			line) until an empty line.
		  join	The ":join" command joins the range of lines together
			into one line.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:g/./		Una orden «:global» que encuentra todas las cadenas
			que contienen al menos un carácter.
	    ,/^$/	Un rango, que empieza en la línea actual (no vacía),
			y acaba en una línea vacía.
		 join	La orden «:join» (unir) une el rango de líneas en una
			sola línea.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	|A letter generation program	   |
	|for a bank.  They wanted to	   |
	|send out a special,		   |
	|personalized letter.		   |
	|				   |
	|To their richest 1000		   |
	|customers.  Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	|A letter generation program	   |
	|for a bank.  They wanted to	   |
	|send out a special,		   |
	|personalized letter.		   |
	|				   |
	|To their richest 1000		   |
	|customers.  Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	+----------------------------------+
	|A letter generation program for a |
	|bank.	They wanted to send out a s|
	|pecial, personalized letter.	   |
	|To their richest 1000 customers.  |
	|Unfortunately for the programmer, |
	+----------------------------------+
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	+----------------------------------+
	|A letter generation program for a |
	|bank.	They wanted to send out a s|
	|pecial, personalized letter.	   |
	|To their richest 1000 customers.  |
	|Unfortunately for the programmer, |
	+----------------------------------+
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this doesn't work when the separating line is blank but not empty;
when it contains spaces and/or tabs.  This command does work with blank lines:
&gt;
	:g/\S/,/^\s*$/join
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que esto no funciona si la línea de separación está en blanco,
pero no vacía; cuando contiene espacios y/o tabulados. Esta orden funciona
con líneas en blanco:
&gt;
	:g/\S/,/^\s*$/join
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.5*	Editing tables
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.5*	Editar tablas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	nice table	  test 1	test 2	    test 3 ~
	input A		  0.534 ~
	input B		  0.913 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Tabla ordenada	  test 1	test 2	    test 3 ~
	entrada A	  0.534 ~
	entrada B	  0.913 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to enter numbers in the third column.  You could move to the second
line, use "A", enter a lot of spaces and type the text.
   For this kind of editing there is a special option: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita introducir números en la tercera columna. Podría desplazarse a la
segunda línea, usar «A», introducir espacios y escribir el texto.
   Existe una orden especial para este tipo de edición: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	set virtualedit=all
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	set virtualedit=all
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	/test 3
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	/test 3
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press "j" and you are right where you can enter the value for "input A".  Typing "0.693" results in:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse ahora «j» y estará dónde puede introducir el valor para «input A». Teclear «0.693» da como resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	nice table	  test 1     test 2	 test 3 ~
	input A		  0.534			 0.693 ~
	input B		  0.913 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Tabla ordenada	  test 1     test 2	 test 3 ~
	entrada A	  0.534			 0.693 ~
	entrada B	  0.913 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has automatically filled the gap in front of the new text for you.  Now, to enter the next field in this column use "Bj".  "B" moves back to the start of a white space separated word.  Then "j" moves to the place where the next field can be entered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim a rellenado automáticamente el espacio en frente del texto. Ahora, para introducir el siguiente campo de esta columna use «Bj». «B» le devuelve al inicio de una palabra separada por un espacio en blanco. «j» le desplaza al lugar dónde puede introducir el siguiente campo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	You can move the cursor anywhere in the display, also beyond the end
	of a line.  But Vim will not insert spaces there, until you insert a
	character in that position.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Puede mover el cursor a cualquier lugar de la pantalla, también más
	allá del final de línea. Pero Vim no insertará aquí espacios hasta
	que inserte un carácter en esa posición.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to add a column, which should be a copy of the third column and
placed before the "test 1" column.  Do this in seven steps:
1.  Move the cursor to the left upper corner of this column, e.g., with
    "/test 3".
2.  Press CTRL-V to start blockwise Visual mode.
3.  Move the cursor down two lines with "2j".  You are now in "virtual space":
    the "input B" line of the "test 3" column.
4.  Move the cursor right, to include the whole column in the selection, plus
    the space that you want between the columns.  "9l" should do it.
5.  Yank the selected rectangle with "y".
6.  Move the cursor to "test 1", where the new column must be placed.
7.  Press "P".
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea añadir una columna, que debe ser la copia de la tercera columna
y deberá situarse antes de la columna «test 1». Haga estos 7 pasos:
1.  Mueva el cursor a la esquina superior izquierda de esta columna, p. ej.,
    con «/test 3».
2.  Pulse CTRL-V para empezar el modo de bloque visual.
3.  Mueva el cursor dos líneas hacia abajo con «2j». Ahora se encuentra en
    espacio virtual («virtual space»): la línea «entrada B» de la columna
    «test 3».
4.  Mueva el cursor a la derecha para incluir toda la columna en la selección
    además del espacio que desea entre las columnas. «9l» hará esto.
5.  Copie el rectángulo seleccionado con «y» (yank).
6.  Mueva el cursor a «test 1», donde se debería situar la nueva columna.
7.  Pulse «P».
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	nice table	  test 3    test 1     test 2	   test 3 ~
	input A		  0.693     0.534		   0.693 ~
	input B			    0.913 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Tabla ordenada	  test 3    test 1     test 2	   test 3 ~
	entrada A	  0.693     0.534		   0.693 ~
	entrada B		    0.913 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set virtualedit=
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set virtualedit=
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The disadvantage of using 'virtualedit' is that it "feels" different.  You
can't recognize tabs or spaces beyond the end of line when moving the cursor
around.  Another method can be used: Virtual Replace mode.
   Suppose you have a line in a table that contains both tabs and other
characters.  Use "rx" on the first tab:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La desventaja de usar 'virtualedit' es que parece distinto. No puede
reconocer tabulados o espacios más allá del final de línea si desplaza el
cursor. Puede usar otro método: Modo Virtual de Reemplazar.
   Suponga que tiene una línea en una tabla que contienen tabulados y otros
caracteres. Use «rx» en el primer tabulado:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inp	0.693   0.534	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inp	0.693   0.534	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	       |
	   rx  |
	       V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	       |
	   rx  |
	       V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inpx0.693   0.534	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inpx0.693   0.534	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The layout is messed up.  To avoid that, use the "gr" command:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EL diseño está desordenado. Use la orden «gr» para evitarlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	       |
	  grx  |
	       V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	       |
	  grx  |
	       V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inpx	0.693   0.534	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inpx	0.693   0.534	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens is that the "gr" command makes sure the new character takes the
right amount of screen space.  Extra spaces or tabs are inserted to fill the
gap.  Thus what actually happens is that a tab is replaced by "x" and then
blanks added to make the text after it keep its place.  In this case a
tab is inserted.
   When you need to replace more than one character, you use the "R" command
to go to Replace mode (see |04.9|).  This messes up the layout and replaces
the wrong characters:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que ocurre es que la orden «gr» se asegura que el nuevo carácter tomará
la cantidad de espacio de pantalla correcta. Los espacios y tabulados
adicionales se insertarán en el hueco. Por ello, lo que realmente ocurre es
que el tabulado se reemplaza por «x», y después se añaden espacios en blanco
para que el texto a continuación siga en el mismo sitio. En este caso se
inserta un tabulado.
   Cuando necesita reemplazar más de un carácter, use la orden «R» para pasar
al modo Reemplazar (consulte |04.9|). Esto desordena la presentación y
reemplaza los caracteres erróneos:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inp	0	0.534	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inp	0	0.534	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		|
	 R0.786 |
		V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		|
	 R0.786 |
		V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inp	0.78634	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inp	0.78634	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "gR" command uses Virtual Replace mode.  This preserves the layout:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «gR» usa el modo Virtual Reemplazar. Esto respeta el diseño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		|
	gR0.786 |
		V
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		|
	gR0.786 |
		V
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	inp	0.786	0.534	0.693 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	inp	0.786	0.534	0.693 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_09.txt*	For Vim version 7.3.  Last change: 2006 Apr 24
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_09.esx*	Para Vim versión 7.3. Último cambio: 24/5/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>				Using the GUI
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		Uso de la interfaz gráfica (GUI)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim works in an ordinary terminal.  GVim can do the same things and a few more.  The GUI offers menus, a toolbar, scrollbars and other items.  This chapter is about these extra things that the GUI offers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim funciona en una terminal normal. GVim puede hacer las mismas cosas y algunas más. La interfaz gráfica ofrece menús, una barra de menú, barras de desplazamiento y otros. Este capítulo trata de las funcionalidades adicionales que la interfaz gráfica ofrece.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|09.1|	Parts of the GUI
|09.2|	Using the mouse
|09.3|	The clipboard
|09.4|	Select mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|09.1|	Partes de la interfaz gráfica
|09.2|	Uso del ratón
|09.3|	El portapapeles
|09.4|	Modo Seleccionar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_10.txt|  Making big changes
 Previous chapter: |usr_08.txt|  Splitting windows
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_10.esx|  Realizar grandes cambios
  Capítulo anterior: |usr_08.esx|  Dividir en ventanas
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.1*	Parts of the GUI
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.1*	Partes de la interfaz gráfica (GUI)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have an icon on your desktop that starts gVim.  Otherwise, one of these commands should do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que tenga un icono en su escritorio que arranca gVim. En caso contrario, una de estas órdenes lo hará: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim file.txt
	vim -g file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim archivo.txt
	vim -g archivo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this doesn't work you don't have a version of Vim with GUI support.  You
will have to install one first.
   Vim will open a window and display "file.txt" in it.  What the window looks
like depends on the version of Vim.  It should resemble the following picture
(for as far as this can be shown in ASCII!).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto no funciona es que no tiene la versión de Vim con soporte para GUI.
Tendrá que instalar una primero.
   Vim abrirá una ventana y mostrará «archivo.txt». El aspecto de la
ventana dependerá de la versión de Vim. Se debería parecer a la siguiente
figura (¡tanto como se pueda parecer con texto ASCII!).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The largest space is occupied by the file text.  This shows the file in the same way as in a terminal.  With some different colors and another font perhaps.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio más grande está ocupado por el archivo de texto. Esto muestra el archivo de una manera similar a una terminal. Con algunas diferencias de tipo de letra y color, quizá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	-	The file cannot be modified (e.g., a help file)
	+	The file contains changes
	=	The file is read-only
	=+	The file is read-only, contains changes anyway
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	-	El archivo no se puede modificar (por ej. la ayuda)
	+	El archivo contiene cambios
	=	El archivo es de sólo lectura
	=+	El archivo es de sólo lectura pero contiene cambios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You know how menus work, right? Vim has the usual items, plus a few more.  Browse them to get an idea of what you can use them for.  A relevant submenu is Edit/Global Settings.  You will find these entries:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya sabe como funcionan los menús, ¿no? Vim tiene los elementos habituales, además de otros. Explórelos para tener una idea de cómo podría usarlos. Un submenú relevante es «Editar/Opciones globlales». Encontrará los siguientes elementos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This contains icons for the most often used actions.  Hopefully the icons are self-explanatory.  There are tooltips to get an extra hint (move the mouse pointer to the icon without clicking and don't move it for a second).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este contiene los iconos para las acciones más empleadas. La intención es que los iconos se expliquen a sí mismos. Hay globos de ayuda que le aconsejan (pon el puntero sobre un botón y no lo muevas durante un segundo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Edit/Global Settings/Toggle Toolbar" menu item can be used to make the toolbar disappear.  If you never want a toolbar, use this command in your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «Editar/Opciones globales/Ocultar/Mostrar barra de herramientas» se puede emplear para hacer que la barra de herramientas desaparezca.  Si no desea tener una barra de herramientas en ningún momento, escriba esto en su «vimrc»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set guioptions-=T
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set guioptions-=T
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This removes the 'T' flag from the 'guioptions' option.  Other parts of the GUI can also be enabled or disabled with this option.  See the help for it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina la opción 'T' de la opción 'guioptions'. Otras partes de la interfaz gráfica se pueden también activar o desactivar del mismo modo.  Consulte la ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default there is one scrollbar on the right.  It does the obvious thing.
When you split the window, each window will get its own scrollbar.
   You can make a horizontal scrollbar appear with the menu item
Edit/Global Settings/Toggle Bottom Scrollbar.  This is useful in diff mode, or
when the 'wrap' option has been reset (more about that later).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión sólo hay una barra de desplazamiento en la derecha. Hace lo que
se espera de ella. Cada ventana tendrá su barra de desplazamiento.
   Puede hacer que una barra horizontal aparezca con la opción «Editar/
Opciones globales/Ocultar/Mostrar barra de desplazamiento inferior».
Esto es útil en el modo diff, o cuando la opción 'wrap' está desactivada
(eso lo veremos más adelante).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are vertically split windows, only the windows on the right side
will have a scrollbar.  However, when you move the cursor to a window on the
left, it will be this one the that scrollbar controls.  This takes a bit of
time to get used to.
   When you work with vertically split windows, consider adding a scrollbar on
the left.  This can be done with a menu item, or with the 'guioptions' option:
&gt;
	:set guioptions+=l
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hay ventanas divididas verticalmente, sólo las de la derecha tendrán
barra de desplazamiento. Sin embargo, si mueve el cursor a una ventana en la
izquierda, será esta la que la barra controle. Lleva cierto tiempo
acostumbrarse a esto.
   Cuando trabaje con ventanas divididas verticalmente, considere la
posibilidad de añadir barras en la izquierda. Pruebe con esta opción: 
&gt;
		:set guioptions+=1
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.2*	Using the mouse
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.2*	Uso del ratón
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards are wonderful.  In Microsoft Windows, you can use the mouse to
select text in a standard manner.  The X Window system also has a standard
system for using the mouse.  Unfortunately, these two standards are not the
same.
   Fortunately, you can customize Vim.  You can make the behavior of the mouse
work like an X Window system mouse or a Microsoft Windows mouse.  The following
command makes the mouse behave like an X Window mouse: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los estándares son maravillosos. En Microsoft Windows, puede usar el ratón
para seleccionar texto de una forma estándar. El sistema de ventanas X
Window System también tiene un estándar para el uso del ratón. Por
desgracia, estos dos estándares no son compatibles.
   Afortunadamente, puede personalizarlo en Vim. Puede hacer que el
comportamiento del ratón sea el mismo que bajo X o el de Windows. La
siguiente orden hace que el ratón se comporte como bajo X: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:behave xterm
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:behave xterm
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:behave mswin
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:behave mswin
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behavior of the mouse on UNIX systems is xterm.  The default behavior on a Microsoft Windows system is selected during the installation process.  For details about what the two behaviors are, see |:behave|.  Here follows a summary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El comportamiento predeterminado de un ratón en los sistemas UNIX es xterm. El comportamiento predeterminado en un sistema Windows se selecciona durante la instalación. Para más detalles sobre estos comportamientos, consulte |:behave|. Aquí tiene un pequeño resumen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Left mouse click		position the cursor
Left mouse drag			select text in Visual mode
Middle mouse click		paste text from the clipboard
Right mouse click		extend the selected text until the mouse
				pointer
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Click botón izquierdo		posicionar el cursor
Arrastrar botón izquierdo	seleccionar texto en modo Visual
Click botón central		pegar texto desde el portapapeles
Click botón derecho		extender el texto seleccionado hasta el
				puntero del ratón
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Left mouse click		position the cursor
Left mouse drag			select text in Select mode (see |09.4|)
Left mouse click, with Shift	extend the selected text until the mouse
				pointer
Middle mouse click		paste text from the clipboard
Right mouse click		display a pop-up menu
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Click botón izquierdo		posicionar el cursor
Arrastrar botón izquierdo	seleccionar texto en modo Seleccionar (|09.4|)
Click botón izquierdo, con May. extender el texto seleccionado hasta el
				puntero del ratón
Click botón central		pegar texto desde el portapapeles
Click botón derecho		mostrar un menú pop-up
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mouse can be further tuned.  Check out these options if you want to change the way how the mouse works:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede configurar el ratón con más detalle. Consulte estas opciones si desea cambiar el funcionamiento del ratón:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	'mouse'			in which mode the mouse is used by Vim
	'mousemodel'		what effect a mouse click has
	'mousetime'		time between clicks for a double-click
	'mousehide'		hide the mouse while typing
	'selectmode'		whether the mouse starts Visual or Select mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	'mouse'			en qué modo Vim usa el ratón
	'mousemodel'		qué efectos tiene pulsar con el ratón
	'mousetime'		tiempo entre dos pulsacionespara un doble
				click
	'mousehide'		esconde el ratón mientras teclea
	'selectmode'		si el ratón comienza el modo Visual o
				Seleccionar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.3*	The clipboard
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.3*	El portapapeles
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In section |04.7| the basic use of the clipboard was explained.  There is one essential thing to explain about X-windows: There are actually two places to exchange text between programs.  MS-Windows doesn't have this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |04.7| se explica el uso básico del portapapeles. Hay algo esencial que debe ser explicado sobre las X-windows: Hay dos lugares para intercambiar texto entre programas. MS-Windows sólo tiene uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In X-Windows there is the "current selection".  This is the text that is
currently highlighted.  In Vim this is the Visual area (this assumes you are
using the default option settings).  You can paste this selection in another
application without any further action.
   For example, in this text select a few words with the mouse.  Vim will
switch to Visual mode and highlight the text.  Now start another gVim, without
a file name argument, so that it displays an empty window.  Click the middle
mouse button.  The selected text will be inserted.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En X-Windows hay una «selección actual». Esto es el texto que está
actualmente marcado. En Vim esto es el área Visual (suponiendo que usa las
opciones predeterminadas). Puede pegar esta selección en otra aplicación sin
ninguna acción posterior.
   Por ejemplo, en este texto seleccione unas cuantas palabras con el
ratón. Vim pasará al modo Visual y resaltará el texto. Ahora inicie otro
gVim, sin un nombre de archivo, de forma que muestre una ventana vacía.
Pulse el botón central del ratón. El texto seleccionado se insertará.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "current selection" will only remain valid until some other text is selected.  After doing the paste in the other gVim, now select some characters in that window.  You will notice that the words that were previously selected in the other gVim window are displayed differently.  This means that it no longer is the current selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «selección actual» sólo será válida hasta que seleccione otro texto.  Tras pegar el texto en otro gVim, seleccione ahora algunos caracteres en esa ventana. Se dará cuenta de que las palabras que estaban previamente seleccionadas en otra ventana gVim se muestran de otro modo. Esto significa que ya no están en la «selección actual».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This use of both the "current selection" and the "real clipboard" might sound a bit confusing.  But it is very useful.  Let's show this with an example.  Use one gVim with a text file and perform these actions:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto de usar simultáneamente la «selección actual» y el «verdadero portapapeles» puede sonar un poco confuso. Pero es muy útil. Veámoslo con un ejemplo. Abra un gVim con un archivo de texto y haga lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like using the mouse, you can access the current selection and
the real clipboard with two registers.  The "* register is for the current
selection.
   To make text become the current selection, use Visual mode.  For example,
to select a whole line just press "V".
   To insert the current selection before the cursor: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gusta usar el ratón, puede acceder a la selección actual y al
verdadero portapapeles con dos registros. El registro "* es para la
selección actual.
   Para hacer que el texto se convierta en selección actual, use el modo
Visual. Por ejemplo, para seleccionar una línea completa use «V».
   Para insertar la selección actual antes del cursor: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"*P
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"*P
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the uppercase "P".  The lowercase "p" puts the text after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que es una «P» mayúscula. La «p» minúscula la pone tras el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "+ register is used for the real clipboard.  For example, to copy the text from the cursor position until the end of the line to the clipboard: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El registro "+ se usa para el verdadero portapapeles. Por ejemplo, para copiar el texto desde la posición del cursor hasta el final de línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"+y$
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"+y$
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, "y" is yank, which is Vim's copy command.
   To insert the contents of the real clipboard before the cursor: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuerde, «y» es copiar («yank»).
   Para insertar los contenidos del verdadero portapapeles antes del cursor: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"+P
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"+P
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.4*	Select mode
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.4*	Modo Seleccionar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And now something that is used more often on MS-Windows than on X-Windows.  But both can do it.  You already know about Visual mode.  Select mode is like Visual mode, because it is also used to select text.  But there is an obvious difference: When typing text, the selected text is deleted and the typed text replaces it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora algo que se emplea más habitualmente en MS-Windows que en X-Windows.  Aún así, ambos pueden hacerlo. Ya conoce el modo Visual. El modo Seleccionar es como el modo Visual, también empleado para la selección.  Pero hay una diferencia básica: Cuando escriba texto, el texto seleccionado se elimina y el texto introducido lo sustituye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set selectmode+=mouse
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set selectmode+=mouse
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the mouse to select some text.  It is highlighted like in Visual mode.  Now press a letter.  The selected text is deleted, and the single letter replaces it.  You are in Insert mode now, thus you can continue typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación, use el ratón para seleccionar algún texto. Se resaltará como con el modo Visual. Pulse ahora un carácter. El texto seleccionado se eliminará, y ese carácter lo reemplazará. Entrará en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_31.txt*	For Vim version 7.3.  Last change: 2007 May 08
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_31.esx*	Para Vim versión 7.3.  Último cambio: 8/6/2007
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			      Exploiting the GUI
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		     Sacar partido a la interfaz gráfica
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim works well in a terminal, but the GUI has a few extra items.  A file browser can be used for commands that use a file.  A dialog to make a choice between alternatives.  Use keyboard shortcuts to access menu items quickly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim funciona bien en una terminal, pero la interfaz gráfica de usuario tiene algunos elementos adicionales. Un explorador de archivos para las órdenes que usan un archivo. Una ventana de diálogo para hacer una elección entre alternativas. Usar accesos directos de teclado para acceder rápidamente a los elementos en los menús.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|31.1|	The file browser
|31.2|	Confirmation
|31.3|	Menu shortcuts
|31.4|	Vim window position and size
|31.5|	Various
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|31.1|	El explorador de archivos
|31.2|	Confirmación
|31.3|	Atajos de teclado para menús
|31.4|	Posición y tamaño de la ventana de Vim
|31.5|	Varios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_32.txt|  The undo tree
 Previous chapter: |usr_30.txt|  Editing programs
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>   Capítulo siguiente: |usr_32.esx|  El árbol de deshacer
     Capítulo anterior: |usr_30.esx|  Editar programas
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.1*	The file browser
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.1*	El explorador de archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the File/Open... menu you get a file browser.  This makes it easier
to find the file you want to edit.  But what if you want to split a window to
edit another file?  There is no menu entry for this.  You could first use
Window/Split and then File/Open..., but that's more work.
   Since you are typing most commands in Vim, opening the file browser with a
typed command is possible as well.  To make the split command use the file
browser, prepend "browse": &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar el menú «Archivo/Abrir»... obtiene un explorador de archivos. 
Esto facilita ubicar el archivo que desea editar. ¿Pero y si desea
dividir una ventana para editar otro archivo? No hay una entrada en el menú
para esto. Puede usar primero «Ventana/Dividir» y luego «Archivo/Abrir»...,
pero eso es más trabajo.
  Ya que está escribiendo la mayoría de las órdenes en Vim, abrir el
explorador de archivos con una orden escrita también es posible. Para hacer
que la orden de división use el explorador de archivos, anteponga «browse»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:browse split
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:browse split
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:browse split /etc
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:browse split /etc
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":browse" command can be prepended to just about any command that opens a
file.
   If no directory is specified, Vim will decide where to start the file
browser.  By default it uses the same directory as the last time.  Thus when
you used ":browse split" and selected a file in "/usr/local/share", the next
time you use a ":browse" it will start in "/usr/local/share" again.
   This can be changed with the 'browsedir' option.  It can have one of three
values:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:browse» puede ser antepuesta prácticamente a cualquier orden que
abra un archivo.
   Si no se especifica un directorio, Vim será quien determine en qué
directorio iniciar el explorador de archivos. De manera predeterminada se usa
el mismo directorio usado la vez anterior. Así, si se usó «:browse split» y
se seleccionó un archivo en «/usr/local/share», la próxima vez que use
«:browse» se empezará desde «/usr/local/share» de nuevo.
   Esto se puede ajustar mediante la opción 'browsedir'. Dicha opción acepta
uno de los tres siguientes valores:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	last		Use the last directory browsed (default)
	buffer		Use the same directory as the current buffer
	current		use the current directory
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	last		Usar el último directorio visitado (predeterminado)
	buffer		Usar el mismo directorio del búfer actual
	current		Usar el directorio actual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set browsedir=buffer
	:browse edit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set browsedir=buffer
	:browse edit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will start the browser in "/usr/local/share".  Alternatively: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecutará el explorador de archivos desde «/usr/local/share». Por otro lado: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set browsedir=current
	:browse edit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set browsedir=current
	:browse edit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	To avoid using the mouse, most file browsers offer using key presses
	to navigate.  Since this is different for every system, it is not
	explained here.  Vim uses a standard browser when possible, your
	system documentation should contain an explanation on the keyboard
	shortcuts somewhere.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Para evitar el uso del ratón, muchos de los exploradores de archivos
	ofrecen navegación mediante teclas. Ya que esto difiere de sistema a
	sistema, no se explica aquí. Vim usa un explorador estándar cuando es
	posible; la documentación del sistema que use debería contener
	una sección acerca de los accesos directos de teclado disponibles.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are not using the GUI version, you could use the file explorer window to select files like in a file browser.  However, this doesn't work for the ":browse" command.  See |netrw-browse|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no se está usando la versión gráfica de Vim, es posible usar el explorador de archivos para seleccionar archivos de la forma habitual con un explorador de archivos. Sin embargo, el explorador no funciona con la orden «:browse». Véase |netrw-browse|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.2*	Confirmation
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.2*	Confirmación
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim protects you from accidentally overwriting a file and other ways to lose
changes.  If you do something that might be a bad thing to do, Vim produces an
error message and suggests appending ! if you really want to do it.
   To avoid retyping the command with the !, you can make Vim give you a
dialog.  You can then press "OK" or "Cancel" to tell Vim what you want.
   For example, you are editing a file and made changes to it.  You start
editing another file with: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le protege de sobreescribir accidentalmente un archivo, y de otras formas
de perder los cambios realizados.  Si hace algo que puede ser peligroso,
Vim muestra un mensaje de error y sugiere añadir ! si el usuario está
seguro de querer hacerlo.
   Para evitar teclear de nuevo la orden con el !, puede hacer que Vim le
ofrezca un diálogo. Así, podrá pulsar «OK» o «Cancelar» para
indicarle a Vim qué desea hacer.
   Por ejemplo, está editando un archivo y ya hizo algunos cambios.
Puede editar otro archivo con: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:confirm edit foo.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:confirm edit foo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now make your choice.  If you do want to save the changes, select "YES".  If you want to lose the changes for ever: "NO".  If you forgot what you were doing and want to check what really changed use "CANCEL".  You will be back in the same file, with the changes still there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y ahora puede decidir qué hacer. Si desea conservar los cambios, escoja «SÍ». Si quiere descartar permanentemente los cambios hechos: «NO».  Si olvidó lo que estaba haciendo y quiere revisar cuáles fueron los cambios hechos, use «CANCELAR». Estará de nuevo en el mismo archivo, y los cambios aún estarán allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like ":browse", the ":confirm" command can be prepended to most commands that edit another file.  They can also be combined: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal como «:browse», la orden «:confirm» se puede anteponer a la mayoría de las órdenes que editan un archivo.  Estas órdenes también se pueden combinar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:confirm browse edit
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:confirm browse edit
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will produce a dialog when the current buffer was changed.  Then it will pop up a file browser to select the file to edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto mostrará un diálogo cuando el búfer actual contiene cambios. Luego se mostrará un explorador de archivos para seleccionar el archivo a editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	In the dialog you can use the keyboard to select the choice.
	Typically the &lt;Tab&gt; key and the cursor keys change the choice.
	Pressing &lt;Enter&gt; selects the choice.  This depends on the system
	though.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Es posible usar el teclado para seleccionar la opción deseada en
	el diálogo. Generalmente, la tecla &lt;Tab&gt; y las teclas de cursor
	cambian la opción seleccionada. Pulsar &lt;Enter&gt; escoge la opción
	definida. Sin embargo, esto varía de sistema a sistema.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are not using the GUI, the ":confirm" command works as well.  Instead of popping up a dialog, Vim will print the message at the bottom of the Vim window and ask you to press a key to make a choice. &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no se usa la GUI, la orden «:confirm» sigue funcionando. En vez de crear una ventana de diálogo, el mensaje se mostrará en la parte de abajo de la ventana de Vim, y se le solicitará pulsar una tecla para hacer una elección. &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:confirm edit main.c
&lt;	Save changes to "Untitled"? ~
	[Y]es, (N)o, (C)ancel:  ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:confirm edit main.c
&lt;	Guardar los cambios en "Sin título"? ~
	[Y]es, (N)o, (C)ancelar:  ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now press the single key for the choice.  You don't have to press &lt;Enter&gt;, unlike other typing on the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede realizar su selección simplemente pulsando una tecla. En particular, no tiene que pulsar &lt;Enter&gt;, a diferencia del tecleo normal en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.3*	Menu shortcuts
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.3*	Atajos de teclado para menús
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a conflict between using the &lt;Alt&gt; key to select menu items, and
using &lt;Alt&gt; key combinations for mappings.  The 'winaltkeys' option tells Vim
what it should do with the &lt;Alt&gt; key.
   The default value "menu" is the smart choice: If the key combination is a
menu shortcut it can't be mapped.  All other keys are available for mapping.
   The value "no" doesn't use any &lt;Alt&gt; keys for the menus.  Thus you must use
the mouse for the menus, and all &lt;Alt&gt; keys can be mapped.
   The value "yes" means that Vim will use any &lt;Alt&gt; keys for the menus.  Some
&lt;Alt&gt; key combinations may also do other things than selecting a menu.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un conflicto con el uso de la tecla &lt;Alt&gt; para seleccionar elementos de
menús, y el uso de la tecla &lt;Alt&gt; en combinaciones de teclas para macros. La
opción 'winaltkeys' le indica a Vim qué hacer con la tecla &lt;Alt&gt;.
   El valor predeterminado «menu» es la selección inteligente: si la
combinación de teclas es un atajo de teclado para el menú, no se la puede
usar en una macro. Todas las otras teclas están disponibles para crear macros.
   El valor «no» hace que no se use ninguna tecla &lt;Alt&gt; para los menús. Por
esto, es necesario usar el ratón para acceder a los menús, y todas las teclas
&lt;Alt&gt; se pueden incluir en macros.
   El valor «yes» implica que Vim usará cualquier tecla &lt;Alt&gt; para los menús.
Algunas combinaciones de teclas con &lt;Alt&gt; pueden hacer cosas distintas a
seleccionar un menú.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.4*	Vim window position and size
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.4*	Posición y tamaño de la ventana de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:winpos
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:winpos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work in the GUI.  The output may look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funcionará en la interfaz gráfica. La salida será similar a lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Window position: X 272, Y 103 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Posición de la ventana: X 272, Y 103 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The position is given in screen pixels.  Now you can use the numbers to move Vim somewhere else.  For example, to move it to the left a hundred pixels: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La posición está dada en píxeles de la pantalla. Puede usar estos números para mover la ventana de Vim a algún otro sitio. Por ejemplo, para moverla a la izquierda cien píxeles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:winpos 172 103
&lt;
	Note:
	There may be a small offset between the reported position and where
	the window moves.  This is because of the border around the window.
	This is added by the window manager.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:winpos 172 103
&lt;
	Nota:
	Puede haber un pequeño desfase entre la posición señalada y el sitio
	al que se mueve la ventana.  Esto es debido al borde de la ventana.
	Éste es añadido por el administrador de ventanas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The size of the Vim window is computed in characters.  Thus this depends on the size of the font being used.  You can see the current size with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El tamaño de la ventana de Vim se calcula en caracteres. Por este motivo el tamaño depende del tipo de letra usado. El tamaño actual puede consultarse con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set lines columns
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set lines columns
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set lines=50
	:set columns=80
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set lines=50
	:set columns=80
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the size works in a terminal just like in the GUI.  Setting the size is not possible in most terminals.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consultar el tamaño funciona en una terminal de la misma manera que en la GUI. En la mayoría de las terminales no es posible ajustar el tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim -geometry {width}x{height}+{x_offset}+{y_offset}
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim -geometry {ancho}x{alto}+{desplz_x}+{desplz_y}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{width} and {height} are in characters, {x_offset} and {y_offset} are in pixels.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{ancho} y {alto} están dados en caracteres, {desplz_x} y {desplz_y} están dados en píxeles. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim -geometry 80x25+100+300
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim -geometry 80x25+100+300
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.5*	Various
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.5*	Varios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use gvim to edit an e-mail message.  In your e-mail program you must
select gvim to be the editor for messages.  When you try that, you will
see that it doesn't work: The mail program thinks that editing is finished,
while gvim is still running!
   What happens is that gvim disconnects from the shell it was started in.
That is fine when you start gvim in a terminal, so that you can do other work
in that terminal.  But when you really want to wait for gvim to finish, you
must prevent it from disconnecting.  The "-f" argument does this: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar gvim para editar mensajes de correo. Debe seleccionar gvim como el
editor para sus mensajes en su programa de correo. Al hacerlo, notará que
esto falla: el programa de correo cree que la edición del mensaje ha
terminado, ¡aún cuando gvim no se ha cerrado!
   El motivo de este error es que gvim se desconecta de la consola en la que
se inició. Esto funciona bien cuando se inicia gvim desde una terminal,
para que se pueda hacer otras cosas en ella. Pero cuando se necesita esperar
a que gvim termine, hay que evitar dicha desconexión. El argumento «-f» hace
precisamente eso: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim -f file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim -f file.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-f" stands for foreground.  Now Vim will block the shell it was started in until you finish editing and exit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«-f» significa foreground (primer plano). Ahora, Vim bloqueará la consola en la que se inició hasta que termine la edición y cierre el editor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix it's possible to first start Vim in a terminal.  That's useful if you do various tasks in the same shell.  If you are editing a file and decide you want to use the GUI after all, you can start it with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix es posible iniciar Vim en una terminal. Esto es útil si se están realizando varias tareas en una misma consola. Si está editando un archivo y decide que después de todo quiere usar la GUI, puede lanzarla con la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:gui
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:gui
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will open the GUI window and no longer use the terminal.  You can continue using the terminal for something else.  The "-f" argument is used here to run the GUI in the foreground.  You can also use ":gui -f".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá la ventana de la GUI y no seguirá usando la terminal. Puede continuar usando la terminal para lo que necesite. El argumento «-f» se usa aquí para ejecutar la GUI en primer plano. También puede usar «:gui -f».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When gvim starts, it reads the gvimrc file.  That's similar to the vimrc file used when starting Vim.  The gvimrc file can be used for settings and commands that are only to be used when the GUI is going to be started.  For example, you can set the 'lines' option to set a different window size: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando gvim inicia, lee el archivo gvimrc. Es similar al archivo vimrc que se
usa al iniciar Vim. El archivo gvimrc puede usarse para fijar opciones de
configuración y órdenes que sólo deban usarse cuando se inicie la GUI. Por
ejemplo, puede definir la opción 'lines' para obtener un tamaño de ventana
diferente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set lines=55
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set lines=55
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't want to do this in a terminal, since its size is fixed (except for
an xterm that supports resizing).
   The gvimrc file is searched for in the same locations as the vimrc file.
Normally its name is "~/.gvimrc" for Unix and "$VIM/_gvimrc" for MS-Windows.
The $MYGVIMRC environment variable is set to it, thus you can use this command
to edit the file, if you have one: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es conveniente hacer esto en una terminal, debido a que su tamaño es fijo
(excepto por un xterm que soporte redimensionado).
   El archivo gvimrc se busca en las mismas ubicaciones que el archivo vimrc.
Habitualmente, su nombre es «~/.gvimrc» en sistemas Unix/Linux y
«$VIM/_gvimrc» en MS-Windows. La ruta de este archivo se almacena en la 
variable de entorno $MYGVIMRC, por lo que puede usar la siguiente orden para
editar ese archivo, si existe: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit $MYGVIMRC
&lt;
   If for some reason you don't want to use the normal gvimrc file, you can
specify another one with the "-U" argument: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit $MYGVIMRC
&lt;
Si por algún motivo no desea usar el archivo gvimrc normal, puede especificar
otro mediante el argumento «-U»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim -U thisrc ...
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim -U otrorc ...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That allows starting gvim for different kinds of editing.  You could set
another font size, for example.
   To completely skip reading a gvimrc file: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite iniciar gvim para distintas formas de edición. Puede,
por ejemplo, definir otro tamaño para el tipo de letra.
   Para evitar la ejecución del archivo gvimrc use: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	gvim -U NONE ...
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	gvim -U NONE ...
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_23.txt*	For Vim version 7.3.  Last change: 2006 Apr 24
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_23.esx*	Para Vim version 7.3. Último cambio: 24/6/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Editing other files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			    Editar otros archivos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter is about editing files that are not ordinary files.  With Vim you can edit files that are compressed or encrypted.  Some files need to be accessed over the internet.  With some restrictions, binary files can be edited as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo trata acerca de editar archivos que no son archivos ordinarios. Con Vim, puede editar archivos comprimidos o cifrados.  Necesita acceder a algunos archivos a través de Internet. Con alguna restricción, también puede editar archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|23.1|	DOS, Mac and Unix files
|23.2|	Files on the internet
|23.3|	Encryption
|23.4|	Binary files
|23.5|	Compressed files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|23.1|	Archivos de DOS, Mac y Unix
|23.2|	Archivos en Internet
|23.3|	Cifrado
|23.4|	Archivos binarios
|23.5|	Archivos comprimidos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_24.txt|  Inserting quickly
 Previous chapter: |usr_22.txt|  Finding the file to edit
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente : |usr_24.esx|  Insertar con rapidez
  Capítulo anterior: |usr_22.esx|  Encontrar el archivo a editar
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.1*	DOS, Mac and Unix files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.1*	Archivos de DOS, Mac y Unix
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back in the early days, the old Teletype machines used two characters to
start a new line.  One to move the carriage back to the first position
(carriage return, &lt;CR&gt;), another to move the paper up (line feed, &lt;LF&gt;).
   When computers came out, storage was expensive.  Some people decided that
they did not need two characters for end-of-line.  The UNIX people decided
they could use &lt;Line Feed&gt; only for end-of-line.  The Apple people
standardized on &lt;CR&gt;.  The MS-DOS (and Microsoft Windows) folks decided to
keep the old &lt;CR&gt;&lt;LF&gt;.
   This means that if you try to move a file from one system to another, you
have line-break problems.  The Vim editor automatically recognizes the
different file formats and handles things properly behind your back.
   The option 'fileformats' contains the various formats that will be tried
when a new file is edited.  The following command, for example, tells Vim to
try UNIX format first and MS-DOS format second: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antiguamente, las viejas máquinas Teletype usaban dos caracteres para
iniciar una nueva línea. Uno desplazaba el transporte de vuelta a la
posición inicial («carriage return», &lt;CR&gt;), y el otro desplazaba la
la página hacia arriba («line feed», &lt;LF&gt;).
   Cuando aparecieron los ordenadores el almacenamiento era caro. Algunas
personas decidieron que no necesitaban dos caracteres para marcar el final
de la línea. La gente de UNIX decidió usar sólo &lt;Line Feed&gt;. La gente de
Apple tomó &lt;CR&gt; como estándar. La gente de MS-DOS (y Microsoft Windows)
decidió seguir con el antiguo &lt;CR&gt;&lt;LF&gt;.
   Esto supone que si intenta mover un archivo de un sistema a otro, tendrá
problemas con el retorno de línea. El editor Vim detecta los diferentes
formatos de archivos automáticamente y gestiona las cosas adecuadamente
sin que usted lo note.
   La opción 'fileformats' contiene los diversos formatos que se prueban
cuando edite un archivo nuevo. La siguiente orden, por ejemplo, le dice a
Vim que primero pruebe con el formato UNIX, y después con el formato MS-DOS: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set fileformats=unix,dos
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set fileformats=unix,dos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the format in the message you get when editing a file.  You don't see anything if you edit a native file format.  Thus editing a Unix file on Unix won't result in a remark.  But when you edit a dos file, Vim will notify you of this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Reconocerá el formato por el mensaje que obtendrá al editar un archivo.  No verá nada si edita un formato de archivo nativo. Por ello, editar un archivo UNIX en Unix no resultará en un aviso. Pero cuando edite un archivo DOS, Vim le notificará de ello:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"/tmp/test" [dos] 3L, 71C ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"/tmp/test" [dos] 3L, 71C ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a Mac file you would see "[mac]".
   The detected file format is stored in the 'fileformat' option.  To see
which format you have, execute the following command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá «[mac]» si es un archivo MAC.
   El formato de archivo detectado se guarda en la opción 'fileformat'. Para
ver qué formato tiene, ejecute la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set fileformat?
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set fileformat?
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	unix		&lt;LF&gt;
	dos		&lt;CR&gt;&lt;LF&gt;
	mac		&lt;CR&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	unix		&lt;LF&gt;
	dos		&lt;CR&gt;&lt;LF&gt;
	mac		&lt;CR&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix, &lt;LF&gt; is used to break a line.  It's not unusual to have a &lt;CR&gt;
character halfway a line.  Incidentally, this happens quite often in Vi (and
Vim) scripts.
   On the Macintosh, where &lt;CR&gt; is the line break character, it's possible to
have a &lt;LF&gt; character halfway a line.
   The result is that it's not possible to be 100% sure whether a file
containing both &lt;CR&gt; and &lt;LF&gt; characters is a Mac or a Unix file.  Therefore,
Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
for this type of file.  To check for this format anyway, add "mac" to
'fileformats': &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, se emplea &lt;LF&gt; para marcar un retorno de línea. No es inusual
obtener un caracter &lt;CR&gt; en mitad de la línea. Fortuitamente, esto ocurre
con regularidad en los scripts de Vi (y Vim).
   En un Macintosh, donde &lt;CR&gt; marca el retorno de línea, es posible obtener
un caracter &lt;LF&gt; en mitad de la línea.
   El resultado es que no es posible estar totalmente seguro de si es un
archivo MAC o UNIX al estar presentes ambos caracteres &lt;CR&gt; y &lt;LF&gt;. Por
ello, Vim asume que probablemente no editaría un archivo MAC bajo Unix, y no
revisará el tipo del archivo. Para revisar el formato de todas maneras,
añada «mac» a 'fileformats'.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set fileformats+=mac
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set fileformats+=mac
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then Vim will take a guess at the file format.  Watch out for situations where Vim guesses wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intentará entonces dilucidar el formato del archivo. Esté atento a las situaciones en las que Vim erra en su conclusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit ++ff=unix file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit ++ff=unix file.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "++" string is an item that tells Vim that an option name follows, which
overrules the default for this single command.  "++ff" is used for
'fileformat'.  You could also use "++ff=mac" or "++ff=dos".
   This doesn't work for any option, only "++ff" and "++enc" are currently
implemented.  The full names "++fileformat" and "++encoding" also work.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La cadena «++» es un elemento que informa a Vim de que a continuación hay
un nombre de opción que invalida el valor predeterminado, sólo de esta
orden. «++ff» se usa para 'fileformat'. También puede usar «++ff=mac» o
«++ff=dos».  Esto no funciona con cualquier opción, y sólo está
implementado «++ff» y «++enc». Los nombres completos, «++fileformat» y
«++encoding», también funcionan.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the 'fileformat' option to convert from one file format to
another.  Suppose, for example, that you have an MS-DOS file named README.TXT
that you want to convert to UNIX format.  Start by editing the MS-DOS format
file: &gt;
	vim README.TXT
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la opción 'fileformat' para convertir el formato de un archivo a
otro. Suponga, por ejemplo, que tiene un archivo MS-DOS llamado README.TXT,
que desea convertir al formato UNIX. Comience editando el archivo de formato
MS-DOS: &gt;
	vim README.TXT
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will recognize this as a dos format file.  Now change the file format to UNIX: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim reconocerá esto como un archivo de formato MS-DOS. Ahora cambie el formato a UNIX: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set fileformat=unix
	:write
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set fileformat=unix
	:write
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.2*	Files on the internet
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.2*	Archivos en Internet
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Someone sends you an e-mail message, which refers to a file by its URL.  For example:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que alguien le manda un correo electrónico que le remite a un archivo a través de su URL. Por ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	You can find the information here: ~
		ftp://ftp.vim.org/pub/vim/README ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Puedes encontrar la información aquí: ~
	ftp://ftp.vim.org/pub/vim/README ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could start a program to download the file, save it on your local disk and
then start Vim to edit it.
   There is a much simpler way.  Move the cursor to any character of the URL.
Then use this command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar un programa para descargar el archivo, guardarlo en su disco
e iniciar Vim para editarlo.
   Existe una manera mucho más simple. Desplace el cursor hacia cualquier
carácter del URL.
Después ejecute esta orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With a bit of luck, Vim will figure out which program to use for downloading
the file, download it and edit the copy.  To open the file in a new window use
CTRL-W f.
   If something goes wrong you will get an error message.  It's possible that
the URL is wrong, you don't have permission to read it, the network connection
is down, etc.  Unfortunately, it's hard to tell the cause of the error.  You
might want to try the manual way of downloading the file.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con un poco de suerte, Vim escogerá qué programa usar para descargarse el
archivo, lo descargará y editará la copia. Para abrir el archivo en una
ventana nueva use «CTRL-W f».
   Se le informará de cualquier incidencia en el proceso. Es posible que
el URL sea erróneo, que no tiene los permisos necesarios para leerlo, que
la conexion a Internet se ha interrumpido, etc. Desafortunadamente, es
difícil conocer la causa del error. Puede que desee intentar una descarga
manual.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing files over the internet works with the netrw plugin.  Currently URLs with these formats are recognized:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El acceso a archivos en Internet es posible gracias a la extensión netrw.  A día de hoy se reconocen los siguientes formatos de URL:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	ftp://		uses ftp
	rcp://		uses rcp
	scp://		uses scp
	http://		uses wget (reading only)
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	ftp://		usa ftp
	rcp://		usa rcp
	scp://		usa scp
	http://		usa wget (sólo lectura)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim doesn't do the communication itself, it relies on the mentioned programs to be available on your computer.  On most Unix systems "ftp" and "rcp" will be present.  "scp" and "wget" might need to be installed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no realiza la conexión por si mismo, sino que depende de que los programas mencionados estén instalados en su ordenador. La mayoría de los sistemas Unix incluyen ftp y rcp. Puede que tenga que instalar scp y wget.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim detects these URLs for each command that starts editing a new file, also with ":edit" and ":split", for example.  Write commands also work, except for http://.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim detecta estas URL para cada orden que inicia la edición de un archivo nuevo, también con «:edit» y «:split», por ejemplo. Las órdenes de escritura también funcionan, a excepción de «http://».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.3*	Encryption
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.3*	Cifrado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -x exam.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -x examen.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Enter encryption key: ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Introduzca la clave de cifrado: ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carefully type the secret key now.  You cannot see the characters you type, they will be replaced by stars.  To avoid the situation that a typing mistake will cause trouble, Vim asks you to enter the key again:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba ahora la clave con cuidado. No puede ver los caracteres que teclea, sino que serán reemplazados por estrellas. Para evitar problemas debidos a un error mecanográfico, Vim le pedirá que introduzca la clave otra vez:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Enter same key again: ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Introduzca la misma clave de cifrado otra vez: ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now edit this file normally and put in all your secrets.  When you
finish editing the file and tell Vim to exit, the file is encrypted and
written.
   When you edit the file with Vim, it will ask you to enter the same key
again.  You don't need to use the "-x" argument.  You can also use the normal
":edit" command.  Vim adds a magic string to the file by which it recognizes
that the file was encrypted.
   If you try to view this file using another program, all you get is garbage.
Also, if you edit the file with Vim and enter the wrong key, you get garbage.
Vim does not have a mechanism to check if the key is the right one (this makes
it much harder to break the key).
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede editar este archivo con normalidad e introducir en él todos sus
secretos. Cuando haya terminado de editar el archivo este se guarda y es
cifrado.
   Cuando edite el archivo con Vim, éste le pedirá que introduzca la
contraseña otra vez. No necesita emplear el argumento «-x». Puede también
usar la orden «:edit». Vim añade una cadena mágica al archivo con el cual
reconoce que el archivo está cifrado.
   Obtendrá sólo basura si intenta editar este archivo con otro programa.
Así mismo, si lo abre con Vim pero introduce mal la contraseña también
obtendrá basura.
Vim no posee un mecanismo para revisar si la clave es correcta (lo cual hace
más difícil descifrar la clave).
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable the encryption of a file, set the 'key' option to an empty string:
&gt;
	:set key=
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desactivar el cifrado de un archivo, configure la opción 'key' con una
cadena vacía: &gt;
	:set key=
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next time you write the file this will be done without encryption.
   Setting the 'key' option to enable encryption is not a good idea, because
the password appears in the clear.  Anyone shoulder-surfing can read your
password.
   To avoid this problem, the ":X" command was created.  It asks you for an
encryption key, just like the "-x" argument did: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente vez que escriba el archivo, ésto se hará sin cifrado.
   Configurar la opción 'key' para activar el cifrado no es una buena idea
ya que la contraseña aparece sin ocultar. Cualquier persona leyendo por
encima de su hombro puede leer su contraseña.
   La orden «:X» se creó para evitar este problema. Le pide una clave de
cifrado, al igual que hizo el argumento «-x»: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:X
	Enter encryption key: ******
	Enter same key again: ******
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:X
	Introduzca la clave de cifrado: ******
	Introduzca la misma clave de cifrado otra vez: ******
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption algorithm used by Vim is weak.  It is good enough to keep out
the casual prowler, but not good enough to keep out a cryptology expert with
lots of time on his hands.  Also you should be aware that the swap file is not
encrypted; so while you are editing, people with superuser privileges can read
the unencrypted text from this file.
   One way to avoid letting people read your swap file is to avoid using one.
If the -n argument is supplied on the command line, no swap file is used
(instead, Vim puts everything in memory).  For example, to edit the encrypted
file "file.txt" without a swap file use the following command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El algoritmo de cifrado de Vim es débil. Es suficiente para mantener alejado
al merodeador de turno, pero no lo es para mantener alejado a un experto
en cifrado con mucho tiempo libre. Debe ser consciente de que el archivo de
de intercambio («swap») no está cifrado; por ello, al editar, personas con
privilegios de superusuario pueden leer el texto sin cifrar en este archivo.
   Una manera de evitar que le gente lea su archivo de intercambio es evitar
tener uno.
Si introduce el argumento «-n» en la linea de órdenes, no se usará ningún
archivo de intercambio (en lugar de ello, volcará todo en la memoria). Por
ejemplo, para editar el archivo cifrado «archivo.txt» si un archivo de
intercambio, use la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -x -n file.txt
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -x -n archivo.txt
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:setlocal noswapfile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:setlocal noswapfile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since there is no swapfile, recovery will be impossible.  Save the file a bit more often to avoid the risk of losing your changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es imposible recuperar un archivo si no existe un archivo de intercambio.  Guarde los datos en el archivo más regularmente para evitar perder sus cambios .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the file is in memory, it is in plain text.  Anyone with privilege can
look in the editor's memory and discover the contents of the file.
   If you use a viminfo file, be aware that the contents of text registers are
written out in the clear as well.
   If you really want to secure the contents of a file, edit it only on a
portable computer not connected to a network, use good encryption tools, and
keep the computer locked up in a big safe when not in use.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un archivo está en texto simple mientras esté en memoria. Cualquiera con los
privilegios necesarios puede mirar en la memoria del editor y descubrir los
contenidos del archivo.
   Si está usando un archivo viminfo, sea consciente de que los contenidos del
registro del texto también se escriben de manera abierta.
   Si realmente desea proteger los contenidos de un archivo, edítelo sólo en
un ordenador portátil sin conexión a ninguna red, use buenas herramientas de
cifrado, y guarde el ordenador en una gran caja fuerte cuando no esté en uso.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.4*	Binary files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.4*	Archivos binarios
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can edit binary files with Vim.  Vim wasn't really made for this, thus
there are a few restrictions.  But you can read a file, change a character and
write it back, with the result that only that one character was changed and
the file is identical otherwise.
   To make sure that Vim does not use its clever tricks in the wrong way, add
the "-b" argument when starting Vim: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede editar archivos binarios con Vim. Vim no se creó para esta labor, y
por ello hay ciertas restricciones. Pero puede leer el archivo, cambiar un
carácter y escribir esto en el archivo, con el resultado de que sólo cambió
un carácter y que, en todo lo demás, el archivo es idéntico.
   Para impedir que Vim use sus ingeniosos trucos de manera inapropiada,
añada el argumento «-b» al iniciar Vim: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	vim -b datafile
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	vim -b archivo_de_datos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This sets the 'binary' option.  The effect of this is that unexpected side effects are turned off.  For example, 'textwidth' is set to zero, to avoid automatic formatting of lines.  And files are always read in Unix file format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto activa la opción 'binary'. El efecto que tiene es que se desactivan ciertos efectos secundarios inesperados. Por ejemplo, 'textwidth' recibe un valor 0, para evitar el formateo automático de las líneas. Y los archivos se leen siempre en el formato de archivo UNIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binary mode can be used to change a message in a program.  Be careful not to insert or delete any characters, it would stop the program from working.  Use "R" to enter replace mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo binario se puede usar para cambiar el mensaje de un programa. Tenga cuidado de no insertar o eliminar cualquier carácter, ya que impediría el funcionamiento del programa.  Use «-R» para pasar al modo «replace» (reemplazar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many characters in the file will be unprintable.  To see them in Hex format: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchos caracteres en el archivo no se pueden imprimir. Para verlos en formato Hex: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set display=uhex
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set display=uhex
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, the "ga" command can be used to see the value of the character under the cursor.  The output, when the cursor is on an &lt;Esc&gt;, looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otro lado, puede usar la orden «ga» para ver el valor del carácter bajo el cursor. La salida, si el cursor está sobre un &lt;Esc&gt;, tiene este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&lt;^[&gt;  27,  Hex 1b,  Octal 033 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&lt;^[&gt;  27,  Hex 1b,  Octal 033 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might not be many line breaks in the file.  To get some overview switch the 'wrap' option off: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que no haya demasiados retornos de línea en el archivo. Para obtener una visión de conjunto, desactive la opción 'wrap': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Col 9-16 of 9-16; Line 277 of 330; Word 1806 of 2058; Byte 10580 of 12206 ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>    Col 9-16 of 9-16; Línea 277 of 330; Palabra 1806 de 2058; Byte 10580 de 12206 ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last two numbers are the byte position in the file and the total number of
bytes.  This takes into account how 'fileformat' changes the number of bytes
that a line break uses.
    To move to a specific byte in the file, use the "go" command.  For
example, to move to byte 2345: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los dos últimos números son el byte posición en el archivo y el número total
de bytes. Tiene en cuenta cómo 'fileformat' cambia el número de bytes que
emplea un retorno de línea.
   Para desplazarse a un byte específico en el archivo, use la orden «go».
Por ejemplo, para ir al byte 2345: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	2345go
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	2345go
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A real binary editor shows the text in two ways: as it is and in hex format.
You can do this in Vim by first converting the file with the "xxd" program.
This comes with Vim.
   First edit the file in binary mode: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un editor realmente binario muestra el texto de dos formas: tal cual y en
formato hexadecimal. Vim hace esto posible si primero convierte el archivo
con el programa «xxd».
Este programa está incluido en Vim.
   Primero edite el archivo en modo binario: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:%!xxd
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:%!xxd
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI ~
	0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0 ~
	0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.".....i.59. ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI ~
	0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0 ~
	0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.".....i.59. ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now view and edit the text as you like.  Vim treats the information as
ordinary text.  Changing the hex does not cause the printable character to be
changed, or the other way around.
   Finally convert it back with:
&gt;
	:%!xxd -r
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede ver y editar el texto como desee. Vim trata la información como
texto normal. Cambiar el valor hexadecimal no provoca un cambio en el
carácter imprimible, o vicecersa.
Por último, conviertalo otra vez con: &gt;
	:%!xxd -r
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only changes in the hex part are used.  Changes in the printable text part on the right are ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se usan los cambios en la parte hexadecimal. Los cambios en la parte imprimible de texto se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.5*	Compressed files
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.5*	Archivos comprimidos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	.Z	compress
	.gz	gzip
	.bz2	bzip2
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	.Z	compress
	.gz	gzip
	.bz2	bzip2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim uses the mentioned programs to do the actual compression and decompression.  You might need to install the programs first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim realiza la compresión y descompresión mediante los programas mencionados. Puede que primero tenga instalar los programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_24.txt*	For Vim version 7.3.  Last change: 2006 Jul 23
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_24.esx*	Para Vim versión 7.3.  Último cambio: 23/6/2006
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>			     Inserting quickly
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>			  Insertar con rapidez
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When entering text, Vim offers various ways to reduce the number of keystrokes and avoid typing mistakes.  Use Insert mode completion to repeat previously typed words.  Abbreviate long words to short ones.  Type characters that aren't on your keyboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al introducir texto, Vim ofrece varias maneras de reducir el número de teclas que pulsa, evitando teclear errores. Use el modo de autocompletado del modo Insertar para repetir palabras anteriormente tecleadas. Abrevie las palabras largas. Teclee caracteres que no están en su teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|24.1|	Making corrections
|24.2|	Showing matches
|24.3|	Completion
|24.4|	Repeating an insert
|24.5|	Copying from another line
|24.6|	Inserting a register
|24.7|	Abbreviations
|24.8|	Entering special characters
|24.9|	Digraphs
|24.10|	Normal mode commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|24.1|	Corregir
|24.2|	Mostrar coincidencias
|24.3|	Autocompletado
|24.4|	Repetir una inserción
|24.5|	Copiar desde otra línea
|24.6|	Insertar un registro
|24.7|	Abreviaturas
|24.8|	Introducir caracteres especiales
|24.9|	Dígrafos
|24.10|	Órdenes del modo Normal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>     Next chapter: |usr_25.txt|  Editing formatted text
 Previous chapter: |usr_23.txt|  Editing other files
Table of contents: |usr_toc.txt|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg> Capítulo siguiente: |usr_25.txt|  Editar texto con formato
  Capitulo anterior: |usr_23.esx|  Editar otros archivos
Tabla de contenidos: |usr_toc.esx|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.1*	Making corrections
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.1*	Corregir
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;BS&gt; key was already mentioned.  It deletes the character just before the
cursor.  The &lt;Del&gt; key does the same for the character under (after) the
cursor.
   When you typed a whole word wrong, use CTRL-W:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;BS&gt; ya se ha mencionado. Borra el carácter que precede al cursor.
La tecla &lt;Del&gt; hace lo mismo con el carácter debajo (después) del cursor.
   Use CTRL-W en caso de haber tecleado una palabra completamente
errónea:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El caballo cayó del cielo ~
					CTRL-W
	El caballo cayó del ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really messed up a line and want to start over, use CTRL-U to delete it.  This keeps the text after the cursor and the indent.  Only the text from the first non-blank to the cursor is deleted.  With the cursor on the "f" of "fallen" in the next line pressing CTRL-U does this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de haber realizado errores en una línea, y desea empezar otra vez, use CTRL-U para eliminarlo. Esto mantiene el texto después del cursor, así como la tabulación. Sólo se elimina el texto desde el primer espacio que no esté vacío hasta el cursor. Pulsar CTRL-U con el cursor sobre la «c» de «cayó» hace lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El caballo cayó del cielo ~
					CTRL-W
	cayó del ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you spot a mistake a few words back, you need to move the cursor there to correct it.  For example, you typed this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando detecta un error en alguna palabra anterior, necesita desplazar el cursor hasta ese punto para corregirlo. Por ejemplo, escribió lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The horse had follen to the ground ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El caballo cayu al suelo ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to change "follen" to "fallen".  With the cursor at the end, you would type this to correct it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita cambiar «cayo» a «cayó». Con el cursor al final,  teclearía esto para corregirlo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>					&lt;Esc&gt;4blraA
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>					&lt;Esc&gt;3blróA
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	get out of Insert mode		&lt;Esc&gt;
	four words back			     4b
	move on top of the "o"		       l
	replace with "a"			ra
	restart Insert mode			  A
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Abandonar el modo insertar   &lt;Esc&gt;
	Cuatro palabras hacia atrás          3b
	Desplazarse a la «u»         		l
	Reemplazar con «ó»			ró
	Reiniciar modo insertar			  A
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe otra manera de hacer esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>		&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;Right&gt;&lt;Del&gt;a&lt;End&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>		&lt;C-Izq&gt;&lt;C-Izq&gt;&lt;C-Izq&gt;&lt;Derecha&gt;&lt;Derecha&gt;&lt;Derecha&gt;&lt;Supr&gt;ó&lt;Fin&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	four words back		     &lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;
	move on top of the "o"			&lt;Right&gt;
	delete the "o"				       &lt;Del&gt;
	insert an "a"					    a
	go to end of the line				     &lt;End&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Tres palabras hacia atrás	        &lt;C-Izq&gt;&lt;C-Izq&gt;&lt;C-Izq&gt;
	Desplazarse a la «u»		 &lt;Derecha&gt;&lt;Derecha&gt;&lt;Derecha&gt;
	Borrar la «u»						&lt;Supr&gt;
	Insertar una «ó»					ó
	Ir al final de la línea					&lt;Fin&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses special keys to move around, while remaining in Insert mode.  This
resembles what you would do in a modeless editor.  It's easier to remember,
but takes more time (you have to move your hand from the letters to the cursor
keys, and the &lt;End&gt; key is hard to press without looking at the keyboard).
   These special keys are most useful when writing a mapping that doesn't
leave Insert mode.  The extra typing doesn't matter then.
   An overview of the keys you can use in Insert mode:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto emplea teclas especiales para el desplazamiento, a la vez que permanece
en el modo Insertar. Esto se parece a lo que haría con un editor sin modos. Es
más fácil de recordar, pero lleva más tiempo (tiene que mover sus manos de
las letras a las teclas del cursor, y es difícil pulsar la tecla &lt;Fin&gt; sin
mirar el teclado).
   Estas teclas especiales son más útiles cuando escribe una macro que no
abandona el modo Insertar. El tecleo adicional no importa en este caso.
   Este es un resumen de las teclas que puede usar en el modo Insertar:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	&lt;C-Home&gt;	to start of the file
	&lt;PageUp&gt;	a whole screenful up
	&lt;Home&gt;		to start of line
	&lt;S-Left&gt;	one word left
	&lt;C-Left&gt;	one word left
	&lt;S-Right&gt;	one word right
	&lt;C-Right&gt;	one word right
	&lt;End&gt;		to end of the line
	&lt;PageDown&gt;	a whole screenful down
	&lt;C-End&gt;		to end of the file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	&lt;C-Inicio&gt;	al principio del archivo
	&lt;Repág&gt;		subir una pantalla
	&lt;Inicio&gt;	al inicio de la línea
	&lt;S-Izq&gt;		una palabra a la izquierda
	&lt;C-Izq&gt;		una palabra a la izquierda
	&lt;S-Der&gt;		una palabra a la derecha
	&lt;C-Der&gt;		una palabra a la derecha
	&lt;Fin&gt;		al final de la línea
	&lt;Avpág&gt;		bajar una pantalla
	&lt;C-Fin&gt;		al final del archivo
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.2*	Showing matches
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.2*	Mostrar coincidencias
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type a ) it would be nice to see with which ( it matches.  To make Vim do that use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al teclear una «)» estaría bien ver con qué «(» encaja. Para hacer que Vim use esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set showmatch
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set showmatch
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now type a text like "(example)", as soon as you type the ) Vim will
briefly move the cursor to the matching (, keep it there for half a second,
and move back to where you were typing.
   In case there is no matching (, Vim will beep.  Then you know that you
might have forgotten the ( somewhere, or typed a ) too many.
   The match will also be shown for [] and {} pairs.  You don't have to wait
with typing the next character, as soon as Vim sees it the cursor will move
back and inserting continues as before.
   You can change the time Vim waits with the 'matchtime' option.  For
example, to make Vim wait one and a half second: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando teclee un texto como «(ejemplo), tan pronto como teclee el «)»
Vim moverá el cursor brevemente al «(» correspondiente, lo mantendrá ahí
medio segundo, y volverá a donde estaba tecleando.
   En caso de no existir un correspondiente «(», Vim pitará. Sabrá entonces que
ha olvidado el «(» en algún lugar, o que escribió una «)» demasiadas veces.
   También se mostrará el signo correspondiente en las parejas «[]» «{}». No
tiene que esperar a teclear el siguiente carácter, ya que tan pronto como Vim
lo detecte, devolverá el cursor a su posición original, continuando la
inserción. Puede modificar el tiempo que Vim espera con la opción 'matchtime'.
Por ejemplo, para hacer que Vim espere un segundo y medio: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:set matchtime=15
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:set matchtime=15
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.3*	Completion
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.3*	Autocompletado
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can automatically complete words on insertion.  You type the first part of
a word, press CTRL-P, and Vim guesses the rest.
   Suppose, for example, that you are creating a C program and want to type in
the following:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede auto-completar palabras durante la inserción. Escriba primero la
parte inicial de una palabra, pulse CTRL-P y Vim adivinará el resto.
   Suponga, por ejemplo, que está creando un programa en C y que desea
teclear lo siguiente:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	total = ch_array[0] + ch_array[1] + ch_array[2]; ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	total = ch_array[0] + ch_array[1] + ch_array[2]; ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	total = ch_array[0] + ch_ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	total = ch_array[0] + ch_ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you tell Vim to complete the word using the command CTRL-P.  Vim searches for a word that starts with what's in front of the cursor.  In this case, it is "ch_", which matches with the word ch_array.  So typing CTRL-P gives you the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este punto es cuando le dice a Vim que complete la palabra usando la orden CTRL-P. Vim buscará una palabra que empiece con lo que se aparece frente al cursor. En este caso, es «ch_», el cual encaja con la palabra «ch_array». Por ello, teclear CTRL-P le daría lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	total = ch_array[0] + ch_array ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	total = ch_array[0] + ch_array ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	total = ch_array[0] + ch_array[1] +  ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	total = ch_array[0] + ch_array[1] +  ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now type CTRL-P Vim will search again for a word that completes the word before the cursor.  Since there is nothing in front of the cursor, it finds the first word backwards, which is "ch_array".  Typing CTRL-P again gives you the next word that matches, in this case "total".  A third CTRL-P searches further back.  If there is nothing else, it causes the editor to run out of words, so it returns to the original text, which is nothing.  A fourth CTRL-P causes the editor to start over again with "ch_array".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa ahora CTRL-P, Vim buscará otra vez una palabra que complete la que se haya frente al cursor. Ya que no hay nada en frente del cursor, busca la palabra en sentido inverso, el cual es «ch_array». Pulsar CTRL-P otra vez le daría la siguiente palabra que encaja, en este caso «total». Si lo pulsa por tercera vez, Vim buscará aún más atrás. Si no hay nada más, al editor se le acabarían las palabras, volviendo al texto original, que es nada. Un cuarto CTRL-P causaría al editor empezar otra vez con «ch_array».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search forward, use CTRL-N.  Since the search wraps around the end of the file, CTRL-N and CTRL-P will find the same matches, but in a different sequence.  Hint: CTRL-N is Next-match and CTRL-P is Previous-match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-N para una búsqueda hacia delante. Ya que la búsqueda vuelve al inicio cuando llega al final del archivo, CTRL-N y CTRL-P encontrarán las mismas coincidencias, pero en distinto orden. Pista: CTRL-N es siguiente coincidencia («Next-match») y CTRL-P es la coincidencia anterior («Previous-match»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor goes through a lot of effort to find words to complete.  By default, it searches the following places:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim realiza un gran esfuerzo por encontrar palabras que completar. Por omisión, busca en los siguientes lugares:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	1. Current file
	2. Files in other windows
	3. Other loaded files (hidden buffers)
	4. Files which are not loaded (inactive buffers)
	5. Tag files
	6. All files #included by the current file
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	1. Archivo actual
	2. Archivos en otras ventanas
	3. Otros archivos cargados (búfers ocultos)
	4. Archivos que no están cargados (búfers inactivos)
	5. Archivos de etiquetas
	6. Todos los archivos #incluidos en el archivo actual
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'ignorecase' option is used.  When it is set, case differences are ignored when searching for matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'ignorecase' es empleada. Las diferencias entre mayúsculas y minúsculas se ignorarán al buscar coincidencias de activar esta opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special option for completion is 'infercase'.  This is useful to find matches while ignoring case ('ignorecase' must be set) but still using the case of the word typed so far.  Thus if you type "For" and Vim finds a match "fortunately", it will result in "Fortunately".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'infercase' es una opción especial para el autocompletado. Es útil para encontrar parejas cuando ignora la sensibilidad a mayúsculas y minúsculas (debe activar 'ignorecase') , y seguir usando con esta palabra la mencionada sensibilidad. Por ello, si teclea «Para» y Vim encuentra «paramilitar», el resultado final será «Paramilitar».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-X CTRL-F		file names
	CTRL-X CTRL-L		whole lines
	CTRL-X CTRL-D		macro definitions (also in included files)
	CTRL-X CTRL-I		current and included files
	CTRL-X CTRL-K		words from a dictionary
	CTRL-X CTRL-T		words from a thesaurus
	CTRL-X CTRL-]		tags
	CTRL-X CTRL-V		Vim command line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-X CTRL-F		Nombres de archivo
	CTRL-X CTRL-L		Líneas completas
	CTRL-X CTRL-D		Definiciones de macros
				(también en archivos incluidos)
	CTRL-X CTRL-I		Archivo actual e incluidos
	CTRL-X CTRL-K		Palabras de un diccionario
	CTRL-X CTRL-T		Palabras de un tesauro
	CTRL-X CTRL-]		Etiquetas
	CTRL-X CTRL-V		Línea de órdenes de Vim
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After each of them CTRL-N can be used to find the next match, CTRL-P to find
the previous match.
   More information for each of these commands here: |ins-completion|.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar CTRL-N después de cada uno de estas órdenes para hallar la siguiente
coincidencia, y CTRL-P para hallar la anterior.
   Para más información acerca de estas órdenes, consulte |ins-completion|.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take CTRL-X CTRL-F as an example.  This will find file names.  It scans
the current directory for files and displays each one that matches the word in
front of the cursor.
   Suppose, for example, that you have the following files in the current
directory:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tomemos CTRL-X CTRL-F como ejemplo. Esto busca nombres de archivo.
Examina el directorio actual en busca de archivos, y muestra cada uno que
encaja con la palabra frenet al cursor.
   Suponga, por ejemplo, que tiene las siguientes líneas en el directorio
actual:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	main.c  sub_count.c  sub_done.c  sub_exit.c
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	main.c  sub_count.c  sub_done.c  sub_exit.c
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The exit code is in the file sub ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El código de salida está en el archivo sub ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you enter the command CTRL-X CTRL-F.  Vim now completes the current word "sub" by looking at the files in the current directory.  The first match is sub_count.c.  This is not the one you want, so you match the next file by typing CTRL-N.  This match is sub_done.c.  Typing CTRL-N again takes you to sub_exit.c.  The results:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este momento, introduzca la orden CTRL-X CTRL-F. Vim completará la palabra «sub» mirando en los ficheros en el directorio actual. La primera coincidencia es «sub_count.c». Esto no es lo que buscaba, así que busca la siguiente pareja pulsando CTRL-N. La coincidencia es «sub_done.c». Teclear CTRL-N otra vez le devolvería a «sub_exit.c». El resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	The exit code is in the file sub_exit.c ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El código de salida está en el archivo sub_exit.c ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all files in the file system.  For example, type "/u" and CTRL-X CTRL-F.  This will match "/usr" (this is on Unix):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el nombre de archivo empieza con «/» (Unix) o «C:\» (MS-Windows), puede buscar todos los archivos en el sistema de archivos. Por ejemplo, teclee «/u» y CTRL-X CTRL-F. Esto buscará «/usr» (en Unix):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	the file is found in /usr/ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El archivo se encuentra en "/usr/" ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now press CTRL-N you go back to "/u".  Instead, to accept the "/usr/" and go one directory level deeper, use CTRL-X CTRL-F again:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora pulsa CTRL-N volvería a «/u». En lugar de ello, para aceptar «/usr/» y descender un nivel en el árbol de directorios, use otra vez CTRL-X CTRL-F:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	the file is found in /usr/X11R6/ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	El archivo se encuentra en /usr/X11R6/~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The results depend on what is found in your file system, of course.  The matches are sorted alphabetically.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los resultados varían según lo que se encuentra en su sistema de archivos. Las coincidencias aparecen alfabéticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source code files are well structured.  That makes it possible to do completion in an intelligent way.  In Vim this is called Omni completion.  In some other editors it's called intellisense, but that is a trademark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los archivos de código están bien estructurados. Esto posibilita un autocompletado inteligente. En Vim, esto se llama autocompletado global («Omni completion»). Algunos otros editores lo llaman intellisense, pero eso es una marca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The key to Omni completion is CTRL-X CTRL-O.  Obviously the O stands for Omni here, so that you can remember it easier.  Let's use an example for editing C source:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla para el autocompletado global es CTRL-X CTRL-O. Obviamente, la «O» significa «Omni», para recordarla mejor. Usemos un ejemplo para editar código C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	{ ~
	    struct foo *p; ~
	    p-&gt; ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	{ ~
	    struct foo *p; ~
	    p-&gt; ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is after "p-&gt;".  Now type CTRL-X CTRL-O.  Vim will offer you a list of alternatives, which are the items that "struct foo" contains.  That is quite different from using CTRL-P, which would complete any word, while only members of "struct foo" are valid here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está después de «p-&gt;». Pulse ahora CTRL-X CTRL-O. Vim le ofrecerá una lista de alternativas, los cuales son los elementos que contiene «struct foo». Esto es diferente al uso de CTRL-P, el cual completa cualquier palabra, mientras que aquí sólo son válidos los miembros de «struct foo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Omni completion to work you may need to do some setup.  At least make sure
filetype plugins are enabled.  Your vimrc file should contain a line like
this: &gt;
	filetype plugin on
Or: &gt;
	filetype plugin indent on
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita realizar alguna configuración para que funcione el autocompletado
global. Asegúrese al menos de que las extensiones de tipo de archivo
(filetype) están activadas. El archivo vimrc debería tener esta línea: &gt;
	filetype plugin on
O: &gt;
	filetype plugin indent on
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For C code you need to create a tags file and set the 'tags' option.  That is explained |ft-c-omni|.  For other filetypes you may need to do something similar, look below |compl-omni-filetypes|.  It only works for specific filetypes.  Check the value of the 'omnifunc' option to find out if it would work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita crear un archivo de etiquetas y definir la opción 'tags' si desea editar código C. Consulte |ft-c-omni|. Puede que tenga que realizar algo
similar para otros tipos de archivo, consulte más adelante |compl-omni-filetypes|. Sólo funciona para ciertos tipos de archivo. Revise el valor de la opción 'omnifunc' para ver si funcionaría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.4*	Repeating an insert
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.4*	Repetir una inserción
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you press CTRL-A, the editor inserts the text you typed the last time you
were in Insert mode.
   Assume, for example, that you have a file that begins with the following:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa CTRL-A, el editor insertará el texto que tecleó la última que estaba
en el modo Insertar.
   Suponga, por ejemplo, que tiene un archivo que empieza con lo siguiente:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"file.h" ~
	/* Main program begins */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"file.h" ~
	/* El programa principal comienza */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#include "file.h" ~
	/* Main program begins */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#include "file.h" ~
	/* El programa principal comienza */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You go down to the beginning of the next line using the commands "j^".  You now start to insert a new "#include" line.  So you type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede bajar hasta el inicio de la siguiente línea con las órdenes «j^». Ahora puede empezar a insertar una nueva línea «include». Asi que escribe: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	i CTRL-A
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	i CTRL-A
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es el siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#include "file.h" ~
	#include /* Main program begins */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#include "file.h" ~
	#include /* El programa principal comienza */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "#include " was inserted because CTRL-A inserts the text of the previous insert.  Now you type "main.h"&lt;Enter&gt; to finish the line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«#include» se insertó porque CTRL-A inserta el texto de la inserción anterior. Teclee ahora «main.h» &lt;Enter&gt; para finalizar la línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	#include "file.h" ~
	#include "main.h" ~
	/* El programa principal comienza */ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-@ command does a CTRL-A and then exits Insert mode.  That's a quick way of doing exactly the same insertion again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-@ realiza un CTRL-A y abandona el modo Insertar. Esta es una manera rápida de hacer la misma inserción otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.5*	Copying from another line
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.5*	Copiar desde otra línea
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-Y command inserts the character above the cursor.  This is useful when you are duplicating a previous line.  For example, you have this line of C code:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-Y inserta el carácter sobre el cursor. Esto es útil si está duplicando una línea anterior. Por ejemplo, tiene esta línea de código C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to type the same line, but with "s_prev" instead of "s_next".  Start the new line, and press CTRL-Y 14 times, until you are at the "n" of "next":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora necesita escribir la misma línea, pero con un «s_prev» en lugar de «s_next». Inicie una nueva línea, y pulse CTRL-Y 14 veces, hasta encontrarse en la «n» de «next»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.6*	Inserting a register
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.6*	Insertar un registro
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command CTRL-R {register} inserts the contents of the register.  This is useful to avoid having to type a long word.  For example, you need to type this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-R {registro} inserta el contenido de un registro. Esto es útil para evitar escribir una palabra larga. Por ejemplo, necesita teclear esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	r = FunciónMuyLarga(a) + FunciónMuyLarga(b) + FunciónMuyLarga(c) ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name is defined in a different file.  Edit that file and move the cursor on top of the function name there, and yank it into register v: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre de la función se define en otro archivo. Edite ese archivo y desplace el cursor sobre el nombre de función presente, y copie el mismo al registro v:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	"vyiw
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	"vyiw
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v is the register specification, "yiw" is yank-inner-word.  Now edit the file where the new line is to be inserted, and type the first letters:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«"v» es el especificador del registro, «yiw» signifia copiar la palabra interior («yank inner word»). Edite ahora el archivo donde se insertará la línea, y escriba las primeras letras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	r = ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	r = ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	r = VeryLongFunction ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	r = FunciónMuyLarga ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You continue to type the characters in between the function name, and use
CTRL-R v two times more.
   You could have done the same with completion.  Using a register is useful
when there are many words that start with the same characters.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Continua insertando caracteres en medio del nombre de la función, y usa
«CTRL-R v» dos veces más.
   Podría haber realizado lo mismo con el autocompletado. Usar un registro
es útil cuando hay varias palabras que empiezan con el mismo carácter.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the register contains characters such as &lt;BS&gt; or other special characters, they are interpreted as if they had been typed from the keyboard.  If you do not want this to happen (you really want the &lt;BS&gt; to be inserted in the text), use the command CTRL-R CTRL-R {register}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el registro contiene caracteres tales como &lt;BS&gt; o otros caracteres especiales, se interpretarán como introducidos a través del teclado. Si no desea que esto ocurra (realmente quiere que &lt;BS&gt; acabe insertado en el texto), use la orden CTRL-R CTRL-R {registro}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.7*	Abbreviations
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.7*	Abreviaturas
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An abbreviation is a short word that takes the place of a long one.  For
example, "ad" stands for "advertisement".  Vim enables you to type an
abbreviation and then will automatically expand it for you.
   To tell Vim to expand "ad" into "advertisement" every time you insert it,
use the following command: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una abreviatura es una palabra corta que sustituye a otra más larga. Por
ejemplo, «poli» simboliza «policía». Vim le permite insertar una abreviatura
para después expandirla automáticamente.
   Para decir a Vim que expanda «poli» a «policía» cada vez que lo inserte,
use la siguiente orden: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:iabbrev ad advertisement
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:iabbrev poli policía
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, when you type "ad", the whole word "advertisement" will be inserted into the text.  This is triggered by typing a character that can't be part of a word, for example a space:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando escribe «po», aparecerá la palabra completa «policía» en el texto. Esto se activa cuando teclea un carácter que no puede ser parte de una palabra, como por ejemplo un espacio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	What Is Entered		What You See
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad&lt;Space&gt;	I saw the advertisement&lt;Space&gt; ~
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Texto introducido	Lo que ve
	Vi al p			Vi al p ~
	Vi al po		Vi al po ~
	Vi al po&lt;Espacio&gt;	Vi al policía&lt;Espacio&gt; ~
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The expansion doesn't happen when typing just "ad".  That allows you to type a word like "add", which will not get expanded.  Only whole words are checked for abbreviations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La expansión no ocurre si solo escribe «po». Esto permite escribir una palabra como «polifacético», que no se expandirá. Solo se revisan palabras completas con abreviaturas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to define an abbreviation that results in multiple words.  For example, to define "JB" as "Jack Benny", use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible definir una abreviatura cuyo resultado sean varias palabras. Por ejemplo, para definir «JB» como «Juan Benítez», use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:iabbrev JB Jack Benny
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:iabbrev JB Juan Benítez
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:iabbrev #b /****************************************
	:iabbrev #e &lt;Space&gt;****************************************/
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:iabbrev #b /****************************************
	:iabbrev #e &lt;Space&gt;****************************************/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are used for creating boxed comments.  The comment starts with #b, which
draws the top line.  I then type the comment text and use #e to draw the
bottom line.
   Notice that the #e abbreviation begins with a space.  In other words, the
first two characters are space-star.  Usually Vim ignores spaces between the
abbreviation and the expansion.  To avoid that problem, I spell space as seven
characters: &lt;, S, p, a, c, e, &gt;.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uso esto para crear comentarios en cajas. El comentario empieza con «#b», el
cual escribe la línea superior. Después escribo el texto del comentario y uso
«#e» para dibujar la línea inferior.
   Observe que la abreviatura «#e» empieza con un espacio. En otras palabras,
los primeros dos caracteres son espacio-asterisco. Por lo general, Vim
ignora los espacios entre la abreviatura y la expansión. Para evitar tal
problema, deletreo espacio («space») como siete caracters: &lt;, S, p, a, c, e,&gt;.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	":iabbrev" is a long word to type.  ":iab" works just as well.
	That's abbreviating the abbreviate command!
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	La palabra «:iabbrev» es algo larga. «:iab» también daría resultado.
	¡Esto es abreviar la orden de abreviar!
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's very common to make the same typing mistake every time.  For example, typing "teh" instead of "the".  You can fix this with an abbreviation: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es bastante normal escribir siempre el mismo error. Por ejemplo, escribir «qeu» en lugar de «que». Puede arreglar esto con una abreviatura: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbreviate teh the
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbreviate qeu que
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a whole list of these.  Add one each time you discover a common mistake.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear una lista completa de ejemplos como este. Añada uno cada vez que descubra un error común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Juan Benítez
	i  po		 policía
	!  qeu		 que
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "i" in the first column indicates Insert mode.  These abbreviations are only active in Insert mode.  Other possible characters are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «i» en la primera columna indica modo Insertar. Estas abreviaturas sólo están activas en el modo Insertar. Otros caracteres posibles son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since abbreviations are not often useful in Command-line mode, you will mostly use the ":iabbrev" command.  That avoids, for example, that "ad" gets expanded when typing a command like: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a que las abreviaturas no son útiles en el modo Línea de órdenes, usará más regularmente la orden «:iabbrev». Esto evita, por ejemplo, que se expanda «po» al escribir una orden como: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:edit ad
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:edit po
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get rid of an abbreviation, use the ":unabbreviate" command.  Suppose you have the following abbreviation: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una abreviatura, use la orden «:unabbreviate». Suponga que tiene la siguiente abreviatura: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbreviate @f fresh
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbreviate @f fresco
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:unabbreviate @f
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:unabbreviate @f
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you type this, you will notice that @f is expanded to "fresh".  Don't
worry about this, Vim understands it anyway (except when you have an
abbreviation for "fresh", but that's very unlikely).
   To remove all the abbreviations: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará al escribir esto que @f se expande a «fresco». No se preocupe, Vim lo
entiende de todas formas (a menos que tenga una abreviatura «fresco», pero
eso es improbable).
   Para eliminar todas las abreviaturas: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abclear
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abclear
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one thing to watch out for when defining an abbreviation: The resulting string should not be mapped.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe un aspecto a tener en cuenta a la hora de definir una abreviatura: no debería asignar la cadena resultante a una macro. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:abbreviate @a adder
	:imap dd disk-door
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:abbreviate @a adder
	:imap dd disk-door
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now type @a, you will get "adisk-doorer".  That's not what you want.  To avoid this, use the ":noreabbrev" command.  It does the same as ":abbreviate", but avoids that the resulting string is used for mappings: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora teclea @a, obtendrá «adisk-doorer». Esto no es lo que quiere. Para evitarlo, use la orden «:noabbrev». Hace lo mismo que «:abbreviate», pero evita que la cadena resultante se use en macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:noreabbrev @a adder
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:noreabbrev @a adder
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.8*	Entering special characters
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.8*	Introducir caracteres especiales
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-V command is used to insert the next character literally.  In other words, any special meaning the character has, it will be ignored.  For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-V se emplea para insertar el siguiente carácter de forma literal. En otras palabras, se ignorará el significado especial de cualquier carácter. Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-V &lt;Esc&gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-V &lt;Esc&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inserts an escape character.  Thus you don't leave Insert mode.  (Don't type the space after CTRL-V, it's only to make this easier to read).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inserta un carácter de escapado. Por ello, no abandona el modo Insertar. (No escriba un espacio después de CTRL-V, sólo lo hace más fácil de leer).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	On MS-Windows CTRL-V is used to paste text.  Use CTRL-Q instead of
	CTRL-V.  On Unix, on the other hand, CTRL-Q does not work on some
	terminals, because it has a special meaning.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	En MS-Windows, CTRL-V se emplea para pegar texto. Use CTRL-Q en
	lugar de CTRL-V. Por otra parte, Unix no reconoce CTRL-Q en algunas
	terminales, porque tiene un significado especial.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use the command CTRL-V {digits} to insert a character with the decimal number {digits}.  For example, the character number 127 is the &lt;Del&gt; character (but not necessarily the &lt;Del&gt; key!).  To insert &lt;Del&gt; type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar la orden CTRL-V {dígitos} para insertar un carácter con el número decimal {dígitos}. Por ejemplo, el carácter número 127 es el carácter &lt;Del&gt; (Supr) (¡pero no necesariamente la tecla &lt;Supr&gt;!). Escriba lo siguiente para insetar &lt;Del&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-V 127
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-V 127
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enter characters up to 255 this way.  When you type fewer than two
digits, a non-digit will terminate the command.  To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.
   All the next commands insert a &lt;Tab&gt; and then a dot:
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede introducir hasta el carácter 255 de esta manera. Cuando escribe menos
de dos dígitos, un no-dígito finalizará la orden. Para evitar la necesidad
de escribir un no-dígito, añada uno o dos ceros para sumar tres dígitos.
   Todas las ordenes a continuación insertan primero un &lt;Tab&gt; y después un
punto:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-V x7f
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-V x7f
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also goes up to character 255 (CTRL-V xff).  You can use "o" to type a character as an octal number and two more methods allow you to type up to a 16 bit and a 32 bit number (e.g., for a Unicode character): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también llega al carácter 255 (CTRL-V xff). También puede usar «o» para escribir un carácter como un número octal, y otros dos métodos le permiten escribir hasta un número en 16 y 32 bit (p, ej., un carácter Unicode): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.9*	Digraphs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.9*	Dígrafos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-K Co
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-K Co
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:digraphs
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:digraphs
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will display the digraph table.  Here are three lines of it:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim mostrará la tabla de dígrafos. Aquí puede ver tres líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	Note:
	The digraphs depend on the character set that Vim assumes you are
	using.  On MS-DOS they are different from MS-Windows.  Always use
	":digraphs" to find out which digraphs are currently available.
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	Nota:
	Los dígrafos dependen del juego de caracteres que Vim asume que está
	usando. En MS-DOS difieren con los de MS-Windows. Use siempre
	«:digraphs» para ver de qué dígrafos dispone.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your own digraphs.  Example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede configurar sus propios dígrafos. Ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	:digraph a" 228
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	:digraph a" 228
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about digraphs here: |digraphs|
   Another way to insert special characters is with a keymap.  More about that
here: |45.5|
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más información acerca de los dígrafos, consulte: |digraphs|
   Otra manera de insertar caracteres especiales es un «keymap». Puede leer
más acerca de esto aquí: |45.5|
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.10*	Normal mode commands
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.10*	Órdenes del modo Normal
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode offers a limited number of commands.  In Normal mode you have many
more.  When you want to use one, you usually leave Insert mode with &lt;Esc&gt;,
execute the Normal mode command, and re-enter Insert mode with "i" or "a".
   There is a quicker way.  With CTRL-O {command} you can execute any Normal
mode command from Insert mode.  For example, to delete from the cursor to the
end of the line: &gt;
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Insertar ofrece un limitado número de órdenes. Dispone de muchas más
en el modo normal. Si desea usar uno, abandone el modo Insertar con &lt;Esc&gt;,
ejecuto la orden en modo Normal, y vuelva al modo Insertar con «i» o «a».
   Hay una manera más rápida. Con CTRL-O {orden} puede ejecutar cualquier
orden de modo Normal en el modo Insertar. Por ejemplo, para eliminar desde
el cursor hasta el final de la línea: &gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-O D
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-O D
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can execute only one Normal mode command this way.  But you can specify a register or a count.  A more complicated example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo puede ejecutar una orden de modo Normal de esta manera. Pero puede especificar un registro o cuenta. Aquí tiene una manera más complicada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>	CTRL-O "g3dw
</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>	CTRL-O "g3dw
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM USER MANUAL - by Bram Moolenaar</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MANUAL DE USUARIO DE VIM - por Bram Moolenaar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_10.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_10.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2006 Nov 05</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 5/11/2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Making big changes</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Realizar grandes cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 4 several ways to make small changes were explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 4 se explicaron algunas formas de hacer cambios pequeños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter goes into making changes that are repeated or can affect a large amount of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo tratará de cambios que se repiten o que afectan a grandes porciones del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Visual mode allows doing various things with blocks of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Visual permite hacer varias cosas con bloques de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use an external program to do really complicated things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use un programa externo para hacer las cosas más complicadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|10.1|	Record and playback commands
|10.2|	Substitution
|10.3|	Command ranges
|10.4|	The global command
|10.5|	Visual block mode
|10.6|	Reading and writing part of a file
|10.7|	Formatting text
|10.8|	Changing case
|10.9|	Using an external program</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|10.1|	Órdenes de grabación y reproducción
|10.2|	Sustitución
|10.3|	Rangos de aplicación
|10.4|	Las órdenes globales
|10.5|	El modo de bloque Visual
|10.6|	Leer y escribir parte de un archivo
|10.7|	Formatear texto
|10.8|	Cambiar mayúsculas y minúsculas
|10.9|	Uso de un programa externo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_11.txt|  Recovering from a crash
 Previous chapter: |usr_09.txt|  Using the GUI
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_11.esx|  Recuperarse de un fallo
  Capítulo anterior: |usr_09.esx|  Uso de la interfaz gráfica
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.1*	Record and playback commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.1*	Órdenes de grabación y reproducción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." command repeats the preceding change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «.» repite el cambio precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But what if you want to do something more complex than a single change?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Pero qué ocurre si quiere hacer algo más complicado que un simple cambio?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's where command recording comes in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eso tenemos la orden de grabación («:recording»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three steps:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay que seguir tres pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "q{register}" command starts recording keystrokes into the register
   named {register}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «q{registro}» inicia la grabación de teclas pulsadas en un registro
   llamado{registro}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The register name must be between a and z.
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del registro debe estar en el rango (a-z).
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type your commands.
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introduzca sus órdenes.
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To finish recording, press q (without any extra character).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse q para detener la grabación (sin ningún carácter adicional).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take a look at how to use these commands in practice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a echarle un vistazo a cómo se usan las órdenes en la práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have a list of filenames that look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene una lista de nombres de archivo como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>stdio.h ~
	fcntl.h ~
	unistd.h ~
	stdlib.h ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#include "stdio.h" ~
	#include "fcntl.h" ~
	#include "unistd.h" ~
	#include "stdlib.h" ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start by moving to the first character of the first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comienza desplazándose al primer carácter de la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you execute the following commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación ejecute la siguiente orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qa			Start recording a macro in register a.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>qa			Comenzar a grabar la macro en el registro «a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>^			Move to the beginning of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>^			Ir al comienzo de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i#include "&lt;Esc&gt;	Insert the string #include " at the beginning
				of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>i#include "&lt;Esc&gt;	Insertar el #include " al comienzo de cada
				línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$			Move to the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>$			Ir al final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a"&lt;Esc&gt;			Append the character double quotation mark (")
				to the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a"&lt;Esc&gt;			Añadir el carácter de comillas dobles (") al
				final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>j			Go to the next line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>j			Ir a la próxima línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>q			Stop recording the macro.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>q			Detener la grabación de la macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you have done the work once, you can repeat the change by typing the
command "@a" three times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que ha realizado el trabajo una vez, puede repetir el cambio tecleando
la orden «@a» tres veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "@a" command can be preceded by a count, which will cause the macro to
be executed that number of times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «@a» puede venir precedido de un multiplicador, el cuál causará
que la macro se ejecute ese número determinado de veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case you would type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3@a</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3@a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have the lines you want to change in various places.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez tenga las líneas que quiere cambiar en varios lugares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just move the
cursor to each location and use the "@a" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente
mueva el cursor a cada ubicación y use la orden «@a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have done that once,
you can do it again with "@@".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha hecho eso
una vez, puede repetirlo con «@@».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a bit easier to type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un poco más sencillo de teclear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now
execute register b with "@b", the next "@@" will use register b.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si
ejecuta el registro b con «@b», el próximo «@@» usará el registro b.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you compare the playback method with using ".", there are several
differences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si compara esto con el método «.», hay varias diferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, "." can only repeat one change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo primero,
«.x sólo puede repetir un cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As seen in the
example above, "@a" can do several changes, and move around as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como ha podido ver en el ejemplo de
arriba, «@a» puede llevar a cabo varios cambios, incluyendo movimientos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secondly, "." can only remember the last change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
otro lado, «.» sólo puede recordar el último cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executing a register allows
you to make any changes and then still use "@a" to replay the recorded
commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecutar un registro le
permite hacer algunos cambios en el texto y poder usar todavía las órdenes
grabadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, you can use 26 different registers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, puede usar 26 registros distintos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can remember
26 different command sequences to execute.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo
puede reusar 26 secuencias diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The registers used for recording are the same ones you used for yank and
delete commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los registros que se usan para grabar son los mismos que se usan para las
órdenes de copiar y eliminar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to mix recording with other commands to
manipulate the registers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite mezclar la grabación con otras
órdenes para manipular los registros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have recorded a few commands in register n.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que ha grabado algunas órdenes en el registro n.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you execute
this with "@n" you notice you did something wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando lo
ejecuta con «@n», se da cuenta de que algo no va bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could try recording
again, but perhaps you will make another mistake.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Podría intentar
grabarlo de nuevo, pero quizá cometa otro error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, use this trick:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mejor usar este truco:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can execute the corrected commands with "@n".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede ejecutar las órdenes corregidas con «@n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If your recorded commands include line breaks, adjust the last two items in the example to include all the lines.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si las órdenes grabadas incluyen saltos de línea, ajuste los dos últimos puntos explicados anteriormente para incluir todas las líneas.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have used a lowercase letter for the register name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta el momento hemos usado letras en minúscula para el nombre del registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To append to a
register, use an uppercase letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para añadir a un registro, use una letra en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have recorded a command to change a word to register c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga por un momento que ha grabado una orden para cambiar una
palabra en el registro c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It
works properly, but you would like to add a search for the next word to
change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Funciona correctamente, pero quisiera añadir una
búsqueda para la siguiente palabra a cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede hacer así: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qC/word&lt;Enter&gt;q</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>qC/palabra&lt;Entrar&gt;q</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start with "qC", which records to the c register and appends.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comience con «qC», que añadirá al registro c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus writing to an uppercase register name means to append to the register with the same letter, but lowercase.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo siempre podrá escribir el registro al que quieras añadir nuevos pasos mediante la misma de letra de identificación, pero en mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works both with recording and with yank and delete commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona tanto grabando como y con las órdenes de copiar y eliminar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you want to collect a sequence of lines into the a register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, quieres reunir una secuencia de líneas en un registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yank the first line with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie la primera línea con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"aY</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"aY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"AY</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"AY</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeat this command for all lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repita la orden para todas las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The a register now contains all those lines, in the order you yanked them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El registro «a» contiene ahora todas estas líneas, en el orden en el que las ha copiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.2*	Substitution						*find-replace*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.2*	Sustitución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":substitute" command enables you to perform string replacements on a whole range of lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:substitute» le permite ejecutar sustituciones de cadenas de caracteres en un rango de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The general form of this command is as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma general es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:[range]substitute/from/to/[flags]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:[rango]substitute/de/a/[opciones]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command changes the "from" string to the "to" string in the lines specified with [range].</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden cambia la cadena «de» por la cadena «a» en las líneas especificadas con [rango].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can change "Professor" to "Teacher" in all lines with the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, puede cambiar «profesor» por «maestro» en todas las líneas con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%substitute/Professor/Teacher/
&lt;
	Note:
	The ":substitute" command is almost never spelled out completely.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%substitute/profesor/maestro/
&lt;
	Nota:
	La orden «:substitute» casi nunca se escribe completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time, people use the abbreviated version ":s".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría
	de las veces la gente escribe la versión abreviada ":s".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From here
	on the abbreviation will be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A partir de
	ahora, se empleará la abreviatura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "%" before the command specifies the command works on all lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «%» antes de la orden especifica que se ejecuta en todas las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without a range, ":s" only works on the current line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin rango, «:s» sólo funciona en la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about ranges in the next section |10.3|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más sobre los rangos en la próxima sección |10.3|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the ":substitute" command changes only the first occurrence on each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, la orden «:substitute» cambia sólo la primera palabra encontrada en cada línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the preceding command changes the line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la orden anterior cambia esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Professor Smith criticized Professor Johnson today.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El profesor Pinilla ha criticado hoy al profesor Burgos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Teacher Smith criticized Professor Johnson today.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El maestro Pinilla ha criticado hoy al profesor Burgos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change every occurrence on the line, you need to add the g (global) flag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para cambiar todas palabras que aparezcan en la línea deberá usar la opción g (global).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/Professor/Teacher/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/profesor/maestro/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Teacher Smith criticized Teacher Johnson today.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El maestro Pinilla ha criticado hoy al maestro Burgos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other flags include p (print), which causes the ":substitute" command to print out the last line it changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otras opciones incluyen p (print = imprimir), que hace la orden «:s» muestre en pantalla la última línea que cambió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The c (confirm) flag tells ":substitute" to ask you for confirmation before it performs each substitution.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «c» (confirm = confirmar) le dice a «:s» que pida confirmación antes que se ejecute cada sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the following: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introduzca lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/Professor/Teacher/c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/profesor/maestro/c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim finds the first occurrence of "Professor" and displays the text it is about to change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encuentra la primera aparición de «profesor» y muestra el texto que está a punto de cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get the following prompt: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le aparecerá la siguiente pregunta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>replace with Teacher (y/n/a/q/l/^E/^Y)?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>replace with maestro (y/n/a/q/l/^E/^Y)?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>y		Yes; make this change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>y               Si; hacer el cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>n		No; skip this match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>n               No; omitir esta coincidenci.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a		All; make this change and all remaining ones without
			further confirmation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a               Todo; hacer este cambio y todos los restantes sin
			pedir más confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>q		Quit; don't make any more changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>q               Quit; no hacer más cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>l		Last; make this change and then quit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>l               Último; hacer este cambio y salir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-E		Scroll the text one line up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-E          Desplazar el texto hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-Y		Scroll the text one line down.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-Y          Desplazar el texto hacia abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s/^the/these/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s/^Eso/Aquello/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are substituting with a "from" or "to" part that includes a slash, you need to put a backslash before it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sustituye con una parte «de» o «a» que incluyan una barra inclinada, tendrá que poner una barra inversa antes de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simpler way is to use another character instead of the slash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma más sencilla es usar otro carácter como separador en lugar de la barra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A plus, for example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «+», por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s+one/two+one or two+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s+uno/dos+uno o dos+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.3*	Command ranges</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.3*	Rangos de aplicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":substitute" command, and many other : commands, can be applied to a
selection of lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:substitute» y muchas otras órdenes «:» se pueden aplicar a
una selección de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called a range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le llama rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simple form of a range is {number},{number}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma más simple de un rango es {n},{n} (n es un número entero).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:1,5s/this/that/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:1,5s/esto/aquello/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executes the substitute command on the lines 1 to 5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecuta la orden sustituir desde la línea 1 a la 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Line 5 is included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea 5 queda incluida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The range is always placed before the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El rango se sitúa justo antes de la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:54s/President/Fool/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:54s/Político/Demagogo/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands work on the whole file when you do not specify a range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes funcionan sobre un archivo completo cuando no le especifica un rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make them work on the current line the "." address is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacerlos funcionar en la línea actual, use «.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":write" command works like that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:write» funciona de ese modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without a range, it writes the whole file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin un rango, escribe el archivo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make it write only the current line into a file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que sólo escriba una línea a un archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.write otherfile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.write otroarchivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first line always has number one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera línea siempre tiene como numeración el 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How about the last line?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Pero qué ocurre con la última línea?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" character is used for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el carácter «$» ppara esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to substitute in the lines from the cursor to the end: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para sustituir en las líneas desde la del cursor hasta el final: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.,$s/yes/no/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.,$s/si/no/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you are editing a chapter in a book, and want to replace all occurrences of "grey" with "gray".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editado un capítulo de un libro y que desea reemplazar todas las palabras «grisx con «blanco».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But only in this chapter, not in the next one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero sólo en ese capítulo, no en el siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You know that only chapter boundaries have the word "Chapter" in the first column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sabe que los límites entre capítulos tienen la palabra «Capítulo» en la primera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will work then: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden funcionaría aquí: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:?^Chapter?,/^Chapter/s=grey=gray=g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:?^Capítulo?,/^Capítulo/s=gris=azul=g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see a search pattern is used twice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede observar que un patrón se ha usado en dos ocasiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first "?^Chapter?" finds the
line above the current position that matches this pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera
«?^Chapter?» busca el patrón en sentido inverso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the ?pattern?
range is used to search backwards.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto «?patrón?»
buscará encima de la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, "/^Chapter/" is used to search
forward for the start of the next chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De forma similar, «/^Capítulo/» se usa para
buscar hacia delante el comienzo del nuevo capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid confusion with the slashes, the "=" character was used in the
substitute command here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar confusión con las barras, el carácter «=» se ha empleado en
la orden sustituir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A slash or another character would have worked as
well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una barra o cualquier otro carácter habría funcionado
igual de bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a slight error in the above command: If the title of the next chapter
had included "grey" it would be replaced as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño error en la orden de arriba: Si el título del siguiente
capítulo hubiese incluido «grisx habría sido reemplazado igualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maybe that's what you
wanted, but what if you didn't?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quizá
quería eso, ¿pero qué ocurre si no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can specify an offset.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede especificar un «offset».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search for a pattern and then use the line above it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para buscar un patrón e indicar la línea anterior: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/Chapter/-1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/Capítulo/-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any number instead of the 1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar cualquier número en lugar de 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To address the second line below the match: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para indicar la segunda línea por debajo de la cadena encontrada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/Chapter/+2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/Capítulo/+2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The offsets can also be used with the other items in a range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El desplazamiento se puede emplear también con otros elementos en un rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at this one: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.+3,$-5</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.+3,$-5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of figuring out the line numbers of certain positions, remembering them
and typing them in a range, you can use marks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de adivinar el número de algunas líneas en determinadas posiciones,
e introducirlas en un rango, puede usar marcadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Place the marks as mentioned in chapter 3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga marcas como se explica en el capítulo 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, use "mt" to mark
the top of an area and "mb" to mark the bottom.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, usa «ms» para
marcar la parte superior de un área y «mi» para marcar la parte inferior".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use this range
to specify the lines between the marks (including the lines with the marks): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el rango para especificar las líneas entre las marcas
(inclusive): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:'t,'b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:'t,'b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can select text with Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede seleccionar texto con el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you then press ":" to start a colon command, you will see this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa «:» para iniciar una orden, verá lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:'&lt;,'&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:'&lt;,'&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	When using Visual mode to select part of a line, or using CTRL-V to
	select a block of text, the colon commands will still apply to whole
	lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Cuando use el modo Visual para seleccionar parte de una línea, o use
	CTRL-V para seleccionar un bloque de texto, las órdenes se aplicarán
	a líneas completas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This might change in a future version of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que esto cambie en una futura versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The '&lt; and '&gt; are actually marks, placed at the start and end of the Visual selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los «'&lt;» y «'&gt;» son marcadores que se sitúan al principio y al final de la selección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The marks remain at their position until another Visual selection is made.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos marcadores mantienen estas posiciones hasta que aparece una nueva selección Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can use the "'&lt;" command to jump to position where the Visual area started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, puede usar la orden «"'&lt;"» para saltar al lugar donde el área Visual comenzaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And you can mix the marks with other items: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede mezclarlas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:'&gt;,$</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:'&gt;,$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you know how many lines you want to change, you can type the number and then ":".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando sepa cuántas líneas quieres cambiar, puede teclear el número y luego «:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when you type "5:", you will get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si, por ejemplo, escribe «5:» obtendrá: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.,.+4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.,.+4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can type the command you want to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puedes ejecutar la orden que quiera usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will use the range "." (current line) until ".+4" (four lines down).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usará el rango «.» (línea actual) hasta «.+4» (cuatro líneas más).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it spans five lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará un total de cinco líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.4*	The global command</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.4*	Las órdenes globales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":global" command is one of the more powerful features of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:global» es una de las características más potentes de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It allows you to find a match for a pattern and execute a command there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Permite que encuentre una cadena con un patrón y ejecute una orden en esa ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The general form is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El formato habitual es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:[range]global/{pattern}/{command}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:[rango]global/{patrón}/{orden}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to the ":substitute" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es similar a la orden «:substitute».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, instead of replacing the matched text with other text, the command {command} is executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero en lugar de reemplazar el texto concordado con otro texto, la orden {orden} se ejecutará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	The command executed for ":global" must be one that starts with a
	colon.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	La orden ejecutada con «:global» debe ser uno que comience con un
	punto y coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normal mode commands can not be used directly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes para el modo Normal no se pueden emplear de
	forma directa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:normal|
	command can do this for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esto se encargará |:normal|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to change "foobar" to "barfoo", but only in C++ style comments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiere cambiar «foobar» por «barfoo», pero solamente en los comentarios de C++.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These comments start with "//".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos comentarios empiezan por «//».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:g+//+s/foobar/barfoo/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:g+//+s/foobar/barfoo/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with ":substitute", any pattern can be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como ocurre con «:substitute», puede emplear cualquier patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you learn more complicated patterns later, you can use them here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando aprenda patrones más complicados, podrá usarlos aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.5*	Visual block mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.5*	El modo de bloque Visual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With CTRL-V you can start selection of a rectangular area of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con CTRL-V puede seleccionar un área rectangular de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few commands that do something special with the text block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algunas órdenes que hacen algo especial con los bloques de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include one ~
	include two ~
	include three ~
	include four ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>include uno ~
	include dos ~
	include tres ~
	include cuatro ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the "o" of "one" and press CTRL-V.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a la «u» de «uno» y presione CTRL-V.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move it down with "3j" to "four".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplácese hacia abajo con «3j» hasta«"cuatro».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have a block selection that spans four lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene una selección que abarca cuatro líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imain.&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imain.&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>include main.one ~
	include main.two ~
	include main.three ~
	include main.four ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>include main.uno ~
	include main.dos ~
	include main.tres ~
	include main.cuatro ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the block spans short lines that do not extend into the block, the text is not inserted in that line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el bloque abarca líneas que no caben dentro del área del bloque, el texto no se insertará en esa línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, make a Visual block selection that includes the word "long" in the first and last line of this text, and thus has no text selected in the second line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, haga un bloque Visual que no incluya la palabra «larga» en la primera y última línea de este texto, de manera que no se seleccione texto en la segunda línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a long line ~
	short ~
	Any other long line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea larga ~
	corta ~
	Cualquier es una línea larga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>^^^^ selected block</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>^^^^^ bloque seleccionado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the command "Ivery &lt;Esc&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora usa la orden «Imuy &lt;Esc&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a very long line ~
	short ~
	Any other very long line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea muy larga ~
	corta ~
	Esto es una línea muy larga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "A" command works the same way, except that it appends after the right
side of the block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «A» funciona de la misma manera, excepto que se añade a la derecha
del bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And it does insert text in a short line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso sí se añade al final de la línea corta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can
make a choice whether you do or don't want to append text to a short line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este
modo puede elegir si quieres añadir o no un texto a la línea corta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one special case for "A": Select a Visual block and then use "$"
to make the block extend to the end of each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un caso especial para «Ax: seleccione un bloque Visual y pulsw «$» para
hacer que el bloque se extienda al final de cada línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "A" now will append
the text to the end of each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «A» añadirá el
texto al final de cada línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the same example from above, and then typing "$A XXX&lt;Esc&gt;, you get
this result:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De usar el mismo ejemplo que arriba y teclear «$A XXX&lt;Esc&gt;» obtendría el
siguiente resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a long line XXX ~
	short XXX ~
	Any other long line XXX ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea larga XXX~
	corta XXX~
	Esto es una línea larga XXX~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This really requires using the "$" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto requiere el uso de la orden «$».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim remembers that it was used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim recordará que los ha usado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Making the same selection by moving the cursor to the end of the longest line with other movement commands will not have the same result.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hacer la misma selección con el cursor hasta el final de la línea más larga con otras órdenes no te dará el mismo resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Visual block "c" command deletes the block and then throws you into Insert
mode to enable you to type in a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden de bloque Visual «c» elimina el bloque y le devuelve al modo
Insertar para que escriba en una cadena de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The string will be inserted in each
line in the block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La cadena se
insertará en cada línea del bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with the same selection of the "long" words as above, then typing
"c_LONG_&lt;Esc&gt;", you get this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comenzando con la misma selección que las palabras zlarga» de arriba,
y teclear después «c_LARGA_&lt;Esc&gt;», le daría esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a _LONG_ line ~
	short ~
	Any other _LONG_ line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea _LARGA_ ~
	corta ~
	Esto es una línea _LARGA_ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with "I" the short line is not changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como ocurre con «Ix, la línea corta no cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, you can't enter a newline in the new text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Del mismo modo, no podrá introducir una nueva línea en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a new text ~
	short ~
	Any other new text ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es un texto nuevo ~
	corta ~
	Esto es un texto nuevo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that, even though only the "long" word was selected, the text after it
is deleted as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que aunque sólo se seleccionó la palabra «larga», el texto
tras ella fue eliminado igualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus only the location of the left edge of the visual
block really matters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto sólo la posición del borde
izquierdo del eje izquierdo importa realmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, short lines that do not reach into the block are excluded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, las palabras que no forman parte del bloque se excluyen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fill the whole block with one character, use the "r" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para rellenar un bloque completo con un sólo carácter, usw la orden «r».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, starting with the same example text from above, and then typing "rx":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruébelo de nuevo con el texto de antes, pulsando «rx»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a xxxx line ~
	short ~
	Any other xxxx line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea larga ~
	corta ~
	Cualquier es una línea larga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	If you want to include characters beyond the end of the line in the
	block, check out the 'virtualedit' feature in chapter 25.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Si desea incluir los caracteres más allá del final de línea en el
	bloque, consulte la opción 'virtualedit' en el capítulo 25.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command "&gt;" shifts the selected text to the right one shift amount,
inserting whitespace.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «&gt;» empuja el texto hacia la derecha un espacio determinado,
insertando espacios en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The starting point for this shift is the left edge of
the visual block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El punto base empleado para esta operación es
el borde izquierdo del bloque visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the same example again, "&gt;" gives this result:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con el mismo ejemplo de nuevo, «&gt;» le da el resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a	  long line ~
	short ~
	Any other	  long line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una	línea larga ~
	corta ~
	Esto es una	línea larga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The shift amount is specified with the 'shiftwidth' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio del desplazamiento se especifica con la opción 'shiftwidth".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change it to use 4 spaces: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para cambiarlo a cuatro espacios: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set shiftwidth=4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set shiftwidth=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "&lt;" command removes one shift amount of whitespace at the left edge of the block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «&lt;» desplaza por cada empuje la misma cantidad de espacios en blanco hacia la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command is limited by the amount of text that is there; so if there is less than a shift amount of whitespace available, it removes what it can.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden se limita al texto que se encuentre, de manera que eliminará la cantidad de espacio en blanco disponible sin sobreescribir texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a long line short Any other long line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una línea larga corta Esto es una línea larga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "J" command doesn't require a blockwise selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «J» no requiere selección de bloques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works with "v" and "V" selection in exactly the same way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Funciona de igual modo con la selección «v» y «V».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.6*	Reading and writing part of a file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.6*	Leer y escribir parte de un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hi John, ~
	Here is the diff that fixes the bug: ~
	Bye, Pierre.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hola Juan, ~
	Aquí tienes el parche que arregla el problema: ~
	Un saludo, Pedro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:read patch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:read parche</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hi John, ~
	Here is the diff that fixes the bug: ~
	2c2 ~
	&lt;	for (i = 0; i &lt;= length; ++i) ~
	--- ~
	&gt;	for (i = 0; i &lt; length; ++i) ~
	Bye, Pierre.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hola Juan, ~
	Aquí tienes el parche que arregla el problema: ~
	2c2 ~
	&lt;	for (i = 0; i &lt;= length; ++i) ~
	--- ~
	&gt;	for (i = 0; i &lt; length; ++i) ~
	Un saludo, Pedro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":read" command accepts a range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:read» acepta un rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file will be put below the last line
number of this range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo será colocado justo debajo de
la última línea de este rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus ":$r patch" appends the file "patch" at the end of
the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, «:$r parche» añadirá el
archivo «parche» al final del actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What if you want to read the file above the first line?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Qué ocurre si quiere pegar el archivo encima de la primera línea?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done
with the line number zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto
se puede realizar con el número de línea cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line doesn't really exist, you will get an
error message when using it with most commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este número de línea en
realidad no existe, lo cuál hará que con muchas órdenes reciba un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this command is allowed:
&gt;
	:0read patch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
&gt;
:0read parche</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write a range of lines to a file, the ":write" command can be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para guardar un rango de líneas en un archivo puede usar la orden «:write».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without a range it writes the whole file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin el rango esto guardará el archivo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With a range only the specified lines are written: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero con un rango especificado únicamente las líneas que se especifiquen se escribirán: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.,$write tempo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.,$write tempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This writes the lines from the cursor until the end of the file into the file "tempo".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará las líneas desde el cursor hasta el final del texto en el archivo «tempo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this file already exists you will get an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si este archivo existe actualmente obtendrá un mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim protects you from accidentally overwriting an existing file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le protege de que sobreescriba un archivo preexistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you know what you are doing and want to overwrite the file, append !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sabe lo que hace y quiere sobreescribirlo, añada «!»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.,$write! tempo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.,$write! tempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CAREFUL: The ! must follow the ":write" command immediately, without white space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CUIDADO: El «!» debe ponerse justo después de la orden «:write», sin el espacio en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise it becomes a filter command, which is explained later in this chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, se convierte en una orden de filtro, el cuál se explica en el capítulo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first section of this chapter was explained how to collect a number of lines into a register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera sección de este capítulo se explicó cómo reunir una serie de líneas en un registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same can be done to collect lines in a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede hacer lo mismo para reunir líneas en un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write the first line with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba una primera línea con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.write collection</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.write archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:.write &gt;&gt;collection</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:.write &gt;&gt;archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "&gt;&gt;" tells Vim the "collection" file is not to be written as a new file,
but the line must be appended at the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «&gt;&gt;» le dice a Vim que «archivo» no se debe escribir como un nuevo
archivo sino que la línea se deba añadir al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat this as many times
as you like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir esto
tantas veces como desee.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.7*	Formatting text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.7*	Formatear texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are typing plain text, it's nice if the length of each line is automatically trimmed to fit in the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando introducza texto, tal vez le resulta útil que, si la longitud de cada línea supera un número, sea automáticamente partida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make this happen while inserting text, set the 'textwidth' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer esto posible, active la opción 'textwidth': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set textwidth=72</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set textwidth=72</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might remember that in the example vimrc file this command was used for every text file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quizá se acuerde de que en el ejemplo de archivo «vimrc» esta orden era empleada para cualquier tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if you are using that vimrc file, you were already using it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, si está usando ese archivo «vimrc», ya lo tiene activado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To check the current value of 'textwidth': &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para comprobar el valor actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set textwidth</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set textwidth</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gqap</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gqap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	A blank line, which contains white space, does NOT separate
	paragraphs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Una línea que contiene espacios en blanco NO separa párrafos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is hard to notice!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto
	suele ser difícil de notar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of "ap" you could use any motion or text object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de «ap» puede usar cualquier movimiento u objeto de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your paragraphs are properly separated, you can use this command to format the whole file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sus párrafos están adecuadamente separados, puede usar esto para formatear todo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gggqG</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gggqG</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.8*	Changing case</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.8*	Cambiar mayúsculas y minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have text with section headers in lowercase.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene texto con las cabeceras de sección en minúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to make the word "section" all uppercase.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quiere que la palabra «sección» esté en mayúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this with the "gU" operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacerlo con el operador «gU».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start with the cursor in the first column: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comience con el cursor en la primera columna: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gUw
&lt;	section header	    ----&gt;      SECTION header</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gUw
&lt;	cabecera de sección ----&gt;      cabecera de SECCIÓN</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>guw
&lt;	SECTION header	    ----&gt;      section header</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>guw
	cabecera de SECCIÓN ----&gt;      cabecera de sección</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>g~~ 
&lt;	Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>g~~ 
	Algunas CHICAS se divierten  ----&gt;  aLGUNAS chicas SE DIVIERTEN ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*10.9*	Using an external program</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*10.9*	Uso de un programa externo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a very powerful set of commands, it can do anything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene un conjunto de órdenes muy potente para hacer cualquier cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But there may
still be something that an external command can do better or faster.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero siempre hay un programa externo que es mejor para una tarea específica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command "!{motion}{program}" takes a block of text and filters it
through an external program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «!{movimiento}{programa}» recoge un bloque de un texto y lo
filtra a través de un programa externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, it runs the system command
represented by {program}, giving it the block of text represented by {motion}
as input.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, ejecuta la
orden de sistema {programa}, dándole el bloque de texto representado por
{movimiento} como entrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output of this command then replaces the selected block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida de la orden sustituirá la selección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que esto requiere más explicación si no usa los filtros UNIX
habitualmente, veamos un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The sort command sorts a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «sort» ordena un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si
ejecuta lo siguiente, el archivo desordenado entrada.txt será ordenado y
guardado en output.txt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(This works on both UNIX and Microsoft Windows.) &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Esto funciona en UNIX y en Windows.) &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sort &lt;input.txt &gt;output.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>sort &lt;input.txt &gt;output.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now do the same thing in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora haga lo mismo en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to sort lines 1 through 5 of a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea ordenar las líneas de la 1 a la 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start by putting the cursor on line 1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para comenzar, ponga el cursor en la línea 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación ejecute la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>!5G</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>!5G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!" tells Vim that you are performing a filter operation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «!» le dice a Vim que está realizando una operación filtro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor
Vim espera que introduzca a continuación un orden de movimiento para saber
qué filtrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "5G" command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «5G» le dice a Vim que vaya a la línea 5, de forma
que sepa que tiene que filtrar desde la línea 1 (la actual) hasta la 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de filtrar nada, la línea de órdenes se activa y muestra un «!».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now type in the name of the filter
program, in this case "sort".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora es el momento de que escriba el filtro, en este caso «sort».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, your full command is as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo
tanto, la orden completo sería: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>!5Gsort&lt;Enter&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>!5Gsort&lt;Entrar&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is that the sort program is run on the first 5 lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es que se ejecuta el programa «sort» sobre las 5 primeras líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output of the program replaces these lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida del programa reemplaza estas líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>line 55			      line 11
	line 33			      line 22
	line 11		--&gt;	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>línea 55		      línea 11
	línea 33		      línea 22
	línea 11	--&gt;	      línea 33
	línea 22		      línea 44
	línea 44		      línea 55
	última línea		      última línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!!" command filters the current line through a filter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «!!» filtra la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Unix the "date" command prints the current time and date.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, la orden »date» imprime la hora y fecha actuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"!!date&lt;Enter&gt;" replaces the current line with the output of "date".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«!!date&lt;Entrar&gt;» reemplaza la línea actual con la salida de «date».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to add a timestamp to a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil para añadir una marca de tiempo al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting a shell, sending it text and capturing the output requires that Vim knows how the shell works exactly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciar la consola, enviarle texto y capturar la salida requiere que Vim sepa exactamente cómo funciona la consola de forma precisa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have problems with filtering, check the values of these options:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tenga problemas con el filtrado, comprueba los valores de las siguientes opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'shell'		specifies the program that Vim uses to execute
			external programs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'shell'		especifica el programa que Vim empleará para ejecutar
			programas externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'shellcmdflag'	argument to pass a command to the shell
	'shellquote'	quote to be used around the command
	'shellxquote'	quote to be used around the command and redirection
	'shelltype'	kind of shell (only for the Amiga)
	'shellslash'	use forward slashes in the command (only for
			MS-Windows and alikes)
	'shellredir'	string used to write the command output into a file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'shellcmdflag'	argumento para pasar un orden a la consola
	'shellquote'	comillas a usar alrededor de la orden
	'shellxquote'	comillas a usar alrededor de la orden y redirección
	'shelltype'	tipo de consola (sólo para Amiga)
	'shellslash'	usar barras inclinadas en la orden (sólo para
			Windows y similares)
	'shellredir'	cadena para escribir la salida a un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix this is hardly ever a problem, because there are two kinds of shells:
"sh" like and "csh" like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix esto es raramente un problema, porque hay dos tipos de consola: «sh» y
«csh».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim checks the 'shell' option and sets related
options automatically, depending on whether it sees "csh" somewhere in
'shell'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim comprueba la opción 'shell' y configura todo automáticamente,
dependiendo de si ve «cshx en algún lugar de 'shell'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, en Windows, hay muchos tipos de consolas y quizá tenga que
ajustar las opciones para hacer que el filtrado funcione correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the help for the options
for more information.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busque en la ayuda más información sobre las opciones de configuración
de la consola para poder solucionarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>on Unix: &gt;
	:read !ls
on MS-Windows: &gt;
	:read !dir</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>en Unix: &gt;
	:read !ls
en MS-Windows: &gt;
	:read !dir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output of the "ls" or "dir" command is captured and inserted in the text,
below the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida de las órdenes «ls» o «dir» se puede capturar e insertar en el
texto, debajo del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to reading a file, except that the "!" is
used to tell Vim that a command follows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es similar a leer un archivo, excepto que el
«!» se emplea para decirle a Vim que hay una orden a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command may have arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que la orden tenga argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And a range can be used to tell where Vim
should put the lines: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede emplear un rango para
decirle a Vim dónde debería poner las líneas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:0read !date -u</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:0read !date -u</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This inserts the current time and date in UTC format at the top of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto inserta la hora y fecha actuales en formato UTC en la primera línea del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Well, if you have a date command that accepts the "-u" argument.)  Note the difference with using "!!date": that replaced a line, while ":read !date" will insert a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Bueno, si tienes una orden «date» que acepta el argumento «-u».) Tenga en cuenta la diferencia de usar «!!date»; esto reemplazó una línea, mientras que «:read !date» insertó una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Unix command "wc" counts words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden Unix «wc» cuenta palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To count the words in the current file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para contar las del archivo actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write !wc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write !wc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the same write command as before, but instead of a file name the "!" character is used and the name of an external command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la misma orden «write» vista que anteriormente, pero en lugar de un nombre de archivo, se emplean el carácter «!» y una orden externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The written text will be passed to the specified command as its standard input.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto guardado será pasado al orden especificado como entrada estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>4      47     249 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>4      47     249 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "wc" command isn't verbose.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «wc» no es muy informativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means you have 4 lines, 47 words and 249 characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que tiene 4 líneas, 47 palabras y 249 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write! wc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write! wc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will write the file "wc" in the current directory, with force.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará el archivo «wc» en el directorio actual con la opción «force» (forzar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>White space is important here!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡El espacio en blanco es muy importante en este caso!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the external command produced an error message, the display may have been messed up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la orden externa produjo un mensaje de error, la pantalla de Vim tal vez esté sobreescrita con información confusa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim is very efficient and only redraws those parts of the screen that it knows need redrawing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim es muy eficiente y sólo reescribe aquellas partes de la pantalla que lo necesiten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it can't know about what another program has written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero no puede saber sobre lo que otro programa ha tocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To tell Vim to redraw the screen: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para decirle a Vim que redibuje la pantalla: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-L</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-L</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_20.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_20.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing command-line commands quickly</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ser eficaz con la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a few generic features that makes it easier to enter commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim posee algunas características genéricas que le facilitan introducir órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Colon commands can be abbreviated, edited and repeated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes de colon («:») se pueden abreviar, editar y repetir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Completion is available for nearly everything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dispone de auto compleción para prácticamente todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|20.1|	Command line editing
|20.2|	Command line abbreviations
|20.3|	Command line completion
|20.4|	Command line history
|20.5|	Command line window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|20.1|	Edición en línea de órdenes
|20.2|	Abreviaturas en línea de órdenes
|20.3|	Autocompletado en la línea de órdenes
|20.4|	Histórico de la línea de órdenes
|20.5|	Ventana de la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_21.txt|  Go away and come back
 Previous chapter: |usr_12.txt|  Clever tricks
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_21.esx| Abandonar el editor y volver
  Capítulo anterior: |usr_12.esx| Trucos ingeniosos
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.1*	Command line editing</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.1*	Edición en línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use a colon (:) command or search for a string with / or ?, Vim puts the cursor on the bottom of the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa una orden de colon («:») o busca una cadena con «/» o «?», Vim sitúa el cursor en la parte inferior de la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There you type the command or search pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahí es donde introduce la orden o el patrón de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called the Command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le llama la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also when it's used for entering a search command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También cuando se usa para introducir una orden de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most obvious way to edit the command you type is by pressing the &lt;BS&gt; key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera más obvia de editar la orden introducida es pulsando la tecla &lt;BS&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This erases the character before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina el carácter anterior al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To erase another character,
typed earlier, first move the cursor with the cursor keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar otro carácter
introducido previamente, desplace antes el cursor con las teclas del cursos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you have typed this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, suponga que ha tecleado esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s/col/pig/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s/vaba/cerdo/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you hit &lt;Enter&gt;, you notice that "col" should be "cow".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de pulsar &lt;Intro&gt;, notará que «vaba» debería ser «vaca».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To correct this, you type &lt;Left&gt; five times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para corregir esto, pulse &lt;Izquierda&gt; seis veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is now just after "col".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está ahora sobre «vaba».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type &lt;BS&gt; and "w" to correct: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee &lt;BS&gt; y «w» para corregirlo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s/cow/pig/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s/vaca/cerdo/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can press &lt;Enter&gt; directly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya puede pulsar &lt;Intro&gt; directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to move the cursor to the end of the line before executing the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No tiene que desplazar el cursor al final de la línea antes de ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Left&gt;			one character left
	&lt;Right&gt;			one character right
	&lt;S-Left&gt; or &lt;C-Left&gt;	one word left
	&lt;S-Right&gt; or &lt;C-Right&gt;	one word right
	CTRL-B or &lt;Home&gt;	to begin of command line
	CTRL-E or &lt;End&gt;		to end of command line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Izquierda&gt;		un carácter a la izquierda
	&lt;Derecha&gt;		un carácter a la derecha
	&lt;S-Izq.&gt; o &lt;C-Izq.&gt;	una palabra a la izquierda
	&lt;S-Der.&gt; o &lt;C-Der.&gt;	una palabra a la derecha
	CTRL-B o &lt;Inicio&gt;	al inicio de la línea de órdenes
	CTRL-E o &lt;Fin&gt;		al final de la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	&lt;S-Left&gt; (cursor left key with Shift key pressed) and &lt;C-Left&gt; (cursor
	left key with Control pressed) will not work on all keyboards.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	&lt;S-Izq.&gt; (tecla izquierda del cursor con la tecla Shift pulsada) y
	&lt;C-Izq.&gt; (tecla izquierda del cursor con la tecla Control pulsada) no
	 funciona en todos los teclados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same
	for the other Shift and Control combinations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ocurre lo mismo con las otras
	 combinaciones con Shift y Control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned, &lt;BS&gt; deletes the character before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como ya se ha dicho, &lt;BS&gt; elimina el carácter anterior al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a whole word use CTRL-W.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar toda una palabra, use CTRL-W.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the fine pig ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/el sutil cerdo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the fine ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/el sutil ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Insert&gt; key toggles between inserting characters and replacing the existing ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Insertar&gt; conmuta entra insertar caracteres y reemplaza los existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start with this text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comience con este texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the start of "fine" with &lt;S-Left&gt; twice (or &lt;Left&gt; eight times, if &lt;S-Left&gt; doesn't work).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplace el cursor al inicio de «sutil» con &lt;S-Izq.&gt; dos veces (o &lt;Izq.&gt; ocho veces, si &lt;S-Izq.&gt; no funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press &lt;Insert&gt; to switch to overstrike and type "great":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse ahora &lt;Insertar&gt; para pasar a superposición y teclee «gran»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the greatpig ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/el grancerdo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oops, we lost the space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya, hemos perdido un espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, don't use &lt;BS&gt;, because it would delete the "t" (this is different from Replace mode).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, no use &lt;BS&gt; porque eliminaría la «t» (a diferencia del modo Reemplazar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, press &lt;Insert&gt; to switch from overstrike to inserting, and type the space:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de ello, pulse &lt;Insertar&gt; para pasar de superposición a insertar, e introduzca el espacio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the great pig ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/el gran cerdo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You thought of executing a : or / command, but changed your mind.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se le ocurrió ejecutar una orden «:» o «/», pero cambió de opinión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get rid of what you already typed, without executing it, press CTRL-C or &lt;Esc&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desechar de lo que ya tecleó sin ejecutarlo pulse CTRL-C o &lt;Esc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	&lt;Esc&gt; is the universal "get out" key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	&lt;Esc&gt; es la tecla universal de salir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, in the good old
	Vi pressing &lt;Esc&gt; in a command line executed the command!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desafortunadamente, en el
	bueno y viejo Vi, pulsar &lt;Esc&gt; la línea de órdenes ejecutaba la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since that
	might be considered to be a bug, Vim uses &lt;Esc&gt; to cancel the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que	esto se puede considerar un fallo, Vim usa &lt;Esc&gt; para cancelar
	la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But with the 'cpoptions' option it can be made Vi compatible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero puede hacer que sea compatible con Vi con la opción 'cpoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And
	when using a mapping (which might be written for Vi) &lt;Esc&gt; also works
	Vi compatible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y cuando usa una macro (quizá escrito para Vi) &lt;Esc&gt; también funciona
	de manera compatible con Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, using CTRL-C is a method that always works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, siempre funcionará el metodo
 	CTRL-C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are at the start of the command line, pressing &lt;BS&gt; will cancel the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se halla al inicio de la línea de órdenes, pulsar &lt;BS&gt; cancelaría la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's like deleting the ":" or "/" that the line starts with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es como eliminar el «:» o «/» al inicio de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.2*	Command line abbreviations</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.2*	Abreviaturas en línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of the ":" commands are really long.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas de las órdenes «:» son muy largas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already mentioned that ":substitute" can be abbreviated to ":s".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya hemos mencionado que «:substitute» se puede abreviar con «:s».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a generic mechanism, all ":" commands can be abbreviated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un mecanismo genérico, todas las órdenes «:» se pueden abreviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How short can a command get?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Como de corto puede ser una orden?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 26 letters, and many more commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay unas 30 letras, y muchas más órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, ":set" also starts with ":s", but ":s" doesn't start a ":set"
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «:set» también empieza con «:s», pero «:s» no inicia la orden
«:set».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead ":set" can be abbreviated to ":se".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de ello, puede abreviar «:set» con «:se».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the shorter form of a command could be used for two commands, it
stands for only one of them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se podría usar la forma corta de una orden para dos órdenes, sólo
simboliza uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no logic behind which one, you have to
learn them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No hay una lógica detrás de cada elección, tendrá que
aprenderlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the help files the shortest form that works is mentioned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En los archivos de ayuda se menciona la forma más corta que
funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s[ubstitute]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s[ubstitute]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that the shortest form of ":substitute" is ":s".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que la forma corta de «:substitute» es «:s».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following characters are optional.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los siguientes caracteres son opcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus ":su" and ":sub" also work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, también funcionan «:su» y «:sub».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the user manual we will either use the full name of command, or a short version that is still readable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el manual de usuario usaremos o bien el nombre completo de la orden, o una versión corta pero legible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, ":function" can be abbreviated to ":fu".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, se puede acortar «:function» a «:fu».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But since most people don't understand what that stands for, we will use ":fun".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero debido a que la mayoría de la gente no entiende qué simboliza, nosotros usaremos «:fun».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Vim doesn't have a ":funny" command, otherwise ":fun" would be confusing too.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Vim no tiene una orden llamada «:funny», en caso contrario, esto también sería confuso.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that in Vim scripts you write the full command name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recomendamos que escriba la orden completa en los Vim scripts.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That
makes it easier to read back when you make later changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace
más fácil leerlo cuando introduce cambios más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except for some
often used commands like ":w" (":write") and ":r" (":read").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A excepción de órdenes
usadas con frecuencia como «:w» («:write») y «:r» («:read»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A particularly confusing one is ":end", which could stand for ":endif",
":endwhile" or ":endfunction".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un caso particularmente confuso es «:end», que podría simbolizar «:endif»,
«:endwhile» o «:endfunction».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, always use the full name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, use siempre el nombre completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the user manual the long version of the option names is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el manual de usuario se usa la versión larga de los nombres de opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many options also have a short name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Varias opciones tienen también un nombre corto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike ":" commands, there is only one short name that works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A diferencia de las órdenes «:», sólo hay un nombre corto que funcione.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the short name of 'autoindent' is 'ai'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, el nombre corto de 'autoindent' es 'ai'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus these two commands do the same thing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, estas dos órdenes hacen lo mismo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set autoindent
	:set ai</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set autoindent
	:set ai</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.3*	Command line completion</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.3*	Autocompletado en la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is one of those Vim features that, by itself, is a reason to switch from Vi to Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una opción que en si misma hace que merezca la pena pasar de Vi a Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have used this, you can't do without.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez que haya usado esto, no podrá vivir sin el.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>info.txt
	intro.txt
	bodyofthepaper.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>info.txt
	intro.txt
	bodyofthepaper.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit bodyofthepaper.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit bodyofthepaper.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's easy to type this wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es fácil equivocarse al teclear esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A much quicker way is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una manera más rápida es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit b&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit b&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which will result in the same command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene a ser la misma orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happened?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Qué ocurrió?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Tab&gt; key does completion of the word before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Tab&gt; realiza el autocompletado de la palabra anterior al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case "b".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«b» en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim looks in the directory and finds only one file that starts with a "b".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim busca en el directorio y encuentra sólo un archivo cuyo nombre empieza por «b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That must be the one you are looking for, thus Vim completes the file name for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este debe ser el que está buscando, y por ello Vim completa por usted el nombre del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit i&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit i&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit info.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit info.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The beep means that Vim has found more than one match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El pitido significa que Vim encontró más de una coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It then uses the first match it found (alphabetically).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces usa la primera coincidencia encontrada (en orden alfabético).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you press &lt;Tab&gt; again, you get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa &lt;Tab&gt; otra vez, obtendrá: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit intro.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit intro.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, if the first &lt;Tab&gt; doesn't give you the file you were looking for, press
it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si el primer &lt;Tab&gt; no le da el archivo que está buscando, púlselo
otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are more matches, you will see them all, one at a time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay más coincidencias, las verá todas de una en una.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you press &lt;Tab&gt; on the last matching entry, you will go back to what you
first typed: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa
&lt;Tab&gt; otra vez en la última entrada coincidente, volverá a lo que tecleo en un
principio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit i</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;------------------- &lt;Tab&gt; -------------------------+
								  |
		  &lt;Tab&gt; --&gt;		       &lt;Tab&gt; --&gt;
	:edit i		      :edit info.txt		   :edit intro.txt
		  &lt;-- CTRL-P		       &lt;-- CTRL-P
	   |
	   +---------------------- CTRL-P ------------------------&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;------------------- &lt;Tab&gt; -------------------------+
								  |
		  &lt;Tab&gt; --&gt;		       &lt;Tab&gt; --&gt;
	:edit i		      :edit info.txt		   :edit intro.txt
		  &lt;-- CTRL-P		       &lt;-- CTRL-P
	   |
	   +---------------------- CTRL-P ------------------------&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set icon</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set icon</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set isk&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set isk&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword=@,48-57,_,192-255</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword=@,48-57,_,192-255</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens here is that Vim inserts the old value of the option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que aquí ocurre es que Vim inserta el valor antiguo de la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you
can edit it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede
editarla ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is completed with &lt;Tab&gt; is what Vim expects in that place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que se completó con &lt;Tab&gt; es lo que Vim espera en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just try
it out to see how it works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe
esto ahora para ver su funcionamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some situations you will not get what you
want.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En algunas situaciones no obtendrá lo
que desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's either because Vim doesn't know what you want, or because
completion was not implemented for that situation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es debido a que Vim no sabe lo que quiere, o porque no se ha
implementado el autocompletado para este evento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that case you will get
a &lt;Tab&gt; inserted (displayed as ^I).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ese caso, obtendrá un
&lt;Tab&gt; insertado (se mostrará como ^I).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are many matches, you would like to see an overview.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando haya coinicidencias, querrá una vista general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this by pressing CTRL-D.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtenga esto pulsando CTRL-D.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, pressing CTRL-D after: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, si pulsa CTRL-D después de: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set is</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set is</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set is
	incsearch  isfname    isident    iskeyword  isprint
	:set is</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set is
	incsearch  isfname    isident    iskeyword  isprint
	:set is</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-L command completes the word to the longest unambiguous string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-L completa la palabra hasta llegar a la cadena no ambigua más larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type ":edit i" and there are files "info.txt" and "info_backup.txt" you will get ":edit info".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea «:edit i» y hay archivos «info.txt» e «info_backup.txt» obtendrá «:edit info».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.4*	Command line history</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.4*	Histórico de la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 3 we briefly mentioned the history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 3 mencionamos de manera breve el historial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basics are that you can use the &lt;Up&gt; key to recall an older command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo básico es que puede usar la tecla &lt;Arriba&gt; para invocar una orden ya pasada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Down&gt; then takes you back to newer commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Abajo&gt; le lleva a aquellas órdenes más recientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are actually four histories.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, hay cuatro historiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ones we will mention here are for ":" commands and for "/" and "?" search commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los que vamos a mencionar aquí son las órdenes «:» y las órdenes de búsqueda «/» y «?».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "/" and "?" commands share the same history, because they are both search commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes «/» y «?» comparten el mismo historial, ya que ambos son órdenes de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two other histories are for expressions and input lines for the input() function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los otros dos historiales sirven para las expresiones y líneas de entrada de la función input().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|cmdline-history|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|cmdline-history|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have done a ":set" command, typed ten more colon commands and then want to repeat that ":set" command again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que ejecutó una orden «:set», introdujo diez órdenes «:» más y que después quiera repetir la orden «:set» otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could press ":" and then ten times &lt;Up&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede pulsar «:» y diez veces &lt;Arriba&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a quicker way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una manera más rápida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:se&lt;Up&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:se&lt;Up&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will now go back to the previous command that started with "se".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim volverá ahora a la orden anterior que empezase con «se».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have a good chance that this is the ":set" command you were looking for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá muchas posibilidades de que esta sea la oren «:set» que estaba buscando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At least you should not have to press &lt;Up&gt; very often (unless ":set" commands is all you have done).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo menos no tendrá que pulsar &lt;Arriba&gt; varias veces (a menos que las órdenes «:set» sea todo lo que ha hecho).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Up&gt; key will use the text typed so far and compare it with the lines in
the history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Arriba&gt; usará el texto introducido hasta el momento y lo comparará
con las líneas en el historial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only matching lines will be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solo se usarán las líneas coincidentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not find the line you were looking for, use &lt;Down&gt; to go back to
what you typed and correct that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de no encontrar la línea que buscaba, use &lt;Down&gt; para volver a lo
que tecleó y corrija eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use CTRL-U to start all over again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O use CTRL-U para iniciar el proceso otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:history</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:history</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's the history of ":" commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el historial de las órdenes «:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The search history is displayed with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver el historial de búsquedas con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:history /</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:history /</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*20.5*	Command line window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*20.5*	Ventana de la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing the text in the command line works different from typing text in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear el texto en la línea de órdenes funciona de manera distinta a teclear texto en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It doesn't allow many commands to change the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No permite a varias órdenes modificar el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For most commands that's OK, but sometimes you have to type a complicated command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto está bien para varias órdenes, aunque a veces tiene que teclear una orden complicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's where the command line window is useful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta situación es cuando la ventana de línea de órdenes es útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>q:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>q:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim now opens a (small) window at the bottom.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá ahora una pequeña ventana en la base.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It contains the command line history, and an empty line at the end:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Contiene el historial de la línea de órdenes, y una línea vacía al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------+
	|other window			      |
	|~				      |
	|file.txt=============================|
	|:e c				      |
	|:e config.h.in			      |
	|:set path=.,/usr/include,,	      |
	|:set iskeyword=@,48-57,_,192-255     |
	|:set is			      |
	|:q				      |
	|:				      |
	|command-line=========================|
	|				      |
	+-------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------------+
	|otra ventana			      |
	|~				      |
	|file.txt=============================|
	|:e c				      |
	|:e config.h.in			      |
	|:set path=.,/usr/include,,	      |
	|:set iskeyword=@,48-57,_,192-255     |
	|:set is			      |
	|:q				      |
	|:				      |
	|línea de órdenes=====================|
	|				      |
	+-------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now in Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora se encuentra en el modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the "hjkl" keys to move around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar las teclas «hjkl» para desplazarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, move up with "5k" to the ":e config.h.in" line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, desplácese con «5k» hasta la línea «:e config.h.in».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type "$h" to go to the "i" of "in" and type "cwout".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee «$h» para ir a la «i» de «in» y teclee «cwout».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you have changed the line to:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, ha cambiado la línea a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:e config.h.out ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:e config.h.out ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command line window is very useful when you want to have overview of the
history, lookup a similar command, change it a bit and execute it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana de línea de órdenes es muy útil cuando quiere una vista general
del historial, mirar una orden similar, modificarlo y ejecutarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A search
command can be used to find something.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar
una orden de búsqueda para buscar algo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous example the "?config" search command could have been used
to find the previous command that contains "config".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo anterior, la orden de búsqueda «?config» se podría haber
usado para encontrar una orden anterior que contenga «?config».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a bit strange,
because you are using a command line to search in the command line window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un poco
extraño, pues está usando una línea de órdenes para buscar en la ventana de
línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While typing that search command you can't open another command line window,
there can be only one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No podrá abrir otra ventana de línea de órdenes mientras
teclee la orden de búsqueda, ya que sólo puede haber una.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_08.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_08.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2006 Jul 18</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 18/6/2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Splitting windows</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dividir en ventanas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display two different files above each other.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mostrar dos archivos diferentes uno encima del otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or view two locations in the file at the same time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mirar dos puntos del mismo archivo a la vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the difference between two files by putting them side by side.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ver las diferencias entre un archivo y otro poniéndolos uno al lado del otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this is possible with split windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo esto es posible dividiendo en ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|08.1|	Split a window
|08.2|	Split a window on another file
|08.3|	Window size
|08.4|	Vertical splits
|08.5|	Moving windows
|08.6|	Commands for all windows
|08.7|	Viewing differences with vimdiff
|08.8|	Various
|08.9|  Tab pages</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|08.1|	Dividir una ventana
|08.2|	Dividir una ventana con otro archivo
|08.3|	Tamaño de ventana
|08.4|	Divisiones verticales
|08.5|	Mover ventanas
|08.6|	Órdenes sobre todas las ventanas
|08.7|	Ver las diferencias con «vimdiff»
|08.8|	Varios
|08.9|	Pestañas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_09.txt|  Using the GUI
 Previous chapter: |usr_07.txt|  Editing more than one file
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_09.esx|  Uso de la interfaz gráfica
  Capítulo anterior: |usr_07.esx|  Editar más de un archivo
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.1*	Split a window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.1*  Dividir una ventana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:split</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	|/* file one.c */		   |
	|~				   |
	|~				   |
	|one.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	|/* archivo uno.c */		   |
	|~				   |
	|~				   |
	|uno.c=============================|
	|/* archivo uno.c */		   |
	|~				   |
	|uno.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-W w command can be used to jump between the windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-W w se puede usar para saltar de una ventana a otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are in the top window, CTRL-W w jumps to the window below it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está en la ventana superior, CTRL-W w salta a la ventana inferior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are in the bottom window it will jump to the first window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está en la ventana inferior saltará a la primera ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(CTRL-W CTRL-W does the same thing, in case you let go of the CTRL key a bit later.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(CTRL-W CTRL-W hace lo mismo, en caso de que suelte la tecla CTRL un poco después.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:close</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:close</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, any command that quits editing a file works, like ":quit" and "ZZ".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, cualquier orden que salga del archivo funciona, como «:quit» y «ZZ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But ":close" prevents you from accidentally exiting Vim when you close the last window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero «:close» evitará que salga accidentalmente de Vim cuando cierre la última ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:only</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:only</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This closes all windows, except for the current one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto cierra todas las ventanas, excepto la actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any of the other windows has changes, you will get an error message and that window won't be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si cualquiera de las otras ventanas tiene cambios, obtendrá un mensaje de error y esa ventana no se cerrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.2*	Split a window on another file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.2*	Dividir una ventana con otro archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following command opens a second window and starts editing the given file:
&gt;
	:split two.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente orden abre una segunda ventana y comienza la edición de un
archivo:
&gt;
	:split two.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	|/* archivo dos.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* archivo uno.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:new</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:new</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.3*	Window size</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.3*	Tamaño de ventana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":split" command can take a number argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:split» puede recibir un argumento numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If specified, this will be the height of the new window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se especifica, este será la altura de la nueva ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following opens a new window three lines high and starts editing the file alpha.c: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, el siguiente abre una nueva ventana con una altura de tres líneas y edita el archivo alpha.c: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:3split alpha.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:3split alpha.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For existing windows you can change the size in several ways.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ventanas ya existentes puede cambiar el tamaño de varias formas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have a working mouse, it is easy: Move the mouse pointer to the status line that separates two windows, and drag it up or down.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene un ratón, es fácil: Coloque el puntero en la línea de estado que separa las dos ventanas y arrástrela.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W +</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W +</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W -</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both of these commands take a count and increase or decrease the window size by that many lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ambas órdenes reciben un multiplicador que modificará la altura de ventana ese número de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "4 CTRL-W +" make the window four lines higher.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«4 CTRL-W +» hará la ventana cuatro líneas más alta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{height}CTRL-W _</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{altura}CTRL-W _</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's: a number {height}, CTRL-W and then an underscore (the - key with Shift
on English-US keyboards).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O sea: un número {altura}, CTRL-W y luego un guión bajo (Mayúsculas más la
tecla -).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make a window as high as it can be, use the CTRL-W _ command without a
count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para maximizar una ventana, use la orden CTRL-W _ sin ningún
multiplicador ni argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim you can do many things very quickly from the keyboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim puede hacer muchas cosas muy rápidamente desde el teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, the window resizing commands require quite a bit of typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por desgracia, las órdenes de ajuste de las ventanas requieren mucho trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, using the mouse is faster.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, usar el ratón es más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Position the mouse pointer on a status line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Coloque el ratón sobre la línea de estado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press the left mouse button and drag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora presione el botón izquierdo y arrastre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The status line will move, thus making the window on one side higher and the other smaller.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea de estado se desplazará, ajustando el tamaño de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'winheight' option can be set to a minimal desired height of a window and
'winminheight' to a hard minimum height.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'winheight' se puede ajustar a una altura mínima de ventana y
'winminheight' a un mínimo estricto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Likewise, there is 'winwidth' for the minimal desired width and
'winminwidth' for the hard minimum width.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Del mismo modo, hay un ancho 'winwidth' para el ancho mínimo deseado y un
'winminheight' para un ancho mínimo estricto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'equalalways' option, when set, makes Vim equalize the windows sizes
when a window is closed or opened.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'equalalways', cuando está activa, hace que Vim equilibre el
tamaño de las ventanas cuando éstas se cierran o se abren nuevas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.4*	Vertical splits</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.4*	Divisiones verticales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":split" command creates the new window above the current one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:split» crea una nueva ventana sobre la actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the window appear at the left side, use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que una ventana aparezca en el lateral izquierda, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:vsplit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:vsplit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or: &gt;
	:vsplit two.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>o: &gt;
	:vsplit two.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+--------------------------------------+
	|/* file two.c */   |/* file one.c */  |
	|~		    |~		       |
	|~		    |~		       |
	|~		    |~		       |
	|two.c===============one.c=============|
	|				       |
	+--------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+--------------------------------------+
	|/*archivo dos.c */ |/*archivo uno.c */|
	|~                  |~                 |
	|~                  |~                 |
	|~                  |~                 |
	|two.c===============one.c=============|
	|                                      |
	+--------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also the ":vnew" command, to open a vertically split window on a new, empty file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hay una orden «:vnew», para abrir una partición vertical con un archivo nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:vertical new</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:vertical new</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":vertical" command can be inserted before another command that splits a window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:vertical» se puede insertar justo antes de otra orden que divida la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will cause that command to split the window vertically instead of horizontally.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede hacer que la ventana se divida verticalmente en lugar de horizontalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If the command doesn't split a window, it works unmodified.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si la orden no divide ventanas se ejecuta de modo normal.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since you can split windows horizontally and vertically as much as you like, you can create almost any layout of windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que puede dividir ventanas horizontal y verticalmente a voluntad, puede crear casi cualquier estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use these commands to move between them:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez las haya creado se puede desplazar por ellas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W h	move to the window on the left
	CTRL-W j	move to the window below
	CTRL-W k	move to the window above
	CTRL-W l	move to the window on the right</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W h        moverse a la ventana de la izquierda
	CTRL-W j        moverse a la ventana de abajo
	CTRL-W k        moverse a la ventana de arriba
	CTRL-W l        moverse a la ventana de la derecha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W t	move to the TOP window
	CTRL-W b	move to the BOTTOM window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W t        moverse a la ventana superior (TOP)
	CTRL-W b        moverse a la ventana inferior (BOTTOM)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the same letters as used for moving the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se habrá dado cuenta de que son las mismas teclas empleadas para mover el
cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the
cursor keys can also be used, if you like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar las teclas de flechas si lo desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More commands to move to other windows: |Q_wi|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más órdenes para moverse a otras ventanas: |Q_wi|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.5*	Moving windows</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.5*	Mover ventanas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have split a few windows, but now they are in the wrong place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imagine que ha creado unas cuantas ventanas, pero están en el lugar equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need a command to move the window somewhere else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesitará una orden para mover las ventanas a otro lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you have three windows like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, tiene tres ventanas como estas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file three.c */		   |
	|~				   |
	|~				   |
	|three.c===========================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	|/* archivo dos.c */		   |
	|~				   |
	|~				   |
	|dos.c=============================|
	|/* archivo tres.c */		   |
	|~				   |
	|~				   |
	|tres.c============================|
	|/* archivo uno.c */		   |
	|~				   |
	|uno.c=============================|
	|				   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clearly the last one should be at the top.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente la última ventana debería estar en la parte superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go to that window (using CTRL-W w)  and the type this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya a esa ventana (usando CTRL-W w) y luego teclee la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W K</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W K</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------------+
	|/* two.c */  |/* three.c */  |/* one.c */  |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|two.c=========three.c=========one.c========|
	|					    |
	+-------------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------------------+
	|/* dos.c */  |/*  tres.c */  |/* uno.c */  |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|dos.c==========tres.c=========uno.c========|
	|					    |
	+-------------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------------+
	|/* three.c */				    |
	|~					    |
	|~					    |
	|three.c====================================|
	|/* two.c */	       |/* one.c */	    |
	|~		       |~		    |
	|two.c==================one.c===============|
	|					    |
	+-------------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------------------+
	|/* tres.c */				    |
	|~					    |
	|~					    |
	|tres.c=====================================|
	|/* dos.c */	       |/* uno.c */	    |
	|~		       |~		    |
	|dos.c==================uno.c===============|
	|					    |
	+-------------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W H	move window to the far left
	CTRL-W J	move window to the bottom
	CTRL-W L	move window to the far right</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W H	mover la ventana al extremo izquierdo
	CTRL-W J	mover la ventana al extremo inferior
	CTRL-W L	mover la ventana al extremo derecho</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.6*	Commands for all windows</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.6*	Órdenes sobre todas las ventanas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have several windows open and you want to quit Vim, you can close each window separately.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene varias ventanas abiertas y quiere salir de Vim, puede cerrar cada ventana por su cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quicker way is using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma más rápida es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:qall</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:qall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stands for "quit all".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene de «quit all» (cerrar todo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any of the windows contain changes, Vim will not exit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si alguna de las ventanas contiene cambios, Vim no saldrá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor will automatically be positioned in a window with changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor se pondrá automáticamente en la ventana con cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then either use ":write" to save the changes, or ":quit!" to throw them away.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «:w» para guardar los cambios, o «:q!» para eliminarlos completamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wall</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stands for "write all".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene de «write all» (escribir/guardar todo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But actually, it only writes files with
changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero, de hecho, sólo
escribe archivos con cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim knows it doesn't make sense to write files that were not
changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim sabe que no tiene sentido guardar
archivos sin cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then there is the combination of ":qall" and ":wall": the "write and
quit all" command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hay una combinación de «:qall» y «:wall»: la orden «guardar y
salir de todas las ventanas»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wqall</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wqall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This writes all modified files and quits Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guarda todos los archivos modificados y sale de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is a command that quits Vim and throws away all changes: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, hay una orden que sale de Vim y no guarda nada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:qall!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:qall!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -o one.txt two.txt three.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -o uno.txt dos.txt tres.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------+
	|file one.txt			|
	|~				|
	|one.txt========================|
	|file two.txt			|
	|~				|
	|two.txt========================|
	|file three.txt			|
	|~				|
	|three.txt======================|
	|				|
	+-------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------+
	|archivo uno.txt		|
	|~				|
	|uno.txt========================|
	|archivo dos.txt		|
	|~				|
	|dos.txt========================|
	|archivo tres.txt		|
	|~				|
	|tres.txt=======================|
	|				|
	+-------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-O" argument is used to get vertically split windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-O"» se usa para que las divisiones se hagan verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Vim is already running, the ":all" command opens a window for each
file in the argument list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando Vim está ejecutándose, la orden «:all» abre una ventana para cada
archivo en la lista de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":vertical all" does it with vertical splits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:vertical all» lo hace verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.7*	Viewing differences with vimdiff</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.7*	Ver las diferencias con «vimdiff»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a special way to start Vim, which shows the differences between two
files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una manera especial de arrancar Vim que muestra las diferencias entre
dos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take a file "main.c" and insert a few characters in one line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cojamos un archivo «main.c» e insertemos unos caracteres en una
línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write this file with the 'backup' option set, so that the backup file
"main.c~" will contain the previous version of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba el archivo con la opción 'backup' activada, de manera que el
archivo «main.c~» contendrá la versión anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type this command in a shell (not in Vim): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escribe la siguiente orden en una consola (no en Vim): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vimdiff main.c~ main.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vimdiff main.c~ main.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will start, with two windows side by side.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim arrancará con dos ventanas verticales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will only see the line in which you added characters, and a few lines above and below it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá solamente la línea en la que ha añadido los cambios y unas cuántas líneas por debajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VV		      VV
	+-----------------------------------------+
	|+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- fold
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	changed text	  |  &lt;- changed line
	|  text		     |	text		  |
	|  text		     |	------------------|  &lt;- deleted line
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|+ +--432 lines: text|+ +--432 lines: text|  &lt;- fold
	|  ~		     |	~		  |
	|  ~		     |	~		  |
	|main.c~==============main.c==============|
	|					  |
	+-----------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VV		      VV
	+-----------------------------------------+
	|+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- pliegue
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto modificado  |  &lt;- línea modificada
	|  texto	     |	texto		  |
	|  texto	     |	------------------|  &lt;- línea eliminada
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|  texto	     |	texto		  |
	|+ +--432 lines:texto|+ +--432 lines:texto|  &lt;- pliegue
	|  ~		     |	~		  |
	|  ~		     |	~		  |
	|main.c~==============main.c==============|
	|					  |
	+-----------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lines that were not modified have been collapsed into one line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas que no se modificaron se han agrupado en una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is
called a closed fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A
esto se le denomina pliegue (fold) cerrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They are indicated in the picture with "&lt;- fold".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se indican con «&lt;- pliegue»
en la figura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus
the single fold line at the top stands for 123 text lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea de arriba marca que hay 123 líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These lines are
equal in both files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas líneas son
iguales en ambos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line marked with "&lt;- changed line" is highlighted, and the inserted
text is displayed with another color.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea marcada con «&lt;- línea modificada» está resaltada y el texto
insertado se muestra con otro color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This clearly shows what the difference
is between the two files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto muestra claramente las
diferencias entre los dos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line that was deleted is displayed with "---" in the main.c window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea que se eliminó se muestra con «---» en la ventana «main.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the "&lt;- deleted line" marker in the picture.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe el «&lt;- línea eliminada» en la figura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These characters are not
really there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos caracteres no están ahí
realmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They just fill up main.c, so that it displays the same number
of lines as the other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente llenan el espacio necesario en «main.c» para que
ambos archivos tengan el mismo número de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each window has a column on the left with a slightly different background.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada ventana tiene una columna en la izquierda que tiene un fondo
ligeramente diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In
the picture above these are indicated with "VV".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la figura de arriba se indican con «VV».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You notice there is a plus
character there, in front of each closed fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fíjese
que hay un carácter «+» en ese sitio, enfrente de cada pliegue cerrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the mouse pointer to that
plus and click the left button.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el puntero del ratón a ese signo «+» y pulse el botón izquierdo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fold will open, and you can see the text
that it contains.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto abrirá el pliegue, mostrando el texto que contiene.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fold column contains a minus sign for an open fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La columna del pliegue muestra un «-» para un pliegue abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you click on
this -, the fold will close.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa
este «-», el pliegue se cerrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, this only works when you have a working mouse.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, esto sólo funciona cuando tiene un ratón configurado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use
"zo" to open a fold and "zc" to close it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También
puedes usar «zo» para abrir un pliegue y «zc» para cerrarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to start in diff mode can be done from inside Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera de iniciar el modo diff es hacerlo desde Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the "main.c" file, then make a split and show the differences: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite el archivo «main.c», haga después un «split» y muestre las diferencias: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit main.c
	:vertical diffsplit main.c~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit main.c
	:vertical diffsplit main.c~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":vertical" command is used to make the window split vertically.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:vertical» se usa para hacer que las ventanas se dividan verticalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you omit this, you will get a horizontal split.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si omite esto, obtendrá una división horizontal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a patch or diff file, you can use the third way to start diff mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene un parche o un archivo diff, puede usarlo como una tercera manera de iniciar el modo diff.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First edit the file to which the patch applies.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero edite el archivo sobre el cuál se aplica el parche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then tell Vim the name of the patch file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces escribe la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit main.c
	:vertical diffpatch main.c.diff</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit main.c
	:vertical diffpatch main.c.diff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARNING: The patch file must contain only one patch, for the file you are
editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>AVISO: El parche debe contener un solo parche, el del archivo que está
editando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise you will get a lot of error messages, and some files might
be patched unexpectedly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, recibirá muchos de mensajes de error y
algunos archivos pueden verse parcheados de forma imprevista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The patching will only be done to the copy of the file in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El parcheo será realizado sólo sobre una copia del archivo en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file on
your harddisk will remain unmodified (until you decide to write the file).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
archivo del disco duro no se modificará hasta que no lo guardes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the files have more changes, you can scroll in the usual way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando los archivos tienen muchos cambios, puede desplazarse de manera
normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will
try to keep both the windows start at the same position, so you can easily see
the differences side by side.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intentará hacer que ambas ventanas comiencen con el mismo
desplazamiento, para que pueda ver las diferencias en cada lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you don't want this for a moment, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no quiera que esto ocurra, use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set noscrollbind</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set noscrollbind</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have disabled folding in some way, it may be difficult to find the changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando haya desactivado los pliegues de algún modo, puede ser más difícil encontrar los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this command to jump forward to the next change: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esta orden para saltar al siguiente cambio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>]c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>]c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can move text from one window to the other.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mover texto de una ventana a otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This either removes differences or adds new ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina diferencias o añade unas nuevas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim doesn't keep the highlighting updated in all situations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no mantiene el texto resaltado en todas las situaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To update it use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para actualizarlo deberá escribir: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:diffupdate</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:diffupdate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove a difference, you can move the text in a highlighted block from one window to another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una diferencia, puede mover el texto de un bloque resaltado desde una ventana a otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take the "main.c" and "main.c~" example above.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga el «main.c» y el «main.c~» del ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the left window, on the line that was deleted in the other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a la izquierda de la ventana, sobre la línea que se eliminó en la otra ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dp</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>dp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will be removed by putting the text of the current window in the
other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio se eliminará poniendo el texto de la ventana actual en la otra
ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"dp" stands for "diff put".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«dp» viene de «diff put» (put = poner).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also do it the other way around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacerlo también de la forma completamente opuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the right
window, to the line where "changed" was inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor
a la ventana de la derecha, donde se insertó el cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>do</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>do</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will now be removed by getting the text from the other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio será ahora eliminado obteniendo el texto desde la otra ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since there are no changes left now, Vim puts all text in a closed fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que no hay cambios restantes, Vim pondrá todo el texto en un pliegue cerrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"do" stands for "diff obtain".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«do» viene de «diff obtain» (obtain = obtener).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"dg" would have been better, but that already has a different meaning ("dgg" deletes from the cursor until the first line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«dg» podría ser mejor (de g = get = obtener) pero «dgg» ya tenía un significado diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.8*	Various</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.8*	Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0	never
	1	only when there are split windows (the default)
	2	always</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>0	nunca
	1	sólo cuando hay más ventanas (predeterminado)
	2	siempre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many commands that edit another file have a variant that splits the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchas órdenes que editan otro archivo disponen de una variante que divide la
ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Command-line commands this is done by prepending an "s".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para los de la línea de órdenes se hace con el prefijo «s».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example:
":tag" jumps to a tag, ":stag" splits the window and jumps to a
tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo «:tag» salta a una etiqueta, «:stag» divide la ventana y salta a la
etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Normal mode commands a CTRL-W is prepended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para órdenes del modo normal se teclea CTRL-W antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-^ jumps to the
alternate file, CTRL-W CTRL-^ splits the window and edits the alternate file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-^ salta al
archivo alterno, CTRL-W CTRL-^ divide la ventana y edita el archivo alterno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'splitbelow' option can be set to make a new window appear below the current window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede activar la opción 'splitbelow' para hacer que la nueva ventana aparezca debajo de la actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'splitright' option can be set to make a vertically split window appear right of the current window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede activar la opción 'splitright' para hacer que una partición vertical aparezca a la derecha de la ventana actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:leftabove {cmd}	left or above the current window
	:aboveleft {cmd}	idem
	:rightbelow {cmd}	right or below the current window
	:belowright {cmd}	idem
	:topleft {cmd}		at the top or left of the Vim window
	:botright {cmd}		at the bottom or right of the Vim window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:leftabove {cmd}	izquierda o encima de la actual
	:aboveleft {cmd}	ídem
	:rightbelow {cmd}	derecha o debajo de la actual
	:belowright {cmd}	ídem
	:topleft {cmd}		encima o a la izquierda de la ventana de 					Vim
	:botright {cmd}		debajo o a la derecha de la ventana de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*08.9*	Tab pages</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*08.9*	Pestañas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have noticed that windows never overlap.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habrá notado que las ventanas no se superponen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That means you quickly run out of screen space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que puede rápidamente acabar sin espacio suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution for this is called Tab pages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La solución son las pestañas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assume you are editing "thisfile".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editando «estearchivo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a new tab page use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para crear una nueva pestaña: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tabedit thatfile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tabedit «aquélarchivo»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will edit the file "thatfile" in a window that occupies the whole Vim window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto editará el archivo «aquélarchivo» en una ventana que ocupe todo el espacio de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And you will notice a bar at the top with the two file names:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá que hay una nueva barra en la parte superior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	| thisfile | /thatfile/ __________X|    (thatfile is bold)
	|/* thatfile */			   |
	|that				   |
	|that				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	| estearchivo | /aquélarchivo/ ___X|   (aquélarchivo está en
	|				   |	negrita)
	|/* aquélarchivo */		   |
	|aquél				   |
	|aquél				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have two tab pages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora tiene dos pestañas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first one has a window for "thisfile" and the second one a window for "thatfile".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera tiene una ventana para «estearchivo» y la segunda para «aquélarchivo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's like two pages that are on top of eachother, with a tab sticking out of each page showing the file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es como dos páginas una encima de la otra, con una pestaña sobresaliendo de cada página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	| /thisfile/ | thatfile __________X|    (thisfile is bold)
	|/* thisfile */			   |
	|this				   |
	|this				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	| /estearchivo/ | aquélarchivo ___X|   (estearchivo está en
	|				   |	negrita)
	|/* estearchivo */		   |
	|este				   |
	|este				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can switch between tab pages by clicking on the label in the top line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo puede pasar entre pestañas pulsando sobre la etiqueta de la línea superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a mouse or don't want to use it, you can use the "gt" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no dispone del ratón o no lo quiere usar, puede emplear la orden «gt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mnemonic: Goto Tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nemotecnia: Goto Tab (ir a pestaña).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tab split</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tab split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------+
	| thisfile | /thisfile/ | thatfile __X|   (thisfile is bold)
	|/* thisfile */			      |
	|this				      |
	|this				      |
	|~				      |
	|~				      |
	|~				      |
	|				      |
	+-------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------------------+
	| estearchivo | /estearchivo/ | aquélarchivo _X| (estearchivo está
	|/* estearchivo */			       |  en negrita)
	|este					       |
	|este					       |
	|~					       |
	|~					       |
	|~					       |
	|					       |
	+----------------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put ":tab" before any Ex command that opens a window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede poner «:tab» antes de cualquier orden «Ex» que abra una ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The window will be opened in a new tab page.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana se abrirá en una nueva ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tab help gt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tab help gt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- click with the mouse on the "X" in the top right corner
	The current tab page will be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- pulse con el ratón sobre la «X» en la esquina superior derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unless there are unsaved
	changes in the current tab page.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La pestaña actual se cerrará a menos que haya cambios sin guardar en la
	pestaña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- double click with the mouse in the top line
	A new tab page will be created.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- doble pulsación con el ratón sobre la línea superior
	Se creará una nueva ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_02.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_02.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first steps in Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primeros pasos en Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter provides just enough information to edit a file with Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo ofrece suficiente información para editar un archivo con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not well or fast, but you can edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No bien ni rápido, pero podrá editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take some time to practice with these commands, they form the base for what follows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tómese un tiempo para practicar estas órdenes, son la base de lo que sigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|02.1|	Running Vim for the First Time
|02.2|	Inserting text
|02.3|	Moving around
|02.4|	Deleting characters
|02.5|	Undo and Redo
|02.6|	Other editing commands
|02.7|	Getting out
|02.8|	Finding help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|02.1|	Ejecutar Vim por primera vez
|02.2|	Insertar texto
|02.3|	Movimiento
|02.4|	Eliminar caracteres
|02.5|	Deshacer y rehacer
|02.6|	Otras órdenes de edición
|02.7|	Salir
|02.8|	Encontrar ayuda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_03.txt|  Moving around
 Previous chapter: |usr_01.txt|  About the manuals
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_03.esx|  Desplazamiento
  Capítulo anterior: |usr_01.esx|  Acerca de los manuales
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.1*	Running Vim for the First Time</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.1*	Ejecutar Vim por primera vez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim file.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In UNIX you can type this at any command prompt.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En UNIX puede introducir esta orden en cualquier interprete de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running Microsoft
Windows, open an MS-DOS prompt window and enter the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está
bajo Microsoft Windows, abra una terminal de MS-DOS e introduzca la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In either case, Vim starts editing a file called file.txt.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ambos casos, Vim se inicia con la edición de un archivo llamado file.txt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because this
is a new file, you get a blank window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que es un archivo nuevo, obtendrá un ventana vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is what your screen will look
like:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así es como su pantalla
debería aparecer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|#					|
	|~					|
	|~					|
	|~					|
	|~					|
	|"file.txt" [New file]			|
	+---------------------------------------+
		('#" is the cursor position.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|#					|
	|~					|
	|~					|
	|~					|
	|~					|
	|"file.txt" [Archivo nuevo]		|
	+---------------------------------------+
		('#" es la posición del cursor.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tilde (~) lines indicate lines not in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas con tilde (~) indican líneas que no se hallan en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, when Vim runs out of file to display, it displays tilde lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, cuando Vim se queda sin archivo que mostrar muestra líneas con tilde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the bottom of the screen, a message line indicates the file is named file.txt and shows that you are creating a new file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la parte inferior de la pantalla, un mensaje muestra que el archivo se llama file.txt y que está creando un archivo nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The message information is temporary and other information overwrites it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La información del mensaje es temporal y otra información la sobreescribirá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gvim command causes the editor to create a new window for editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «gvim» hace que el editor cree una nueva ventana para editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim file.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the editing occurs inside your command window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>la edición ocurre dentro de la ventana de llamada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, if you are running inside an xterm, the editor uses your xterm window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, si está dentro de una xterm, el editor usa su ventana xterm.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using an MS-DOS command prompt window under Microsoft Windows, the editing occurs inside this window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está usando una terminal de MS-DOS bajo Windows, la edición tendrá lugar dentro de esta ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text in the window will look the same for both versions, but with gvim you have extra features, like a menu bar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto en la ventana tendrá el mismo aspecto en ambas versiones, pero con gvim tiene características extra, como una barra de menú.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about that later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Volveremos a este punto posteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.2*	Inserting text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.2*	Insertar texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iA very intelligent turtle
	Found programming UNIX a hurdle</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>iA very intelligent turtle
	Found programming UNIX a hurdle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After typing "turtle" you press the &lt;Enter&gt; key to start a new line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras teclear «turtle», pulse la tecla &lt;Intro&gt; para comenzar una nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally you press the &lt;Esc&gt; key to stop Insert mode and go back to Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, presione la tecla &lt;Esc&gt; para salir del modo Insertar y volver al modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have two lines of text in your Vim window:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora tienes dos línea de texto en su ventana de Vim:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set showmode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set showmode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that when typing the colon Vim moves the cursor to the last
line of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comprobará que cuando introduce dos puntos, Vim desplaza el cursor a la
última línea de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's where you type colon commands (commands that start
with a colon).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Allí es donde introducirá órdenes con dos puntos
(órdenes que comienzan con dos puntos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finish this command by pressing the &lt;Enter&gt; key (all commands
that start with a colon are finished this way).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Finalice la orden presionando la
tecla &lt;Intro&gt; (todas estas órdenes se finalizan de este modo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, if you type the "i" command Vim will display --INSERT-- at the bottom
of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsase ahora la orden «i», Vim mostrará --INSERT-- en la parte
inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates you are in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto indica que está en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|-- INSERT --				|
	+---------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|-- INSERT --				|
	+---------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the problems for Vim novices is mode confusion, which is caused by forgetting which mode you are in or by accidentally typing a command that switches modes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de los problemas para los que comienzan a usar Vim es la confusión de los modos, que se produce al olvidar en qué modo está o por teclear accidentalmente una orden que cambia de modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get back to Normal mode, no matter what mode you are in, press the &lt;Esc&gt; key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para volver al modo Normal, no importa el modo en el que esté,presione la tecla &lt;Esc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you have to press it twice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En algunas ocasiones, tendrá que presionarlo dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim beeps back at you, you already are in Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim emite un pitido, entonces es que está de vuelta al modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.3*	Moving around</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.3*	Movimiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>h   left						*hjkl*
	j   down
	k   up
	l   right</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>h   izquierda						*hjkl*
	j   abajo
	k   arriba
	l   derecha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At first, it may appear that these commands were chosen at random.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un principio, puede parecer que estas órdenes se han elegido arbitrariamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After all, who ever heard of using l for right?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después de todo, ¿quién ha visto usar l para derecha?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But actually, there is a very good reason for these choices: Moving the cursor is the most common thing you do in an editor, and these keys are on the home row of your right hand.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, hay una buena razón para esto: mover el cursor es una de las cosas más comunes que hará en un editor, y estas teclas están en la fila central de su mano derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, these commands are placed where you can type them the fastest (especially when you type with ten fingers).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, estas órdenes se sitúan donde puede teclearlos de manera más rápida (especialmente cuando escribe con diez dedos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	You can also move the cursor by using the arrow keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	También puede mover el cursor usando las flechas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do,
	however, you greatly slow down your editing because to press the arrow
	keys, you must move your hand from the text keys to the arrow keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo haces, sin
	embargo, ralentizará considerablemente la edición, ya que para ello
	tendrá que desplazar su mano desde las letras a las flechas del
	teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Considering that you might be doing it hundreds of times an hour, this
	can take a significant amount of time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teniendo en cuenta que debe hacerlo cientos de veces cada
	hora, esto puede llevar un tiempo considerable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, there are keyboards which do not have arrow keys, or which
	locate them in unusual places; therefore, knowing the use of the hjkl
	keys helps in those situations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además, hay teclados que no tienen teclas de flechas, o que las
	colocan en lugares inusuales; por lo tanto, conocer el uso de hjkl
	ayuda en esas situaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to remember these commands is that h is on the left, l is on the right and j points down.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una manera de recordar estas órdenes es que la h está a la izquierda, l en la derecha y j apunta hacia abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a picture: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un esquema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>k
		   h     l
		     j</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>k
		   h     l
		      j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to learn these commands is by using them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mejor manera de aprender estas órdenes es usándolas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the "i" command to insert some more lines of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «i» para insertar algunas líneas de texto más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use the hjkl keys to move around and insert a word somewhere.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use entonces las teclas hjkl para moverse e insertar palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to press &lt;Esc&gt; to go back to Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se olvide de presionar &lt;Esc&gt; para volver al modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |vimtutor| is also a nice way to learn by doing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El |vimtutor| es también una práctica manera de aprender.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Komsomolsk
			    ^
			    |
	   Huan Ho	&lt;--- ---&gt;  Los Angeles
	(Yellow river)	    |
			    v
			  Java (the island, not the programming language)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Komsomolsk
			    ^
			    |
	   Huan Ho	&lt;--- ---&gt;  Los Angeles
	(Río amarillo)	    |
			    v
			  Java (la isla, no el lenguaje de programación)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.4*	Deleting characters</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.4*	Eliminar caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a character, move the cursor over it and type "x".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar un carácter, sitúe el cursor encima de él y presione «x».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(This is a throwback to the old days of the typewriter, when you deleted things by typing xxxx over them.)  Move the cursor to the beginning of the first line, for example, and type xxxxxxx (seven x's) to delete "A very ".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Esto es una reminiscencia de los días de las máquinas de escribir, cuando se eliminaban caracteres escribiendo xxxx sobre ellos.) Sitúe el cursor al comienzo de la primera línea, por ejemplo, y pulse xxxxxxx (siete «xx») para eliminar «A very».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result should look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado debería ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|intelligent turtle			|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|intelligent turtle			|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>iA young &lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>iA young &lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This begins an insert (the i), inserts the words "A young", and then exits
insert mode (the final &lt;Esc&gt;).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto inicia una inserción (la «i»), inserta las palabras «A young», y
sale del modo insertar (el &lt;Esc&gt; final).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|A young intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|A young intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a whole line use the "dd" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una línea entera use la orden «dd».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following line will then move up to fill the gap:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente línea se moverá hacia arriba para rellenar el hueco:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------+
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------+
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|~					|
	|					|
	+---------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim you can join two lines together, which means that the line break
between them is deleted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim puede unir dos líneas, lo que significa que el salto de línea entre
ellas se elimina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "J" command does this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «J» hace esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take these two lines:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga estas dos líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A young intelligent ~
	turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A young intelligent ~
	turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A young intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A young intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.5*	Undo and Redo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.5*	Deshacer y rehacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you delete too much.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que elimina demasiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, you can type it in again, but an easier
way exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede teclearlo de nuevo, pero existe una
manera más fácil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "u" command undoes the last edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «u» deshace la última edición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take a look at this in
action: After using "dd" to delete the first line, "u" brings it back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vea
esto en acción: Tras usar «dd» para eliminar la última línea, «u» la devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another one: Move the cursor to the A in the first line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra más: mueve el cursor a la A en la primera línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now type xxxxxxx to delete "A young".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora teclee xxxxxxx para eliminar «A young».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type "u" to undo the last delete.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee «u» para deshacer la última eliminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That delete removed the g, so the undo restores the character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esa última eliminación quitó la g, por lo que deshacer la devuelve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>g intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>g intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ng intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ng intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ung intelligent turtle ~
	oung intelligent turtle ~
	young intelligent turtle ~
	 young intelligent turtle ~
	A young intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ung intelligent turtle ~
	oung intelligent turtle ~
	young intelligent turtle ~
	 young intelligent turtle ~
	A young intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	If you type "u" twice, and the result is that you get the same text
	back, you have Vim configured to work Vi compatible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Si teclea la «u» dos veces, y el resultado que obtendrá es el mismo
	texto de vuelta, es que tiene Vim configurado para que sea
	Vi-compatible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look here to fix
	this: |not-compatible|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase aquí para solucionarlo: |not-compatible|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This text assumes you work "The Vim Way".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este texto asume que trabaja en «El Modo Vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might prefer to use
	the good old Vi way, but you will have to watch out for small
	differences in the text then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quizá quiera usar
	el viejo modo Vi, pero entonces tendrá que observar las pequeñas
	diferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you undo too many times, you can press CTRL-R (redo) to reverse the preceding command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si deshace de más, puede pulsar CTRL-R (rehacer) para revertir la orden precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, it undoes the undo.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, deshace el deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see this in action, press CTRL-R twice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver esto en acción, presione CTRL-R dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character A and the space after it disappear:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter A y el espacio desaparecerían:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>young intelligent turtle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>young intelligent turtle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a special version of the undo command, the "U" (undo line) command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una versión especial de la orden deshacer, la orden «U» (deshacer línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The undo line command undoes all the changes made on the last line that was edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden deshacer línea deshace todos los cambios realizados en la última línea editada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing this command twice cancels the preceding "U".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea esta orden dos veces, deshará la «U» precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very intelligent turtle ~
	  xxxx				Delete very</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A very intelligent turtle ~
	  xxxx				Eliminar very</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A intelligent turtle ~
		      xxxxxx		Delete turtle</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A intelligent turtle ~
		      xxxxxx		Eliminar turtle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A intelligent ~
					Restore line with "U"
	A very intelligent turtle ~
					Undo "U" with "u"
	A intelligent ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A intelligent ~
					Restaurar línea con «U»
	A very intelligent turtle ~
					Deshacer «U» con «u»
	A intelligent ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "U" command is a change by itself, which the "u" command undoes and CTRL-R redoes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «U» es un cambio en sí mismo, que la orden «u» deshace y CTRL-R rehace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This might be a bit confusing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede resultar confuso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't worry, with "u" and CTRL-R you can go to any of the situations you had.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se preocupe, con «u» y CTRL-R puede ir a cualquier situación anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about that in section |32.2|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más información en la sección |32.2|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.6*	Other editing commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.6*	Otras órdenes de edición</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a large number of commands to change the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una larga lista de órdenes para modificar texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Q_in| and below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |Q_in| y a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are a few often used ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí hay algunos de uso frecuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "i" command inserts a character before the character under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «i» inserta un carácter antes del carácter bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That works fine; but what happens if you want to add stuff to the end of the
line?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto
funciona bien; pero ¿qué ocurre si quieres añadir algo al final de la línea?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that you need to insert text after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello necesita insertar texto después del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done with
the "a" (append) command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se hace con la
orden «a» (añadir).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to change the line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para modificar la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and that's not saying much for the turtle.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>and that's not saying much for the turtle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
to
	and that's not saying much for the turtle!!!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
a
	and that's not saying much for the turtle!!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a!!!&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a!!!&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and that's not saying much for the turtle!!!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>and that's not saying much for the turtle!!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "o" command creates a new, empty line below the cursor and puts Vim in
Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «o» crea una nueva línea vacía debajo del cursor y pone Vim en modo
insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can type the text for the new line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede introducir el texto de la nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose the cursor is somewhere in the first of these two lines:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que el cursor está en algún lugar de la primera de estas líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very intelligent turtle ~
	Found programming UNIX a hurdle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A very intelligent turtle ~
	Found programming UNIX a hurdle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>oThat liked using Vim&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>oThat liked using Vim&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very intelligent turtle ~
	That liked using Vim ~
	Found programming UNIX a hurdle ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A very intelligent turtle ~
	That liked using Vim ~
	Found programming UNIX a hurdle ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to move up nine lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiera desplazarse nueve líneas hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can type "kkkkkkkkk" or you can enter the command "9k".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede teclear «kkkkkkkkk» o puede teclear la orden «9k».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In fact, you can precede many commands with a number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, se puede emplear el multiplicador con muchas órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Earlier in this chapter, for instance, you added three exclamation points to the end of a line by typing "a!!!&lt;Esc&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Anteriormente en este capítulo, añadió tres exclamaciones al final de la línea con «a!!!&lt;Esc&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to do this is to use the command "3a!&lt;Esc&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra forma de hacer esto es usar la orden «3a!&lt;Esc&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The count of 3 tells the command that follows to triple its effect.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El multiplicador 3 hace que la orden a continuación triplique su efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, to delete three characters, use the command "3x".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De igual modo, para eliminar tres caracteres, use «3x».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The count always comes before the command it applies to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El multiplicador siempre va delante de la orden sobre el que se aplica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.7*	Getting out</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.7*	Salir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To exit, use the "ZZ" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para salir, use la orden «ZZ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command writes the file and exits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden escribe el archivo y sale.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Unlike many other editors, Vim does not automatically make a backup
	file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Al revés que muchos otros editores, Vim no hace un archivo de
	seguridad automático.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type "ZZ", your changes are committed and there's no
	turning back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si escribe «ZZ», sus cambios se comprometen
	sin vuelta atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Vim editor to produce backup
	files, see |07.4|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede configurar el editor Vim para que haga
	copias de seguridad, consulte |07.4|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will make a sequence of changes and suddenly realize you were better off before you started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones se dará cuenta de que tras una serie de cambios, estaba mejor donde comenzó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not to worry; Vim has a quit-and-throw-things-away command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se preocupe; Vim tiene una orden para salir y descartar todos los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:q!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:q!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For those of you interested in the details, the three parts of this command
are the colon (:), which enters Command-line mode; the q command, which tells
the editor to quit; and the override command modifier (!).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para aquellos de vosotros interesados en los detalles, las tres partes de esta
orden son los dos puntos (:), que entra en el modo en línea de órdenes; la
orden «q», para salir; y el modificador de anulación (!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The override command modifier is needed because Vim is reluctant to throw
away changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modificador de anulación es necesario porque Vim se resiste a perder los
cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you were to just type ":q", Vim would display an error
message and refuse to exit:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si escribiese sólo «:q», Vim mostraría un mensaje de error y se
negaría a salir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E37: No write since last change (use ! to override) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E37: No se ha guardado el fichero desde el último cambio
	(añada ! para forzar) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*02.8*	Finding help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*02.8*	Encontrar ayuda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything you always wanted to know can be found in the Vim help files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo lo que quiera saber puede encontrarlo en los archivos de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't be afraid to ask!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡No tenga miedo a preguntar!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get generic help use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la siguiente orden para obtener ayuda genérica:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also use the first function key &lt;F1&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar la tecla &lt;F1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your keyboard has a &lt;Help&gt;
key it might work as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su teclado tiene tecla &lt;Ayuda&gt; puede que
funcione también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't supply a subject, ":help" displays the general help window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no define un tema, «:help» muestra la ventana de ayuda general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The creators of Vim did something very clever (or very lazy) with the help
system: They made the help window a normal editing window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los creadores de Vim hicieron algo muy inteligente (o fueron muy vagos) con el
sistema de ayuda: Hicieron la ventana de ayuda una ventana normal de edición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use all
the normal Vim commands to move through the help information.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar todas las órdenes comunes de Vim para moverse por ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore h, j,
k, and l move left, down, up and right.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo
tanto, h, j, k, l mueven el cursor hacia la izquierda, derecha, arriba y abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get out of the help window, use the same command you use to get out of
the editor: "ZZ".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para salir de la ventana de ayuda, usa la misma orden que usas para salir
del editor: «ZZ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only close the help window, not exit Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo cierra la ayuda, no sale de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help {subject}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help {subject}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help x</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help deleting</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help deleting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help index</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help index</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to get help for a control character command (for example, CTRL-A), you need to spell it with the prefix "CTRL-".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando necesite obtener ayuda para las órdenes de control de carácter (por ejemplo, CTRL-A), debe escribirlo con el prefijo «CTRL-».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help CTRL-A</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help CTRL-A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor has many different modes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim tiene muchos modos diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the help system displays the normal-mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De manera predeterminada, el sistema de ayuda muestra las ordenes del modo normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following command displays help for the normal-mode CTRL-H command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la siguiente orden muestra la ayuda para la orden CTRL-H en modo normal: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help CTRL-H</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help CTRL-H</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To identify other modes, use a mode prefix.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para identificar otros modos, se necesita un prefijo de modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want the help for the insert-mode version of a command, use "i_".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere ayuda para la versión en modo Insertar de una orden, use «i_».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For CTRL-H this gives you the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para, CTRL-H es la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help i_CTRL-H</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help i_CTRL-H</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help -t</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help -t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor has a number of options that enable you to configure and customize the editor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim tiene una serie de opciones que le permiten configurar y personalizar el editor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want help for an option, you need to enclose it in single quotation marks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere ayuda para una opción, tiene que escribirla entre comillas simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find out what the 'number' option does, for example, use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar lo que hace la opción 'number' por ejemplo, usa la orden siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help 'number'</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help 'number'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special keys are enclosed in angle brackets.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las teclas especiales se escriben entre corchetes angulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find help on the up-arrow key in Insert mode, for instance, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar ayuda sobre la flecha hacia arriba en modo insertar, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help i_&lt;Up&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help i_&lt;Up&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*intro.txt*     For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*intro.esx*   Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM REFERENCE MANUAL    by Bram Moolenaar</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MANUAL DE REFERENCIA DE VIM  por Bram Moolenar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction to Vim					*ref* *reference*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introducción a Vim				*ref* *referencia* *reference*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction			|intro|
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introducción			|intro|
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim on the internet		|internet|
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim en internet		|internet|
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credits			|credits|
4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Créditos			|credits|
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notation			|notation|
5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notación			|notación| |notation|
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modes, introduction		|vim-modes-intro|
6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modos, introducción		|vim-modes-intro|
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switching from mode to mode	|mode-switching|
7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cambiar de Modos		|cambiar-modo| |mode-switching|
7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The window contents		|window-contents|
8.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El contenido de la ventana	|ventana-contenidos| |window-contents|
8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Definitions			|definitions|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definiciones			|definiciones| |definitions|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Introduction						*intro*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introducción						*intro*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim stands for Vi IMproved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim son las siglas de Vi Improved («Vi mejorado»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It used to be Vi IMitation, but there are so many
improvements that a name change was appropriate.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solía significar Vi
IMitation, pero hay tantas mejoras que se consideró apropiado cambiar el
nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim is a text editor which
includes almost all the commands from the Unix program "Vi" and a lot of new
ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim es un editor de texto que incluye casi todas las órdenes del
programa para Unix, Vi, así como otras más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very useful for editing programs and other plain text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es muy útil para la edición de
programas y archivos de formato de texto normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All commands are given with the keyboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas las órdenes se introducen mediante el teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This has the advantage that you
can keep your fingers on the keyboard and your eyes on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésto ofrece la ventaja
de poder tener sus dedos en el teclado y sus ojos en la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For those
who want it, there is mouse support and a GUI version with scrollbars and
menus (see |gui.txt|).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para
aquellos que lo deseen, también tiene compatibilidad con ratón y una versión
que ofrece una interfaz gráfica con barras de desplazamiento y menús (consulte
|gui.txt|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An overview of this manual can be found in the file "help.txt", |help.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrará una visión general de este manual en el archivo «help.txt»,
|help.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be accessed from within Vim with the &lt;Help&gt; or &lt;F1&gt; key and with the
|:help| command (just type ":help", without the bars or quotes).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede acceder a él a través de Vim con la tecla &lt;Ayuda&gt; o &lt;F1&gt; y
con la orden |:help| (sólo teclee «:help», sin las comillas o barras).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'helpfile' option can be set to the name of the help file, in case it
is not located in the default place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'helpfile' se puede configurar con el nombre del archivo de ayuda
en caso de no encontrarse en la ubicación habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can jump to subjects like with tags:
Use CTRL-] to jump to a subject under the cursor, use CTRL-T to jump back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede saltar de un tema
a otro como si fuesen etiquetas:
Use CTRL-] para pasar al tema bajo el cursor, y CTRL-T para volver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Throughout this manual the differences between Vi and Vim are mentioned in curly braces, like this: {Vi does not have on-line help}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las diferencias entre Vi y Vim se señalarán con llaves, por ejemplo: {Vi no tiene ayuda en línea}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |vi_diff.txt| for a summary of the differences between Vim and Vi.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |vi_diff.txt| para un resumen de las diferencias entre Vim y Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This manual refers to Vim on various machines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este manual trata el uso de Vim en varios sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There may be small differences between different computers and terminals.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pueden existir pequeñas diferencias entre computadoras y terminales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Besides the remarks given in this document, there is a separate document for each supported system, see |sys-file-list|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además de los comentarios que se ofrecen en este documento, hay un documento aparte para cada sistema compatible, consulte |sys-file-list|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*pronounce*
Vim is pronounced as one word, like Jim, not vi-ai-em.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*pronounce* *pronunciar*
Vim se pronuncia como una sola palabra, como Jim, no uve-a-eme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's written with a
capital, since it's a name, again like Jim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se escribe
mayúscula, ya que es un nombre al igual que Jim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This manual is a reference for all the Vim commands and options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este manual es una referencia para todas las órdenes y opciones de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not an introduction to the use of Vi or Vim, it gets a bit complicated here and there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es una introducción al uso de Vi o Vim, y algunas secciones son complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For beginners, there is a hands-on |tutor|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un tutor práctico, |tutor|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn using Vim, read the user manual |usr_toc.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere aprender a usar Vim, consulte el manual de usuario |usr_toc.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*book*
There are many books on Vi that contain a section for beginners.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*book*
Existen muchos libros sobre Vi que contienen una sección para principiantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are
two books I can recommend:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Personalmente recomiendo dos libros:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Vim - Vi Improved" by Steve Oualline</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«Vim - Vi Improved» por Steve Oualline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the very first book completely dedicated to Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el primer libro completamente dedicado a Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very good for
beginners.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es muy bueno para
principiantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most often used commands are explained with pictures and
examples.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes más usadas se explican con imágenes y ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The less often used commands are also explained, the more advanced
features are summarized.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También se tratan aquellas órdenes menos comunes, y las características más
avanzadas son resumidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a comprehensive index and a quick
reference.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene un completo índice y una rápida referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parts of this book have been included in the user manual
|frombook|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay partes de este libro incluidas en el manual de usuario |frombook|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Published by New Riders Publishing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Publicado por New Riders Publishing.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ISBN: 0735710015
For more information try one of these:
	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ISBN: 0735710015
Pruebe estos enlaces para más información:
	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Learning the Vi editor" by Linda Lamb and Arnold Robbins</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«Learning the Vi editor» por Linda Lamb y Arnold Robbins</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim on the internet					*internet*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim en internet					*internet*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*www* *WWW*  *faq* *FAQ* *distribution* *download*
The Vim pages contain the most recent information about Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*www* *WWW*  *faq* *FAQ* *distribution* *download* *descargar*
Las páginas de Vim ofrecen la información más actualizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They also
contain links to the most recent version of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También
contienen enlaces a la versión más reciente de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The FAQ is a list of
Frequently Asked Questions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El FAQ es una lista de
las preguntas más frecuentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read this if you have problems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte esa página en caso de tener problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM home page:	  http://www.vim.org/
	VIM FAQ:	  http://vimdoc.sf.net/
	Downloading:	  ftp://ftp.vim.org/pub/vim/MIRRORS</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Página web de VIM http://www.vim.org/
	VIM FAQ:	  http://vimdoc.sf.net/
	Descargar:	  ftp://ftp.vim.org/pub/vim/MIRRORS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usenet News group where Vim is discussed:		*news* *usenet*
	comp.editors
This group is also for other editors.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Grupo de Usenet News en el que se trata Vim: 		*news* *usenet*
	comp.editors
Este grupo también trata de otros editores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you write about Vim, don't forget to
mention that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si escribe sobre Vim, no olvide
de mencionar esto último.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*mail-list* *maillist*
There are several mailing lists for Vim:
&lt;vim@vim.org&gt;
	For discussions about using existing versions of Vim: Useful mappings,
	questions, answers, where to get a specific version, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*mail-list* *maillist*
Existen varias listas de correo acerca de Vim:
&lt;vim@vim.org&gt;
	Para discusiones acerca del uso de varias versiones de Vim: Macros
	útiles, preguntas, respuestas, dónde obtener una versión especifica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are
	quite a few people watching this list and answering questions, also
	for beginners.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay varias personas mirando esta lista, y que responden a
	preguntas, también para principiantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't hesitate to ask your question here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No dude en preguntar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;vim-dev@vim.org&gt;				*vim-dev* *vimdev*
	For discussions about changing Vim: New features, porting, patches,
	beta-test versions, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;vim-dev@vim.org&gt;				*vim-dev* *vimdev*
	Para la discusión de cambios en Vim: Nuevas características,
	portabilidad, parches, versiones beta, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;vim-announce@vim.org&gt;				*vim-announce*
	Announcements about new versions of Vim; also for beta-test versions
	and ports to different systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;vim-announce@vim.org&gt;				*vim-announce*
	Anuncios acerca de nuevas versiones de Vim; también para versiones beta
	y la adaptación a otras arquitecturas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a read-only list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lista de sólo lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;vim-multibyte@vim.org&gt;				*vim-multibyte*
	For discussions about using and improving the multi-byte aspects of
	Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;vim-multibyte@vim.org&gt;				*vim-multibyte*
	Discusión acerca de la mejora de la experiencia multi-byte en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;vim-mac@vim.org&gt;				*vim-mac*
	For discussions about using and improving the Macintosh version of
	Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;vim-mac@vim.org&gt;				*vim-mac*
	Discusión acerca del uso y la mejora de la versión Macintosh de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE:
- You can only send messages to these lists if you have subscribed!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>NOTA:
- Sólo puede mandar mensajes a estas listas si esta suscrito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- You need to send the messages from the same location as where you subscribed
  from (to avoid spam mail).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Debe mandar los mensajes desde la misma dirección desde la cual se
  suscribió (para evitar el spam).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Maximum message size is 40000 characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El tamaño máximo de un mensaje es de 40000 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*subscribe-maillist*
If you want to join, send a message to
	&lt;vim-subscribe@vim.org&gt;
Make sure that your "From:" address is correct.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*lista-correo* *subscribe-maillist*
Si desea unirse, envie un mensaje a
	&lt;vim-subscribe@vim.org&gt;
Asegúrese de que su dirección «De:» es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the list server will
give you help on how to subscribe.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El servidor de la lista
le asistirá para suscribirse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*maillist-archive*
For more information and archives look on the Vim maillist page:
http://www.vim.org/maillist.php</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*maillist-archive*
Para más información y visitar los archivos, visite la página de listas de
correo de Vim:
http://www.vim.org/maillist.php</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bug reports:				*bugs* *bug-reports* *bugreport.vim*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Informes de fallo:	*fallos* *informe-de-fallo* *bugs* *bug-reports*
							 *bugreport.vim*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will help to include information about the version of Vim you are using and
your setup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nos ayudaría si incluye información acerca de su configuración y versión de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the information with this command: &gt;
   :so $VIMRUNTIME/bugreport.vim
This will create a file "bugreport.txt" in the current directory, with a lot
of information of your environment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener esta información con la siguiente orden: &gt;
   :so $VIMRUNTIME/bugreport.vim
Esto creará el archivo «bugreport.txt» en el directorio presente, conteniendo
información relativa a su entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before sending this out, check if it
doesn't contain any confidential information!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de enviarlo, revise que no contenga
ninguna información confidencial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim crashes, please try to find out where.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim se cuelga, intente encontrar donde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find help on this here: |debug.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar ayuda aquí: |debug.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might be a year 2038 problem, when the seconds don't fit in a 32 bit int anymore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede aparecer un problema en el año 2038, cuando los segundos no quepan en 32 bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This depends on the compiler, libraries and operating system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto depende del compilador, la bibliotecas y el sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specifically, time_t and the ctime() function are used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se usan particularmente las funciones «time_t» y «ctime()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the time_t is stored in four bytes in the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«time_t» se guarda en cuatro bytes en el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But that's only used for printing a file date/time for recovery, it will never affect normal editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto último sólo se emplea para imprimir una fecha/tiempo para la recuperación y en ningún caso afectará a la edición normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim strftime() function directly uses the strftime() system function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función de Vim «strftime()» usa directamente la función del sistema «strftime()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>localtime() uses the time() system function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«localtime()» usa la función del sistema «time()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getftime() uses the time returned by the stat() system function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«getftime» usa el tiempo devuelto por la función del sistema «stat()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your system libraries are year 2000 compliant, Vim is too.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si las bibliotecas de sus sistema son compatibles con el año 2000, Vim también lo es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user may create scripts for Vim that use external commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario puede crear scripts para Vim que usan órdenes externas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These might introduce Y2K problems, but those are not really part of Vim itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede introducir problemas Y2K, pero no son parte de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credits				*credits* *author* *Bram* *Moolenaar*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Creditos			*credits* *créditos* *autor* *Bram* *Moolenaar*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parts of the documentation come from several Vi manuals, written by:
	W.N.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El origen de algunas partes de la documentación nacen de varios manuales
de Vim, escritos por:
	W.N.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Joy
	Alan P.W.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Joy
	Alan P.W.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hewett
	Mark Horton</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hewett
	Mark Horton</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor is based on Stevie and includes (ideas from) other software, worked on by the people mentioned here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim está basado en Stevie, e incluye ideas procedentes de otro software, trabajadas por la gente aquí mencionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other people helped by sending me patches, suggestions and giving feedback about what is good and bad in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra gente me ayudó mediante parches, sugerencias y opiniones acerca de lo bueno y malo de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I wish to thank all the people that sent me bug reports and suggestions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quisiera dar gracias a toda la gente que envió informes de fallo y sugerencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list is too long to mention them all here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La lista es demasiado larga como para mencionarlos a todos aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim would not be the same without the ideas from all these people: They keep Vim alive!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no sería lo mismo sin las ideas de todas esta gente: ¡Mantienen Vim vivo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this documentation there are several references to other versions of Vi:
							*Vi* *vi*
Vi	"the original".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A lo largo de la documentación verá varias referencias a otras versiones de Vi:
							*Vi* *vi*
Vi	«El original».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without further remarks this is the version
	of Vi that appeared in Sun OS 4.x.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin mas detalle, esta es la versión de Vim que apareció
	en Sun Os 4.x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":version" returns
	"Version 3.7, 6/7/85".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:version» devuelve «Version 3.7, 6/7/85».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes other versions are referred
	to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces
	encontrara referencias a otras versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only runs under Unix.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo funciona bajo Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source code only available with a
	license.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
	código sólo está disponible a través de una licencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on Vi can be found through:
		http://vi-editor.org	[doesn't currently work...]
							*Posix*
Posix	From the IEEE standard 1003.2, Part 2: Shell and utilities.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar
	más información a cerca de Vi:
		http://vi-editor.org (no funciona a día de hoy...)
							*Posix*
Posix	Pertenece al estándar IEEE 1003.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally known as "Posix".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Parte 2: Consola y utilidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a textual description of
	how Vi is supposed to work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente conocido como «Posix»,  una descripción textual de cómo
	debe funcionar Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |posix-compliance|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |posix-compliance|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Nvi*
Nvi	The "New" Vi.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*Nvi*
Nvi	El «Nuevo» Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of Vi that comes with BSD 4.4 and FreeBSD.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión de Vi que ofrece BSD 4.4 y FreeBSD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very good compatibility with the original Vi, with a few extensions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es muy compatible con el editor original Vi, con unas cuantas
	extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version used is 1.79.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión referida es 1.79.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":version" returns "Version 1.79
	(10/23/96)".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:version» devuelve
	«Version 1.79 (10/23/96).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There has been no release the last few years, although
	there is a development version 1.81.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se ha publicado una nueva versión en
	los últimos años, aunque existe una versión en desarrollo 1.81.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source code is freely available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código se distribuye libremente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Elvis*
Elvis	Another Vi clone, made by Steve Kirkendall.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*Elvis*
Elvis	Otro clon de Vi, hecho por Steve Kirkendall.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very compact but isn't
	as flexible as Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muy compacto pero
	menos flexible que Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version used is 2.1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión referida es 2.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is still being developed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún está en desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source code is
	freely available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código se
	distribuye libremente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notation						*notation*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notación					*notación* *leyenda*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When syntax highlighting is used to read this, text that is not typed literally is often highlighted with the Special group.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa el resaltado de sintaxis para leer esto, el texto que no se ha introducido literalmente será resaltado como perteneciente al grupo Special.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are items in [], {} and &lt;&gt;, and CTRL-X.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos son los elementos [], {}, &lt;&gt; y CTRL-X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that Vim uses all possible characters in commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que Vim utiliza todos los caracteres posibles en las órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes the [], {} and &lt;&gt; are part of what you type, the context should make this clear.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El contexto aclarará cuando los signos [], () y &lt;&gt; son parte de texto literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[]		Characters in square brackets are optional.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[]		Los caracteres entre corchetes son opcionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*count* *[count]* *E489*
[count]		An optional number that may precede the command to multiply
		or iterate the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*[número]* *[count]* *E489*
		Un número opcional que puede preceder a la orden para
		multiplicar o cambiar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no number is given, a count of one
		is used, unless otherwise noted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no introduce un número, se
		usará uno a menos que se indique lo contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this manual the
		[count] is not mentioned in the description of the command,
		but only in the explanation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta]
		que en este manual, el [número no se menciona en las descripciones
		de las órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This was done to make the
		commands easier to look up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La razón para esto es facilitar la lectura de las órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showcmd' option is on,
		the (partially) entered count is shown at the bottom of the
		window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción
		esta activada, el número (parcialmente) introducido se
		mostrará en la parte inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use &lt;Del&gt; to erase the last digit (|N&lt;Del&gt;|).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar &lt;Supr&gt;
		para eliminar el último dígito (|N&lt;Supr&gt;|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*[quotex]*
["x]		An optional register designation where text can be stored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*quotex*
["x]		Un destino opcional para un registro dónde guardar el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |registers|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |registers|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The x is a single character between 'a' and
		'z' or 'A' and 'Z' or '"', and in some cases (with the put
		command) between '0' and '9', '%', '#', or others.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La x es un único carácter entre 'a'
		y 'z', o 'A' y 'Z' o '"', y en algunos casos (con la orden
		«put») entre '0' y '9', '%', '#', u otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
		uppercase and lowercase letter designate the same register,
		but the lowercase letter is used to overwrite the previous
		register contents, while the uppercase letter is used to
		append to the previous register contents.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las mayúsculas y
		y minúsculas designan el mismo registro, pero la minúscula se
		usa para eliminar los contenidos anteriores del registro, y
		la mayúscula para añadir contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without the ""x" or
		with """" the stored text is put into the unnamed register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto se almacenará
		en un registro sin nombre en caso de no usar «"x» o «""».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*{}*
{}		Curly braces denote parts of the command which must appear,
		but which can take a number of different values.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*{}*
{}		Las llaves indican qué partes de una orden son
		obligatorios, pero que pueden tomar distintos valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
		differences between Vim and Vi are also given in curly braces
		(this will be clear from the context).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las
		diferencias entre Vim y Vi también se resaltan con llaves
		(el contexto aclarará esto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*{char1-char2}*
{char1-char2}	A single character from the range char1 to char2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*{car1-car2}*
{car1-car2}	Un único carácter entre el rango car1 y car2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
		example: {a-z} is a lowercase letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo:
		{a-z} simboliza un carácter en minúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ranges may be
		concatenated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encadenar
		varios rangos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, {a-zA-Z0-9} is any alphanumeric
		character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, {a,zA-Z0-9} es cualquier carácter
		alfanumérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*&lt;character&gt;*
&lt;character&gt;	A special character from the table below, optionally with
		modifiers, or a single ASCII character with modifiers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*&lt;carácter&gt;* *&lt;character&gt;*
&lt;carácter&gt;	Un carácter especial de la tabla a continuación, que acepta
		modificadores opciones, o un único carácter ASCII sin
		modificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*'character'*
'c'		A single ASCII character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*'character'*
'c'		Un único carácter ASCII.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*'option'*
'option'	An option, or parameter, that can be set to a value, is
		enclosed in single quotes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*'option'*
'opción'	Una opción o parámetro que puede definir con un valor
		aparecerá entre comillas simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |options|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |options|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*quotecommandquote*
"command"	A reference to a command that you can type is enclosed in
		double quotes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*quotecommandquote*
"orden"		Las referencias a una orden aparecerán entre comillas dobles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*key-notation* *key-codes* *keycodes*
These names for keys are used in the documentation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*notación-teclas* *teclas-tabla*
*leyendatabla*
Éstos son los nombres de las teclas en la documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They can also be used
with the ":map" command (insert the key name by pressing CTRL-K and then the
key you want the name for).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede
usarlos con la orden «:map» (inserte el nombre de la tecla pulsando CTRL-K y
la tecla cuyo nombre desea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>notation	meaning		    equivalent	decimal value(s)	~
-----------------------------------------------------------------------</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>notación	significado	    equivalente	    valor(es) decimal  ~
-----------------------------------------------------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Nul&gt;		zero			CTRL-@	  0 (stored as 10) *&lt;Nul&gt;*
&lt;BS&gt;		backspace		CTRL-H	  8	*backspace*
&lt;Tab&gt;		tab			CTRL-I	  9	*tab* *Tab*
							*linefeed*
&lt;NL&gt;		linefeed		CTRL-J	 10 (used for &lt;Nul&gt;)
&lt;FF&gt;		formfeed		CTRL-L	 12	*formfeed*
&lt;CR&gt;		carriage return		CTRL-M	 13	*carriage-return*
&lt;Return&gt;	same as &lt;CR&gt;				*&lt;Return&gt;*
&lt;Enter&gt;		same as &lt;CR&gt;				*&lt;Enter&gt;*
&lt;Esc&gt;		escape			CTRL-[	 27	*escape* *&lt;Esc&gt;*
&lt;Space&gt;		space				 32	*space*
&lt;lt&gt;		less-than		&lt;	 60	*&lt;lt&gt;*
&lt;Bslash&gt;	backslash		\	 92	*backslash* *&lt;Bslash&gt;*
&lt;Bar&gt;		vertical bar		|	124	*&lt;Bar&gt;*
&lt;Del&gt;		delete				127
&lt;CSI&gt;		command sequence intro  ALT-Esc 155	*&lt;CSI&gt;*
&lt;xCSI&gt;		CSI when typed in the GUI		*&lt;xCSI&gt;*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Nul&gt;		cero			CTRL-@	  0 (stored as 10) *&lt;Nul&gt;*
&lt;BS&gt;		tecla de retroceso	CTRL-H	  8	*backspace*
&lt;Tab&gt;		tabulado		CTRL-I	  9	*tab* *Tab*
							*linefeed*
&lt;NL&gt;		avanzar una línea	CTRL-J	 10 (usado por &lt;Nul&gt;)
&lt;FF&gt;		formfeed		CTRL-L	 12	*formfeed*
&lt;CR&gt;		retorno de línea	CTRL-M	 13	*carriage-return*
&lt;Return&gt;	idéntico a &lt;CR&gt;				*&lt;Return&gt;*
&lt;Enter&gt;		idéntico a &lt;CR&gt;				*&lt;Enter&gt;*
&lt;Esc&gt;		escape			CTRL-[	 27	*escape* *&lt;Esc&gt;*
&lt;Space&gt;		espacio				 32	*space*
&lt;lt&gt;		menos que		&lt;	 60	*&lt;lt&gt;*
&lt;Bslash&gt;	barra inversa		\	 92	*backslash* *&lt;Bslash&gt;*
&lt;Bar&gt;		barra vertical		|	124	*&lt;Bar&gt;*
&lt;Del&gt;		eliminar				127
&lt;CSI&gt;		command sequence intro 	ALT-Esc 155	*&lt;CSI&gt;*
&lt;xCSI&gt;		CSI tecleado en la interfaz gráfica	*&lt;xCSI&gt;*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;EOL&gt;		end-of-line (can be &lt;CR&gt;, &lt;LF&gt; or &lt;CR&gt;&lt;LF&gt;,
		depends on system and 'fileformat')	*&lt;EOL&gt;*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;EOL&gt;		«end-of-line» (fin de línea, puede ser &lt;CR&gt;, &lt;LF&gt;
		o &lt;CR&gt;&lt;LF&gt;, dependiendo del sistema y de 'fileformat')
		&lt;EOL&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: The shifted cursor keys, the help key, and the undo key are only available on a few terminals.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: Las teclas de movimiento, la tecla de ayuda y la tecla deshacer combinados con la tecla shift sólo están disponibles en algunas terminales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the Amiga, shifted function key 10 produces a code (CSI) that is also used by key sequences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Amiga, la tecla función 10 con shift produce un código (CSI) también empleado en secuencias de teclas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will be recognized only after typing another key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se reconocerá tras pulsar otra tecla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: There are two codes for the delete key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: Hay dos códigos para la tecla suprimir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>127 is the decimal ASCII value for the delete key, which is always recognized.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor decimal ASCII de la tecla suprime es 127, éste siempre se reconocerá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some delete keys send another value, in which case this value is obtained from the termcap entry "kD".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas teclas suprimir envían otro valor, en cuyo caso el valor se obtiene de la entrada de termcap «kD».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both values have the same effect.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ambos valores tienen el mismo efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see |:fixdel|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase también |:fixdel|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: The keypad keys are used in the same way as the corresponding "normal" keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: El uso de las teclas del teclado numérico es idéntico a sus teclas «normales» correspondientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, &lt;kHome&gt; has the same effect as &lt;Home&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, &lt;kHome&gt; tiene el mismo efecto que &lt;Home&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a keypad key sends the same raw key code as its non-keypad equivalent, it will be recognized as the non-keypad code.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si una tecla del bloque envía el mismo código que su equivalente externo al bloque numérico, será reconocido como un código que no pertenece al bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when &lt;kHome&gt; sends the same code as &lt;Home&gt;, when pressing &lt;kHome&gt; Vim will think &lt;Home&gt; was pressed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, cuando &lt;kHome&gt; envía el mismo código que &lt;Home&gt;, Vim creerá que pulsa &lt;Home&gt; cuando en realidad pulsa &lt;kHome&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapping &lt;kHome&gt; will not work then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De ser así, las macros con &lt;kHome&gt; no funcionarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples for mapping CTRL-H to the six characters "&lt;Home&gt;": &gt;
	:imap &lt;C-H&gt; \&lt;Home&gt;
	:imap &lt;C-H&gt; &lt;lt&gt;Home&gt;
The first one only works when the 'B' flag is not in 'cpoptions'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplos para asignar CTRL-H a los seis caracteres «&lt;Home&gt;»: &gt;
	:imap &lt;C-H&gt; \&lt;Home&gt;
	:imap &lt;C-H&gt; &lt;lt&gt;Home&gt;
El primero sólo funciona si la opción 'B' no está en 'cpoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second
one always works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El segundo
siempre funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get a literal "&lt;lt&gt;" in a mapping: &gt;
	:map &lt;C-L&gt; &lt;lt&gt;lt&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para obtener un &lt;lt&gt; en una macro: &gt;
	:map &lt;C-L&gt; &lt;lt&gt;lt&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For mapping, abbreviation and menu commands you can then copy-paste the examples and use them directly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede copiar y pegar los ejemplos directamente para las macros, abreviaturas y órdenes de menú.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or type them literally, including the '&lt;' and '&gt;' characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O también introducirlos literalmente, incluyendo los caracteres «&lt;» y «&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does NOT work for other commands, like ":set" and ":autocmd"!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Esto NO funciona con otras órdenes, como «:set» y «:autocmd».!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modes, introduction				*vim-modes-intro* *vim-modes*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introducción a los modos	*modos-vim* *vim-modes-intro* *vim-modes*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual mode		This is like Normal mode, but the movement commands
			extend a highlighted area.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Visual		Es similar al modo Normal, pero las órdenes de
			movimiento extienden un área resaltada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a non-movement
			command is used, it is executed for the highlighted
			area.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use
			una orden que no sea de moción, éste afectará a toda
			el área resaltada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Visual-mode|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |Visual-mode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- VISUAL --" is shown
			at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción 'showmode' está activada, verá 
			«-- VISUAL --» en la parte inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select mode		This looks most like the MS-Windows selection mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo seleccionar		Similar al modo de selección de MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing a printable character deletes the selection
			and starts Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear un carácter imprimible elimina la selección
			e inicia el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Select-mode|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |Select-mode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- SELECT --" is shown
			at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción 'showmode' esta activada, verá
			«-- SELECT --» en la parte inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode		In Insert mode the text you type is inserted into the
			buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Insertar		En el modo Insertar, el texto que teclee
			aparecerá en el búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Insert-mode|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |Insert-mode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- INSERT --" is shown
			at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción 'showmode' esta activada, verá
			«-- INSERT --» en la parte inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command-line mode	In Command-line mode (also called Cmdline mode) you
Cmdline mode		can enter one line of text at the bottom of the
			window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Línea de órdenes	En este modo (también llamado «Cmdline mode»)
Cmdline mode		puede introducir una línea de texto en la parte
			inferior de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is for the Ex commands, ":", the pattern
			search commands, "?" and "/", and the filter command,
			"!".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésto es para las órdenes
			Ex, «:», las órdenes de búsqueda de patrón, «?» y
			«/», y la orden de filtrado, «!».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|Cmdline-mode|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|Cmdline-mode|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ex mode			Like Command-line mode, but after entering a command
			you remain in Ex mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Ex			Es similar al modo Línea de órdenes, pero
			permanecerá en modo Ex después de ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very limited editing of the
			command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ofrece una edición limitada de la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|Ex-mode|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|Ex-mode|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Operator-pending* *Operator-pending-mode*
Operator-pending mode	This is like Normal mode, but after an operator
			command has started, and Vim is waiting for a {motion}
			to specify the text that the operator will work on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*Operator-pending* *Operator-pending-mode*
Modo Operator-pending	Es similar al modo Normal, pero se inicia tras una
			orden de operador, tras el cual Vim esperará a un
			movimiento {motion} para especificar el texto
			afectado por el operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace mode		Replace mode is a special case of Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Reemplazar		El modo Reemplazar es un tipo especial del modo
			Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
			can do the same things as in Insert mode, but for
			each character you enter, one character of the existing
			text is deleted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer las mismas cosas que en el modo
			Insertar, pero sustituirá un carácter existente por
			cada carácter que inserte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Replace-mode|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |Replace-mode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- REPLACE --" is
			shown at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción 'showmode' está activada, verá
			«-- REPLACE --» en la base de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual Replace mode	Virtual Replace mode is similar to Replace mode, but
			instead of file characters you are replacing screen
			real estate.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Reemplazar Virtual El modo Reemplazar Virtual es similar al modo
			Reemplazar, pero en lugar de reemplazar caracteres,
			reemplaza el estado real de la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |Virtual-Replace-mode|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |Virtual-Replace-mode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- VREPLACE --" is
			shown at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción 'showmode' está activada, verá
			«-- VREPLACE --» en la base de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert Select mode	Entered when starting Select mode from Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modo Seleccionar	Se inicia al ejecutar el modo Seleccionar a partir
de inserción		del modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g., by dragging the mouse or &lt;S-Right&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, arrastrando el ratón
			o &lt;S-Derecha&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the Select mode ends, Vim returns to Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le devolverá al modo Insertar al
			finalizar el modo Seleccionar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showmode' option is on "-- (insert) SELECT --"
			is shown at the bottom of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la opción
			'showmode' está activada, verá «-- (insert) SELECT --»
			en la base de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switching from mode to mode				*mode-switching*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cambiar de modo			*cambiar-modo*  *mode-switching*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*i_esc*
		TO mode						    ~
		Normal	Visual	Select	Insert	  Replace   Cmd-line  Ex ~
FROM mode								 ~
Normal			v V ^V	  *4	 *1	   R gR     : / ?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*i_esc*
		DESDE el modo					    ~
		Normal	Visual	Selección Insertar Reemplazar Línea  Ex ~
							   de órdenes
A el modo								 ~
Normal			v V ^V	  *4	 *1¿	   R gR     : / ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q
Visual		 *2		  ^G	 c C	    --	      :       --
Select		 *5	^O ^G		 *6	    --	      --      --
Insert		 &lt;Esc&gt;	  --	  --		  &lt;Insert&gt;    --      --
Replace		 &lt;Esc&gt;	  --	  --	&lt;Insert&gt;	      --      --
Command-line	 *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Q
Visual		 *2		  ^G	 c C	    --	      :       --
Seleccionar	 *5	^O ^G		 *6	    --	      --      --
Insertar	 &lt;Esc&gt;	  --	  --		  &lt;Insertar&gt;  --      --
Reemplazar	 &lt;Esc&gt;	  --	  --	&lt;Insertar&gt;	      --      --
Línea de órdenes *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N* *v_CTRL-\_CTRL-N*
Additionally the command CTRL-\ CTRL-N or &lt;C-\&gt;&lt;C-N&gt; can be used to go to
Normal mode from any other mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N* *v_CTRL-\_CTRL-N*
De forma adicional, puede usar CTRL-\ CTRL-N o &lt;C-\&gt;&lt;C-N&gt; para pasar al modo
Normal a partir de cualquier otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to make sure Vim is in
Normal mode, without causing a beep like &lt;Esc&gt; would.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar esto para asegurarse de que Vim
está en modo Normal, sin causar el pitido que &lt;Esc&gt; realiza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, this does not
work in Ex mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otra parte,
esto no funciona en modo Ex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used after a command that takes an argument, such as
|f| or |m|, the timeout set with 'ttimeoutlen' applies.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa esto después de una orden que toma un
argumento, como |f| o |m|, se aplicará la cuenta atrás definida con
'ttimeoutlen'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
The command CTRL-\ CTRL-G or &lt;C-\&gt;&lt;C-G&gt; can be used to go to Insert mode when
'insertmode' is set.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
La orden CTRL-\ CTRL-G o &lt;C-\&gt;&lt;C-G&gt; se puede usar para pasar al modo Insertar
cuando 'insertmode' está definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise it goes to Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, vuelve al modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to
make sure Vim is in the mode indicated by 'insertmode', without knowing in
what mode Vim currently is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar esto para asegurarse de que Vim está en el modo indicado por
'insertmode', sin conocer el modo actual en el que está Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The window contents					*window-contents*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El contenido de las ventanas		*ventanas-contenido* *window-contents*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Normal mode and Insert/Replace mode the screen window will show the current
contents of the buffer: What You See Is What You Get.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana muestra los contenidos actuales del búfer en modo Normal y modo
Insertar/Reemplazar: lo que ve es lo que hay.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two
exceptions:
- When the 'cpoptions' option contains '$', and the change is within one line,
  the text is not directly deleted, but a '$' is put at the last deleted
  character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos excepciones:
- Si la opción 'cppoptions' contiene «$», y el cambio se realizará dentro
  de una línea, el texto no se eliminará directamente, sino que se insertará
  «$» en el último carácter eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- When inserting text in one window, other windows on the same text are not
  updated until the insert is finished.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Si inserta texto en una ventana, otras ventanas mostrando el mismo
  contenido no se actualizarán hasta finalizar la inserción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{Vi: The screen is not always updated on slow terminals}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{Vi: La pantalla no se refrescará siempre en terminales lentas}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lines longer than the window width will wrap, unless the 'wrap' option is off (see below).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas más largas que el ancho de la ventana se justificarán a menos que la opción 'wrap' esté desactivada (consulte a continuación).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'linebreak' option can be set to wrap at a blank character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'linebreak' se puede configurar para justificar a partir de un carácter vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-----------------------+
	|some line		|
	|last line		|
	|~			|
	|~			|
	+-----------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-----------------------+
	|alguna línea		|
	|última línea		|
	|~			|
	|~			|
	+-----------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-----------------------+
	|first line		|
	|second line		|
	|@			|
	|@			|
	+-----------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-----------------------+
	|primera línea		|
	|segunda línea		|
	|@			|
	|@			|
	+-----------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-----------------------+
	|first line		|
	|second line		|
	|a very long line that d|
	|oesn't fit in the wi@@@|
	+-----------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-----------------------+
	|primera línea		|
	|segunda línea		|
	|una línea muy larga que|
	|no encaja en la vent@@@|
	+-----------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a single line that is too long to fit in the window, this is a special situation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una situación particular es cuando existe una sola línea que no encaja en la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will show only part of the line, around where the cursor is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim mostrará solo la parte de la línea en torno al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no special characters shown, so that you can edit all parts of this line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No verá caracteres especiales, para que así pueda editar esa parte de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{Vi: gives an "internal error" on lines that do not fit in the window}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{Vi: devuelve un «error interno» en las líneas que no encajan en la ventana.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The '@' occasion in the 'highlight' option can be used to set special highlighting for the '@' and '~' characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La aparición de «@» en la opción 'highlight' (resaltar) se puede usar para dar un resaltado especial a los caracteres «@» y «~».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes it possible to distinguish them from real characters in the buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto posibilita distinguirlos de aquellos caracteres reales en el búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All normal ASCII characters are displayed directly on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todos los caracteres normales ASCII aparecerán directamente en la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Tab&gt; is replaced with the number of spaces that it represents.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Tab&gt; será reemplazada por el número de espacios que representa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other non-printing characters are replaced with "^{char}", where {char} is the non-printing character with 64 added.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otros caracteres no imprimibles se reemplazarán por «^{char}», donde
{char} es el carácter no imprimible más la suma de 64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus character 7 (bell) will be shown as "^G".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, el carácter
7 (campana) aparecerá como «^G».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Characters between 127 and 160 are replaced with "~{char}", where {char} is the character with 64 subtracted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los caracteres entre el 127 y el 160 serán
reemplazados por «~{char}», donde {char} es el carácter menos la resta de 64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These characters occupy more than one position on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos caracteres tomarán más de un espacio en la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor can only be positioned on the first one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor sólo
aparecerá sobre el primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you set the 'number' option, all lines will be preceded with their
number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si activa la opción 'number', todas las líneas estarán precedidas por su
número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tip: If you don't like wrapping lines to mix with the line numbers,
set the 'showbreak' option to eight spaces:
	":set showbreak=\ \ \ \ \ \ \ \ "</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consejo: Si no le gusta que el justificado de línea se mezcle con
los números de línea, configure la opción 'showbreak' con 8 espacios:
	«:set showbreak=\ \ \ \ \ \ \ \ »</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you set the 'list' option, &lt;Tab&gt; characters will not be shown as several spaces, but as "^I".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los caracteres &lt;Tab&gt; aparecerán como ^I, en lugar de como varios espacios, en caso de activar la opción 'list'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A '$' will be placed at the end of the line, so you can find trailing blanks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se insertará un «$» al final de la
línea para así poder encontrar caracteres en exceso al final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Command-line mode only the command-line itself is shown correctly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el modo Línea de órdenes, sólo la misma línea de órdenes se mostrará correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The display of the buffer contents is updated as soon as you go back to Command mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La vista de los contenidos del búfer se actualizarán tan pronto como vuelva al modo de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last line of the window is used for status and other messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La última línea de la ventana se usa para mostrar el estado y otros mensajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The status messages will only be used if an option is on:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se mostrarán los mensajes de estado si activa una opción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The current mode is "-- INSERT --" or "-- REPLACE --", see |'showmode'|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo actual es «-- INSERT --» o «-- REPLACE --», consulte |'showmode|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command characters are those that you typed but were not used yet.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los caracteres de la orden son aquellos que tecleó pero que aún no ha ejectuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{Vi: does not show the characters you typed or the cursor position}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{Vi: no muestra los caracteres que ha introducido, o la posición del cursor.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a slow terminal you can switch off the status messages to speed
up editing:
	:set nosc noru nosm</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desactivar los mensajes de estado para agilizar la edición si tiene una
terminal lenta:
	:set nosc noru nosm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is an error, an error message will be shown for at least one second (in reverse video).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de error, verá un mensaje de error durante al menos un segundo (en vídeo inverso).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{Vi: error messages may be overwritten with other messages before you have a chance to read them}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{Vi: puede que los mensajes de error sean sobreescritos antes de poder leerlos.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands show how many lines were affected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes muestran cuantas líneas fueron afectadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Above which threshold this happens can be controlled with the 'report' option (default 2).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede controlar el umbral a partir del cual esto ocurre con la opción 'report' (2 por omisión).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the Amiga Vim will run in a CLI window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim se ejecutará en una ventana CLI bajo Amiga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name Vim and the full name of the current file name will be shown in the title bar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre «Vim» y el nombre completo del archivo aparecerán en la barra de título.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the window is resized, Vim will automatically redraw the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim redibujará la ventana en caso de redimensionarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may make the window as small as you like, but if it gets too small not a single line will fit in it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede reducir la ventana tanto como quiera, pero no cabrá ni una línea en caso de reducirla demasiado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make it at least 40 characters wide to be able to read most messages on the last line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga que tenga, por lo menos, un ancho de 40 columnas para poder leer la mayoría de mensajes en la última línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On most Unix systems, resizing the window is recognized and handled correctly by Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de sistemas Unix Vim trata adecuadamente redimensionar las ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{Vi: not ok}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{Vi: no tan bien.}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>8.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Definitions						*definitions*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definiciones				 *definiciones* *definitions*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>screen		The whole area that Vim uses to work in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>pantalla		El área completa que usa Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be
			a terminal emulator window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ser la ventana de
			un emulador de terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also called "the Vim
			window".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También llamada la «ventana
			de Vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>window		A view on a buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ventana		El área de visión de un búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------+
screen	| window 1	| window 2	|
	|		|		|
	|		|		|
	|= status line =|= status line =|
	| window 3			|
	|				|
	|				|
	|==== status line ==============|
	|command line			|
	+-------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------+
pantalla| ventana 1	| ventana 2	|
	|		|		|
	|		|		|
	|línea de estado|línea de estado|
	| ventana 3			|
	|				|
	|				|
	|==== línea de estado ==========|
	|línea de órdenes		|
	+-------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command line is also used for messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea de órdenes se usa también para mensajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It scrolls up the screen when there is not enough room in the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplaza la pantalla hacia arriba cuando no hay suficiente espacio para la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>buffer lines	logical lines	window lines	screen lines ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>líneas de búfer	líneas lógicas	líneas de ventana	líneas de pantalla ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1. one		1. one		1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1. uno		1. uno		1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-- folded   1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-- plegado  1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-- folded
2. two		2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-- plegado
2. dos		2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-- folded	2. five		2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-- plegado	2. cinco	2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>five
3. three	3. five		3. six		3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cinco
3. tres		3. cinco	3. seis		3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>six
4. four		4. six		4. seven	4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>seis
4. cuatro	4. seis		4. siete	4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>seven
5. five		5. seven			5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>siete
5. cinco	5. siete			5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>=== status line ===
6. six						6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>=== línea de estado ===
6. seis						6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>aaa
7. seven					7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>aaa
7. siete					7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>bbb
						8.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>bbb
						8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ccc ccc c
1. aaa		1. aaa		1. aaa		9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ccc ccc c
1. aaa		1. aaa		1. aaa		9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cc
2. bbb		2. bbb		2. bbb		10. ddd
3. ccc ccc ccc	3. ccc ccc ccc	3. ccc ccc c	11.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cc
2. bbb		2. bbb		2. bbb		10. ddd
3. ccc ccc ccc	3. ccc ccc ccc	3. ccc ccc c	11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~ 
4. ddd		4. ddd		4. cc		12.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~ 
4. ddd		4. ddd		4. cc		12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>=== status line ===
				5. ddd		13.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>=== línea de estado ===
				5. ddd		13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(command line)
				6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(línea de órdenes)
				6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim:tw=78:ts=8:ft=help:norl:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim:tw=78:ts=8:ft=help:norl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_21.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_21.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2008 Nov 09</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 9/11/2008</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go away and come back</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Abandonar el editor y volver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|21.1|	Suspend and resume
|21.2|	Executing shell commands
|21.3|	Remembering information; viminfo
|21.4|	Sessions
|21.5|	Views
|21.6|	Modelines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|21.1|	Suspender y continuar
|21.2|	Ejecutar órdenes de consola
|21.3|	Recordar información; viminfo
|21.4|	Sesiones
|21.5|	Vistas
|21.6|	«Modelines»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_22.txt|  Finding the file to edit
 Previous chapter: |usr_20.txt|  Typing command-line commands quickly
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_22.esx|  Encontrar el archivo a editar
  Capítulo anterior: |usr_20.esx|  Teclear con rapidez órdenes de consola
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.1*	Suspend and resume</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.1*	Suspender y continuar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-Z
	{any sequence of shell commands}
	fg</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-Z
	{cualquier secuencia de órdenes de consola}
	fg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only Unix has support for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solo Unix es compatible con esta función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On other systems Vim will start a shell for
you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim iniciará una consola
en otros sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also has the functionality of being able to execute shell commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también tiene la funcionalidad de permitirle
ejecutar órdenes de consola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it's a new shell, not the one that you started Vim from.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero esta es una nueva consola, no desde la que inició Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are running the GUI you can't go back to the shell where Vim was
started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando está ejecutando la interfaz gráfica no puede volver a la consola
desde la que se inició Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-Z will minimize the Vim window instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta situación, CTRL-Z minimizará la ventana
de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.2*	Executing shell commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.2*	Ejecutar órdenes de consola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To execute a single shell command from Vim use ":!{command}".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:!{orden}» para ejecutar una sola orden de consola desde Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to see a directory listing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para ver el listado de un directorio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!ls
	:!dir</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!ls
	:!dir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first one is for Unix, the second one for MS-Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primero es para Unix, el segundo para MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will execute the program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ejecutará el programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it ends you will get a prompt to hit
&lt;Enter&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando finalice, obtendrá un dialogo para
pulsar &lt;Intro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to have a look at the output from the command before
returning to the text you were editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite ver la salida de la orden antes de volver
al texto que estaba editando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!" is also used in other places where a program is run.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El signo «!» también se usa en otros sitios cuando se ejecuta un programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take
a look at an overview:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veamos com funciona esto de una manera general.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!{program}		execute {program}
	:r !{program}		execute {program} and read its output
	:w !{program}		execute {program} and send text to its input
	:[range]!{program}	filter text through {program}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!{programa}		execute {programa}
	:r !{programa}		execute {programa} y lea su salida
	:w !{programa}		execute {programa} y envíe texto a su entrada
	:[range]!{programa}	filtra texto a través de {programa}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the presence of a range before "!{program}" makes a big difference.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nótese que la presencia de un rango antes de «!{programa}» marca una gran diferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without it executes the program normally, with the range a number of text lines is filtered through the program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin él, ejecuta el programa de manera normal, con el rango se filtran un número de líneas a través del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Executing a whole row of programs this way is possible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es imposible ejecutar una fila de programas de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But a shell is much better at it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero una consola es mejor para estas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start a new shell this way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar una nueva consola de la siguiente manera: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:shell</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to using CTRL-Z to suspend Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es parecido al uso de «CTRL-Z» para suspender Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The difference is that a new shell is started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La diferencia es que se inicia una nueva consola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the GUI the shell will be using the Vim window for its input and
output.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar la GUI, la consola usará la ventana de Vim para entrada y salida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since Vim is not a terminal emulator, this will not work perfectly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya
que Vim no es una terminal, esto no funcionará perfectamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have trouble, try toggling the 'guipty' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene un problema, pruebe a conmutar la opción 'guipty'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this still doesn't
work well enough, start a new terminal to run the shell in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto tampoco
funciona, inicie una nueva terminal para iniciar el intérprete de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example with:
&gt;
	:!xterm&amp;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, con:
&gt;
	:!xterm&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.3*	Remembering information; viminfo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.3*	Recordar información; viminfo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command-line and Search pattern history
	Text in registers
	Marks for various files
	The buffer list
	Global variables</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Histórico de la línea de órdenes y patrones de búsqueda
	Texto en registros
	Marcas para varios archivos
	La lista de búfers
	Variables globales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time you exit Vim it will store this information in a file, the viminfo file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada vez que cierre Vim, este guardará esta información en un archivo, el archivo viminfo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Vim starts again, the viminfo file is read and the information restored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando inicie Vim otra vez, leerá el archivo viminfo y restaurará la información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'viminfo' option is set by default to restore a limited number of items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'viminfo' esta configurada por omisión para almacenar un limitado número de elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to set it to remember more information.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desee configurarlo para que recuerde más información.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done through the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se hace con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set viminfo=string</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set viminfo=string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set viminfo='1000</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set viminfo='1000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The f option controls whether global marks (A-Z and 0-9) are stored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «f» controla si se guardan las marcas globales (A-Z y 0-9).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this option is 0, none are stored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esta opción es 0, no se guarda nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is 1 or you do not specify an f option, the marks are stored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es 1 o no especificó una opción «f», las marcas se guardan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want this feature, so now you have this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea esta función, y por ello ahora obtiene esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set viminfo='1000,f1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set viminfo='1000,f1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt; option controls how many lines are saved for each of the registers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «&lt;» define el número de líneas a guardar por cada registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all the lines are saved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, todas las líneas se guardan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If 0, nothing is saved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es 0, nada se guarda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid adding thousands of lines to your viminfo file (which might never get used and makes starting Vim slower) you use a maximum of 500 lines: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que se añadan miles de líneas a su archivo viminfo (que puede que nunca se usen, y ralenticen el arranque de Vim) puede usar un máximo de 500 líneas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set viminfo='1000,f1,&lt;500
&lt;
Other options you might want to use:
	:	number of lines to save from the command line history
	@	number of lines to save from the input line history
	/	number of lines to save from the search history
	r	removable media, for which no marks will be stored (can be
		used several times)
	!	global variables that start with an uppercase letter and
		don't contain lowercase letters
	h	disable 'hlsearch' highlighting when starting
	%	the buffer list (only restored when starting Vim without file
		arguments)
	c	convert the text using 'encoding'
	n	name used for the viminfo file (must be the last option)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set viminfo='1000,f1,&lt;500
&lt;
Otras opciones que puede que desee usar:
	:	número de líneas a guardar del historial de la línea
		de órdenes
	@	número de líneas a guardar de la línea de entrada del
		historial
	/	número de líneas a guardar del historial de búsquedas
	r	dispositivos extraíbles, del cual no se guardan marcas
		(se puede introducir varias veces)
	!	variables globales que comienzan con mayúscula y que no
		contienen minúsculas
	h	desactivar el resaltado de 'hlsearch' al inicio
	%	la lista de búfers (solo se restaura si inicia Vim
		sin argumentos de archivo)
	c	convertir el texto usando 'encoding'
	n	nombre usado para el archivo viminfo (tiene que ser la
		última opción)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go back to a file that you edited recently, but not when exiting Vim, there is a slightly more complicated way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea volver a un archivo que editó recientemente, pero no al cerrar Vim, hay una manera un tanto más complicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see a list of files by typing the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver una lista de archivos tecleando la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you would like to edit the second file, which is in the list preceded by "2:".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora le gustaría editar el segundo archivo, que está en la lista precedido por «2:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:e #&lt;2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:e #&lt;2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ":e" you can use any command that has a file name argument, the "#&lt;2" item works in the same place as "%" (current file name) and "#" (alternate file name).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de «:e», puede usar cualquier orden que tiene un nombre de archivo como argumento, el elemento «#&lt;2» funciona en el mismo lugar que «%» (nombre del archivo actual) y «#» (nombre de archivo alterno).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So you can also split the window to edit the third file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede también dividir la ventana para editar el tercer archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:split #&lt;3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:split #&lt;3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That #&lt;123 thing is a bit complicated when you just want to edit a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar #&lt;123 es poco complicado cuando solo quiere editar un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately there is a simpler way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Afortunadamente, hay una manera más simple: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:browse oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
	-- More --</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:browse oldfiles
&lt;	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
	-- Más --</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get the same list of files as with |:oldfiles|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá la misma lista de archivos que con |:oldfiles|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to edit "resume.txt" first press "q" to stop the listing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea editar «resume.txt», pulse primero «q» para detener el listado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will get a prompt:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá un dialogo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type number and &lt;Enter&gt; (empty cancels): ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee el número y pulse &lt;Intro&gt; (vaciar cancelaciones): ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the ":wviminfo" and ":rviminfo" commands to save and restore the information while still running Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede emplear las órdenes «:wviminfo» y «:rviminfo» para guardar y restaurar la información mientras Vim se está ejecutando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful for exchanging register contents between two instances of Vim, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésto es útil para intercambiar los contenidos del registro de dos instancias de Vim, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first Vim do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el primer Vim, haga: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wviminfo!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wviminfo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:rviminfo!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:rviminfo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, the "w" stands for "write" and the "r" for "read".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, «w» significa «write», y «r», «read».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ! character is used by ":wviminfo" to forcefully overwrite an existing
file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El caracter «!» se usa por «:wviminfo» para forzar la sobreescritura de
un archivo existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it is omitted, and the file exists, the information is merged into
the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se omite, y el archivo existe, la información
es fusionada en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ! character used for ":rviminfo" means that all the information is
used, this may overwrite existing information.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El caracter «!» usado por «:rviminfo» significa que se usa toda la
información, y esto puede sobreescribir información ya presente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without the ! only information
that wasn't set is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin «!»
sólo se usa la información que no estaba definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These commands can also be used to store info and use it again later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas órdenes se pueden usar también para guardar info y usarlo más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
could make a directory full of viminfo files, each containing info for a
different purpose.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear un directorio lleno de archivos «viminfo», cada uno con info
dependiendo del propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.4*	Sessions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.4*	Sesiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mksession vimbook.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mksession vimbook.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:source vimbook.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:source vimbook.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -S vimbook.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -S vimbook.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to read a specific file on startup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le dice a Vim que lea un archivo en particular al inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'S' stands for session (actually, you can source any Vim script with -S, thus it might as well stand for "source").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «S» significa sesión (en realidad, puede introducir cualquier script a Vim con «-S», por ello también puede significar «source», fuente).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The windows that were open are restored, with the same position and size as
before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las ventanas que estaban abiertas se restauran, con la misma posición y
tamaño que antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mappings and option values are like before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las macros y valores de opciones son también las mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What exactly is restored depends on the 'sessionoptions' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que se restaura exactamente depende de la opción 'sessionoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
default value is "blank,buffers,curdir,folds,help,options,winsize".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
valor predeterminado es «blank,buffers,curdir,folds,help,options,winsize».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>blank		keep empty windows
	buffers		all buffers, not only the ones in a window
	curdir		the current directory
	folds		folds, also manually created ones
	help		the help window
	options		all options and mappings
	winsize		window sizes</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>blank		mantener ventanas vacías
	buffers		todos los «buffers», no sólo los de una ventana
	curdir		el directorio actual
	folds		pliegues, también los manualmente creados
	help			la ventana de ayuda
	options		todas las opciones y macros
	winsize		tamaño de ventanas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change this to your liking.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modifique esto según su convenienvia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To also restore the size of the Vim window, for example, use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para también restaurar el tamaño de la ventana de Vim use, por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set sessionoptions+=resize</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set sessionoptions+=resize</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The obvious way to use sessions is when working on different projects.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera obvia de usar sesiones es cuando trabaja en diferenes proyetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you store you session files in the directory "~/.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que guarda sus archivos de sesión en el directorio «~/.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are currently working on the "secret" project and have to switch to the "boring" project: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Está trabajando actualmente en el proyecto «secreto» y tiene que cambiar al proyecto «aburrido»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wall
	:mksession!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wall
	:mksession!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vim/secret.vim
	:source ~/.vim/boring.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vim/secreto.vim
	:source ~/.vim/aburrido.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:source ~/.vim/boring.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:source ~/.vim/aburrido.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you have complete control over whether you want to continue next time
where you are now, by saving the current setup in a session, or keep the
session file as a starting point.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, ahora tiene un completo control sobre continuar en el mismo punto
la siguiente vez que lo abra, guardando la configuración actual en una
sesión, o mantener el archivo de sesión como un punto de partida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way of using sessions is to create a window layout that you like to
use, and save this in a session.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera de usar sesiones es crear una organización de ventana que le
gusta usar, y guardarla en una sesión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can go back to this layout whenever
you want.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después podrá volver a este orden
siempre que quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, this is a nice layout to use:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, esta es una bonita organización que puede usar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------------+
	|		   VIM - main help file  |
	|					 |
	|Move around:  Use the cursor keys, or "h|
	|help.txt================================|
	|explorer   |				 |
	|dir	    |~				 |
	|dir	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|~/=========|[No File]===================|
	|					 |
	+----------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------------+
	|		   VIM - main help file  |
	|					 |
	|Desplazarse:  Use las teclas de direcció|
	|help.txt================================|
	|explorer   |				 |
	|dir	    |~				 |
	|dir	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|file	    |~				 |
	|~/=========|[No File]===================|
	|					 |
	+----------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This has a help window at the top, so that you can read this text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta tiene una ventana de ayuda en la parte superior, para que pueda leer
este texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The narrow
vertical window on the left contains a file explorer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La estrecha ventana vertical a la izquierda contiene un
explorador de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a Vim plugin
that lists the contents of a directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una extensión de Vim que lista los
contenidos de un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can select files to edit there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede seleccionar qué archivos editar ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about this in the next chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más acerca de esto en el siguiente capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create this from a just started Vim with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear esto con una instancia nueva de Vim con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help
	CTRL-W w
	:vertical split ~/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help
	CTRL-W w
	:vertical split ~/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can resize the windows a bit to your liking.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede redimensionar las ventanas a su gusto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then save the session with:
&gt;
	:mksession ~/.vim/mine.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Guarde entonces la sesión con:
&gt;
	:mksession ~/.vim/mio.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -S ~/.vim/mine.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -S ~/.vim/mio.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: To open a file you see listed in the explorer window in the empty window, move the cursor to the filename and press "O".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pista: Para abrir un archivo que vea listado en la ventana del explorador en la ventana vacía, mueva el cursor al nombre del archivo y pulse «O».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Double clicking with the mouse will also do this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar dos veces con el ratón le daría el mismo resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some people have to do work on MS-Windows systems one day and on Unix another day.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay gente que tiene que trabajar un día con sistemas MS-WINDOWS y con Unix al siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are one of them, consider adding "slash" and "unix" to 'sessionoptions'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es uno de ellos, considere añadir «slash» y «unix» a 'sessionoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The session files will then be written in a format that can be used on both systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los archivos de sesión se guardarán en un formato que les permita ser usados en ambos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the command to put in your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una orden para poner en su archivo vimrc: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set sessionoptions+=unix,slash</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set sessionoptions+=unix,slash</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will use the Unix format then, because the MS-Windows Vim can read and write Unix files, but Unix Vim can't read MS-Windows format session files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará el formato Unix, porque Vim para MS-Windows puede leer y escribir archivos de Unix, pero Vim para Unix no puede leer los archivos de sesión con formato de MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, MS-Windows Vim understands file names with / to separate names, but Unix Vim doesn't understand \.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De manera similar, Vim para MS-Windows entiene los nombres de archivo con «/» como diferentes palabras, pero Vim para Unix no entiende «\».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sessions store many things, but not the position of marks, contents of
registers and the command line history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las sesiones guardan muchas cosas, pero no la posición de las marcas,
contenidos de registros e historiales de la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to use the viminfo feature
for these things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Precisa emplear
«viminfo» para estas cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most situations you will want to use sessions separately from viminfo.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de las situaciones deseará usar sesiones separadas de
«viminfo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to switch to another session, but keep the command line
history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede emplear esto para pasar a otra sesión, pero manteniendo el historial
de la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And yank text into registers in one session, and paste it back in
another session.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede copiar el texto de los registros de una
sesión, y pegarlos en otra sesión diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might prefer to keep the info with the session.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que prefiera mantener el información en la sesión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have to do
this yourself then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que hacer
esto usted mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mksession!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mksession!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vim/secret.vim
	:wviminfo!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vim/secreto.vim
	:wviminfo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:source ~/.vim/secret.vim
	:rviminfo!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:source ~/.vim/secreto.vim
	:rviminfo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.5*	Views</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.5*	Vistas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A session stores the looks of the whole of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una sesión guarda el aspecto completo de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to store the
properties for one window only, use a view.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando desea guardar sólo las
propiedades de una ventana, use una vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use of a view is for when you want to edit a file in a specific way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El uso de una vista es útil cuando desea editar un archivo de una manera
específica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you have line numbers enabled with the 'number' option and
defined a few folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, ha activado el número de líneas con la opción 'number' y
definido algunos plegados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with sessions, you can remember this view on
the file and restore it later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al igual que con las sesiones, puede guardar esta
vista en el archivo y restaurarla más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, when you store a session, it stores
the view of each window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, cuando guarda una
sesión, éste guarda la vista de cada ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two basic ways to use views.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos maneras básicas de usar las vistas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first is to let Vim pick a name
for the view file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera es dejar que Vim
escoja el nombre para el archivo de la vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the view when you later edit the same
file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede restaurar la vista
posteriormente cuando edite el mismo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To store the view for the current window: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para guardar la vista de la
ventana actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mkview</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mkview</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will decide where to store the view.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim decidirá donde guardar la vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you later edit the same file you get the view back with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando más tarde edite el mismo archivo puede recuperar la vista con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:loadview</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:loadview</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's easy, isn't it?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fácil, ¿no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you want to view the file without the 'number' option on, or with all
folds open, you can set the options to make the window look that way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando quiere ver el archivo sin la opción 'number' activada, o con todos
los plegados abiertos, puede definir las opciones para que la ventana
presente ese aspecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then
store this view with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez hecho ésto, guarde ésta vista con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mkview 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mkview 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:loadview 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:loadview 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can switch between the two views on the file by using ":loadview" with
and without the "1" argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede pasar de una vista a otra del archivo usando «:loadview» con y
sin el argumento «1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can store up to ten views for the same file this way, one unnumbered
and nine numbered 1 to 9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta forma, puede guardar hasta diez vistas para el
mismo archivo, uno sin numerar y nueve numerados del 1 al 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second basic way to use views is by storing the view in a file with a name
you chose.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda manera básica de usar las vistas se puede hacer guardando la vista
en un archivo con un nombre de su elección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This view can be loaded while editing another file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cargar esta vista mientras
edita un archivo distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will then
switch to editing the file specified in the view.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, Vim pasará a editar el archivo
especificado en la vista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can use this to
quickly switch to editing another file, with all its options set as you saved
them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, puede usar ésto para pasar rápidamente
a editar otro archivo, con todas las opciones definidas tal y como las
guardó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to save the view of the current file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para guardar la vista del archivo actual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mkview ~/.vim/main.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mkview ~/.vim/principal.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:source ~/.vim/main.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:source ~/.vim/principal.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*21.6*	Modelines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*21.6*	«Modelines»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When editing a specific file, you might set options specifically for that
file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al editar un archivo en particular, puede que defina opciones específicas
para ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing these commands each time is boring.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear estas órdenes es aburrido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a session or view for
editing a file doesn't work when sharing the file between several people.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar una sesión o vista
para editar un archivo no funciona cuando comparte el archivo con varias
personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution for this situation is adding a modeline to the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La solución para esta situación es añadir un «modeline» al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is
a line of text that tells Vim the values of options, to be used in this file
only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éste
es una línea de texto que le dice a Vim los valores de las opciones para su
uso con este archivo en particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A typical example is a C program where you make indents by a multiple of 4
spaces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo típico es un programa en C en el que introduce los tabulados
como múltiplos de 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This requires setting the 'shiftwidth' option to 4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto requiere que configure la opción 'shiftwidth' a 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This modeline
will do that:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este «modeline» hará esta función:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* vim:set shiftwidth=4: */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* vim:set shiftwidth=4: */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this line as one of the first or last five lines in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga esta línea como uno de las primeras o cinco últimas líneas en el
archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When
editing the file, you will notice that 'shiftwidth' will have been set to
four.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite el archivo, notará que 'shiftwidth' se ha definido
con valor de cuatro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When editing another file, it's set back to the default value of eight.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite otro archivo, esta opción será devuelta
a su valor predeterminado de ocho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For some files the modeline fits well in the header, thus it can be put at
the top of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para algunas líneas, el «modeline» encaja en la cabecera, y por ello puede
ponerlo al inicio del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For text files and other files where the modeline gets
in the way of the normal contents, put it at the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para los archivos de texto y otros archivos en
los que el «modeline» se interpone en el camino de los contenidos normales,
póngala al final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'modelines' option specifies how many lines at the start and end of the file are inspected for containing a modeline.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «modelines» especifica cuantas líneas son inspeccionadas al inicio y final del archivo en busca de un «modeline».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To inspect ten lines: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para inspeccionar diez líneas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set modelines=10</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set modelines=10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'modeline' option can be used to switch this off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la opción 'modeline' para desactivar ésto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this when you are working as root on Unix or Administrator on MS-Windows, or when you don't trust the files you are editing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga ésto cuando trabaje como «root» en Unix, o administrador en MS-Windows; o cuando no confía en los archivos que está editando: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nomodeline</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nomodeline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>any-text vim:set {option}={value} ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>any-text vim:set {opción}={valor} ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>: any-text ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>: any-text ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "any-text" indicates that you can put any text before and after the part
that Vim will use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«any-text» indica que puede introducir texto antes y después de la parte
que Vim usará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows making it look like a comment, like what was
done above with /* and */.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite que presente el aspecto de un comentario, de la
manera en que se hizo antes con /* y */.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The " vim:" part is what makes Vim recognize this line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte de «vim:» es lo que hace que Vim reconozca esta línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There must be
white space before "vim", or "vim" must be at the start of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe haber
un espacio en blanco antes de «vim», o «vim» ha de estar al inicio de la
línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus
using something like "gvim:" will not work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, usar algo como «gvim» no funcionaría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The part between the colons is a ":set" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte entre los dos puntos es una orden «:set».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works the same way as
typing the ":set" command, except that you need to insert a backslash before a
colon (otherwise it would be seen as the end of the modeline).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Funciona de la misma
manera que teclear la orden «:set», con la excepción de que tiene que
introducir una barra inversa antes de un colon (en caso contrario, se vería
como el final de un «modeline»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>// vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>// vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an extra backslash before the first colon, so that it's included in the ":set" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una barra inversa extra antes del primer colon, y por ello se incluye en la orden «:set».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text after the second colon is ignored, thus a remark can be placed there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se ignora el texto antes del segundo colon, y por ello puede introducir aquí un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_29.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_29.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2008 Jun 28</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 8/6/2008</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving through programs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Moverse a través de programas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The creator of Vim is a computer programmer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El creador de Vim es un programador informático.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's no surprise that Vim contains many features to aid in writing programs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, no sorprende que Vim integre tantas características que facilitan la edición de programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jump around to find where identifiers are defined and used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Salte de un punto a otro para ver dónde se definen y usan los identificadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preview declarations in a separate window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Previsualize declaraciones en una ventana distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is more in the next chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay aún más en el siguiente capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|29.1|	Using tags
|29.2|	The preview window
|29.3|	Moving through a program
|29.4|	Finding global identifiers
|29.5|	Finding local identifiers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|29.1|	Usar etiquetas
|29.2|	La ventana de vista previa
|29.3|	Moverse a través de un programa
|29.4|	Buscar identificadores globales
|29.5|	Buscar identificadores locales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_30.txt|  Editing programs
 Previous chapter: |usr_28.txt|  Folding
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_30.txt|  Editar programas
  Capítulo anterior: |usr_28.esx|  Plegado
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.1*	Using tags</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.1*	Usar etiquetas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ctags *.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ctags *.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://ctags.sf.net ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>http://ctags.sf.net ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tag startlist</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tag startlist</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i &lt; cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--&gt; |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--&gt; |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------------+
	|void write_block(char **s; int cnt)  |
	|{				      |
	|   int i;			      |
	|   for (i = 0; i &lt; cnt; ++i)	      |
	|      write_line(s[i]);	      |
	|}	    |			      |
	+-----------|-------------------------+
		    |
	     CTRL-] |
		    |	 +----------------------------+
		    +--&gt; |void write_line(char *s)    |
			 |{			      |
			 |   while (*s != 0)	      |
			 |	write_char(*s++);     |
			 |}	  |		      |
			 +--------|-------------------+
				  |
			   CTRL-] |
				  |    +------------------------------------+
				  +--&gt; |void write_char(char c)		    |
				       |{				    |
				       |    putchar((int)(unsigned char)c); |
				       |}				    |
				       +------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tags
	  # TO tag	   FROM line  in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	&gt; ~
&gt;
Now to go back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tags
	  # TO tag	   FROM line  in file/text ~
	  1  1 write_line	   8  write_block.c ~
	  2  1 write_char	   7  write_line.c ~
	&gt; ~
&gt;
Vuelva atrás ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-T command goes to the preceding tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «CTRL-T» se desplaza a la etiqueta precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example
above you get back to the "write_line" function, in the call to "write_char".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo anterior, vuelve a la función «write_line» al invocar
«write_char».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command takes a count argument that indicates how many tags to jump
back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden toma un argumento numérico que indica el número de etiquetas
que se desplazará hacia atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have gone forward, and now back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que ha ido hacia delante, vuelva atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go forward again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vayamos otra vez hacia delante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
following command goes to the tag on top of the list: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente orden se desplaza a la etiqueta
al principio de la lista: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tag</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tag</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can prefix it with a count and jump forward that many tags.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede precederlo de un número para saltar hacia delante ese número d
etiquetas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example:
":3tag".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo:
«:3tag».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-T also can be preceded with a count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede preceder «CTRL-T» con un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These commands thus allow you to go down a call tree with CTRL-] and back
up again with CTRL-T.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, estas órdenes permiten desplazarse hacia delante con «CTRL-]»,
y hacia atrás con «CTRL-T».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ":tags" to find out where you are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:tags» conocer dónde se encuentra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":tag" command replaces the file in the current window with the one
containing the new function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:tag» reemplaza el fichero en la ventana actual con el que contiene
la nueva función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But suppose you want to see not only the old
function but also the new one?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero suponga que desea ver no sólo la función antigua, y
no sólo la nueva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can split the window using the ":split"
command followed by the ":tag" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello, puede dividir la ventana usando la orden
«:split», seguida de la orden «:tag».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a shorthand command that does
both: &gt;
	:stag tagname</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una orden corta que realiza
ambas funciones: &gt;
	:stag tagname</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W ]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have files in many directories, you can create a tags file in each of
them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene varios ficheros en muchos directorios, puede crear un fichero de
etiquetas en cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will then only be able to jump to tags within that directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim sólo podrá saltar a etiquetas dentro de
ese directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find more tags files, set the 'tags' option to include all the relevant
tags files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar más ficheros de etiquetas, defina la opción 'tags' para
incluir todos los ficheros de etiquetas relevantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=./tags,./../tags,./*/tags</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=./tags,./../tags,./*/tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds a tags file in the same directory as the current file, one
directory level higher and in all subdirectories.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra un fichero de etiquetas en el mismo directorio que el
fichero actual, un nivel de directorios superiores y en todos los
subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is quite a number of tags files, but it may still not be enough.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un alto número de ficheros de etiquetas, pero puede que no lo
suficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, when editing a file in "~/proj/src", you will not find the tags file
"~/proj/sub/tags".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, al editar un fichero en «~/proj/src», no encontraría
el fichero de etiquetas «~/proj/sub/tags».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this situation Vim offers to search a whole directory
tree for tags files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, Vim ofrece buscar
ficheros de etiquetas en todo el árbol de directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=~/proj/**/tags</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=~/proj/**/tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cd ~/proj
	ctags -R .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cd ~/proj
	ctags -R .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The nice thing about this is that Exuberant ctags recognizes various file
types.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo mejor de esto es que Exuberant ctags reconoce varios tipos de fichero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus this doesn't work just for C and C++ programs, also for Eiffel
and even Vim scripts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, no sólo funciona con programas de C y C++, sino también para
Eiffel e incluso scripts de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the ctags documentation to tune this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte la documentación de ctags para
información de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you only need to tell Vim where your big tags file is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora sólo tiene que decir a Vim dónde está su fichero grande de
etiquetas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=~/proj/tags</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=~/proj/tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a function is defined multiple times (or a method in several classes),
the ":tag" command will jump to the first one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una función se define varias veces (o un mismo método en varias
clases), la orden «:tag» saltaría a la primera aparición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a match in the
current file, that one is used first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De haber una
coincidencia en el fichero actual, se usará éste en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now jump to other matches for the same tag with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede saltar a otras coincidencias de la misma etiqueta con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tnext</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tnext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeat this to find further matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repita para encontrar más coincidencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are many, you can select which one to jump to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De haber varias, puede seleccionar a cuál saltar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tselect tagname</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tselect etiqueta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (&lt;CR&gt; to abort):  ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg># pri kind tag	       file ~
	  1 F	f    mch_init	       os_amiga.c ~
		       mch_init() ~
	  2 F	f    mch_init	       os_mac.c ~
		       mch_init() ~
	  3 F	f    mch_init	       os_msdos.c ~
		       mch_init(void) ~
	  4 F	f    mch_init	       os_riscos.c ~
		       mch_init() ~
	Enter nr of choice (&lt;CR&gt; to abort):  ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now enter the number (in the first column) of the match that you would like to jump to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede introducir el número (en la primera columna) de la coincidencia a la que desea saltar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The information in the other columns give you a good idea of where the match is defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La información en las otras columnas le dan un buena idea de dónde se define la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tfirst			go to first match
	:[count]tprevious	go to [count] previous match
	:[count]tnext		go to [count] next match
	:tlast			go to last match</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tfirst			Primera coincidencia
	:[número]tprevious	Ir a la [número] coincidencia anterior
	:[count]tnext		Ir a la [número] coincidencia siguiente
	:tlast			Ir a la última coincidencia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line completion is a good way to avoid typing a long tag name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El autocompletado de línea de órdenes es una buena manera de evitar escribir un nombre de etiqueta largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just type the first bit and press &lt;Tab&gt;: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente escriba la primera parte y pulse &lt;Tab&gt;: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tag write_&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tag write_&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tag /block</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tag /block</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use command line completion: press &lt;Tab&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora el autocompletado de línea de órdenes pulsando &lt;Tab&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find all tags that
contain "block" and use the first match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim
encontrará todas las etiquetas que contienen «block», y usará la primera
coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "/" before a tag name tells Vim that what follows is not a literal tag
name, but a pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «/» antes del nombre de una etiqueta le dice a Vim que lo
hay a continuación no es un nombre de etiqueta, sino un patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use all the items for search patterns here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar
todos los elementos de patrones de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, suppose you want to select a tag that starts with "write_": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, supongo que desea seleccionar una etiqueta que empieza con
«write»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tselect /^write_</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tselect /^write_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" specifies that the tag starts with "write_".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «^» especifica que la etiqueta empieza con «write_».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise it would also be found halfway a tag name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario,
se detectaría también de estar en medio de un nombre de etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly "$" at the end makes sure the pattern matches until the end of a tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De forma
similar, el signo «$» al final asegura que el patrón sólo coincida con el
final de una etiqueta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since CTRL-] takes you to the definition of the identifier under the cursor,
you can use a list of identifier names as a table of contents.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que «CTRL-]» le lleva a la definición del identificador bajo el cursor,
puede usar un alista de nombres identificadores como una tabla de contenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an
example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First create a list of identifiers (this requires Exuberant ctags): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero cree una lista de identificadores (require Exuberant ctags): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ctags --c-types=f -f functions *.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ctags --c-types=f -f functions *.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim
	:vsplit functions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim
	:vsplit functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The window contains a list of all the functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta ventana contiene todas una lista de todas las funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is some more stuff,
but you can ignore that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hay
más elementos, pero los puede ignorar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do ":setlocal ts=99" to clean it up a bit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecute «setlocal ts=99» para
organizarlo un poco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this window, define a mapping: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina una macro en esta ventana: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:nnoremap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;"&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:nnoremap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;"&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'tagbsearch' option tells if the tags file is sorted or not.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'tagbsearch' indica si el archivo de etiquetas está ordenado o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default is to assume a sorted tags file, which makes a tags search a lot faster, but doesn't work if the tags file isn't sorted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado es suponer un archivo de etiquetas ordenado, que agiliza la búsqueda de etiquetas, pero no funciona si el archivo de etiquetas no está ordenado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use the SNiFF+ program, you can use the Vim interface to it |sniff|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa el programa SNiFF+, puede usar la interfaz de Vim |sniff|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SNiFF+ is a commercial program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>SNiFF+ es un programa comercial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cscope is a free program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cscope es un programa libre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not only find places where an identifier is declared, but also where it is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No sólo encuentra los lugares dónde se declara un identificador. sino también dónde se usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |cscope|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |cscope|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.2*	The preview window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.2*	La ventana de previsualización</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you edit code that contains a function call, you need to use the correct
arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edita código que contiene una llamada a una función, necesitará los
argumentos correctos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To know what values to pass you can look at how the function is
defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para conocer los valores que puede introducir, puede
ver cómo se define la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The tags mechanism works very well for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El mecanismo de etiquetas es adecuado para
esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Preferably the
definition is displayed in another window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Preferentemente, la definición se muestra en otra ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this the preview window can be
used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar
la ventana de previsualización para esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To open a preview window to display the function "write_char": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente para abrir una ventana de previsualización que muestre
la función «write_char»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:ptag write_char</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:ptag write_char</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will open a window, and jumps to the tag "write_char".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá una ventana, y saltará a la etiqueta «write_char».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then it takes you
back to the original position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A
continuación, vuelve a la posición original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can continue typing without the need
to use a CTRL-W command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, puede seguir escribiendo
sin necesidad de usar la orden «CTRL-W».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the name of a function appears in the text, you can get its definition
in the preview window with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el nombre de una función aparece en el texto, puede obtener su
definición en la ventana de previsualización con lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-W }</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-W }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a script that automatically displays the text where the word under the cursor was defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un script que muestra el texto automáticamente dónde se definió la
palabra bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |CursorHold-example|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |CursorHold-example|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pclose</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:pclose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To edit a specific file in the preview window, use ":pedit".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para editar un fichero específico en la ventana de previsualización, use «_pedit».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be useful to edit a header file, for example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede ser útil para editar la cabecera de un archivo, por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pedit defs.h</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:pedit defs.h</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, ":psearch" can be used to find a word in the current file and any included files and display the match in the preview window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, «:psearch» se puede utilizar para buscar una palabra en el archivo actual y cualquier archivo incluido («include») y mostrar la coincidencia en la ventana de previsualización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is especially useful when using library functions, for which you do not have a tags file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es especialmente útil cuando se utilizan las funciones de la biblioteca para el que no tiene un archivo de etiquetas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:psearch popen</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:psearch popen</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FILE	*popen __P((const char *, const char *)); ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>FILE	*popen __P((const char *, const char *)); ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.3*	Moving through a program</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.3*	Moverse a través de un programa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since a program is structured, Vim can recognize items in it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a que un programa está estructurado, Vim puede reconocer elementos en
él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specific
commands can be used to move around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar órdenes específicas para desplazarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>C programs often contain constructs like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los programas en C habitualmente contienen construcciones como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#ifdef USE_POPEN ~
	    fd = popen("ls", "r") ~
	#else ~
	    fd = fopen("tmp", "w") ~
	#endif ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But then much longer, and possibly nested.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero también más largo, y posiblemente anidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Position the cursor on the
"#ifdef" and press %.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posicione el cursor sobre
«#ifdef» y pulse «%».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will jump to the "#else".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim saltará al siguiente «#else».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing % again takes
you to the "#endif".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar «%» otra vez
le devuelve a «#endif».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another % takes you to the "#ifdef" again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro «%» le llevaría a «#ifdef» otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the construct is nested, Vim will find the matching items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una construcción está anidada, Vim encontrará los elementos
coincidentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a
good way to check if you didn't forget an "#endif".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una buena forma de comprobar si se ha olvidado de
insertar un «#endif».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are somewhere inside a "#if" - "#endif", you can jump to the start
of it with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando está en algún punto dentro de un «#if - #endif», puede saltar al
principio con lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[#</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not after a "#if" or "#ifdef" Vim will beep.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no está después de un «#if» o «#ifdef» Vim emitirá un sonido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To jump forward to the next "#else" or "#endif" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar hacia adelante al siguiente «#else» o «#endif» use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>]#</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>]#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two commands skip any "#if" - "#endif" blocks that they encounter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas dos órdenes omiten cualquier bloque «#if - #endif» que se encuentran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#if defined(HAS_INC_H) ~
	    a = a + inc(); ~
	# ifdef USE_THEME ~
	    a += 3; ~
	# endif ~
	    set_width(a); ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the cursor in the last line, "[#" moves to the first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con el cursor en la última línea, «[#» le lleva a la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "#ifdef" - "#endif" block in the middle is skipped.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El bloque «#ifdef - #endif» en el centro se omite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C code blocks are enclosed in {}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los bloques de código C están limitados por {}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can get pretty long.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede ser muy largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move to
the start of the outer block use the "[[" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar al principio del bloque exterior use la orden «[[».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "][" to find the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «][»
para encontrar el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This assumes that the "{" and "}" are in the first column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto supone que «{» y «}» están en la primera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[{" command moves to the start of the current block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «[{» le lleva al principio del bloque actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It skips over
pairs of {} at the same level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Omite las parejas
de «{}» en el mismo nivel.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"]}" jumps to the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«]}» salta al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An overview:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vista general:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function(int a)
	   +-&gt;		{
	   |		    if (a)
	   |	   +-&gt;	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +-&gt;	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 &lt;-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       &lt;-+	 |
			}				       &lt;-+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function(int a)
	   +-&gt;		{
	   |		    if (a)
	   |	   +-&gt;	    {
	[[ |	   |		for (;;)	       --+
	   |	   |	  +-&gt;	{			 |
	   |	[{ |	  |	    foo(32);		 |     --+
	   |	   |   [{ |	    if (bar(a))  --+	 | ]}	 |
	   +--	   |	  +--		break;	   | ]}  |	 |
		   |		}		 &lt;-+	 |	 | ][
		   +--		foobar(a)		 |	 |
			    }			       &lt;-+	 |
			}				       &lt;-+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing C++ or Java, the outer {} block is for the class.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al escribir en C++ o Java, el bloque exterior «{}» es para la clase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next level of {} is for a method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El siguiente nivel de «{}» es para un método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When somewhere inside a class use "[m" to find the previous start of a method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se encuentra dentro de una clase, use «[m» para encontrar el inicio previo de un método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"]m" finds the next start of a method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«]m» encuentra el siguiente inicio de un método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally, "[]" moves backward to the end of a function and "]]" moves forward to the start of the next function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además, «[]» se mueve hacia atrás al final de la función, y «]]» se mueve hacia adelante, al inicio de la siguiente función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end of a function is defined by a "}" in the first column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El final de la función está definido con un «}» al principio de la primera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int func1(void)
				{
					return 1;
		  +----------&gt;  }
		  |
	      []  |		int func2(void)
		  |	   +-&gt;	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +-&gt;	}
	      ]]  |
		  |		int func3(void)
		  +----------&gt;	{
					return 3;
				}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>int func1(void)
				{
					return 1;
		  +----------&gt;  }
		  |
	      []  |		int func2(void)
		  |	   +-&gt;	{
		  |    [[  |		if (flag)
	start	  +--	   +--			return flag;
		  |    ][  |		return 2;
		  |	   +-&gt;	}
	      ]]  |
		  |		int func3(void)
		  +----------&gt;	{
					return 3;
				}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget you can also use "%" to move between matching (), {} and [].</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se olvido de que también puede usar «%» para desplazarase entre parejas  de «()», «{}» y «[]».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That also works when they are many lines apart.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También funciona cuando están separados por varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[(" and "])" commands work similar to "[{" and "]}", except that they
work on () pairs instead of {} pairs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes  «[(» y «])» funcionan de manera similar a «[{» y «]}», con
la excepción de que funcionan con parejas de «()» en lugar de «{}».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
				  [(
&lt;		    &lt;--------------------------------
			      &lt;-------
		if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y) ~
				  --------------&gt;
			  --------------------------------&gt; &gt;
				       ])</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
				  [(
&lt;		    &lt;--------------------------------
			      &lt;-------
		if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y) ~
				  --------------&gt;
			  --------------------------------&gt; &gt;
				       ])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move back to the start of a comment use "[/".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «[/» para volver al principio de un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move forward to the end of a comment with "]/".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede moverse hacia adelante al final de un comentario con «]/».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works for /* - */ comments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo funciona con comentarios /* - */.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-&gt;	  +-&gt; /*
	  |    [/ |    * A comment about      --+
       [/ |	  +--  * wonderful life.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-&gt;	  +-&gt; /*
	  |    [/ |    * Comentario sobre la  --+
       [/ |	  +--  * maravillosa vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>| ]/
	  |	       */		      &lt;-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* a short comment */  &lt;-+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>| ]/
	  |	       */		      &lt;-+
	  |
	  +--	       foo = bar * 3;	      --+
						| ]/
		       /* Comentario corto */ &lt;-+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.4*	Finding global identifiers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.4* Buscar identificadores globales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[I</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[I</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will list the matching lines it can find.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VIM enumerará las líneas coincidentes que puede encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not only in the current file, but also in all included files (and files included in them, etc.).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No sólo en el archivo actual, sino también en todos los archivos incluidos (y archivos incluidos en ellos, etc..).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>structs.h ~
	 1:   29     unsigned     column;    /* column number */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find included files in the places specified with the 'path'
option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encontrará ficheros incluidos en los lugares definidos con la opción
'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a directory is missing, some include files will not be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si falta un directorio puede que no se encuentren todos los archivos
incluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
can discover this with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede descubrirlo con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:checkpath</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:checkpath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will list the include files that could not be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto lista todos los archivos incluidos que no pudo encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also files included by the files that could be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También incluye archivos incluidos por los ficheros no encontrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of the output:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo de la salida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--- Included files not found in path --- ~
	&lt;io.h&gt; ~
	vim.h --&gt; ~
	  &lt;functions.h&gt; ~
	  &lt;clib/exec_protos.h&gt; ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--- Included files not found in path --- ~
	&lt;io.h&gt; ~
	vim.h --&gt; ~
	  &lt;functions.h&gt; ~
	  &lt;clib/exec_protos.h&gt; ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "io.h" file is included by the current file and can't be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo «io.h» está incluido en el archivo actual y no se puede encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"vim.h" can be found, thus ":checkpath" goes into this file and checks what it includes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede encontrar «vim.h», y por ello «:checkpath» acude a ese archivo y compruebe qué incluye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "functions.h" and "clib/exec_protos.h" files, included by "vim.h" are not found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los archivos «functions.h» y «clib/exec_protos.h», incluidos por «vim.h» no se pueden encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Vim is not a compiler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Vim no es un compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not recognize "#ifdef" statements.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No reconoce las declaraciones «#ifdef».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means every "#include" statement is used, also when it comes
	after "#if NEVER".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que se usa cada declaración «#include», incluso si
	aparece después de «#if NEVER».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fix the files that could not be found, add a directory to the 'path' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para arreglar los archivo no encontrados, añada el directorio a la opción 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A good place to find out about this is the Makefile.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un buen sitio para averiguar esto es el archivo «Makefile».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look out for lines that contain "-I" items, like "-I/usr/local/X11".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busque líneas que contengan elementos «-I», como «-I/usr/local/X11».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add this directory use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use los siguiente para añadir este directorio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set path+=/usr/local/X11</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set path+=/usr/local/X11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are many subdirectories, you can use the "*" wildcard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el comodín «*» cuando haya varios directorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set path+=/usr/*/include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set path+=/usr/*/include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working on a project with a whole nested tree of included files, the "**" items is useful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos «**» son de utilidad cuando trabaja en un proyecto con un árblo anidado de archivos incluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will search down in all subdirectories.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto busca en todos los subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set path+=/projects/invent/**/include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set path+=/projects/invent/**/include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/projects/invent/include ~
	/projects/invent/main/include ~
	/projects/invent/main/os/include ~
	etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are even more possibilities.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay incluso más posibilidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the 'path' option for info.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más información consulte la opción
'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to see which included files are actually found, use this
command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la siguiente orden si desea ver qué archivos incluidos se
encontraron: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:checkpath!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:checkpath!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will get a (very long) list of included files, the files they include, and so on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá un lista muy larga de los archivos incluidos, los que éstos incluyen, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To shorten the list a bit, Vim shows "(Already listed)" for files that were found before and doesn't list the included files in there again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para acortar la lista Vim muestra «Ya está listado» para los archivos encontrados anteriormente, y no muestra los ficheros incluidos nuevamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"[I" produces a list with only one line of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«[I» produce una lista con una sola línea de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to have a closer look at the first item, you can jump to that line with the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando desee ver el primer elemento, salte a esa línea con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list that "[I" produces has a number at the start of each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La lista que «[I» produce tiene un número al principio de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to jump to another item than the first one, type the number first: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando desee saltar a otro elemento distinto al primero, primero introduzca el número:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3[&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3[&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will jump to the third item in the list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto salta al tercer elemento de la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember that you can use CTRL-O to jump back to where you started from.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuerde que puede usar «CTRL-O» para volver al punto desde donde empezó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[i		only lists the first match
	]I		only lists items below the cursor
	]i		only lists the first item below the cursor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[i		Lista sólo la primera coincidencia
	]I		Lista sólo elementos bajo el cursor
	]i		Lista sólo el primer elemento bajo el cursor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[I" command finds any identifier.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «[I» encuentra cualquier identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find only macros, defined with "#define" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sólo desea usar macros definidos con «#define» use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[D</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[D</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[d		only lists the first match
	]D		only lists items below the cursor
	]d		only lists the first item below the cursor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[d		Lista sólo la primera coincidencia
	]D		Lista sólo elementos bajo el cursor
	]d		Lista sólo el primer elemento bajo el cursor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*29.5*	Finding local identifiers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*29.5* Buscar identificadores locales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "[I" command searches included files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «[I» busca archivos incluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search in the current file only, and jump to the first place where the word under the cursor is used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente para buscar sólo en el archivo actual y saltar al primer sitio donde se usa la palabra bajo el cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gD</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-&gt;   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-&gt;   static int counter = 0;
	   |
	   |     int get_counter(void)
	gD |     {
	   |	     ++counter;
	   +--	     return counter;
		 }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will go back to the start of the current function and find the first occurrence of the word under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto volvería al principio de la función actual, y buscará la primera aparición de la palabra bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, it searches backwards to an empty line above a "{" in the first column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, busca en sentido inverso una línea vacía sobre un «{» en la primera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From there it searches forward for the identifier.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A partir de ahí, busca hacia adelante el identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example (cursor on "idx"):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo (cursor sobre «idx»):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>int find_entry(char *name)
		{
	   +-&gt;	    int idx;
	   |
	gd |	    for (idx = 0; idx &lt; table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>int find_entry(char *name)
		{
	   +-&gt;	    int idx;
	   |
	gd |	    for (idx = 0; idx &lt; table_len; ++idx)
	   |		if (strcmp(table[idx].name, name) == 0)
	   +--		    return idx;
		}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_40.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_40.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make new commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Crear órdenes nuevas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|40.1|	Key mapping
|40.2|	Defining command-line commands
|40.3|	Autocommands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|40.1|	Macros de teclado
|40.2|	Definir órdenes de línea de órdenes
|40.3|	Órdenes automáticas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_41.txt|  Write a Vim script
 Previous chapter: |usr_32.txt|  The undo tree
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_41.esx|  Escribir scripts para Vim
  Capítulo anterior: |usr_32.esx|  El árbol de deshacer
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.1*	Key mapping</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.1*	Crear macros</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A simple mapping was explained in section |05.3|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |05.3| se explicaba una macro («mapping») sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The principle is that one
sequence of key strokes is translated into another sequence of key strokes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El principio
es que una secuencia de pulsaciones de tecla se traduce a otra secuencia de
pulsaciones de tecla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a simple, yet powerful mechanism.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un mecanismo sencillo pero poderoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest form is that one key is mapped to a sequence of keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma más simple es asignar una tecla a una secuencia de teclas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since
the function keys, except &lt;F1&gt;, have no predefined meaning in Vim, these are
good choices to map.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido
a que las teclas de función, a excepción de &lt;F1&gt;, no tienen un significado
predefinido para Vim, son buenas candidatas para definir macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows how three modes are used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este ejemplo muestra como usar tres modos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After going to the last line with "G",
the "o" command opens a new line and starts Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después de ir a la última línea
con «G», la orden «o» crea una nueva línea e inicia el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text "Date: " is
inserted and &lt;Esc&gt; takes you out of insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se
inserta el texto «Date:», y &lt;Esc&gt; abandona el modo de inserción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of special keys inside &lt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta el uso de teclas especiales dentro de &lt;&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called angle bracket
notation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se llama
notación de corchetes agudos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You type these as separate characters, not by pressing the key
itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los teclea como caracteres distintos, y no pulsando
la tecla referida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes the mappings better readable and you can copy and paste
the text without problems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que las macros sean más legibles,
permitiendo copiar y pegar el texto de la misma sin problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":" character takes Vim to the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter «:» inicia la línea de órdenes de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":read !date" command
reads the output from the "date" command and appends it below the current
line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:read !date»
lee la salida de la orden «date» y la añade bajo la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;CR&gt; is required to execute the ":read" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
&lt;CR&gt; se requiere para ejecutar la orden «:read».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point of execution the text looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este punto, el texto tiene el siguiente aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Date:  ~
	Fri Jun 15 12:54:34 CEST 2001 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now "kJ" moves the cursor up and joins the lines together.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora «kJ» desplaza el cursor hacia arriba y une las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To decide which key or keys you use for mapping, see |map-which-keys|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para decidir qué teclas usar para las macros, consulte |map-which-keys|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command defines remapping for keys in Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» define una macro a usar en modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define mappings for other modes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede definir macros para otros modos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, ":imap" applies to Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «imap» afecta al modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use it to insert a date below the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usarlo para insertar una fecha bajo el cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It looks a lot like the mapping for &lt;F2&gt; in Normal mode, only the start is
different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se parece mucho a la macro para &lt;F2&gt; en modo Normal, sólo el
principio es diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;F2&gt; mapping for Normal mode is still there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La macro &lt;F2&gt; para el modo Normal aún existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can map
the same key differently for each mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede asignar la misma tecla de forma diferente según el modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that, although this mapping starts in Insert mode, it ends in Normal
mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que, aunque esta macro empieza en el modo Insertar,
termina en modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want it to continue in Insert mode, append an "a" to the
mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea continuar en modo Insertar, añada una
«a» a la asignación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map		Normal, Visual and Operator-pending
	:vmap		Visual
	:nmap		Normal
	:omap		Operator-pending
	:map!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map		Normal, Visual y Operator-pending
	:vmap		Visual
	:nmap		Normal
	:omap		Operator-pending
	:map!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert and Command-line
	:imap		Insert
	:cmap		Command-line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Insertar y Command-line
	:imap		Insertar
	:cmap		Línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Operator-pending mode is when you typed an operator character, such as "d" or "y", and you are expected to type the motion command or a text object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Operator-pending es cuando introduce un carácter como operador, por ejemplo «y» o «d», y se espera a que introduzca la orden de desplazamiento o un objeto de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus when you type "dw", the "w" is entered in operator-pending mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, cuando teclea «dw», la «w» es introducida en el modo Operator-pending</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose that you want to define &lt;F7&gt; so that the command d&lt;F7&gt; deletes a C program block (text enclosed in curly braces, {}).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que desea definir &lt;F7&gt; para que la orden «d&lt;F7&gt;» elimine el bloque de un programa escrito en C (el texto se cierra con llaves, {}).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly y&lt;F7&gt; would yank the program block into the unnamed register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De forma similar «y&lt;F7&gt;» copiaría el bloque del programa al registro sin nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, what you need to do is to define &lt;F7&gt; to select the current program block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, lo que debe hacer es definir &lt;F7&gt; para seleccionar el bloque actual del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this with the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente orden le permite hacer esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:omap &lt;F7&gt; a{</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:omap &lt;F7&gt; a{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This causes &lt;F7&gt; to perform a select block "a{" in operator-pending mode, just like you typed it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto provoca que &lt;F7&gt; realice una selección  de bloque «a{» en el modo Operator-pending, justo como lo escribió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mapping is useful if typing a { on your keyboard is a bit difficult.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta macro es útil si teclear «a{» en su teclado es difícil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_g		 :call MyGrep(1)&lt;CR&gt; ~
	v  &lt;F2&gt;		 :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	n  &lt;F2&gt;		 :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	   &lt;xHome&gt;	 &lt;Home&gt;
	   &lt;xEnd&gt;	 &lt;End&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>_g		 :call MyGrep(1)&lt;CR&gt; ~
	v  &lt;F2&gt;		 :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	n  &lt;F2&gt;		 :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` ~
	   &lt;xHome&gt;	 &lt;Home&gt;
	   &lt;xEnd&gt;	 &lt;End&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first column of the list shows in which mode the mapping is effective.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera columna de la lista muestra el modo en el que la macro tiene
efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is "n" for Normal mode, "i" for Insert mode, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es, «n» para el modo Normal, «i» para el modo Insertar, etc...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A blank is used for a
mapping defined with ":map", thus effective in both Normal and Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se
usa un espacio en blanco con las macros definidas mediante «:map», y por
ello, con efecto en el modo Visual y Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One useful purpose of listing the mapping is to check if special keys in &lt;&gt;
form have been recognized (this only works when color is supported).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un propósito útil de listar las macros es comprobar si se han reconocido
las teclas especiales con la forma &lt;&gt; (sólo funciona con compatibilidad con
color).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, when &lt;Esc&gt; is displayed in color, it stands for the escape character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, cuando &lt;Esc&gt; se muestra en color, simboliza el carácter
de escape.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it has the same color as the other text, it is five characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene el mismo color que el resto del texto, simboliza
cinco caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of a mapping is inspected for other mappings in it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado de una macro se inspecciona en busca de otras macros en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the mappings for &lt;F2&gt; above could be shortened to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, las macros para &lt;F2&gt; vistas anteriormente se pueden acortar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;F2&gt; G&lt;F3&gt;
	:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;
	:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;F2&gt; G&lt;F3&gt;
	:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;
	:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Normal mode &lt;F2&gt; is mapped to go to the last line, and then behave like &lt;F3&gt; was pressed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En modo Normal, &lt;F2&gt; tiene un macro para ir a la última línea, y después comportarse como si se hubiese pulsado &lt;F3&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Insert mode &lt;F2&gt; stops Insert mode with &lt;Esc&gt; and then also uses &lt;F3&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En modo Insertar, &lt;F2&gt; detiene el modo Insertar con &lt;Esc&gt;, y después usa también &lt;F3&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then &lt;F3&gt; is mapped to do the actual work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, se usa la macro de &lt;F3&gt; para el trabajo real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you hardly ever use Ex mode, and want to use the "Q" command to format text (this was so in old versions of Vim).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que apenas usa el modo Ex, y desea usar la orden «Q» para formatear texto (este era el comportamiento en versiones anteriores de Vim).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mapping will do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta macro realizará esta función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map Q gq</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map Q gq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, in rare cases you need to use Ex mode anyway.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero, en algunos casos necesita usar el modo Ex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's map "gQ" to Q, so that you can still go to Ex mode: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a asignar «gQ» a «Q», para que así pueda ir la modo Ex: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map gQ Q</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map gQ Q</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens now is that when you type "gQ" it is mapped to "Q".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que ocurre ahora es que cuando escribe «gQ», se asigna a la «Q».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far so
good.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ahora, todo bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But then "Q" is mapped to "gq", thus typing "gQ" results in "gq", and
you don't get to Ex mode at all.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero, a continuación, asigna «Q» a «gq», y por ello escribir
«gQ» resulta en «gq», y no entra en modo Ex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid keys to be mapped again, use the ":noremap" command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que las claves se asignen otra vez, utilice la orden
«:noremap»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap gQ Q</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap gQ Q</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Vim knows that the "Q" is not to be inspected for mappings that apply to it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora Vim sabe que no se puede analizar «Q» en busca de macros que le afecten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a similar command for every mode:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una orden similar para cada modo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap	Normal, Visual and Operator-pending
	:vnoremap	Visual
	:nnoremap	Normal
	:onoremap	Operator-pending
	:noremap!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap		Normal, Visual y Operator-pending
	:vnoremap	Visual
	:nnoremap	Normal
	:onoremap	Operator-pending
	:noremap!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert and Command-line
	:inoremap	Insert
	:cnoremap	Command-line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Insertar y Línea de órdenes
	:inoremap		Insertar
	:cnoremap	Línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a mapping triggers itself, it will run forever.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una macro se activa, se ejecutará indefinidamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to
repeat an action an unlimited number of times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede
usar esto para repetir una acción un número ilimitado de veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you have a list of files that contain a version number in the
first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, tiene una lista de archivos que contienen un número de
versión en la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You edit these files with "vim *.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después, edita estos archivos con «vim.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now editing the
first file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora está editando el primer archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define this mapping: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina esta macro: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove a mapping use the ":unmap" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «:unmap» para eliminar una macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, the mode the unmapping applies to depends on the command used:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, el modo sobre el que actúa la eliminación de la macro depende de la orden usada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unmap		Normal, Visual and Operator-pending
	:vunmap		Visual
	:nunmap		Normal
	:ounmap		Operator-pending
	:unmap!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unmap		Normal, Visual y Operator-pending
	:vunmap		Visual
	:nunmap		Normal
	:ounmap		Operator-pending
	:unmap!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert and Command-line
	:iunmap		Insert
	:cunmap		Command-line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Insertar y Línea de órdenes
	:iunmap		Insertar
	:cunmap		Línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a trick to define a mapping that works in Normal and Operator-pending mode, but not in Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dispone de un truco para definir una macro que funciona tanto modo Operator-pending como normal, pero no en modo visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First define it for all three modes, then delete it for Visual mode: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, defina la macro para los tres modos, y después borre la macro del modo Visual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;C-A&gt; /---&gt;&lt;CR&gt;
	:vunmap &lt;C-A&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;C-A&gt; /---&gt;&lt;CR&gt;
	:vunmap &lt;C-A&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove all mappings use the |:mapclear| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden |:mapclear| para eliminar todas las macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can guess the variations for different modes by now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede averiguar las variantes según el modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful with this command, it can't be undone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga cuidado con esta orden, ya que su acción no se puede deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command can be followed by another command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» puede ir seguida de otra orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A | character
separates the two commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un carácter «|» separa ambas
órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that a | character can't be used
inside a map command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también significa que no puede usar un carácter «|» dentro
de una orden «map».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To include one, use &lt;Bar&gt; (five characters).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para incluir uno, use &lt;Bar&gt; (cinco caracteres).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:
&gt;
	:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo: &gt;
:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same problem applies to the ":unmap" command, with the addition that you
have to watch out for trailing white space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El mismo problema afecta a la orden «:unmap», con la adición de que debe
tener cuidado con espacio vacío adicional al final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two commands are different:
&gt;
	:unmap a | unmap b
	:unmap a| unmap b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas dos
órdenes son diferentes: &gt;
	:unmap a | unmap b
	:unmap a| unmap b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;Space&gt; W</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;Space&gt; W</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to put a comment directly after a mapping, because the " character is considered to be part of the mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es posible insertar un comentario justo antes de una macro, ya que el carácter «"» se considera parte de la macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use |", this starts a new, empty command with a comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «|"», iniciando una nueva y vacía orden con un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;Space&gt; W|     " Use spacebar to move forward a word</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;Space&gt; W|     " Usa la barra espaciadora para avanzar un palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abbreviations are a lot like Insert mode mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las abreviaturas se parecen mucho a las macros del modo Insetar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arguments are handled
in the same way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los
argumentos se tratan de la misma forma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main difference is the way they are triggered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La diferencia principal es la
forma en que se ejecutan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An
abbreviation is triggered by typing a non-word character after the word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una abreviatura se inicia tecleando un
carácter que no sea una palabra, a continuación de una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A
mapping is triggered when typing the last character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una
macro se inicia al teclear el último carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another difference is that the characters you type for an abbreviation are
inserted in the text while you type them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra diferencia es que los caracteres que usa para una abreviatura
se insertan en el texto mientras los teclea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the abbreviation is triggered
these characters are deleted and replaced by what the abbreviation produces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al ejecutar la abreviatura,
estos caracteres se eliminan y reemplazan por el resultado de la
abreviatura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When typing the characters for a mapping, nothing is inserted until you type
the last character that triggers it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al teclear los caracteres de una macro, no se inserta nada
hasta que introduce el último carácter que lo inicia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the 'showcmd' option is set, the
typed characters are displayed in the last line of the Vim window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se define la
opción 'showcmd', los caracteres tecleados se muestran en la última
línea de la ventana de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An exception is when a mapping is ambiguous.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una excepción es cuando la macro es ambigua.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have done two
mappings: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene
dos macros: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:imap aa foo
	:imap aaa bar</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:imap aa foo
	:imap aaa bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, when you type "aa", Vim doesn't know if it should apply the first or the second mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando escribe «aa», Vim no sabe si afecta a la primera o segunda macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It waits for another character to be typed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Espera a que se introduzca otro carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is an "a", the second mapping is applied and results in "bar".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es una «a», se ejecuta la segunda macro, y cuyo resultado es «bar».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is a space, for example, the first mapping is applied, resulting in "foo", and then the space is inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es un espacio, por ejemplo, se ejecuta la primera macro, resultando en «foo», para después insertar el espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;script&gt; keyword can be used to make a mapping local to a script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la palabra clave &lt;script&gt; para hacer que una macro sea local al script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |:map-&lt;script&gt;|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |:map-&lt;script&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;buffer&gt; keyword can be used to make a mapping local to a specific buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;buffer&gt; se puede usar para que una macro sea local a un búfer específico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |:map-&lt;buffer&gt;|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |:map-&lt;buffer&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;unique&gt; keyword can be used to make defining a new mapping fail when it already exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;unique&gt; se puede usar para que definir una macro nueva falle cuando ya existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise a new mapping simply overwrites the old one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, una nueva macro sencillamente sobreescribe el antiguo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |:map-&lt;unique&gt;|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |:map-&lt;unique&gt;|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make a key do nothing, map it to &lt;Nop&gt; (five characters).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para que una tecla no haga nada, asígnelo a &lt;Nop&gt; (cinco caracteres).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make the &lt;F7&gt; key do nothing at all: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo siguiente hace que la tecla &lt;F7&gt; no tenga efecto alguno: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;F7&gt; &lt;Nop&gt;| map!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;F7¡&gt; &lt;Nop&gt;| map!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;F7&gt; &lt;Nop&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;F7&gt; &lt;Nop&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.2*	Defining command-line commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.2*	Definir órdenes de línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor enables you to define your own commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim le permite crear sus propias órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You execute these
commands just like any other Command-line mode command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ejecutar estas
órdenes como cualquier otra orden del modo Línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a command, use the ":command" command, as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para definir una orden, use la orden «:command» de la siguiente
forma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command DeleteFirst 1delete</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command DeleteFirst 1delete</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	User-defined commands must start with a capital letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Las órdenes definidas por el usuario deben comenzar con una letra
	mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot
	use ":X", ":Next" and ":Print".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede usar «:X», «:Next» y «:Print».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The underscore cannot be used!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡No puede usar el
	guión bajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
	can use digits, but this is discouraged.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar dígitos, pero no se recomienda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like with the builtin commands, the user defined commands can be abbreviated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al igual que las órdenes integradas, las órdenes definidas por el usuario se pueden abreviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to type just enough to distinguish the command from another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita teclear lo justo para distinguir una orden de otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line completion can be used to get the full name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El autocompletado de línea de órdenes se puede usar para obtener el nombre completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User-defined commands can take a series of arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes definidas por el usuario aceptan una serie de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The number of arguments must be specified by the -nargs option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El número de argumentos se debe especificar con la opción «-nargs».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, the example :DeleteFirst command takes no arguments, so you could have defined it as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la orden de ejemplo «DeleteFirst» no permite argumentos, así que lo debe definir del siguiente modo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -nargs=0 DeleteFirst 1delete</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -nargs=0 DeleteFirst 1delete</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, because zero arguments is the default, you do not need to add "-nargs=0".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, ya que cero argumentos es el comportamiento predeterminado, no necesita añadir «-nargs=0».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other values of -nargs are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación puede ver los otros valores de «-nargs»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-nargs=0	No arguments
	-nargs=1	One argument
	-nargs=*	Any number of arguments
	-nargs=?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-nargs=0	Sin argumentos
	-nargs=1	Un argumento
	-nargs=*	Cualquier número de argumentos
	-nargs=?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero or one argument
	-nargs=+	One or more arguments</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cero o más argumentos
	-nargs=+	Uno o más argumentos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside the command definition, the arguments are represented by the &lt;args&gt; keyword.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dentro de la definición de la orden, los argumentos se representan con la palabra clave &lt;args&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -nargs=+ Say :echo "&lt;args&gt;"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -nargs=+ Say :echo "&lt;args&gt;"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Say Hello World</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Say Hello World</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim echoes "Hello World".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim muestra «Hello World».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you add a double quote, it won't work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, no funcionará si añade una comilla doble.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Say he said "hello"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Say he said "hello"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -nargs=+ Say :echo &lt;q-args&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -nargs=+ Say :echo &lt;q-args&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo "he said \"hello\""</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo "he said \"hello\""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;f-args&gt; keyword contains the same information as the &lt;args&gt; keyword,
except in a format suitable for use as function call arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La palabra clave &lt;f-args&gt; contiene la misma información que la palabra
clave &lt;args&gt;, pero en un formato adecuado para usar argumentos que
invocan funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example:
&gt;
	:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)
	:DoIt a b c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo: &gt;
	:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)
	:DoIt a b c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:call AFunction("a", "b", "c")</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:call AFunction("a", "b", "c")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some commands take a range as their argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas órdenes toman un rango como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To tell Vim that you are defining such a command, you need to specify a -range option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para indicar a Vim que está definiendo una orden así, debe especificar una opción «-range».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values for this option are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación puede ver los valores de esta opción:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-range		Range is allowed; default is the current line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-range		El rango está permitido, el valor
				predeterminado es la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-range=%	Range is allowed; default is the whole file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-range=%	El rango está permitido, el valor
				predeterminado es el archivo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-range={count}	Range is allowed; the last number in it is used as a
			single number whose default is {count}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-range={número}	El rango está permitido, el último número
				presente se usa como un sólo número cuyo valor
				predeterminado es {número}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a range is specified, the keywords &lt;line1&gt; and &lt;line2&gt; get the values of the first and last line in the range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando un rango se especifica, las palabras clave &lt;line1&gt; y &lt;line2&gt; obtienen el valor de la primera y última línea del rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following command defines the SaveIt command, which writes out the specified range to the file "save_file": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la siguiente orden define la orden «SaveIt», que escribe el rango especificado al archivo «save_file»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, you have the &lt;lt&gt; keyword.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, tiene la palabra clave &lt;lt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It stands for the character &lt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simboliza el carácter «&lt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this to escape the special meaning of the &lt;&gt; items mentioned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Úselo para escapar el significado especial de los elementos &lt;&gt; mencionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -nargs=+ Say :echo "&lt;args&gt;"
	:command!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -nargs=+ Say :echo "&lt;args&gt;"
	:command!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-nargs=+ Say :echo &lt;q-args&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-nargs=+ Say :echo &lt;q-args&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a user command use ":delcommand".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:delcommand» para eliminar una orden de usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It takes a single argument, which is the name of the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Toma un único argumento, el nombre de la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:delcommand SaveIt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:delcommand SaveIt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:comclear</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:comclear</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*40.3*	Autocommands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*40.3*	Autocommands</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An autocommand is a command that is executed automatically in response to some
event, such as a file being read or written or a buffer change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una orden automática (Autocommand) es una orden a ejecutar en respuesta otro
evento, un archivo siendo leído y editado o un cambio en un búfer, por
ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Through the
use of autocommands you can train Vim to edit compressed files, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, Vim puede editar archivos comprimidos a través de las
órdenes automáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is used in the |gzip| plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La extensión |gzip| hace uso de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Autocommands are very powerful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes automáticas son muy potentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use them with care and they will help you
avoid typing many commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Úselos con cuidado, y le ayudarán
a disminuir el número de órdenes que introduce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use them carelessly and they will cause a lot of
trouble.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Úselos sin cuidado, y
generarán un gran número de problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to replace a datestamp on the end of a file every time it is written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que desea reemplazar una marca de tiempo al final del archivo cada vez que se escriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you define a function: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, define una función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function DateInsert()
	:  $delete
	:  read !date
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function DateInsert()
	:  $delete
	:  read !date
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want this function to be called each time, just before a file is written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea que esta función se invoque justo antes de guardar un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make that happen: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo siguiente lo logra este objetivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd FileWritePre *  call DateInsert()</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd FileWritePre *  call DateInsert()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd [group] {events} {file_pattern} [nested] {command}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd [grupo] {eventos} {patrón_archivo} [anidado] {orden}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The [group] name is optional.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento [grupo] es opcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is used in managing and calling the commands
(more on this later).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se usa al gestionar e invocar las órdenes
(más información más adelante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {events} parameter is a list of events (comma
separated) that trigger the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El parámetro {eventos} es una lista separada
 por comas de eventos que inician la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{file_pattern} is a filename, usually with wildcards.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{patrón_archivo} es un nombre de archivo, a menudo con comodines.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, using
"*.txt" makes the autocommand be used for all files whose name end in ".txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, usar «*.txt» provoca que la orden automática afecte a todos los
archivos cuyo nombre termina en «.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The optional [nested] flag allows for nesting of autocommands (see below), and
finally, {command} is the command to be executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La elemento opcional [anidado] permite anidar órdenes automáticas (a
continuación), y, por último, {orden} es la orden a ejecutar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the most useful events is BufReadPost.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de los eventos más útiles es «BufReadPost».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is triggered after a new file is being edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se inicia después de editar un nuevo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is commonly used to set option values.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se usa habitualmente para definir valores para opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you know that "*.gsm" files are GNU assembly language.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, sabe que los archivos «.gsm» están escritos en lenguaje ensamblador de GNU.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get the syntax file right, define this autocommand: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Especifique esta orden para obtener la adecuada sintaxis de archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufReadPost *.gsm  set filetype=asm</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufReadPost *.gsm  set filetype=asm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim is able to detect the type of file, it will set the 'filetype' option for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim es capaz de detectar el tipo de archivo, definirá la opción 'filetype' automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This triggers the Filetype event.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los siguiente incia el evento «Filetype».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this to do something when a certain type of file is edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usarlo para iniciar una acción al editar un tipo de archivo en particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to load a list of abbreviations for text files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para cargar una lista de abreviaturas de archivos de texto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd Filetype text  source ~/.vim/abbrevs.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd Filetype text  source ~/.vim/abbrevs.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {file_pattern} argument can actually be a comma-separated list of file
patterns.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento {patrón_archivo] puede ser una lista separada por comas de
patrones de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example: "*.c,*.h" matches files ending in ".c" and ".h".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, "*.c,*.h" coincide con los archivos
terminados en «.c» y «.h».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual file wildcards can be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar los comodines de archivo habituales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a summary of the most often
used ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene un resumen
de los más usados:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*		Match any character any number of times
	?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*		Busca cualquier caracteres cualquier número de veces
	?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match any character once
	[abc]		Match the character a, b or c
	.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busca cualquier carácter una vez
	[abc]		Busca el carácter a, b o c
	.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches a dot
	a{b,c}		Matches "ab" and "ac"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busca un punto
	a{b,c}		Busca «ab» y «ac»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	When working on a system that uses a backslash as file separator, such
	as MS-Windows, you still use forward slashes in autocommands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Al trabajar con un sistema que usa la barra inversa como separador de
	archivos, como MS-Windows, necesita una barra inclinada en las
	órdenes automáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
	makes it easier to write the pattern, since a backslash has a special
	meaning.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto facilita escribir un patrón, ya que la barra
	inversa tiene un significado especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also makes the autocommands portable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hace portables las
	órdenes automáticas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete an autocommand, use the same command as what it was defined with, but leave out the {command} at the end and use a !.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una orden automática, use la misma orden con la que se definió, pero omitiendo la {orden} al final y usando «!».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FileWritePre *</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>FileWritePre *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list can be very long, especially when filetype detection is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta lista puede ser muy largo, en particular si se utiliza la detección de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To list only part of the commands, specify the group, event and/or pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para listar sólo parte de las órdenes, especifique el grupo, evento y/o patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to list all BufNewFile autocommands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para listar todas las órdenes automáticas para «BufNewFile»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufNewFile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufNewFile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd * *.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd * *.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "*" for the event will list all the events.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «*» como el evento lista todos los eventos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To list all autocommands for the cprograms group: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para listar todas las órdenes automáticas del grupo cprograms: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd cprograms</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd cprograms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {group} item, used when defining an autocommand, groups related autocommands
together.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento {grupo}, usado al definir una orden automática, agrupa
órdenes automáticas relacionadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to delete all the autocommands in a certain group,
for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede usar para eliminar todas las
órdenes automáticas en un grupo particular, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When defining several autocommands for a certain group, use the ":augroup"
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al definir varias órdenes automáticas para un grupo particular, use la
orden «:augroup».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, let's define autocommands for C programs: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, vamos a definir unas órdenes automáticas
para programas C: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd! cprograms</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd! cprograms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generally, commands executed as the result of an autocommand event will not trigger any new events.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, las órdenes ejecutadas como resultado de un evento de orden automática no iniciarán ningún evento nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you read a file in response to a FileChangedShell event, it will not trigger the autocommands that would set the syntax, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lee un archivo como respuesta a un evento «FileChangedShell», no iniciará las órdenes automáticas que definirían la sintaxis, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the events triggered, add the "nested" argument: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para que se los eventos se inicien, añada el argumento «nested»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd FileChangedShell * nested  edit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd FileChangedShell * nested  edit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to trigger an autocommand by pretending an event has occurred.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible iniciar una orden automática simulando un evento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to have one autocommand trigger another one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil para que una orden automática inicie otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines an autocommand that is triggered when a new file has been edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto define una orden automática que se inicia al editar un nuevo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file name must end in ".new".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre de archivo debe terminar con «.new».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":execute" command uses expression evaluation to form a new command and execute it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:execute» usa expresiones de evaluación para formar una nueva orden y ejecutarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When editing the file "tryout.c.new" the executed command will be: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden ejecutada al editar el archivo «prueba.c.new» sería: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:doautocmd BufReadPost tryout.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:doautocmd BufReadPost tryout.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":doautocmd" executes on the current buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:doautocmd» se ejecuta en el búfer actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":doautoall" command works like "doautocmd" except it executes on all the buffers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:doautoall» funciona como «doautocmd», con la diferencia de que afecta a todos los búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands executed by an autocommand are Command-line commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes ejecutadas por una orden automática son órdenes del modo Línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a Normal mode command, the ":normal" command can be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea usar una orden del modo normal, puede usar la orden «:normal».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufReadPost *.log normal G</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufReadPost *.log normal G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make the cursor jump to the last line of *.log files when you start
to edit it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que el cursor salte a la última línea de archivos «*.log» cuando
empieza a editarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the ":normal" command is a bit tricky.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar la orden «:normal» es un poco difícil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure its
argument is a complete command, including all the arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, compruebe que su
argumento es una orden completa, incluyendo todos los argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use "i"
to go to Insert mode, there must also be a &lt;Esc&gt; to leave Insert mode again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa una «i» para entrar el modo Insertar, también debe tener un
&lt;Esc&gt; para abandonar el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a "/" to start a search pattern, there must be a &lt;CR&gt; to execute
it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «/» para iniciar una búsqueda
de un patrón, debe usar &lt;CR&gt; para ejecutarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":normal" command uses all the text after it as commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:normal» usa todo el texto a continuación como órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus there
can be no | and another command following.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ello, no debe estar presente «|» y una orden a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To work around this, put the
":normal" command inside an ":execute" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para solucionar
este problema, ubique la orden «:normal» dentro de una orden «:execute».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also makes it possible
to pass unprintable characters in a convenient way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También posibilita pasar caracteres no imprimibles de una forma
cómoda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |
		\ 1read !date</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |
		\ 1read !date</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also shows the use of a backslash to break a long command into more lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también muestra el usa de la barra inversa para dividir una orden en varias líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used in Vim scripts (not at the command line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede usar en scripts de Vim (no en la línea de órdenes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want the autocommand do something complicated, which involves jumping around in the file and then returning to the original position, you may want to restore the view on the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que la orden automática haga algo más complicado, que incluya saltar de un punto a otro en el archivo para volver finalmente a la posición inicial, puede que desee restaurar la vista del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |restore-position| for an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para un ejemplo, consulte |restore-position|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At times, you will not want to trigger an autocommand.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces, no querrá iniciar una orden automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'eventignore' option contains a list of events that will be totally ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'eventignore' contiene una lista de eventos a ignorar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following causes events for entering and leaving a window to be ignored: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, lo siguiente provoca que se ignoren los siguientes eventos iniciados al entrar y salir de un programa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set eventignore=WinEnter,WinLeave</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set eventignore=WinEnter,WinLeave</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set eventignore=all</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set eventignore=all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set eventignore=</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set eventignore=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_11.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_11.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Recovering from a crash</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuperarse de un fallo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|11.1|	Basic recovery
|11.2|	Where is the swap file?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|11.1|	Recuperación básica
|11.2|	¿Dónde está el archivo de intercambio?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_12.txt|  Clever tricks
 Previous chapter: |usr_10.txt|  Making big changes
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_12.esx|  Trucos
  Capítulo anterior: |usr_10.esx|  Realizar grandes cambios
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.1*	Basic recovery</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.1*	Recuperación básica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In most cases recovering a file is quite simple, assuming you know which file you were editing (and the harddisk is still working).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de los casos, recuperar un archivo es bastante sencillo, si suponemos que sabe qué archivo estaba editando (y el disco duro aún funciona).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Vim on the file, with the "-r" argument added: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Inicie Vim con el archivo y el argumento «-r»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -r help.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -r ayuda.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will read the swap file (used to store text you were editing) and may read bits and pieces of the original file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim leerá el archivo de intercambio (empleado para almacenar el texto editado) y puede que lea bits y porciones del texto original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim recovered your changes you will see these messages (with different file names, of course):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá los siguientes mensajes si todo ha ido bien (con nombres de fichero diferentes, por supuesto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should check if everything is OK.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>You should check if everything is OK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	(You might want to write out this file under another name ~
	and run diff with the original file to check for changes) ~
	You may want to delete the .swp file now.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write help.txt.recovered</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write ayuda.txt.recuperado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compare the file with the original file to check if you ended up with what you expected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compare el archivo con el original para ver si obtuvo lo que esperaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vimdiff is very useful for this |08.7|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vimdiff es muy útil para esta tarea |08.7|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write help.txt.recovered
	:edit #
	:diffsp help.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write help.txt.recovered
	:edit #
	:diffsp help.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out for the original file to contain a more recent version (you saved
the file just before the computer crashed).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compruebe que el archivo original no contenga una versión más reciente
(guardó el archivo justo antes de que el sistema diese un fallo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And check that no lines are
missing (something went wrong that Vim could not recover).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compruebe también que no se ha omitido ninguna línea (algo ha ido mal
y Vim no pudo recuperar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If Vim produces warning messages when recovering, read them carefully.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim genera mensajes de advertencia al recuperar un archivo, lea
éstos cuidadosamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is rare though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así, es poco habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffer contents equals file contents.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Buffer contents equals file contents.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	You may want to delete the .swp file now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	You may want to delete the .swp file now.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This usually happens if you already recovered your changes, or you wrote the file after making changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, esto ocurre si ya ha recuperado los cambios, o si editó el archivo después de realizar cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is safe to delete the swap file now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este momento ya puede eliminar el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is normal that the last few changes can not be recovered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es normal que los últimos cambios no se puedan recuperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim flushes the changes to disk when you don't type for about four seconds, or after typing about two hundred characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim vuelca los cambios al disco duro cuando no teclea durante cuatro segundos, o tras escribir unos doscientos caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is set with the 'updatetime' and 'updatecount' options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede modificar con las opciones 'updatetime' y 'updatecount'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus when Vim didn't get a chance to save itself when the system went down, the changes after the last flush will be lost.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta forma, cuando Vim no tiene posibilidad de guardar cuando el sistema cae, tendrá los cambios del último volcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -r ""</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -r ""</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.2*	Where is the swap file?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.2* 	¿Dónde está el archivo de intercambio?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can store the swap file in several places.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede guardar el archivo de intercambio en distintos lugares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally it is in the same directory as the original file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Normalmente se encuentra en el mismo directorio que el archivo original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find it, change to the directory of the file, and use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrarlo, cambie al directorio del archivo y escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -r</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will list the swap files that it can find.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará una lista de archivos de intercambio que ha encontrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will also look in other
directories where the swap file for files in the current directory may be
located.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También
buscará en otros directorios donde los archivos de intercambio para archivos
en el actual puedan encontrarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will not find swap files in any other directories though, it
doesn't search the directory tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No buscará archivos de intercambio en
otros directorios, ni siquiera en los subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Swap files found: ~
	   In current directory: ~
	1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Swap files found: ~
	   In current directory: ~
	1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.main.c.swp ~
		  owned by: mool   dated: Tue May 29 21:00:25 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: YES ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12525 ~
	   In directory ~/tmp: ~
	      -- none -- ~
	   In directory /var/tmp: ~
	      -- none -- ~
	   In directory /tmp: ~
	      -- none -- ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>.main.c.swp ~
		  owned by: mool   dated: Tue May 29 21:00:25 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: YES ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12525 ~
	   In directory ~/tmp: ~
	      -- none -- ~
	   In directory /var/tmp: ~
	      -- none -- ~
	   In directory /tmp: ~
	      -- none -- ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are several swap files that look like they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay varios archivos de intercambio que parecen ser el que quiere
usar, se mostrará una lista y se requerirá que introduzcas el número del que
quiere seleccionar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carefully look at the dates to decide
which one you want to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe con cuidado las fechas para decidir cuál
quieres usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you don't know which one to use, just try them one by one and check
the resulting files if they are what you expected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de que no sepa cuál seleccionar, pruébelos uno a uno y compruebe
que los archivos resultantes son el que deseas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you know which swap file needs to be used, you can recover by giving the swap file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sabe qué archivo de intercambio quiere usar, puede realizar la intercambio dando como argumento el nombre de este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will then finds out the name of the original file from the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encontrará el nombre del archivo original del cuál éste es el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example: &gt;
	vim -r .help.txt.swo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo: &gt;
	vim -r .help.txt.swo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also handy when the swap file is in another directory than expected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto resulta útil cuando el archivo de intercambio está en otro directorio diferente al esperado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim recognizes files with the pattern *.s[uvw][a-z] as swap files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim reconoce los archivos con el patrón *.s[uvw][a-z] como archivos de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this still does not work, see what file names Vim reports and rename the files accordingly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto tampoco funciona, compruebe los nombres de archivo que Vim reporta y renombre los archivos acordemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the 'directory' option to see where Vim may have put the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compruebe la opción 'directory' para ver dónde ha podido poner Vim el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.3*	Crashed or not?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.3*	¿Se ha colgado o no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*ATTENTION* *E325*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*ATTENTION* *E325*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim tries to protect you from doing stupid things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intenta protegerle de cometer estupideces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you innocently start editing a file, expecting the contents of the file to show up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que inocentemente comienza la edición de un archivo, a la espera de que los contenidos se muestren.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, Vim produces a very long message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En su lugar, Vim produce un mensaje muy largo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E325: ATTENTION ~
	Found a swap file by the name ".main.c.swp" ~
		  owned by: mool   dated: Tue May 29 21:09:28 2001 ~
		 file name: ~mool/vim/vim6/src/main.c ~
		  modified: no ~
		 user name: mool   host name: masaka.moolenaar.net ~
		process ID: 12559 (still running) ~
	While opening file "main.c" ~
		     dated: Tue May 29 19:46:12 2001 ~
 ~
	(1) Another program may be editing the same file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E325: ATENCIÓN ~
Se ha encontrado un archivo de intercambio con el nombre ".main.c.swp" ~
		propiedad de: mool   de fecha: Tue May 29 21:09:28 2001 ~
		nombre del archivo: ~mool/vim/vim6/src/main.c ~
		modificado: no ~
		nombre del usuario: mool   host name: masaka.moolenaar.net ~
		ID del proceso: 12559 (aún en ejecución) ~
		al abrir el archivo "main.c" ~
		de fecha: Tue May 29 19:46:12 2001 ~
 ~
	(1)  Puede que otro programa esté editando el mismo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	    If this is the case, be careful not to end up with two ~
	    different instances of the same file when making changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	    De ser así, tenga cuidado de no acabar con dos ~
	    ejemplares diferentes del mismo archivo al hacer cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	    Quit, or continue with caution.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	    Salga del programa o continúe con precaución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
 ~
	(2) An edit session for this file crashed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
 ~
	(2) Falló una sesión de edición de este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	    If this is the case, use ":recover" or "vim -r main.c" ~
	    to recover the changes (see ":help recovery").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	    Si es así, use \":recover\" o \"vim -r  main.c" ~
	    para recuperar los cambios (véa \":help recovery\").</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	    If you did this already, delete the swap file ".main.c.swp" ~
	    to avoid this message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	    Si Ud. ya ha hecho esto, borre el archivo de intercambio ".main.c.swp" ~
	    para evitar este mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get this message, because, when starting to edit a file, Vim checks if a swap file already exists for that file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ha recibido este mensaje porque cuando comienza a editar un archivo, Vim comprueba que exista un archivo de intercambio para este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is one, there must be something wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay uno, algo debe estar pasando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may be one of these two situations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ocurrir cualquiera de estas situaciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another edit session is active on this file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay otra sesión de edición activa en este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look in the message for the
   line with "process ID".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busque en el
   mensaje la línea con «ID del proceso».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede parecerse a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>process ID: 12559 (still running) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>process ID: 12559 ((aún en ejecución) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text "(still running)" indicates that the process editing this file
   runs on the same computer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto «(still running)» indica que el proceso que edita este archivo
está corriendo en el mismo ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When working on a non-Unix system you will not
   get this extra hint.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando estés bajo un sistema no
Unix, no obtendrá esta información extra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When editing a file over a network, you may not see
   the hint, because the process might be running on another computer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite un archivo a través
de red, seguramente no verá esta información, porque el proceso estará en otro
   ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In
   those two cases you must find out what the situation is yourself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que averiguarlo por su cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is another Vim editing the same file, continuing to edit will
   result in two versions of the same file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay otro Vim editando el mismo archivo, continuar editándolo
   conllevará a que tenga dos versiones del mismo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one that is written last will
   overwrite the other one, resulting in loss of changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La última que
   guarde sobreescribirá a la otra, con la consecuente pérdida de los
   cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You better quit
   this Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mejor salir de este Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The swap file might be the result from a previous crash of Vim or the
   computer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo de intercambio puede ser el resultado de un cuelgue anterior
   de Vim o del ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the dates mentioned in the message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise las fechas mencionadas en el mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the date of the
   swap file is newer than the file you were editing, and this line appears:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la
   fecha del archivo de intercambio es más reciente que la del archivo que
   está editando, y aparece esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>modified: YES ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>modificado: YES ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you very likely have a crashed edit session that is worth recovering.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces es muy probable que haya ocurrido algo con la sesión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the date of the file is newer than the date of the swap file, then
   either it was changed after the crash (perhaps you recovered it earlier,
   but didn't delete the swap file?), or else the file was saved before the
   crash but after the last write of the swap file (then you're lucky: you
   don't even need that old swap file).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la fecha del archivo es posterior a la fecha del archivo de
   intercambio, es que o cambiado tras el cuelgue (quizá la recuperó antes
   y no eliminó el archivo de intercambio), o es que el archivo fue
   guardado después de la última grabación del archivo de intercambio
   (entonces tienes suerte: no necesita ni ese viejo archivo de
   intercambio).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will warn you for this with this
   extra line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le advertirá de esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NEWER than swap file!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MÁS NUEVO que el archivo de intercambio!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[cannot be read] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[no se puede leer] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will appear under the name of the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>aparecerá bajo el nombre del archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be good or bad, depending on circumstances.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede ser bueno o malo dependiendo de las circunstancias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is good if a previous editing session crashed without having made any changes to the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Son buenas noticias si la sesión anterior se colgó sin haber hecho ningún cambio al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then a directory listing of the swap file will show that it has zero bytes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En tal caso un listado de archivos del directorio mostrará que tiene cero bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may delete it and proceed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez quiera eliminarla y continuar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is slightly bad if you don't have read permission for the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No son muy buenas noticias si lo que ocurre es que no tiene permisos de lectura del archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to view the file read-only, or quit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez desee ver el archivo en modo sólo lectura o salir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On multi-user systems, if you yourself did the last changes under a different login name, a logout followed by a login under that other name might cure the "read error".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En sistemas multiusuario, si empleó otro usuario, salir y volver a identificarte tal vez resuelva el «error de lectura».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or else you might want to find out who last edited (or is editing) the file and have a talk with them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O en su defecto quizá quiera encontrar quien lo editó por última vez (o está editándolo ahora mismo) y hablar con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very bad if it means there is a physical read error on the disk containing the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Son muy malas noticias si significa que hay un error de lectura a nivel físico del disco duro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, this almost never happens.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Afortunadamente, esto no ocurre casi nunca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to view the file read-only at first (if you can), to see the extent of the changes that were "forgotten".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quizá quiera ver el archivo en modo sólo lectura inicialmente (si puede), para ver el alcance de los cambios que fueron «olvidados».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are the one in charge of that file, be prepared to redo your last changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si eres el que está a cargo del archivo, prepárate para rehacer los últimos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WHAT TO DO?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿QUÉ HACER?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*swap-exists-choices*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*swap-exists-choices*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Swap file ".main.c.swp" already exists!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Swap file ".main.c.swp" already exists!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>O  Open the file readonly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O  Abrir el archivo en modo sólo lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this when you just want to view the file and
   don't need to recover it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto cuando sólo desee ver el
   archivo y no necesite recuperarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez quiera usar esto cuando sepa
   que alguien está usando el archivo y usted sólo quiera echar un vistazo sin
   hacer cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E  Edit the file anyway.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E  Editar el archivo igualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this with caution!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Use esto con cuidado!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the file is being edited
   in another Vim, you might end up with two versions of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el archivo está
   siendo utilizado por otro Vim, terminará con dos versiones del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will
   try to warn you when this happens, but better be safe then sorry.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intentará advertirte si esto va a ocurrir, pero más vale prevenir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>R  Recover the file from the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>R  Recuperar el archivo del archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this if you know that the swap
   file contains changes that you want to recover.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Emplee esto si sabe que
   el archivo de intercambio contiene los cambios que desea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A  Abort.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A  Abortar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like Quit, but also abort further commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como salir (Q), pero también aborta las órdenes posteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil cuando cargue un script que edita varios archivos, como una
   sesión con múltiples ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>D  Delete the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>D  Eliminar el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this when you are sure you no longer need it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto cuando esté seguro de que
   no lo necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, cuando no contenga cambios o cuando el
   archivo en sí sea más nuevo que el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix esta opción sólo se ofrece cuando el proceso que creó el archivo
   de intercambio no parece que estar en ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not get the dialog (you are running a version of Vim that does not support it), you will have to do it manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no ve el diálogo (está ejecutando una versión de Vim que no lo soporta, tendrá que hacerlo a mano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To recover the file, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para recuperar el archivo, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:recover</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:recover</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim cannot always detect that a swap file already exists for a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no puede siempre detectar cuando ya existe un archivo de intercambio para un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the case when the other edit session puts the swap files in another directory or when the path name for the file is different when editing it on different machines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el caso cuando otras sesiones de edición ponen los archivos en otro directorio o cuando una ruta de archivo difiere en máquinas distintas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, don't rely on Vim always warning you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, no confíe en que Vim siempre le vaya a alertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really don't want to see this message, you can add the 'A' flag to the 'shortmess' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente no quiere ver este mensaje, puede añadir la opción 'A' a la opción 'shortmess'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it's very unusual that you need this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero es poco habitual que lo necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*11.4*	Further reading</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*11.4*	Más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|swap-file|	An explanation about where the swap file will be created and
		what its name is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|swap-file|	Una explicación sobre dónde se creará el archivo de
		intercambio y cuál es su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:preserve|	Manually flushing the swap file to disk.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:preserve|	Volcado manual de un archivo de intercambio al disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:swapname|	See the name of the swap file for the current file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:swapname|	Ver el nombre del archivo de intercambio para el actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'updatecount'	Number of key strokes after which the swap file is flushed to
		disk.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'updatecount'	Número de pulsación tras las cuales el archivo de intercambio
		es volcado al disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'updatetime'	Timeout after which the swap file is flushed to disk.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'updatetime'	Temporizador tras el cuál se producirá el volcado a disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'swapsync'	Whether the disk is synced when the swap file is flushed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'swapsync'	Si se debe sincornizar el disco duro tras el volcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'directory'	List of directory names where to store the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'directory'	Listado de directorios para el archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'maxmem'	Limit for memory usage before writing text to the swap file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'maxmem'	Limitar el uso de memoria antes de hacer el volcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'maxmemtot'	Same, but for all files in total.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'maxmemtot'	Lo mismo pero incluyendo todos los archivos en total.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_22.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_22.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2010 Feb 21</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 21/2/2010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finding the file to edit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrar el archivo a editar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|22.1|	The file browser
|22.2|	The current directory
|22.3|	Finding a file
|22.4|	The buffer list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|22.1|	El explorador de archivos
|22.2|	El directorio actual
|22.3|	Encontrar un archivo
|22.4|	La lista de búfers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_23.txt|  Editing other files
 Previous chapter: |usr_21.txt|  Go away and come back
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_23.esx|  Editar otros archivos
  Capítulo anterior: |usr_21.est|  Abandonar el editor y volver
Tabla de contenidos: |usr_toc.est|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.1*	The file browser</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.1*	El explorador de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a plugin that makes it possible to edit a directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una extensión que permita editar un directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Through the magic of autocommands and Vim scripts, the window will be filled with the contents of the directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mediante la magia de las autoórdenes y de scripts de Vim, la pantalla mostrará los contenidos del directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" ============================================================================ ~
" Netrw Directory Listing                                        (netrw v109) ~
"   Sorted by      name ~
"   Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$ ~
"   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec ~
" ============================================================================ ~
../ ~
./ ~
check/ ~
Makefile ~
autocmd.txt ~
change.txt ~
eval.txt~ ~
filetype.txt~ ~
help.txt.info ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" ============================================================================ ~
" Netrw Directory Listing                                        (netrw v109) ~
"   Sorted by      name ~
"   Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$ ~
"   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec ~
" ============================================================================ ~
../ ~
./ ~
check/ ~
Makefile ~
autocmd.txt ~
change.txt ~
eval.txt~ ~
filetype.txt~ ~
help.txt.info ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the browsing tool and its version number
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre de la herramienta de exploración y su número de versión
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the browsing directory
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del directorio presente
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method of sorting (may be by name, time, or size)
4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La directriz de ordenación (puede ser por nombre, tiempo o tamaño)
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How names are to be sorted (directories first, then *.h files,
    *.c files, etc)
5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El orden de aparición de los nombres (primero directorios, después 
    archivos *.h, archivos *.c, etc)
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to get help (use the &lt;F1&gt; key), and an abbreviated listing
    of available commands
6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cómo obtener ayuda (use la tecla &lt;F1&gt;), y una lista abreviada
    de las órdenes disponibles
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A listing of files, including "../", which allows one to list
    the parent directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una lista de archivos, incluyendo «../», que permite acceder al
    al directorio padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use Normal mode Vim commands to move around in the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar las órdenes de Vim en el modo normal para desplazarse a a través del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, move the cursor atop a file and press &lt;Enter&gt;; you will then be editing that file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, mueva el cursor al inicio del archivo y pulse &lt;Intro&gt;; estará ahora editando ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go back to the browser use ":edit ." again, or use ":Explore".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para volver al explorador, use «:edit» otra vez, o use «:Explore».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-O also works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-O también funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try using &lt;Enter&gt; while the cursor is atop a directory name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use &lt;Intro&gt; mientras el cursor está sobre un nombre de directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is that the file browser moves into that directory and displays the items found there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El el resultado es que el explorador de archivos entra en ese directorio y muestra los elementos que ahí se encuentran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing &lt;Enter&gt; on the first directory "../" moves you one level higher.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa &lt;Intro&gt; en el primer directorio «../», se desplazará al nivel superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing "-" does the same thing, without the need to move to the "../" item first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar «-» realiza la misma acción, sin la necesidad de posicionarse primero sobre el elemento «../».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can press &lt;F1&gt; to get help on the things you can do in the netrw file browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener ayuda pulsando &lt;F1&gt; referente a las acciones que puede realizar en el explorador de archivos netrw.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is what you get: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación verá lo que obtiene.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Directory Browsing	 netrw-browse   netrw-dir   netrw-list   netrw-help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Directory Browsing	 netrw-browse   netrw-dir   netrw-list   netrw-help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MAPS								 netrw-maps 
     	 &lt;F1&gt;.............Help.......................................|netrw-help|
     	 &lt;cr&gt;.............Browsing...................................|netrw-cr|
     	 &lt;del&gt;............Deleting Files or Directories..............|netrw-delete|
     	 -................Going Up...................................|netrw--|
     	 a................Hiding Files or Directories................|netrw-a|
     	 mb...............Bookmarking a Directory....................|netrw-mb|
     	 gb...............Changing to a Bookmarked Directory.........|netrw-gb|
     	 c................Make Browsing Directory The Current Dir....|netrw-c|
     	 d................Make A New Directory.......................|netrw-d|
     	 D................Deleting Files or Directories..............|netrw-D|
     	 &lt;c-h&gt;............Edit File/Directory Hiding List............|netrw-ctrl-h|
     	 i................Change Listing Style.......................|netrw-i|
     	 &lt;c-l&gt;............Refreshing the Listing.....................|netrw-ctrl-l|
     	 o................Browsing with a Horizontal Split...........|netrw-o|
     	 p................Use Preview Window.........................|netrw-p|
     	 P................Edit in Previous Window....................|netrw-p|
     	 q................Listing Bookmarks and History..............|netrw-q|
     	 r................Reversing Sorting Order....................|netrw-r|
&lt;    	(etc)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MAPS								 netrw-maps 
     	 &lt;F1&gt;.............Ayuda......................................|netrw-help|
     	 &lt;cr&gt;.............Explorar...................................|netrw-cr|
     	 &lt;del&gt;............Borrar archivos o directorios..............|netrw-delete|
     	 -................Subir......................................|netrw--|
     	 a................Ocultar archivos o directorios.............|netrw-a|
     	 mb...............Marcar un directorio como favorito.........|netrw-mb|
     	 gb...............Pasar a un directorio favorito.............|netrw-gb|
     	 c................Hacer del directorio explorado el actual...|netrw-c|
     	 d................Crear un directorio........................|netrw-d|
     	 D................Borrar archivos o directorios..............|netrw-D|
     	 &lt;c-h&gt;............Editar la lista de archivos/dir ocultos....|netrw-ctrl-h|
     	 i................Cambiar el estilo de la lista..............|netrw-i|
     	 &lt;c-l&gt;............Refrescar la lista.........................|netrw-ctrl-l|
     	 o................Explorar con una división horizontal.......|netrw-o|
     	 p................Usar la ventana de previsualización........|netrw-p|
     	 P................Editar en la anterior ventana..............|netrw-p|
     	 q................Listar favoritos y el histório.............|netrw-q|
     	 r................Invertir el orden de agrupación............|netrw-r|
&lt;    	(etc)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;F1&gt; key thus brings you to a netrw directory browsing contents help page.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;F1&gt; le lleva un directorio netrw explorando los contenidos de la página de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a regular help page; use the usual |CTRL-]| to jump to tagged help items and |CTRL-O| to jump back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta es una página de ayuda normal; use |CTRL-]| para saltar entre los elementos de ayuda etiquetados, y |CTRL-O| para volver atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;enter&gt;		Open the file in the current window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;enter&gt;		Abrir el archivo en la ventana actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|netrw-cr|
	o		Horizontally split window and display file |netrw-o|
	v		Vertically split window and display file   |netrw-v|
	p		Use the |preview-window| 		   |netrw-p|
	P		Edit in the previous window		   |netrw-P|
	t		Open file in a new tab			   |netrw-t|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|netrw-cr|
	o		Dividir la ventana horizontalmente y mostrar el archivo |netrw-o|
	v		Dividir la ventana verticalmente y mostrar el archivo   |netrw-v|
	p		Usar la |preview-window| (ventana de previsualización)		  |netrw-p|
	P		Editar en la ventana anterior		   |netrw-P|
	t		Abrir el archivo en una nueva pestaña			   |netrw-t|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i		Controls listing style (thin, long, wide, and tree).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>i		Control el formato de la lista (estrecho, largo, ancho, y árbol).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The long listing includes size and date information.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El formato de lista largo incluye información de tamaño y fecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>s		Repeatedly pressing s will change the way the files
			are sorted; one may sort on name, modification time,
			or size.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>s		Pulsar «s» repetidas veces modifica la manera en que se organizan
			los archivos; una para ordenar por nombre, fecha de modificación,
			o tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>r		Reverse the sorting order.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>r		Invertir el orden de presentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>c		Change Vim's notion of the current directory to be
			the same as the browser directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>c		Cambiar la noción de directorio actual de Vim, para
			coincidir con el directorio del navegador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(see
			|g:netrw_keepdir| to control this, too)
	R		Rename the file or directory under the cursor; a
			prompt will be issued for the new name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Véase
			|g:netrw_keepdir| para controlare esto también.)
	R		Renombrar el archivo o directorio bajo el cursor; verá
			una ventana de dialogo para introducir el nombre nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>D		Delete the file or directory under the cursor; a
			confirmation request will be issued.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>D		Borrar el archivo o directorio bajo el cursor; un
			dialogo le pedirá confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mb gb		Make bookmark/goto bookmark</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mb gb		Crear marcador/ir a bookmark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Explore [directory]	Browse specified/current directory
	:NetrwSettings		A comprehensive list of your current netrw
				settings with help linkage.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Explore [directory]	Explorar el directorio actual o especificado
	:NetrwSettings		Una completa lista de su configuración actual de
				netrw, con enlaces de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The netrw browser is not limited to just your local machine; one may use
urls such as:    (that trailing / is important)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El explorador netrw no esta limitado al sistema local; puede usar
direcciones url tales como:    (espacio en blanco / es importante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Explore ftp://somehost/path/to/dir/
	:e scp://somehost/path/to/dir/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Explore ftp://sistema_anfitrión/ruta/al/directorio/
	:e scp://sistema_anfitrión/ruta/al/directorio/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.2*	The current directory</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.2*	El directorio actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit VeryLongFileName/file1.txt
	:edit VeryLongFileName/file2.txt
	:edit VeryLongFileName/file3.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit Nombre_Largo_de_Directorio/archivo1.txt
	:edit Nombre_Largo_de_Directorio/archivo2.txt
	:edit Nombre_Largo_de_Directorio/archivo3.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cd VeryLongFileName
	:edit file1.txt
	:edit file2.txt
	:edit file3.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cd Nombre_Largo_de_Directorio
	:edit archivo1.txt
	:edit archivo2.txt
	:edit archivo3.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":cd" command changes the current directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:cd» le permite cambiar a otro directorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see what the current directory is with the ":pwd" command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver cual es el directorio actual con la orden «:pwd»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pwd
	/home/Bram/VeryLongFileName</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:pwd
	/home/Bram/Nombre_Largo_de_Directorio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim remembers the last directory that you used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim recuerda el último directorio que usó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "cd -" to go back to it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «cd -» para volver a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pwd
	/home/Bram/VeryLongFileName
	:cd /etc
	:pwd
	/etc
	:cd -
	:pwd
	/home/Bram/VeryLongFileName
	:cd -
	:pwd
	/etc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:pwd
	/home/Bram/Nombre_Largo_de_Directorio
	:cd /etc
	:pwd
	/etc
	:cd -
	:pwd
	/home/Bram/Nombre_Largo_de_Directorio
	:cd -
	:pwd
	/etc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you split a window, both windows use the same current directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando divide una ventana, ambas ventanas usan el mismo directorio actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to edit a number of files somewhere else in the new window, you can make it use a different directory, without changing the current directory in the other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando desea editar un nombre de archivos en otra ubicación en la ventana nueva, puede usar un directorio diferente, sin cambiar el directorio actual en la otra ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called a local directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le llama el directorio local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:pwd
	/home/Bram/VeryLongFileName
	:split
	:lcd /etc
	:pwd
	/etc
	CTRL-W w
	:pwd
	/home/Bram/VeryLongFileName</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:pwd
	/home/Bram/Nombre_Largo_de_Archivo
	:split
	:lcd /etc
	:pwd
	/etc
	CTRL-W w
	:pwd
	/home/Bram/Nombre_Largo_de_Archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So long as no ":lcd" command has been used, all windows share the same current
directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mientras no use ninguna orden «:lcd», todas las ventanas comparten
el directorio actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Doing a ":cd" command in one window will also change the current
directory of the other window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecutar una orden «:cd» en una ventana cambiará
también el directorio de la otra ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a window where ":lcd" has been used a different current directory is
remembered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se usa con «:lcd» con una ventana, se recordará otro directorio
actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using ":cd" or ":lcd" in other windows will not change it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «:cd» o «:lcd» en otras ventanas no modificará esta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a ":cd" command in a window that uses a different current
directory, it will go back to using the shared directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use la orden «:cd» en una ventana que usa un directorio actual
diferente, esta volverá al directorio compartido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.3*	Finding a file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.3*	Encontrar un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "inits.h" ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#include "inits.h" ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to see what is in that "inits.h" file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desea ver el contenido del archivo «inits.h».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor on the name of the file and type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplace el cursor al nombre del archivo y teclee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gf</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gf</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find the file and edit it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim encontrará el archivo y lo editará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What if the file is not in the current directory?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Y en el caso de que el archivo no está en el directorio actual?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will use the 'path'
option to find the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim
usará la opción 'path' (ruta) para encontrar el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This option is a list of directory names where to
look for your file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta opción es una
lista de nombres de directorio donde buscar su archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have your include files located in "c:/prog/include".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene sus archivos include en «c:/prog/include».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
command will add it to the 'path' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden
la añadiría a la opción 'path': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set path+=c:/prog/include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set path+=c:/prog/include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This directory is an absolute path.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este directorio es una ruta absoluta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No matter where you are, it will be the
same place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa donde esté, tendrá
la misma ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What if you have located files in a subdirectory, below where the
file is?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Y en el caso de que tiene archivos ubicados en un
subdirectorio, debajo de donde está el archivo?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can specify a relative path name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede especificar en este
caso un nombre de ruta relativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts with a dot:
&gt;
	:set path+=./proto</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto empieza con un punto:
&gt;
	:set path+=./proto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to look in the directory "proto", below the directory where the
file in which you use "gf" is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim mire en el directorio «proto», debajo del
directorio en el que está el archivo sobre el que usa «gf».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus using "gf" on "inits.h" will make Vim
look for "proto/inits.h", starting in the directory of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, usar
«gf» con «inits.h» hace que Vim busque «proto/inits.h», empezando por el
directorio del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without the "./", thus "proto", Vim would look in the "proto" directory
below the current directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin el «./», en este caso «proto», Vim buscará en el directorio «proto»
por debajo del directorio actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the current directory might not be where the
file that you are editing is located.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y puede que el directorio actual no sea
en el que se ubica el archivo que está editando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'path' option allows specifying the directories where to search for files
in many more ways.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'path' permite especificar de muchas más maneras los directorios
donde buscar los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the help on the 'path' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase la ayuda de la opción 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'isfname' option is used to decide which characters are included in the
file name, and which ones are not (e.g., the " character in the example
above).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'isfname' se usa para decidir qué caracteres están incluidos
en el nombre del archivo, y cuales no lo están (p. ej., el carácter «"» en
el ejemplo anterior).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:find inits.h</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:find inits.h</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will then use the 'path' option to try and locate the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará entonces la opción 'path' para buscar y ubicar el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the same as the ":edit" command, except for the use of 'path'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto equivale a la orden «:edit», excepto por el uso de 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim "+find stdio.h"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim "+find stdio.h"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds the file "stdio.h" in your value of 'path'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra el archivo «stdio.h» en su valor de 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quotes are necessary to have one argument |-+c|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las comillas son necesarias para tener un argumento |-+c|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*22.4*	The buffer list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*22.4*	La lista de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor uses the term buffer to describe a file being edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim usa el término búfer para describir un archivo en edición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, a buffer is a copy of the file that you edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, un búfer es una copia del archivo que edita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you finish changing the buffer, you write the contents of the buffer to the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando termina de modificar el búfer, escribe los contenidos del búfer en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Buffers not only contain file contents, but also all the marks, settings, and other stuff that goes with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los búfers no solo contienen los contenidos de al archivo, sino también las marcas, configuraciones y otros elementos que lo acompañan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:hide edit two.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:hide edit dos.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The buffer "one.txt" disappears from the screen, but Vim still knows that you
are editing this buffer, so it keeps the modified text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El búfer «uno.txt» desaparece de la pantalla, pero Vim sabe aún sabe que
esté editando el búfer, así que guarda el texto modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called a
hidden buffer: The buffer contains text, but you can't see it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le
llama un búfer oculto: El búfer contiene texto, pero no puede verlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The argument of ":hide" is another command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento de «:hide» es otra orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":hide" makes that command
behave as if the 'hidden' option was set.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:hide» hace que una orden se
comporte como si la opción 'hidden' estuviese activada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also set this option
yourself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También podría
configurar usted mismo esta opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The effect is that when any buffer is abandoned, it becomes hidden.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El efecto que esto tiene es que cuando
cualquier búfer, éste se ocultará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Cuidado!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have hidden buffers with changes, don't exit Vim
without making sure you have saved all the buffers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tenga búfers ocultos con cambios, no cierre Vim antes de
asegurarse de haber guardado todos los búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a buffer has been used once, Vim remembers some information about it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si un búfer se ha usado una vez, Vim recordará alguna información del búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it is not displayed in a window and it is not hidden, it is still in the
buffer list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no está activa en una ventana y no oculta, aún se encontrará en la
lista de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called an inactive buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le llama un búfer inactivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overview:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vista general:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Active		Appears in a window, text loaded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Activo		Aparece en una ventana, texto cargado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hidden		Not in a window, text loaded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hidden		No aparece en una ventana, texto cargado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inactive		Not in a window, no text loaded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Inactive		No aparece en una ventana, texto no cargado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:buffers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:buffers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:ls</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:ls</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1 #h	"help.txt"			line 62 ~
  2 %a+	"usr_21.txt"			line 1 ~
  3	"usr_toc.txt"			line 1 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1 #h	"help.txt"			línea 62 ~
  2 %a+	"usr_21.txt"			línea 1 ~
  3	"usr_toc.txt"			línea 1 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first column contains the buffer number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera columna contiene el número de búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use this to edit the
buffer without having to type the name, see below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar esto para
editar el búfer sin tener que introducir el nombre, explicado a
continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After the buffer number come the flags.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después del número aparecen las opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the name of the file
and the line number where the cursor was the last time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, el nombre del
archivo y el número de línea en el que estaba el cursor al última vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The flags that can appear are these (from left to right):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se permiten las siguientes opciones (de izquierda a derecha):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>u	Buffer is unlisted |unlisted-buffer|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>u	Buffer no está listado |unlisted-buffer|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%	Current buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>%	Búfer actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#	Alternate buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#	Búfer alternativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a	Buffer is loaded and displayed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a	El búfer está cargado y visible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>h	Buffer is loaded but hidden.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>h	El búfer está cargado pero oculto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>=	Buffer is read-only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>=	El búfer es de sólo lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-	Buffer is not modifiable, the 'modifiable' option is off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-	El búfer no es modificable, la opción 'modifiable' está desactivada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+	Buffer has been modified.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+	El búfer se ha modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can edit a buffer by its number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede editar un búfer por su número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That avoids having to type the file name: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto evita tener que introducir el nombre del archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:buffer 2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:buffer 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the only way to know the number is by looking in the buffer list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero la única manera de saber el número es a través de la lista de de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the name, or part of it, instead: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de esto, puede usar el nombre, o parte de él: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:buffer help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:buffer help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will find the best match for the name you type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim mostrará la coincidencia más cercana al nombre que introduzca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is only one
buffer that matches the name, it will be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De
sólo haber un búfer que coincida con el nombre, este se usará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case "help.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso,
«help.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To open a buffer in a new window: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente para abrir un búfer en una nueva ventana: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:sbuffer 3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:sbuffer 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:bnext		go to next buffer
	:bprevious	go to previous buffer
	:bfirst		go to the first buffer
	:blast		go to the last buffer</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:bnext		Ir al siguiente búfer
	:bprevious	Ir al búfer anterior
	:bfirst		Ir al primer búfer
	:blast		Ir al último búfer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:bdelete 3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:bdelete 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, this also works with a name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, esto también funciona con un nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you delete a buffer that was active (visible in a window), that window
will be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si elimina un búfer que estaba activo (visible en una ventana), esa
ventana se cerrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you delete the current buffer, the current window will be
closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si elimina el búfer actual, se cerrará la ventana
actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it was the last window, Vim will find another buffer to edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si era la última ventana, Vim encontrará otro búfer que editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
can't be editing nothing!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡No
puede editar la nada!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Even after removing the buffer with ":bdelete" Vim still remembers it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Aún después de eliminar un búfer con «:bdelete», Vim aún lo recuerda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's actually made "unlisted", it no longer appears in the list from
	":buffers".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, pasa a no «unlisted» (no listado), ya que no aparece en la
	lista de «:buffers».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":buffers!" command will list unlisted buffers (yes,
	Vim can do the impossible).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:buffers!» muestra los búfers no listados
	(sí, Vim es capaz de lo imposible).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To really make Vim forget about a buffer,
	use ":bwipe".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que Vim olvide
	completamente un búfer, use «:bwipe».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see the 'buflisted' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase también la opción	'buflisted'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_90.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_90.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2008 Sep 10</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 10/09/2008</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Instalar Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*install*
Before you can use Vim you have to install it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*instalar* *install*
Antes de usar Vim, tiene que instalarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on your system it's
simple or easy.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es sencillo o fácil
dependiendo de su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter gives a few hints and also explains how
upgrading to a new version is done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo ofrece algunas
indicaciones y explica cómo se actualiza a una nueva versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|90.1|	Unix
|90.2|	MS-Windows
|90.3|	Upgrading
|90.4|	Common installation issues
|90.5|	Uninstalling Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|90.1|	Unix
|90.2|	MS-Windows
|90.3|	Actualizar
|90.4|	Problemas de instalación habituales
|90.5|	Desinstalar Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous chapter: |usr_45.txt|  Select your language
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_45.esx|  Seleccione su idioma
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.1*	Unix</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.1*	Unix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you have to decide if you are going to install Vim system-wide or for a
single user.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero debe decidir si va a instalar Vim para uno o todos los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installation is almost the same, but the directory where Vim
is installed in differs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
instalación es muy similar, pero difiere el directorio de instalación de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a system-wide installation the base directory "/usr/local" is often
used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para una instalación de sistema (todos los usuarios), a menudo se usa
el directorio base «/usr/local».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But this may be different for your system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero puede ser distinto en su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try finding out where other
packages are installed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Intente averiguar dónde se instalan los otros paquetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When installing for a single user, you can use your home directory as the
base.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando realiza una instalación para un sólo usuario, puede usar su
directorio personal como base.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The files will be placed in subdirectories like "bin" and "shared/vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los ficheros se ubicarań en subdirectorios
como «bin» y «shared/vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get precompiled binaries for many different UNIX systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener binarios precompilados para muchos sistemas UNIX diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a long list with links on this page:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta página hay una larga lista con enlaces:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://www.vim.org/binaries.html ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>http://www.vim.org/binaries.html ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Volunteers maintain the binaries, so they are often out of date.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los responsables de los binarios son voluntarios, por lo que a menudo están obsoletos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a good idea to compile your own UNIX version from the source.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es una buena idea compilar su propia versión UNIX desde las fuentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, creating the editor from the source allows you to control which features are compiled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así mismo, crear el editor desde las fuentes le permite controlar las características a compilar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does require a compiler though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otra parte, esto requiere un compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a Linux distribution, the "vi" program is probably a minimal version of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene una distribución de Linux, el programa vi es probablemente una versión mínima de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It doesn't do syntax highlighting, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No ejecuta el resaltado de sintaxis, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try finding another Vim package in your distribution, or search on the web site.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Intente buscar otro paquete de Vim en su distribución, o busque en la página web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-  A C compiler (GCC preferred)
	-  The GZIP program (you can get it from www.gnu.org)
	-  The Vim source and runtime archives</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-  Un compilador C (preferentemente GCC)
	-  El programa GZIP (puede obtenerlo en www.gnu.org)
	-  Los archivos de Vim fuente y de tiempo de ejecución</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ftp://ftp.vim.org/pub/vim/MIRRORS ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ftp://ftp.vim.org/pub/vim/MIRRORS ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go to the
"unix" directory and you'll find a list of files there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya al directorio «unix», y encontrará una serie de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version number is
embedded in the file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
número de versión está integrado en el nombre del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the files for Unix in two ways: One big archive that contains
everything, or four smaller ones that each fit on a floppy disk.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener los archivos para Unix de dos formas: Un único archivo
grande que contiene todo, o cuatro más pequeños que caben en un
disquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For version
6.1 the single big one is called:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo de la versión 6.1 se llama:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim-6.1.tar.bz2 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim-6.1.tar.bz2 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need the bzip2 program to uncompress it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita el programa bzip2 para descomprimirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have it, get the four smaller files, which can be uncompressed with gzip.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no lo tiene, descargue los cuatro archivos más pequeños, que se pueden descomprimir con gzip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Vim 6.1 they are called:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para Vim 6.1, se llaman:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim-6.1-src1.tar.gz ~
	vim-6.1-src2.tar.gz ~
	vim-6.1-rt1.tar.gz ~
	vim-6.1-rt2.tar.gz ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim-6.1-src1.tar.gz ~
	vim-6.1-src2.tar.gz ~
	vim-6.1-rt1.tar.gz ~
	vim-6.1-rt2.tar.gz ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mkdir ~/vim
	cd ~/vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mkdir ~/vim
	cd ~/vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then unpack the archives there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Descomprima los archivos en esa ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have the one big archive, you unpack it like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene el archivo único grande, lo puede desempaquetar de la siguiente forma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>bzip2 -d -c path/vim-6.1.tar.bz2 | tar xf -</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>bzip2 -d -c ruta/vim-6.1.tar.bz2 | tar xf -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gzip -d -c path/vim-6.1-src1.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-src2.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-rt1.tar.gz | tar xf -
	gzip -d -c path/vim-6.1-rt2.tar.gz | tar xf -</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gzip -d -c ruta/vim-6.1-src1.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-src2.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-rt1.tar.gz | tar xf -
	gzip -d -c ruta/vim-6.1-rt2.tar.gz | tar xf -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cd vim61/src
	make</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cd vim61/src
	make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The make program will run configure and compile everything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El programa «make» ejecutará «configure» y compilará todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further on we
will explain how to compile with different features.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más adelante
explicaremos como compilar con diferentes funcionalidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are errors while compiling, carefully look at the error messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si detecta errores durante la compilación, mire con detenimiento los
mensajes de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There should be a hint about what went wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debería haber una indicación de qué falló.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully you will be able to
correct it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con suerte,
podrá corregirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have to disable some features to make Vim compile.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que tenga que desactivar algunas funcionalidades
para poder compilar Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look in the Makefile for specific hints for your system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte el archivo «Makefile» para ver
indicaciones específicas a su sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make test</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>make test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run a sequence of test scripts to verify that Vim works as expected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ejecutará una secuencia de scripts de prueba para comprobar que Vim funciona de la manera esperada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will be started many times and all kinds of text and messages flash by.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se iniciará Vim varias veces, y aparecerán rápidamente todo tipo de texto y mensajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is alright you will finally see:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si todo es correcto, verá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>test results: ~
	ALL DONE ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>test results: ~
	ALL DONE ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you get "TEST FAILURE" some test failed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si le devuelve «TEST FAILURE», es que ha fallado alguna prueba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are one or two messages about failed tests, Vim might still work, but not perfectly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si existen uno o más mensajes de pruebas fallidas, puede que Vim funcione, pero no a la perfección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you see a lot of error messages or Vim doesn't finish until the end, there must be something wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ve muchos mensajes de error o Vim no continua hasta el final, puede que exista algún problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either try to find out yourself, or find someone who can solve it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede intentar encontrarlo manualmente, o encontrar a alguien que lo puede solucionar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could look in the |maillist-archive| for a solution.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede consultar la lista de correo (|maillist-archive|) en busca de una solución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If everything else fails, you could ask in the vim |maillist| if someone can help you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si todo falla, puede preguntar en la lista de correo (|maillist|) de Vim si alguien le puede ayudar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>INSTALLING
							*install-home*
If you want to install in your home directory, edit the Makefile and search
for a line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>INSTALACIÓN
							*install-home*
Si desea instalar Vim en su directorio personal (o «home»), edite el
archivo «Makefile» y busque la siguiente línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#prefix = $(HOME) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#prefix = $(HOME) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the # at the start of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Elimine «#» al principio de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When installing for the whole system, Vim has most likely already selected
a good installation directory for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al instalar para todo el sistema, los más probable es que Vim haya
seleccionado un directorio de instalación adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify one, see below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede
definir uno; vea a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to become root for the following.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita ser el administrador para
poder realizar lo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make install</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>make install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That should move all the relevant files to the right place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto debería mover todos los archivos relevantes al sitio adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can try running vim to verify that it works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede intentar ejecutar Vim para comprobar que funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use two simple tests to check if Vim can find its runtime files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use dos pruebas sencillas para comprobar que Vim puede encontrar sus archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help
	:syntax enable</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help
	:syntax enable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo $VIMRUNTIME</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo $VIMRUNTIME</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget that the user manual assumes you Vim in a certain way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No olvide que el manual del usuario supone que usa Vim de una cierta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After installing Vim, follow the instructions at |not-compatible| to make Vim work as assumed in this manual.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras instalar Vim, siga las instrucciones en |not-compatible| para que Vim funcione de la forma aceptada en este manual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has many ways to select features.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece varias formas de seleccionar funcionalidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the simple ways is to edit the
Makefile.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una de las más
sencillas es editar el archivo «Makefile».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many directions and examples.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay muchas indicaciones y
ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often you can enable or
disable a feature by uncommenting a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, puede activar o desactivar una funcionalidad
simplemente descomentando una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to run "configure" separately.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra alternativa es ejecutar «configure» de forma separada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to
specify configuration options manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le permite
especificar opciones de configuración manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The disadvantage is that you have to
figure out what exactly to type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La desventaja es que
tiene que averiguar qué teclear exactamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of the most interesting configure arguments follow.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación tiene algunas de los argumentos más interesantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can also be
enabled from the Makefile.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También
se pueden activar desde el archivo «Makefile».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--prefix={directory}		Top directory where to install Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--prefix={directorio}		Directorio superior donde instalar Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--with-features=tiny		Compile with many features disabled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--with-features=tiny		Compilación con varias funcionalidades desactivadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--with-features=small		Compile with some features disabled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--with-features=small		Compilación con algunas funcionalidades desactivadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--with-features=big		Compile with more features enabled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--with-features=big		Compilación con más funcionalidades activadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--with-features=huge		Compile with most features enabled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--with-features=huge		Compilación con la mayoría de funcionalidades activadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |+feature-list| for which feature
					is enabled in which case.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |+feature-list| para ver qué
					funcionalidad está activa por omisión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--enable-perlinterp		Enable the Perl interface.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--enable-perlinterp		Activa la interfaz de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are
					similar arguments for ruby, python and
					tcl.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen
					argumentos similares para Ruby,
					Python y tcl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--disable-gui			Do not compile the GUI interface.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--disable-gui			No compila la interfaz gráfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>--without-x			Do not compile X-windows features.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>--without-x			No compila las funcionalidades del sistema
						de ventanas X.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When both of these are used, Vim will
					not connect to the X server, which
					makes startup faster.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se usan las dos, Vim no se conectará al
					servidor de X, lo cual agiliza el inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./configure --help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>./configure --help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find a bit of explanation for each feature, and links for more
information here: |feature-list|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar una explicación de cada funcionalidad y enlaces a
más información aquí: |feature-list|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the adventurous, edit the file "feature.h".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para los atrevido, edite el archivo «feature.h».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also change the
source code yourself!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡También puede
modificar el código fuente directamente!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.2*	MS-Windows</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.2*	MS-Windows</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to install the Vim program for Microsoft Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen dos formas de instalar el programa Vim para Microsoft Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can uncompress several archives, or use a self-installing big archive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede descomprimir varios archivos, o usar un sólo archivo de instalación automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most users with fairly recent computers will prefer the second method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría de usuarios con ordenadores relativamente recientes pueden preferir el segundo método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the first one, you will need:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se requiere lo siguiente para usar el primero:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- An archive with binaries for Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Un archivo con binarios para Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- The Vim runtime archive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El archivo de tiempo de ejecución («runtime) de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- A program to unpack the zip files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Un programa para desempaquetar los archivos zip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go to the "pc" directory and you'll find a list of files there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya al directorio «pc» y verá una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version number is embedded in the file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El número de versión se incluye en el nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use "61" here, which is version 6.1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este documento se usará «61», la versión 6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim61.exe		The self-installing archive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim61.exe		El archivo de instalación automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is all you need for the second method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es todo lo que necesita para el segundo método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just launch the executable, and follow the prompts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente ejecute el archivo, y siga los diálogos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the first method you must chose one of the binary archives.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe escoger uno de los archivos binarios para realizar el primer método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are available:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los siguientes están disponibles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim61.zip		The normal MS-Windows GUI version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim61.zip		La versión de interfaz gráfica normal de MS Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim61ole.zip		The MS-Windows GUI version with OLE support.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim61ole.zip		La versión gráfica de MS Windows con compatibilidad
					con OLE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uses more memory, supports interfacing with
				other OLE applications.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usa más memoria, permite interactuar con otras
				aplicaciones OLE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim61w32.zip		32 bit MS-Windows console version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim61w32.zip		La versión de consola de 32 bit para MS Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For use in
				a Win NT/2000/XP console.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para el uso en una consola Win NT/2000/XP console.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does not work well
				on Win 95/98.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No funciona bien en Win 95/98.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim61d32.zip		32 bit MS-DOS version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim61d32.zip		Versión de 32 bit para MS-DOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For use in the
				Win 95/98 console window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para el uso en una
				ventana de consola de Win 95/98.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim61d16.zip		16 bit MS-DOS version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim61d16.zip		Versión de 16 bit para MS-DOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only for old systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo para sistemas
				antiguos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does not support long filenames.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No permite el uso de nombres de archivo largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You only need one of them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo necesita uno de estos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although you could install both a GUI and a console version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aunque puede instalar la versión gráfica y una versión de intérprete de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You always need to get the archive with runtime files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siempre necesita obtener el archivo con los archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim61rt.zip		The runtime files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim61rt.zip		Los archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use your un-zip program to unpack the files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use su programa un-zip para descomprimir lso archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, using the "unzip" program: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, usando el programa «unzip»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cd c:\
	unzip path\gvim61.zip
	unzip path\vim61rt.zip</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cd c:\
	unzip path\gvim61.zip
	unzip path\vim61rt.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will unpack the files in the directory "c:\vim\vim61".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éstas órdenes desempaquetarán los ficheros en el directorio «c:\vim\vim61».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already
have a "vim" directory somewhere, you will want to move to the directory just
above it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ya tiene un directorio «vim», puede navegar al directorio superior a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now change to the "vim\vim61" directory and run the install program: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, entre al directorio «vim\vim61» y ejecute el programa de
instalación: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>install</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carefully look through the messages and select the options you want to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise los mensajes con cuidado y seleccione las opciones que desea usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you finally select "do it" the install program will carry out the actions
you selected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si al final selecciona «do it», el programa de instalación llevará a cabo las
acciones seleccionadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The install program doesn't move the runtime files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El programa de instalación no reubica los archivos de tiempo de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They remain where you
unpacked them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Permanecerán en el lugar en el que los desempaquetó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are not satisfied with the features included in the supplied binaries, you could try compiling Vim yourself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el caso de que no esté satisfecho con las características incluidas en los binarios proporcionados, puede intentar compilar Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the source archive from the same location as where the binaries are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtenga el archivo de fuentes de la misma ubicación de los binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need a compiler for which a makefile exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesitará un compilador que permita «makefiles».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft Visual C works, but is expensive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Microsoft Visual C funciona, pero es caro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Free Borland command-line compiler 5.5 can be used, as well as the free MingW and Cygwin compilers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el compilador de línea de órdenes libre Borland 5.5, así como los compiladores libres MingW y Cygwin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the file src/INSTALLpc.txt for hints.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte el archivo «src/INSTALLpc.txt» para más indicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.3*	Upgrading</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.3*	Actualizar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type "make install" the runtime files will be copied to a directory
which is specific for this version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando teclea «make install», los ficheros de tiempo de ejecución se
copiarán un directorio específico a la versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus they will not overwrite a previous
version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, no sobreescribirán
una versión anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes it possible to use two or more versions next to
each other.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite usar dos o más versiones
simultáneamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable "vim" will overwrite an older version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El ejecutable «vim» sobreescribirá una versión anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't care
about keeping the old version, running "make install" will work fine.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le
interesa preservar la versión más antigua, ejecutar «make install»
funcionará sin problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can
delete the old runtime files manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede eliminar los archivos de
tiempo de ejecución manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just delete the directory with the
version number in it and all files below it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente elimine el directorio con
el número de versión y todos los archivos contenidos en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>rm -rf /usr/local/share/vim/vim58</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>rm -rf /usr/local/share/vim/vim58</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are normally no changed files below this directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, bajo este directorio no hay archivos modificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did change the "filetype.vim" file, for example, you better merge the changes into the new version before deleting it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha modificado el archivo «filetype.vim», por ejemplo, será mejor que introduzca esos cambios en la versión nueva antes de eliminar el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are careful and want to try out the new version for a while before switching to it, install the new version under another name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es cuidadoso y desea probar la nueva versión durante un tiempo antes de cambiar a ella, instale la nueva versión bajo otro nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to specify a configure argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita especificar un argumento de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./configure --with-vim-name=vim6</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>./configure --with-vim-name=vim6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running "make install", you could use "make -n install" to check that
no valuable existing files are overwritten.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debería usar «make -n install» antes de ejecutar «make install» para
comprobar que no se sobreescribirá ningún archivo valioso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you finally decide to switch to the new version, all you need to do is
to rename the binary to "vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando decida pasar a la nueva versión, todo lo que necesita hacer es
renombrar el binario a «vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mv /usr/local/bin/vim6 /usr/local/bin/vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mv /usr/local/bin/vim6 /usr/local/bin/vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Upgrading is mostly equal to installing a new version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Actualizar es casi idéntico a instalar una versión nueva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just unpack the files
in the same place as the previous version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sencillamente
desempaquete los archivos en la misma ubicación de la versión anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new directory will be created,
e.g., "vim61", for the files of the new version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se creará un directorio nuevo, esto es, «vim61», para los archivos de la
versión nueva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your runtime files, vimrc
file, viminfo, etc. will be left alone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sus archivos de tiempo de ejecución, «vimrc» y «viminfo»
no se modificarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to run the new version next to the old one, you will have to do
some handwork.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea ejecutar la nueva versión junto a la antigua, tendrá que hacer
algún trabajo manual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't run the install program, it will overwrite a few files
of the old version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No ejecute el programa de instalación, ya que
sobreescribirá algunos archivos de la versión antigua.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execute the new binaries by specifying the full path.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecute los binarios
nuevos especificando la ruta completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The program should be able to automatically find the runtime files for the
right version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El programa debería averiguar
automáticamente la ubicación de los archivos de tiempo de ejecución para
la versión adecuada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, this won't work if you set the $VIMRUNTIME variable
somewhere.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otra parte, no funcionará si define en algún lugar
la variable «$VIMRUNTIME».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are satisfied with the upgrade, you can delete the files of the
previous version.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la actualización le satisface, puede eliminar los archivos de la versión
anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |90.5|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |90.5|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.4*	Common installation issues</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.4*	Problemas de instalación habituales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section describes some of the common problems that occur when installing Vim and suggests some solutions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta sección describe algunos de los problemas más habituales al instalar Vim, y sugiere algunas soluciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also contains answers to many installation questions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También contiene respuestas a muchas preguntas sobre la instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: I Do Not Have Root Privileges.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: No tengo privilegios de administrador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How Do I Install Vim?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Cómo puedo instalar Vim?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./configure --prefix=$HOME</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>./configure --prefix=$HOME</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This gives you a personal copy of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto genera una copia personal de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to put $HOME/bin in your path to execute the editor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita poner «$HOME/bin» en su ruta (variable PATH) para ejecutar el editor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see |install-home|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte también |install-home|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: The Colors Are Not Right on My Screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: Los colores no son los correctos en mi pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>echo $TERM</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>echo $TERM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the terminal type listed is not correct, fix it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el tipo de terminal listado no es el correcto, corríjalo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more hints, see |06.2|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más indicaciones, consulte |06.2|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to always use the GUI version of Vim, called gvim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra solución es usar siempre la versión gráfica de usuario de Vim, llamado gvim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This avoids the need for a correct terminal setup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto último evita la necesidad de una correcta configuración de terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The definition of what key sends what code is very unclear for backspace &lt;BS&gt; and Delete &lt;Del&gt; keys.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La definición del código que cada tecla envía no está muy clara con las teclas de retroceso &lt;BS&gt; y eliminar &lt;Del&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, check your $TERM setting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, compruebe su opción de configuración «$TERM».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is nothing wrong with it, try this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no detecta nada incorrecto: pruebe esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set t_kb=^V&lt;BS&gt;
	:set t_kD=^V&lt;Del&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set t_kb=^V&lt;BS&gt;
	:set t_kD=^V&lt;Del&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first line you need to press CTRL-V and then hit the backspace key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera línea tiene que pulsar «CTRL-V» y después pulsar la tecla de retroceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the second line you need to press CTRL-V and then hit the Delete key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la segunda, debe pulsar «CTRL-V» y pulsar la tecla de eliminar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put these lines in your vimrc file, see |05.1|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede poner estas líneas en su archivo «vimrc», consulte |05.1|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage is that it won't work when you use another terminal some day.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una desventaja es que no funcionará cuando use otra terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look here for alternate solutions: |:fixdel|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte aquí las posibles soluciones: |:fixdel|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: I Am Using RedHat Linux.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: Uso RedHat Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I Use the Vim That Comes with the System?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Puedo usar la versión de Vim que viene con el sistema?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default RedHat installs a minimal version of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, RedHat instala una versión mínima de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check your RPM packages for something named "Vim-enhanced-version.rpm" and install that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busque entre los paquetes RPM algo llamado «Vim-enhanced-version.rpm» e instale ese paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Q: How Do I Turn Syntax Coloring On?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>P: ¿Como se activa el resaltado de sintaxis?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I make plugins work?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Como hago funcionar las extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the example vimrc script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use el script de ejemplo «vimrc».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find an explanation on how to use it here: |not-compatible|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrará una explicación de su uso en el siguiente apartado: |not-compatible|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many users have uploaded useful Vim scripts and plugins there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchos usuarios han enviado útiles scripts de Vim y extensiones a esta ubicación de Internet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an archive with hints from Vim users.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un archivo con indicaciones de usuarios de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might also want to search in the |maillist-archive|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que también desee buscar en el archivo de la lista de correo, |maillist-archive|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*90.5*	Uninstalling Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*90.5*	Desinstalar Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you installed Vim as a package, check your package manager to find out
how to remove the package again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha instalado Vim como un paquete, compruebe su gestor de paquetes para
averiguar cómo eliminar el paquete.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you installed Vim from sources you can use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha instalado Vim a partir de las fuentes, puede usar la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make uninstall</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>make uninstall</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you have deleted the original files or you used an archive that someone supplied, you can't do this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, si ha eliminado los archivos originales, o ha usado un archivo que alguien le ha proporcionado, no podrá hacer esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do delete the files manually, here is an example for when "/usr/local" was used as the root: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un ejemplo de desinstalación manual de Vim cuando «/usr/local» se ha usado como el directorio raíz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>rm -rf /usr/local/share/vim/vim61
	rm /usr/local/bin/eview
	rm /usr/local/bin/evim
	rm /usr/local/bin/ex
	rm /usr/local/bin/gview
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvimdiff
	rm /usr/local/bin/rgview
	rm /usr/local/bin/rgvim
	rm /usr/local/bin/rview
	rm /usr/local/bin/rvim
	rm /usr/local/bin/rvim
	rm /usr/local/bin/view
	rm /usr/local/bin/vim
	rm /usr/local/bin/vimdiff
	rm /usr/local/bin/vimtutor
	rm /usr/local/bin/xxd
	rm /usr/local/man/man1/eview.1
	rm /usr/local/man/man1/evim.1
	rm /usr/local/man/man1/ex.1
	rm /usr/local/man/man1/gview.1
	rm /usr/local/man/man1/gvim.1
	rm /usr/local/man/man1/gvimdiff.1
	rm /usr/local/man/man1/rgview.1
	rm /usr/local/man/man1/rgvim.1
	rm /usr/local/man/man1/rview.1
	rm /usr/local/man/man1/rvim.1
	rm /usr/local/man/man1/view.1
	rm /usr/local/man/man1/vim.1
	rm /usr/local/man/man1/vimdiff.1
	rm /usr/local/man/man1/vimtutor.1
	rm /usr/local/man/man1/xxd.1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>rm -rf /usr/local/share/vim/vim61
	rm /usr/local/bin/eview
	rm /usr/local/bin/evim
	rm /usr/local/bin/ex
	rm /usr/local/bin/gview
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvim
	rm /usr/local/bin/gvimdiff
	rm /usr/local/bin/rgview
	rm /usr/local/bin/rgvim
	rm /usr/local/bin/rview
	rm /usr/local/bin/rvim
	rm /usr/local/bin/rvim
	rm /usr/local/bin/view
	rm /usr/local/bin/vim
	rm /usr/local/bin/vimdiff
	rm /usr/local/bin/vimtutor
	rm /usr/local/bin/xxd
	rm /usr/local/man/man1/eview.1
	rm /usr/local/man/man1/evim.1
	rm /usr/local/man/man1/ex.1
	rm /usr/local/man/man1/gview.1
	rm /usr/local/man/man1/gvim.1
	rm /usr/local/man/man1/gvimdiff.1
	rm /usr/local/man/man1/rgview.1
	rm /usr/local/man/man1/rgvim.1
	rm /usr/local/man/man1/rview.1
	rm /usr/local/man/man1/rvim.1
	rm /usr/local/man/man1/view.1
	rm /usr/local/man/man1/vim.1
	rm /usr/local/man/man1/vimdiff.1
	rm /usr/local/man/man1/vimtutor.1
	rm /usr/local/man/man1/xxd.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you installed Vim with the self-installing archive you can run
the "uninstall-gui" program located in the same directory as the other Vim
programs, e.g.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha instalado Vim el archivo de instalación automática, puede
ejecutar el programa «uninstall-gui», ubicado en el mismo directorio
de otros programas de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"c:\vim\vim61".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es, «c:\vim\vim61».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also launch it from the Start menu if
installed the Vim entries there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede
iniciarlo desde el menú de aplicaciones si ha instalado las entradas
de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will remove most of the files, menu
entries and desktop shortcuts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina la mayoría de los archivos, entradas de menú
y enlaces directos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some files may remain however, as they need a
Windows restart before being deleted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, algunos archivos permanecerán en
el sistema, ya que necesitan un reinicio de Windows antes de su
eliminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will be given the option to remove the whole "vim" directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se le dará la opción de eliminar todo el directorio «vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It
probably contains your vimrc file and other runtime files that you created, so
be careful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Probablemente, contiene su archivo «vimrc» y otros archivos de
tiempo de ejecución que ha creado, tenga cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui_x11.txt*   For Vim version 7.2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui_x11.txt*  Para Vim versión 7.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2007 Dec 09</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 2007 Dec 09</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim's Graphical User Interface				*gui-x11* *GUI-X11*
							*Athena* *Motif*
1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaz gráfica de usuario de Vim				*gui-x11* *GUI-X11*
							*Athena* *Motif*
1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the X11 GUI		|gui-x11-start|
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciar GUI para X11		|gui-x11-start|
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI Resources		|gui-resources|
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recursos de la GUI		|gui-resources|
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shell Commands		|gui-pty|
4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Órdenes del intérprete de órdenes		|gui-pty|
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various			|gui-x11-various|
5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Varios			|gui-x11-various|
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GTK version			|gui-gtk|
6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Versión GTK			|gui-gtk|
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GNOME version		|gui-gnome|
7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Versión GNOME 		|gui-gnome|
7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>KDE version			|gui-kde|
8.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Versión KDE 			|gui-kde|
8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling			|gui-x11-compiling|
9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compilar			|gui-x11-compiling|
9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>X11 selection mechanism	|x11-selection|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mecanismo de selección de X11	|x11-selection|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the X11 GUI					*gui-x11-start* *E665*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciando la IGU de X11					*gui-x11-start* *E665*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you call the executable "gvim", or make "gvim" a link to the executable,
then the GUI version will automatically be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si invoca el ejecutable «gvim», o enlaza «gvim» al ejecutable,
la interfaz gráfica se usará automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional characters may be
added after "gvim", for example "gvim-5".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se pueden añadir caracteres
adicionales tras «gvim», «gvim-5» por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui-fork*
When the GUI is started, it does a fork() and exits the current process.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui-fork*
Cuando inicia la GUI, crea un «fork()» y termina el proceso actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When gvim was started from a shell this makes the shell accept further
commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se ha iniciado gvim desde un interprete de órdenes, esto
hace que la consola pueda recibir futuras órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want this (e.g. when using gvim for a mail program
that waits for gvim to exit), start gvim with "gvim -f", "vim -gf" or use
":gui -f".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no desea
esto, (p. ej., cuando usa gvim para un programa de correo que 
espera a que gvim se cierre), inicie gvim con «gvim -f», «vim -gf»
o use «:gui -f».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't use "vim -fg", because "-fg" specifies the foreground
color.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No use «vim -fg» porque «-fg» especifica el color
en primer plano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using "gvim -f" and then ":gui", Vim will run in the foreground.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «gvim -f», y después «:gui», Vim se ejectuará en primer plano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
"-f" argument will be remembered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-f» se recordará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To force running Vim in the background use
":gui -b".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para forzar que Vim se inicie de fondo,
use «gui -b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want the GUI to run in the foreground always, include the 'f'
flag in 'guioptions'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que la IGU siempre se ejecute en primer plano, incluya
la marca «f» en 'guioptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|-f|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|-f|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==============================================================================
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==============================================================================
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI Resources			*gui-resources* *.Xdefaults*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recursos de la IGU			*gui-resources* *.Xdefaults*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using the Motif or Athena version of the GUI (not for the KDE, GTK+ or Win32
version), a number of X resources are available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de que este usando la versión Motif o Athena de la IGU (no la versión 
de KDE, GTK+ o Win32), no dispondrá de una serie de recursos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should use Vim's class
"Vim" when setting these.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debería usar
la clase de Vim «Vim» cuando define esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They are as follows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Son como sigue:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource name	Meaning		~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nombre del recurso	Significado		~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>reverseVideo	Boolean: should reverse video be used?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>reverseVideo	Boolean: ¿Se debe usar el vídeo inverso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>background		Color of background.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>background		Color del fondo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>foreground		Color of normal text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>foreground		Color del texto normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>scrollBackground	Color of trough portion of scrollbars.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>scrollBackground	Color de la porción pilón de las barras de desplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>scrollForeground	Color of slider and arrow portions of scrollbars.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>scrollForeground	Color de la barra y las porciones de flecha de las barras
		                desplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>menuBackground	Color of menu backgrounds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>menuBackground	Color de fondo del menú.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>menuForeground	Color of menu foregrounds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>menuForeground	Color de primer plano del menú.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooltipForeground	Color of tooltip and balloon foreground.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>tooltipForeground	Color de primer plano de las sugerencias y de los globos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooltipBackground	Color of tooltip and balloon background.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>tooltipBackground	Color de fondo de las sugerencias y de los globos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui.txt*       For Vim version 7.2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui.txt*	Para Vim version 7.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the GUI		|gui-start|
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciar la GUI		|gui-start|
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scrollbars			|gui-scrollbars|
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Barras de desplazamiento	|gui-scrollbars|
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mouse Control		|gui-mouse|
4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Control del ratón		|gui-mouse|
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Making GUI Selections	|gui-selections|
5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Seleccionar en la GUI	|gui-selections|
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Menus			|menus|
6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Menús		 	|menus|
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extras			|gui-extras|
7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Extras			|gui-extras|
7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shell Commands		|gui-shell|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Órdenes de consola		|gui-shell|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other GUI documentation:
|gui_x11.txt|	For specific items of the X11 GUI.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más documentación de la GUI:
|gui_x11.txt|	Para elementos específicos de la GUI bajo X11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|gui_w32.txt|	For specific items of the Win32 GUI.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|gui_w32.txt|	Para elementos específicos de la GUI bajo Win32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting the GUI				*gui-start* *E229* *E233*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Iniciar la GUI				*gui-start* *E229* *E233*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you must make sure you actually have a version of Vim with the GUI code
included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asegúrese primero de que realmente tiene una versión de Vim con el código de
la GUI integrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can check this with the ":version" command, it says "with xxx
GUI", where "xxx" is X11-Motif, X11-Athena, Photon, GTK, GTK2, etc., or
"MS-Windows 32 bit GUI version".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede revisar esto con la orden :version, el cual
devuelve
«con GUI xxx», donde «xxx» puede ser X11-Motif, X11-Athena, Photon, GTK, GTK2,
etc... o «versión GUI MS-Windows 32 bit».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to start the GUI depends on the system used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como iniciar la interfaz gráfica depende del sistema que se usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mostly you can run the
GUI version of Vim with:
    gvim [options] [files...]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, puede iniciar la versión GUI de Vim con:
    gvim [opciones] [archivos...]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The X11 version of Vim can run both in GUI and in non-GUI mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión X11 de Vim puede ejecutarse en modo gráfico o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See
|gui-x11-start|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase
|gui-x11-start|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
The gvimrc file is where GUI-specific startup commands should be placed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*gui-init* *gvimrc* *.gvimrc* *_gvimrc*
El archivo gvimrc es donde debe escribir las órdenes de inicio específicos de
la GUI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It
is always sourced after the |vimrc| file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siempre se lee después del archivo |vimrc|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have one then the $MYGVIMRC
environment variable has its name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene uno, la variable
de entorno $MYGVIMRC llevará su tal nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this happens AFTER the normal Vim initializations, like reading your
.vimrc file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo esto ocurre despues de las órdenes de inicio de Vim, como si
leyese el archivo «.vimrc».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |initialization|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |initialization|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the GUI window is only opened after all the initializations have been
carried out.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ventana de la interfaz gráfica solo se abre después de llevar a cabo
todas las órdenes de inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want some commands to be executed just after opening the
GUI window, use the |GUIEnter| autocommand event.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que alguna orden se ejecute justo
después de abrir la ventana de la interfaz gráfica, use el evento de
autorden |GUIEvent|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example: &gt;
	:autocmd GUIEnter * winpos 100 50</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplo: &gt;
	:autocmd GUIEnter * winpos 100 50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a number of options which only have meaning in the GUI version of
Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un número de opciones que solo tienen efecto en la versión GUI
de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are 'guicursor', 'guifont', 'guipty' and 'guioptions'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos son 'guicursor', 'guifont', 'guipty' y 'guioptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They are
documented in |options.txt| with all the other options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Están documentadas en |options.txt|, junto con el resto de opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:highlight Normal guibg=grey90</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:highlight Normal guibg=grey90</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"*p</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"*p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_26.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_26.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeating</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repetición</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An editing task is hardly ever unstructured.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Rara vez, una tarea de edición carece de estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A change often needs to be made several times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A menudo tiene que realizar un cambio varias veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this chapter a number of useful ways to repeat a change will be explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este capítulo se muestran varias maneras útiles de repetir un cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|26.1|	Repeating with Visual mode
|26.2|	Add and subtract
|26.3|	Making a change in many files
|26.4|	Using Vim from a shell script</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|26.1|	Repetir en modo Visual
|26.2|	Sumar y restar
|26.3|	Realizar un cambio en varios archivos
|26.4|	Usar Vim desde un script de intérprete de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_27.txt|  Search commands and patterns
 Previous chapter: |usr_25.txt|  Editing formatted text
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_27.esx|  Órdenes y patrones de búsqueda
  Capitulo anterior: |usr_24.esx|  Editar otros archivos
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.1*	Repeating with Visual mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.1*	Repetición en modo Visual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual mode is very handy for making a change in any sequence of lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Visual es útil cuando desea modificar una secuencia de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
can see the highlighted text, thus you can check if the correct lines are
changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al poder ver el texto resaltado, puede revisar si las líneas a modificar
lo han sido correctamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But making the selection takes some typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero hacer la selección conlleva teclear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "gv" command
selects the same area again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
orden «gv» selecciona la misma área otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to do another operation on the
same text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite realizar otra
acción sobre el texto seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have some lines where you want to change "2001" to "2002" and
"2000" to "2001":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene algunas líneas en las que desea cambiar «2001» a «2002»
y «2000» a «2001»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The financial results for 2001 are better ~
	than for 2000.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los resultados financieros de 2001 son mejores ~
	que para el año 2000.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First change "2001" to "2002".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero cambie «2001» a ««2002».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select the lines in Visual mode, and use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Seleccione las líneas en modo Visual y use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:s/2001/2002/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:s/2001/2002/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use "gv" to reselect the same text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora «gv» para seleccionar otra vez el mismo texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It doesn't matter where the cursor
is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa donde está
el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use ":s/2000/2001/g" to make the second change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use entonces «:s/2000/2001/g» para hacer el segundo cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, you can repeat these changes several times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, puede repetir estos cambios varias veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.2*	Add and subtract</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.2*	Sumar y restar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/19[0-9][0-9]\|20[0-9][0-9]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/19[0-9][0-9]\|20[0-9][0-9]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press CTRL-A.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora pulse Ctrl-A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The year will be increased by one:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El año se incrementará en uno:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The financial results for 2002 are better ~
	than for 2000.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los resultados financieros de 2002 son mejores ~
	que para el año 2000.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding more than one can be done by prepending the number to CTRL-A.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible añadir más de uno si prefija un número a CTRL-A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have this list:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene esta lista:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item four ~
	2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cuarto elemento ~
	2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item five ~
	3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>quinto elemento ~
	3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item six ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>sexto elemento ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>3 CTRL-A</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>3 CTRL-A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "1." will change to "4.".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «1.» pasará a ser «4.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, you can use "." to repeat this on the other numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra vez, puede usar «.» para repetir la misma acción sobre otros números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>006	foo bar ~
	007	foo bar ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>006	foo bar ~
	007	foo bar ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>007	foo bar ~
	010	foo bar ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>007	foo bar ~
	010	foo bar ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7 plus one is 10?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿7 más 1 igual a 10?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happened here is that Vim recognized "007" as an octal number, because there is a leading zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que ha ocurrido es que Vim reconoció 007 como un número octal, ya que hay un cero precediendo el número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This notation is often used in C programs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta notación se usa a menudo en programas C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want a number with leading zeros to be handled as octal, use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no desea que un número con ceros a la izquierda se considere un número octal, use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nrformats-=octal</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nrformats-=octal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.3*	Making a change in many files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.3*	Realizar un cambio en varios archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:args *.c
&lt;
This finds all C files and edits the first one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:args *.c
&lt;
Esto encuentra todos los archivos C y edita el primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can perform a
substitution command on all these files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede realizar
una orden de sustitución sobre todos estos archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":argdo" command takes an argument that is another command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:argdo» toma otra orden como argumento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That command
will be executed on all files in the argument list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden se ejecutará
sobre todos los archivos en la lista de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "%s" substitute command that follows works on all lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden de sustitución «%s» a continuación afecta a todas las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It finds the
word "x_cnt" with "\&lt;x_cnt\&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Busca la palabra «x_cnt» con «\&lt;x_cnt\&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "\&lt;" and "\&gt;" are used to match the whole
word only, and not "px_cnt" or "x_cnt2".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los «\&lt;» y «\&gt;» se usan para
encontrar sólo la palabra completa, y no «px_cnt» o «x_cnt2».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The flags for the substitute command include "g" to replace all occurrences
of "x_cnt" in the same line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las opciones para la orden de sustitución incluyen «g» para reemplazar
todas las apariciones de «x_cnt» en la misma línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "e" flag is used to avoid an error message
when "x_cnt" does not appear in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «e» se emplea
para evitar un mensaje de error cuando «x_cnt» no está presente en el
archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise ":argdo" would abort on
the first file where "x_cnt" was not found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrar, «:argdo» se interrumpiría en el primer archivo en
el que no se encontrase «x_cnt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "|" separates two commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «|» separa dos órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following "update" command writes the
file only if it was changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden a continuación «update» escribe en el
archivo sólo si éste cambió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no "x_cnt" was changed to "x_counter" nothing
happens.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no se cambió ningún «x_cnt» a «x_counter»
no ocurrirá nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also the ":windo" command, which executes its argument in all windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También dispone de la orden «:windo», que ejecuta su argumento en todas las ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And ":bufdo" executes its argument on all buffers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:bufdo» ejecuta su argumento en todos los búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful with this, because you might have more files in the buffer list than you think.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sea cuidadoso
con esto, porque puede que tenga más archivos de los que crea en su lista
de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check this with the ":buffers" command (or ":ls").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise esto con la orden «:buffers» (o «:ls»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*26.4*	Using Vim from a shell script</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*26.4*	Usar Vim desde un script de intérprete de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have a lot of files in which you need to change the string
"-person-" to "Jones" and then print it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene que cambiar la cadena «-persona-»  a «Juan» en varios
archivos, e imprimirlo después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do you do that?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Como se hace?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way is to
do a lot of typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una manera es teclear mucho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other is to write a shell script to do the work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La otra es escribir un script de consola para hacer la tarea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor does a superb job as a screen-oriented editor when using
Normal mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim realiza un trabajo superlativo como un editor orientado a
pantalla cuando usa las órdenes de modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For batch processing, however, Normal mode commands do
not result in clear, commented command files; so here you will use Ex mode
instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para un procesamiento en
lotes, por otra parte, las órdenes de modo Normal no finalizan correctamente
como archivos claros y comentados; para ello tiene que usar el modo Ex.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mode gives you a nice command-line interface that makes it easy
to put into a batch file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este modo ofrece una bonita interfaz de línea de órdenes que facilita su
inserción en un archivo de lotes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>("Ex command" is just another name for a
command-line (:) command.)
   The Ex mode commands you need are as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(«Orden Ex» es sólo otro nombre para una
orden en la línea de órdenes («:»).)
   Las órdenes del modo Ex que necesita son las siguientes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%s/-person-/Jones/g
	write tempfile
	quit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>%s/-persona-/Juan/g
	write archivo_temporal
	quit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You put these commands in the file "change.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga estas órdenes en el archivo «change.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now to run the editor in batch mode, use this shell script: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ejecutar el editor en modo de lotes, ese este script de consola: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>for file in *.txt; do
	  vim -e -s $file &lt; change.vim
	  lpr -r tempfile
	done</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>for file in *.txt; do
	  vim -e -s $file &lt; change.vim
	  lpr -r archivo_temporal
	done</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The for-done loop is a shell construct to repeat the two lines in between,
while the $file variable is set to a different file name each time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El bucle for-done es una construcción de consola para repetir las dos
líneas entre ellas, mientras que la variable $file es definida con un nombre
diferente cada vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second line runs the Vim editor in Ex mode (-e argument) on the file
$file and reads commands from the file "change.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda línea inicia Vim en modo Ex (argumento «-e») en el archivo
$file y lee las órdenes del archivo «change.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The -s argument tells
Vim to operate in silent mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-s» le dice
a Vim que opere en modo silencioso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, do not keep outputting the
:prompt, or any other prompt for that matter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, no mostrar «:prompt»
(cuadro de diálogo interactivo), o cualquier otro diálogo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "lpr -r tempfile" command prints the resulting "tempfile" and deletes
it (that's what the -r argument does).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «lpr -r archivo_temporal» muestra el «archivo_temporal»
resultante y lo elimina (esto es lo que hace el argumento «-r»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can read text on standard input.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede leer texto desde la entrada estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the normal way is to read commands there, you must tell Vim to read text instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a que esta es la manera normal de leer órdenes, tendrá que decirle a Vim que lea texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done by passing the "-" argument in place of a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se hace introduciendo el argumento «-» en lugar de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ls | vim -</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ls | vim -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to edit the output of the "ls" command, without first saving
the text in a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite editar la salida de la orden «ls», sin guardar primero el texto
en un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the standard input to read text from, you can use the "-S"
argument to read a script: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa la entrada estándar para leer texto, puede usar el argumento «-S»
para leer un script: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>producer | vim -S change.vim -</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>producer | vim -S change.vim -</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -s script file.txt ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -s script file.txt ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;
	Note:
	"-s" has a different meaning when it is used without "-e".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;
	Nota:
	«-s» tiene un significado diferente cuando se usa sin «-e».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here it
	means to source the "script" as Normal mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí
	significa que tiene que cargar el script como si fueran órdenes de
	modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used with
	"-e" it means to be silent, and doesn't use the next argument as a
	file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«-e» significa modo silencioso, y no usa el siguiente
	argumento como un nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands in "script" are executed like you typed them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes en «script» se ejecutan como los introdujo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget that
a line break is interpreted as pressing &lt;Enter&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No olvide que un 
salto de línea se interpreta como &lt;Intro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Normal mode that moves
the cursor to the next line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En modo Normal, desplaza el cursor
a la siguiente línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create the script you can edit the script file and type the commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para crear el script, puede editar el archivo de script y teclear las
órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to imagine what the result would be, which can be a bit difficult.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita imaginar el resultado final, lo cual es un poco difícil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way is to record the commands while you perform them manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera es grabar las órdenes al ejecutarlas manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
is how you do that: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así es como se hace: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -w script file.txt ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -w script file.txt ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_01.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_01.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2008 May 07</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 7/6/2008</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About the manuals</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Acerca de los manuales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter introduces the manuals available with Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo le introduce a los manuales disponibles con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read this to know the conditions under which the commands are explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lea esto para conocer las condiciones bajo las cuales se explican las órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|01.1|	Two manuals
|01.2|	Vim installed
|01.3|	Using the Vim tutor
|01.4|	Copyright</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|01.1|	Dos manuales
|01.2|	Vim instalado
|01.3|	Usar el tutor de Vim
|01.4|	Copyright</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_02.esx|  Primeros pasos en Vim
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.1*	Two manuals</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.1*	Dos manuales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The User manual
   Task oriented explanations, from simple to complex.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de usuario
   Explicaciones orientadas a tareas, de las simples a las más complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reads from start to
   end like a book.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede leer de principio a fin, como un libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reference manual
   Precise description of how everything in Vim works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de referencia
   Una precisa descripción del funcionamiento de cada elemento dentro
   de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text contains hyperlinks between the two parts, allowing you to quickly jump between the description of an editing task and a precise explanation of the commands and options used for it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto contiene hiperenlaces entre las dos partes, lo cual le permite saltar rápidamente de la descripción de una tarea de edición a una precisa explicación de las órdenes y opciones que se emplean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use these two commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use estas dos órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Press  CTRL-]  to jump to a subject under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse «CTRL-]» para saltar al tema bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Press  CTRL-O  to jump back (repeat to go further back).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse «CTRL-O» para saltar atrás (repita para volver más allá de ese
	punto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many links are in vertical bars, like this: |bars|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay varios enlaces entre barras verticales, como este: |bars|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An option name, like 'number', a command in double quotes like ":write" and any other word can also be used as a link.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar como enlace un nombre de opción, como 'number', una orden entrecomillada, como «:write», o cualquier otra palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try it out: Move the cursor to CTRL-] and press CTRL-] on it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebelo: mueva el cursor a «CTRL-]» y pulse «CTRL-]» sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.2*	Vim installed</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.2*	Vim instalado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unix: &gt;
	:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc
MS-DOS, MS-Windows, OS/2: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc
Amiga: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Unix: &gt;
	:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc
MS-DOS, MS-Windows, OS/2: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc
Amiga: &gt;
	:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you start Vim now, the 'compatible' option should be off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si inicia ahora Vim, la opción 'compatible' debería estar desactivada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can check it with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede asegurarse con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set compatible?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set compatible?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it responds with "nocompatible" you are doing well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si devuelve "nocompatible", es que todo va bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the response is "compatible" you are in trouble.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la respuesta es «compatible», tiene un problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will have to find out why the option is still set.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que encontrar porqué esta opción está aún definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Perhaps the file you wrote above is not found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que no se encontrase el archivo que copió antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this command to find out: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esta orden para ver el problema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:scriptnames</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:scriptnames</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your file is not in the list, check its location and name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su archivo no se encuentra en la lista, revise su nombre y ubicación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is in the list, there must be some other place where the 'compatible' option is switched back on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está en la lista, debe haber algún otro sitio en el que se reactiva la opción 'compatible'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	This manual is about using Vim in the normal way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Este manual trata acerca del uso de Vim de la manera normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an
	alternative called "evim" (easy Vim).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una
	alternativa llamada «evim» (easy Vim).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is still Vim, but used in
	a way that resembles a click-and-type editor like Notepad.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sigue siendo Vim, pero se usa de
	una manera parecida a un editor como Notepad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It always
	stays in Insert mode, thus it feels very different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Permanece siempre
	en el modo Insertar, y por ello parece muy distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not
	explained in the user manual, since it should be mostly self
	explanatory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se explica
	en el manual de usuario, ya que es bastante sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |evim-keys| for details.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |evim-keys| para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.3*	Using the Vim tutor				*tutor* *vimtutor*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.3*	Usar el tutor de Vim				*tutor* *vimtutor*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of reading the text (boring!) you can use the vimtutor to learn your first Vim commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de leer el texto (¡aburre!), puede usar vimtutor para aprender sus primeras órdenes con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a 30 minute tutorial that teaches the most basic Vim functionality hands-on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éste es un tutorial de treinta minutos que enseña las funcionalidades básicas de Vim a través de la práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix, if Vim has been properly installed, you can start it from the shell:
&gt;
	vimtutor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, si Vim se instaló adecuadamente, puede iniciar Vim desde la
consola:
&gt;
	vimtutor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-Windows you can find it in the Program/Vim menu.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-Windows, lo encontrará en el menú Programas/Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or execute vimtutor.bat in the $VIMRUNTIME directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O puede ejecutar «vimtutor.bat» en el directorio $VIMRUNTIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make a copy of the tutor file, so that you can edit it without
the risk of damaging the original.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto crea una copia del archivo del tutor, para que así pueda editarlo sin
peligro de dañar el original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few translated versions of the tutor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen unas cuantas versiones traducidas del tutor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find out if yours is
available, use the two-letter language code.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver si el suyo
está disponible, use el código de idioma de dos letras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For French: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para el francés: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vimtutor fr</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vimtutor fr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@VIM:vimtutor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>@VIM:vimtutor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the tutor file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie el archivo del tutor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this with Vim (it knows where to find it):
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer esto con Vim (sabe donde
encontrarlo):
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TUTORCOPY' -c 'q'
&lt;
   This will write the file "TUTORCOPY" in the current directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>TUTORCOPY' -c 'q'
&lt;
   Esto copia el archivo «TUTORCOPY» al directorio actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a
translated version of the tutor, append the two-letter language code to the
filename.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para usar una
versión traducida del tutor, afije el código de idioma al nombre del
archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For French:
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para francés:
&gt;
	vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TUTORCOPY' -c 'q'
&lt;
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>TUTORCOPY' -c 'q'
&lt;
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the copied file with Vim:
&gt;
	vim -u NONE -c "set nocp" TUTORCOPY
&lt;
   The extra arguments make sure Vim is started in a good mood.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite la copia del archivo con Vim:
&gt;
	vim -u NONE -c "set nocp" TUTORCOPY
&lt;
   Los argumentos extra se aseguran de que Vim se inicie adecuadamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the copied file when you are finished with it:
&gt;
	del TUTORCOPY
&lt;
==============================================================================</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Borrar el archivo copiado cuando haya acabado con él:
&gt;
	del TUTORCOPY
==============================================================================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*01.4*	Copyright					*manual-copyright*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*01.4*	Copyright					*manual-copyright*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim user manual and reference manual are Copyright (c) 1988-2003 by Bram
Moolenaar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de usuario y el manual de referencia están bajo el Copyright (c)
1988-2003 por Bram Moolenaar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This material may be distributed only subject to the terms and
conditions set forth in the Open Publication License, v1.0 or later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este material se distribuirá sólo bajo estos
términos de licencia y condiciones expuestas en la Open Publication License,
versión 1.0 o posterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
latest version is presently available at:
	     http://www.opencontent.org/openpub/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión más actual está ahora disponible en:
	     http://www.opencontent.org/openpub/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>People who contribute to the manuals must agree with the above copyright
notice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las personas que contribuyan al manual también tienen que aceptar el
copyright expuesto anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*frombook*
Parts of the user manual come from the book "Vi IMproved - Vim" by Steve
Oualline (published by New Riders Publishing, ISBN: 0735710015).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*frombook*
Hay partes del manual de usuario que proceden del libro «Vi IMproved - Vim»,
por Steve Oualline (publicado por New Riders Publishing, ISBN: 0735710015).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Open
Publication License applies to this book.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La Open Publication License también cubre a este libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only selected parts are included
and these have been modified (e.g., by removing the pictures, updating the
text for Vim 6.0 and later, fixing mistakes).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se incluyen partes seleccionadas, y estas se han modificado (p. ej. se
eliminaron las fotos, se actualizó el texto para Vim 6.0 y posteriores,
corrección de errata).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The omission of the |frombook|
tag does not mean that the text does not come from the book.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La omisión de la etiqueta |frombook| no significa
que el texto no proceda del libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many thanks to Steve Oualline and New Riders for creating this book and publishing it under the OPL!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Muchas gracias a Steve Oualline y a New Riders por crear este libro, y publicarlo bajo la licencia OPL!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It has been a great help while writing the user manual.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ha servido de gran ayuda a la hora de escribir este manual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not only by providing literal text, but also by setting the tone and style.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No sólo por el texto literal, sino también al definir el tono y estilo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you make money through selling the manuals, you are strongly encouraged to donate part of the profit to help AIDS victims in Uganda.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si obtiene beneficios mediante la venta de los manuales, le animamos a que done parte de los beneficios para ayudar a las victimas del SIDA en Uganda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |iccf|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |iccf|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_07.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_07.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Editing more than one file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Editar más de un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No matter how many files you have, you can edit them without leaving Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa cuántos archivos tenga, puede editarlos todos sin salir de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a list of files to work on and jump from one to the other.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina una lista de archivos de trabajo y pase de uno a otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy text from one file and put it in another one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie texto de un archivo a otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|07.1|	Edit another file
|07.2|	A list of files
|07.3|	Jumping from file to file
|07.4|	Backup files
|07.5|	Copy text between files
|07.6|	Viewing a file
|07.7|	Changing the file name</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|07.1|	Editar otro archivo
|07.2|	Una lista de archivos
|07.3|	Pasar de archivo a archivo
|07.4|	Copias de seguridad
|07.5|	Copiar texto entre archivos
|07.6|	Ver un archivo
|07.7|	Cambiar el nombre de archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_08.txt|  Splitting windows
 Previous chapter: |usr_06.txt|  Using syntax highlighting
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_08.esx|  Dividir en ventanas
  Capítulo anterior: |usr_06.esx|  Uso del coloreado de sintaxis
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.1*	Edit another file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.1*	Editar otro archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit foo.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit foo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any file name instead of "foo.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar cualquier nombre de archivo en lugar de «foo.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will close the current file and open the new one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim cerrará el archivo actual y abrirá uno nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the current file has unsaved changes, however, Vim displays an error message and does not open the new file:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, si el archivo actual tiene cambios no guardados, Vim mostrará un error y no abrirá el archivo nuevo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Vim puts an error ID at the start of each error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Vim coloca una ID de error al comienzo de cada mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do
	not understand the message or what caused it, look in the help system
	for this ID.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si
	no entiende el mensaje o su causa, puedes buscar ayuda para esta ID.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you have a number of alternatives.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este punto, dispone de una serie de alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write the file using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede escribir el archivo usando esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit! foo.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit! foo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:hide edit foo.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:hide edit foo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text with changes is still there, but you can't see it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto con los cambios está todavía aquí, pero no lo puede ver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is further explained in section |22.4|: The buffer list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se explica con más detalle en la sección |22.4|: La lista de búfers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.2*	A list of files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.2*	Una lista de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start Vim to edit a sequence of files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar Vim para editar una secuencia de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim one.c two.c three.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim uno.c dos.c tres.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command starts Vim and tells it that you will be editing three files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inicia Vim y le dice que va a editar tres archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim displays just the first file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim muestra solamente el primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you have done your thing in this file, to edit the next file you use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras haber terminado con el primero, puede editar el siguiente con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:next</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:next</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have unsaved changes in the current file, you will get an error message and the ":next" will not work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene cambios sin guardar en el archivo actual, obtendrá un mensaje de error y «:next» no funcionará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the same problem as with ":edit" mentioned in the previous section.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el mismo problema mencionado con «:edit» en la sección anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To abandon the changes: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para abandonar los cambios: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:next!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:next!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But mostly you want to save the changes and move on to the next file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero habitualmente querrá guardar los cambios e ir al siguiente archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a special command for this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una orden especial para esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wnext</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wnext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write
	:next</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write
	:next</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see which file in the argument list you are editing, look in the window
title.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver qué archivo de la lista de argumentos está editando, mire en el
título de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should show something like "(2 of 3)".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debería mostrar algo como «(2 de 3)».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means you are editing
the second file out of three files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa
que está editando un segundo archivo de una lista de tres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to see the list of files, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quieres ver la lista de archivos, use esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:args</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:args</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is short for "arguments".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la abreviatura de «argumentos».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output might look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida será algo así:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one.c [two.c] three.c ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>uno.c [dos.c] tres.c ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the files you started Vim with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos son los archivos con los que ha iniciado Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one you are currently editing, "two.c", is in square brackets.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El que está editando actualmente, «dos.c», se encuentra entre corchetes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:previous</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:previous</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is just like the ":next" command, except that it moves in the other direction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es justo como la orden «:next», excepto que va en la otra dirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, there is a shortcut command for when you want to write the file first: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, existe una orden para cuando quiera escribir el archivo primero: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:wprevious</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:wprevious</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:last</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:last</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:first</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:first</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a count for ":next" and ":previous".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar un multiplicador para «:next» y «:previous».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To skip two files forward: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar dos archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:2next</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:2next</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When moving around the files and making changes, you have to remember to use ":write".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se mueva por los archivos y haga cambios, tiene que recordar usar «:write».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise you will get an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, obtendrá mensajes de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are sure you always want to write modified files, you can tell Vim to automatically write them: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está seguro de que siempre va a escribir los archivos modificados, puede decirle a Vim que los escriba automáticamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set autowrite</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set autowrite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set noautowrite</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set noautowrite</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can redefine the list of files without the need to exit Vim and start it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede redefinir la lista de archivos sin la necesidad de salir de Vim y arrancarlo de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this command to edit three other files: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Emplee esta orden para editar otros tres archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:args five.c six.c seven.h</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:args cinco.c seis.c siete.h</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:args *.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:args *.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will take you to the first file in the list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le llevará al primer archivo en la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, if the current file has changes, you can either write the file first, or use ":args!" (with ! added) to abandon the changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De nuevo, si el archivo actual cambia, puede tanto guardar el archivo antes como usar «:args!» (con el ! añadido) para abandonar los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DID YOU EDIT THE LAST FILE?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿HA EDITADO EL HASTA EL ÚLTIMO ARCHIVO?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*arglist-quit*
When you use a list of files, Vim assumes you want to edit them all.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*arglist-quit*
Cuando usa una lista de archivos, Vim asume que quiere editarlos todos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To
protect you from exiting too early, you will get this error when you didn't
edit the last file in the list yet:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar cerrar antes de tiempo, obtendrá un error cuando no haya
editado el último archivo en la lista e intentes salir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E173: 46 more files to edit ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E173: 46 more files to edit ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really want to exit, just do it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente desea salir, simplemente inténtelo de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then it will work (but not when you did other commands in between).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces funcionará (pero no si ejecuta otras órdenes durante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.3*	Jumping from file to file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.3*	Pasar de un archivo a otro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To quickly jump between two files, press CTRL-^ (on English-US keyboards the ^ is above the 6 key).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar rápidamente entre dos archivos, pulse CTRL-^ (en teclados Inglés-EEUU el ^ se encuentra encima de la tecla 6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:args one.c two.c three.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:args uno.c dos.c tres.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you are in two.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora está en two.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use CTRL-^ to go back to one.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-^ para volver a uno.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another CTRL-^ and you are back in two.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-^ otra vez y estará de vuelta en dos.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another CTRL-^ and you are in one.c again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro CTRL-^ y estará en uno.c de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora hace: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are in three.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Está en tres.c.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the CTRL-^ command does not change the idea of where you are in the list of files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la orden CTRL-^ no cambia la idea de dónde está en la lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only commands like ":next" and ":previous" do that.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo órdenes como «:next» y «:previous» lo hacen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file you were previously editing is called the "alternate" file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo que haya estado editando anteriormente se llama el archivo «alterno».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you just started Vim CTRL-^ will not work, since there isn't a previous file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta que no haya un archivo anterior, CTRL-^ no funcionará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>`"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This takes you to the position where the cursor was when you left the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le lleva a la posición en la que estaba el cursor cuando salió del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another mark that is remembered is the position where you made the last change: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra marca que se recuerda es la posición donde hizo el último cambio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you are editing the file "one.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que está editando el archivo «uno».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Somewhere halfway the file you use "x" to delete a character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En algún lugar a mitad de camino en el archivo, use «x» para eliminar un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you go to the last line with "G" and write the file with ":w".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya ahora a la última línea con «G» y escriba el archivo con «:w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You edit several other files, and then use ":edit one.txt" to come back to "one.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite otros archivos y use «:edit uno.txt» para volver a «uno.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now use `" Vim jumps to the last line of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora usa `", Vim saltará a la última línea del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `. takes you to the position where you deleted the character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar `. le llevará a la posición donde eliminó el carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Even when you move around in the file `" and `. will take you to the remembered position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Incluso cuando se mueva por el archivo, `" y `. le llevará a la posición recordada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At least until you make another change or leave the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al menos hasta que realice otro cambio o salga del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>50%mF</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>50%mF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now edit the file "bar.txt" and place the B mark (B for bar) at its last line:
&gt;
	GmB</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ahora el archivo «bar.txt» y coloque el marcador B en su última línea:
&gt;
	GmB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the "'F" command to jump back to halfway foo.txt.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar la orden «'F» para saltar al punto marcado de foo.txt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or edit yet another file, type "'B" and you are at the end of bar.txt again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O edite otro archivo, escriba «'B» y estará en el final de bar.txt de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file marks are remembered until they are placed somewhere else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas marcas de archivo se recordarán hasta que se coloquen en algún
otro lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you
can place the mark, do hours of editing and still be able to jump back to that
mark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así podrás colocar los marcadores, trabajar durante horas y aún
tendrá la posibilidad de volver al punto marcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's often useful to think of a simple connection between the mark letter
and where it is placed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil pensar en una conexión sencilla entre la letra del marcador y el
lugar donde se coloca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, use the H mark in a header file, M in
a Makefile and C in a C code file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, use la letra H para un archivo de
cabecera (*.h), M para un Makefile y C para código C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:marks M</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:marks M</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:marks MCP</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:marks MCP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.4*	Backup files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.4*	Copias de seguridad</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually Vim does not produce a backup file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, Vim no produce copias de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to have one, all you need to do is execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que lo haga,lo único que tiene que hacer es ejecutar la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set backup</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set backup</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the backup file is the original file with a  ~  added to the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del archivo de seguridad es el original con un ~ añadido al
final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your file is named data.txt, for example, the backup file name is
data.txt~.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su archivo se llama datos.txt, por ejemplo, el archivo de seguridad será
datos.txt~.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not like the fact that the backup files end with ~, you can
change the extension: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gusta el hecho de que las copias de seguridad terminen con ~,
puedes cambiar la extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set backupext=.bak</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set backupext=.bak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will use data.txt.bak instead of data.txt~.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que Vim use datos.txt.bak en lugar de datos.txt~.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another option that matters here is 'backupdir'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra opción que resulta importante aquí es 'backupdir'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It specifies where the
backup file is written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Especifica dónde
se guardará el archivo de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default, to write the backup in the same
directory as the original file, will mostly be the right thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción por omisión, escribir la
copia de seguridad en el mismo directorio, es habitualmente la mejor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	When the 'backup' option isn't set but the 'writebackup' is, Vim will
	still create a backup file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Cuando la opción 'backup' no está activada pero 'writebackup' lo está,
	Vim creará igualmente la copia de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, it is deleted as soon as writing
	the file was completed successfully.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, se
	eliminará tan pronto como se escriba el archivo con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This functions as a safety
	against losing your original file when writing fails in some way (disk
	full is the most common cause; being hit by lightning might be
	another, although less common).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto
	funciona como seguridad ante la pérdida de su archivo original cuando
	la escritura falla por algún motivo (un disco lleno es el más habitual,
	un rayo puede ser otra causa aunque menos común).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are editing source files, you might want to keep the file before you
make any changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está editando archivos fuente, quizá desee mantener el archivo antes de
hacer ningún cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the backup file will be overwritten each time you write
the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero la copia de seguridad se sobreescribirá cada vez que
escriba el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it only contains the previous version, not the first one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así sólo contendrá la versión previa y no la original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make Vim keep the original file, set the 'patchmode' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que Vim mantenga el archivo original, activa la opción
'patchmode'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
specifies the extension used for the first backup of a changed file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto especifica la extensión usada para la primera copia de
seguridad de un archivo modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually
you would do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente harás esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set patchmode=.orig</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set patchmode=.orig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now edit the file data.txt for the first time, make changes and write
the file, Vim will keep a copy of the unchanged file under the name
"data.txt.orig".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite el archivo datos.txt por primera vez, haga cambios y guarde el
archivo, Vim mantendrá una copia del archivo sin cambios bajo el nombre
«datos.txt.orig».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you make further changes to the file, Vim will notice that
"data.txt.orig" already exists and leave it alone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hace más cambios, Vim notará que «datos.txt.orig» ya existe y lo dejará
en paz.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further backup files will
then be called "data.txt~" (or whatever you specified with 'backupext').</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resto de copias de seguridad se llamarán «datos.txt~» (o lo que
haya especificado con 'backupext').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you leave 'patchmode' empty (that is the default), the original file
will not be kept.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si deja 'patchmode' vacío (la opción por defecto), el archivo original no
se guardará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.5*	Copy text between files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.5*	Copiar texto entre archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit thisfile
	/This
	vjjjj$y</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit estearchivo
	/Este
	vjjjj$y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now edit the file you want to put the text in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ahora el archivo donde desea poner el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the
character where you want the text to appear after.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor al
caracter donde quiera que el texto se coloque a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "p" to put the text
there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «p» para
poner el texto allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	:edit otherfile
	/There
	p</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	:edit otroarchivo
	/Allí
	p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course you can use many other commands to yank the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Naturalmente, podrás usar cualquiera otra orden de copia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to
select whole lines start Visual mode with "V".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para
seleccionar líneas completas, inicie el modo Visual con «V».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use CTRL-V to select a
rectangular block.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O pulse CTRL-V
para seleccionar bloques rectangulares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use "Y" to yank a single line, "yaw" to yank-a-word,
etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «Y» para simplemente
copiar una línea, «yaw» para pegar una palabra (yank-a-word).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "p" command puts the text after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «p» pone el texto después del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "P" to put the text
before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «P» para pegarlo
antes del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that Vim remembers if you yanked a whole line or a
block, and puts it back that way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repare en el hecho de que Vim recuerda si ha copiado una
línea completa o un bloque y lo pondrá del mismo modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to copy several pieces of text from one file to another, having
to switch between the files and writing the target file takes a lot of time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando quiera copiar diversas porciones de un texto de un archivo a otro,
tener que cambiar entre los archivos y guardarlos lleva mucho tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this, copy each piece of text to its own register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para
evitar esto, copie cada porción en un registro independiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A register is a place where Vim stores text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un registro es un lugar donde Vim guarda texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we will use the
registers named a to z (later you will find out there are others).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí usaremos los
registros nombrados desde la «a» a la «z» (más tarde se percatará de que hay
otros).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's copy
a sentence to the f register (f for First): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a copiar una frase en el registro f: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"fyas</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"fyas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "yas" command yanks a sentence like before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «yas» copia una frase.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's the "f that tells Vim
the text should be place in the f register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es el «"f» el que le dice a Vim que el texto
se debe situar en el registro f.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This must come just before the
yank command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto debe aparecer justo antes de la orden
copiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now yank three whole lines to the l register (l for line): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora copie tres líneas completas en el registro l: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"l3Y</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"l3Y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The count could be before the "l just as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El multiplicador puede situarse también antes del «"l».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To yank a block of text to the b (for block) register: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para copiar un bloque de texto al registro b: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-Vjjww"by</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-Vjjww"by</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the register specification "b is just before the "y" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la especificación del registro «"b» se encuentra justo antes
de la orden «y».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is required.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es imprescindible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would have put it before the "w" command, it would
not have worked.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo hubierse puesto antes de la
orden «w», no habría funcionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you have three pieces of text in the f, l and b registers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora tiene tres porciones de texto en los registros f, l, y b.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit
another file, move around and place the text where you want it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite
otro archivo, desplácese por el texto y allá donde desee: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"fp</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"fp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you delete text, you can also specify a register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimine texto, también puedes especificar un registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this to move several pieces of text around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto para mover varias porciones de texto de un lado para otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to delete-a-word and write it in the w register: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para eliminar una palabra y ponerla en el registro w (delete-a-word): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"wdaw</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"wdaw</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:write &gt;&gt; logfile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:write &gt;&gt; archivo_registro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.6*	Viewing a file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.6*	Ver un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you only want to see what a file contains, without the intention to
ever write it back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces sólo quiere ver qué contiene un archivo, sin la intención de
guardar ningún cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is the risk that you type ":w" without thinking and
overwrite the original file anyway.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe el riesgo de que escribas «:w» sin pensar y
sobreescriba el archivo original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this, edit the file read-only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar esto, edite el archivo como
sólo lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start Vim in readonly mode, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ejecutar Vim en modo sólo lectura, haga lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -R file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -R archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>view file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>view archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now editing "file" in read-only mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora está editando «archivo» en modo sólo lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you try using ":w" you
will get an error message and the file won't be written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando pruebe a usar
«:w» se dará cuenta de que aparecerá un mensaje de error y no se guardará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you try to make a change to the file Vim will give you a warning:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando intente hacer un cambio al archivo, Vim le dará un aviso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>W10: Warning: Changing a readonly file ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>W10: Advertencia: cambiando un fichero de solo lectura ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The change will be done though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cambio se realizará igualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows for formatting the file, for
example, to be able to read it easily.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite formatear el archivo, por
ejemplo, para facilitar su lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you make changes to a file and forgot that it was read-only, you can
still write it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si intenta hacer cambios a un archivo y olvidas que era de sólo lectura,
aún podrá guardarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the ! to the write command to force writing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Añada «!» a la orden guardar para forzar la escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -M file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -M file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every attempt to change the text will fail.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cualquier intento de cambiar el texto fallará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The help files are like this, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los archivos de ayuda son así, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you try to make a change you get this error message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si intenta cambiar algo, obtendrá el siguiente error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E21: Cannot make changes, 'modifiable' is off ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E21: No se pueden hacer cambios, «modifiable» está desactivado ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set modifiable
	:set write</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set modifiable
	:set write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*07.7*	Changing the file name</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*07.7*	Cambiar el nombre de un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A clever way to start editing a new file is by using an existing file that contains most of what you need.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma inteligente de comenzar la edición de un archivo nuevo es usar un archivo similar de partida que contenga algo parecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you start writing a new program to move a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, empiece a escribir un programa para filtrar archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You know that you already have a program that copies a file, thus you start with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sabe que ya tiene un código que copia archivos, así que podría comenzar con él: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit copy.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit copiar.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can delete the stuff you don't need.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede eliminar lo que no necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to save the file under a new name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación tendrá que guardar el archivo bajo un nombre distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":saveas" command can be used for this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:saveas» es adecuado para esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:saveas move.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:saveas filtrar.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will write the file under the given name, and edit that file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim escribirá el archivo con el nuevo nombre y editará el nuevo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the
next time you do ":write", it will write "move.c".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así la próxima vez que haga «:write», escribirá «filtrar.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"copy.c" remains
unmodified.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«copiar.c» se
mantiene sin modificaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to change the name of the file you are editing, but don't
want to write the file, you can use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando desee cambiar el nombre del archivo que está editando pero no
quiere escribirlo, puede usar el siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:file move.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:file move.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will mark the file as "not edited".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim marcará el archivo como «no editado».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that Vim knows this is not the file you started editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que Vim sabe que este no es el archivo que comenzó a editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you try to write the file, you might get this message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando intente guardar el archivo, puede que vea el siguiente mensaje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E13: File exists (use ! to override) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E13: El fichero ya existe (use ! para sobreescribir) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_41.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_41.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a Vim script</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escribir scripts para Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim script language is used for the startup vimrc file, syntax files, and many other things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El lenguaje de programación de Vim se usa en el archivo de arranque vimrc, los archivos de sintaxis, y muchas otras cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter explains the items that can be used in a Vim script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo presenta y explica en detalle los elementos que componen un script de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of them, thus this is a long chapter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay muchos de ellos, por lo que éste es un capítulo largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|41.1|	Introducción
|41.2|	Variables
|41.3|	Expresiones
|41.4|	Estructuras de decisión
|41.5|	Ejecución de expresiones
|41.6|	Funciones
|41.7|	Definición de funciones
|41.8|	Listas y Diccionarios
|41.9|	Excepciones
|41.10|	Observaciones
|41.11|	Escribir extensiones
|41.12|	Escribir extensiones para tipo de archivo
|41.13|	Escribir extensiones para compiladores
|41.14|	Escribir extensiones que carguen rápidamente
|41.15|	Escribir bibliotecas
|41.16|	Distribuir scripts de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_42.esx|  Añadir menús nuevos
  Capítulo anterior: |usr_40.esx|  Crear órdenes nuevas
Tabla de contenidos: |usr_toc.txt|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.1*	Introduction				*vim-script-intro* *script*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.1*	Introducción				*vim-script-intro* *script*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let i = 1
	:while i &lt; 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
&lt;
	Note:
	The ":" characters are not really needed here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let i = 1
	:while i &lt; 5
	:  echo "cuenta es" i
	:  let i += 1
	:endwhile
&lt;
	Nota:
	En realidad en el ejemplo de arriba los caracteres «:» no son
	necesarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You only need to use
	them when you type a command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo es necesario su uso al escribir una orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Vim script file they can be left
	out.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En los
	archivos de script de Vim es posible omitirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí se muestran para
	evidenciar que son órdenes de la línea de órdenes, y no órdenes del
	modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Puede probar los ejemplos que se muestran aquí copiando el texto
	correspondiente, y ejecutándolo con la orden «:@"»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cuenta es 1 ~
	cuenta es 2 ~
	cuenta es 3 ~
	cuenta es 4 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first line the ":let" command assigns a value to a variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la primera línea la orden «:let» le asigna un valor a una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let {variable} = {expression}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let {variable} = {expresión}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case the variable name is "i" and the expression is a simple value,
the number one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso el nombre de la variable es «i» y la expresión es simplemente un
valor, el número uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":while" command starts a loop.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:while» inicia un ciclo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:while {condition}
	:  {statements}
	:endwhile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:while {condicion}
	:  {instrucciones}
	:endwhile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The statements until the matching ":endwhile" are executed for as long as the
condition is true.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las instrucciones hasta el «:endwhile» correspondiente se ejecutan mientras
que la {condicion} se siga cumpliendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The condition used here is the expression "i &lt; 5".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La condición aquí es la expresión
«i &lt; 5».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
is true when the variable i is smaller than five.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta es verdadera cuando la variable i es menor a cinco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Si llega a escribir un ciclo «while» que nunca termina de ejecutarse,
	puede interrumpirlo presionando CTRL-C (o CTRL-Break en MS-Windows).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":echo" command prints its arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:echo» imprime en pantalla los argumentos que se le introduzcan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case the string "count is" and the value of the variable i.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso son la cadena «cuenta es» y el valor de la variable i.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since i is one, this will print:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como i vale uno, se imprimirá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>count is 1 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cuenta es 1 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then there is the ":let i += 1" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego está la orden «:let i += 1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does the same thing as ":let i = i + 1".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta tiene el mismo efecto que «:let i = i + 1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This adds one to the variable i and assigns the new value to the same variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le añade uno a la variable i y asigna el resultado a la misma variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for i in range(1, 4)
	:  echo "count is" i
	:endfor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for i in range(1, 4)
	:  echo "cuenta es" i
	:endfor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We won't explain how |:for| and |range()| work until later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El funcionamiento de |:for| y |range()| se explicará después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the links if you are impatient.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siga los enlaces si no desea esperar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers can be decimal, hexadecimal or octal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los números pueden ser decimales, hexadecimales, u octales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A hexadecimal number starts
with "0x" or "0X".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un número
hexadecimal empieza con «0x» o «0X».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example "0x1f" is decimal 31.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «0x1f» es 31 en decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An octal number starts
with a zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un
número octal empieza con cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"017" is decimal 15.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«017» es 15 en decimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Careful: don't put a zero before a decimal
number, it will be interpreted as an octal number!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga cuidado: no ponga
ceros al comienzo de un número decimal, ¡será interpretado como un octal!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":echo" command always prints decimal numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:echo» siempre muestra los números como decimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo 0x7f 036
&lt;	127 30 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo 0x7f 036
&lt;	127 30 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number is made negative with a minus sign.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se pueden obtener números negativos añadiéndoles un signo de resta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works for hexadecimal
and octal numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona
también para números octales y hexadecimales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A minus sign is also used for subtraction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El signo menos también se usa
para la substracción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compare this
with the previous example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compare lo siguiente con el ejemplo anterior: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo 0x7f -036
&lt;	97 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo 0x7f -036
&lt;	97 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>White space in an expression is ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En las expresiones se ignoran los espacios en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, it's recommended to use it for separating items, to make the expression easier to read.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, es recomendable usarlo para separar elementos, para hacer que las expresiones sean más legibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to avoid the confusion with a negative number above, put a space between the minus sign and the following number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para evitar confundir el ejemplo anterior con un número negativo, ponga un espacio entre el signo de resta y el número que lo sigue: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo 0x7f - 036</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo 0x7f - 036</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.2*	Variables</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.2*	Variables</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A variable name consists of ASCII letters, digits and the underscore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los nombres de variables pueden consistir de las letras del código ASCII, dígitos, y el guión bajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It cannot start with a digit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No pueden empezar con dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Valid variable names are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los siguientes son nombres válidos de variables:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>contador
	_aap3
	nombre_de_variable_largo_con_guion_bajo
	FuncLongitud
	LONGITUD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invalid names are "foo+bar" and "6var".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«foo+bar» y «6var» no son nombres válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These variables are global.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas variables son globales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see a list of currently defined variables
use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver un listado de las variables
definidas actualmente, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let s:count = 1
	:while s:count &lt; 5
	:  source other.vim
	:  let s:count += 1
	:endwhile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let s:cuenta = 1
	:while s:cuenta &lt; 5
	:  source otro.vim
	:  let s:cuenta += 1
	:endwhile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since "s:count" is local to this script, you can be sure that sourcing the "other.vim" script will not change this variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que el ámbito de «s:cuenta» es local al script, puede estar seguro de que cargar el archivo «otro.vim» no hará cambios a dicha variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If "other.vim" also uses an "s:count" variable, it will be a different copy, local to that script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si «otro.vim» también usa una variable «s:cuenta», será una copia distinta, local al ámbito de ese script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about script-local variables here: |script-variable|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar más información acerca de las variables locales a un script en |script-variable|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are more kinds of variables, see |internal-variables|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existen más clases de variables, consulte |internal-variables|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most often used ones are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las que se usan más frecuentemente son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>b:nombre		variable local a un búfer
	w:nombre		variable local a una ventana
	g:nombre		variable global (incluso dentro de funciones)
	v:nombre		variable predeterminada por Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables take up memory and show up in the output of the ":let" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las variables que aparecen en el listado que genera la orden «:let» consumen recursos de memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a variable use the ":unlet" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una variable use la orden «:unlet».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unlet s:count</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unlet s:cuenta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This deletes the script-local variable "s:count" to free up the memory it uses.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden elimina la variable «s:count», local al script actual, para liberar la memoria que ésta usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not sure if the variable exists, and don't want an error message when it doesn't, append !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no está seguro de que una variable exista, y no quiere obtener mensajes de error si no existe, añada ! a la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unlet! s:count</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unlet! s:cuenta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a script finishes, the local variables used there will not be automatically freed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando la ejecución de un script termina, no se liberan automáticamente los recursos usados por sus variables locales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next time the script executes, it can still use the old value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La próxima vez que se ejecute el script, los valores antiguos estarán disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if !exists("s:cuenta_llamadas")
	:  let s:cuenta_llamadas = 0
	:endif
	:let s:cuenta_llamadas = s:cuenta_llamadas + 1
	:echo "llamado" s:cuenta_llamadas "veces"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "exists()" function checks if a variable has already been defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función «exists()» comprueba la existencia de una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Its argument is the name of the variable you want to check.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recibe como argumento el nombre de la variable a comprobar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not the variable itself!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡No la variable como tal!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si intenta esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if !exists(s:call_count)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if !exists(s:cuenta_llamadas)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the value of s:call_count will be used as the name of the variable that
exists() checks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor de «s:cuenta_llamadas» se usará como el nombre de variable que
exists() revisará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The exclamation mark ! negates a value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El símbolo de exclamación ! niega un valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the value was true, it
becomes false.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando un valor es verdadero,
se vuelve falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it was false, it becomes true.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando es falso, se vuelve verdadero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read it as "not".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede leer este símbolo
como «not» (negación lógica).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "if !exists()" can be read as "if not exists()".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, «if !exists()» se lee como «if not
exists()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What Vim calls true is anything that is not zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim considera como verdadero cualquier valor distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Zero is false.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cero
equivale a falso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Vim automatically converts a string to a number when it is looking for
	a number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Vim convierte las cadenas de texto a números de manera automática
	cuando se espera un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a string that doesn't start with a digit the
	resulting number is zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se hace esta conversión con una
	cadena que no empieza con un dígito el número resultante es cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus look out for this: &gt;
		:if "true"
&lt;	The "true" will be interpreted as a zero, thus as false!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a esto, tenga cuidado con instrucciones como: &gt;
		:if "verdadero"
&lt;	en este caso, la cadena «verdadero» será interpretada como un cero, ¡y
	por tanto como falso!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far only numbers were used for the variable value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora sólo se han usado números como valores de variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings can be used as
well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También es
posible usar cadenas de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Numbers and strings are the basic types of variables that Vim supports.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los tipos básicos de variables que Vim soporta
son números y cadenas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The type is dynamic, it is set each time when assigning a value to the
variable with ":let".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El tipo de cada variable es dinámico, y se fija cada
vez que se asigna un valor a una variable mediante «:let».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about types in |41.8|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Refiérase a |41.8|
para más información acerca de tipos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To assign a string value to a variable, you need to use a string constant.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para asignar un valor de tipo cadena a una variable, debe usar una
constante de cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two types of these.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos tipos de estas constantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First the string in double quotes: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primero es la
cadena con comillas dobles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let name = "peter"
	:echo name
&lt;	peter ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let nombre = "pedro"
	:echo nombre
&lt;	pedro ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let name = "\"peter\""
	:echo name
&lt;	"peter" ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let nombre = "\"pedro\""
	:echo nombre
&lt;	"pedro" ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let name = '"peter"'
	:echo name
&lt;	"peter" ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let nombre = '"pedro"'
	:echo nombre
&lt;	"pedro" ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside a single-quote string all the characters are as they are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En una cadena de comillas sencillas todos los caracteres tienen solamente su
significado literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the
single quote itself is special: you need to use two to get one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo la comilla sencilla es especial: debe usar dos
seguidas para obtener una dentro de una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La barra inversa se considera
literalmente, por lo que no es posible usarla para cambiar el significado del
carácter después de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In double-quote strings it is possible to use special characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En las cadenas de comillas dobles es posible usar caracteres especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are
a few useful ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A
continuación algunos de los más usados:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, line break
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, backspace
	\"		"
	\\		\, backslash
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\t		&lt;Tab&gt;
	\n		&lt;NL&gt;, salto de línea
	\r		&lt;CR&gt;, &lt;Enter&gt;
	\e		&lt;Esc&gt;
	\b		&lt;BS&gt;, retroceso
	\"		"
	\\		\, barra inversa
	\&lt;Esc&gt;		&lt;Esc&gt;
	\&lt;C-W&gt;		CTRL-W</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last two are just examples.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los últimos dos sólo son ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The  "\&lt;name&gt;" form can be used to include
the special key "name".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede usar la forma «\&lt;nombre&gt;» para
incluir la tecla «nombre».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |expr-quote| for the full list of special items in a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |expr-quote| para ver la lista completa de elementos especiales
en una cadena de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.3*	Expressions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.3*	Expresiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a rich, yet simple way to handle expressions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una forma expresiva, pero sencilla, de manejar expresiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read the
definition here: |expression-syntax|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede
leer la definición aquí: |expression-syntax|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we will show the most common
items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación mostraremos
algunos de los elementos más comunes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The numbers, strings and variables mentioned above are expressions by
themselves.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los números, cadenas, y las variables mencionadas anteriormente son
expresiones por sí mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus everywhere an expression is expected, you can use a number,
string or variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así que, en donde sea que se espere una expresión,
puede usar un número, una cadena, o una variable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other basic items in an expression are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otros de los elementos
comunes en una expresión son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$NAME		environment variable
	&amp;name		option
	@r		register</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>$NOMBRE		variable de entorno
	&amp;nombre		opción
	@r		registro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo "The value of 'tabstop' is" &amp;ts
	:echo "Your home directory is" $HOME
	:if @a &gt; 5</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo "El valor de 'tabstop' es" &amp;ts
	:echo "Su directorio personal es" $HOME
	:if @a &gt; 5</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &amp;name form can be used to save an option value, set it to a new value, do something and restore the old value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la forma «&amp;nombre» para guardar el valor de una opción, fijarla a un nuevo valor, hacer algo, y restaurar el valor original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let save_ic = &amp;ic
	:set noic
	:/The Start/,$delete
	:let &amp;ic = save_ic</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let ic_orig = &amp;ic
	:set noic
	:/El Principio/,$delete
	:let &amp;ic = ic_orig</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes sure the "The Start" pattern is used with the 'ignorecase' option off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con esto se asegura que el patrón «El Principio» se buscará con la opción 'ignorecase' desactivada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Still, it keeps the value that the user had set.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, se conserva y restaura el valor que el usuario definió para la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Another way to do this would be to add "\C" to the pattern, see |/\C|.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Otra forma de hacer esta búsqueda es añadir «\C» al patrón, consulte |/\C|.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It becomes more interesting if we combine these basic items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las cosas se hacen más interesantes si combinamos estos elementos básicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with mathematics on numbers:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Empecemos con operaciones matemáticas sobre números:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a + b		adición
	a - b		sustracción
	a * b		multiplicación
	a / b		división
	a % b		módulo (residuo)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual precedence is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se maneja la precendencia de operadores usual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo 10 + 5 * 2
&lt;	20 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo 10 + 5 * 2
&lt;	20 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grouping is done with braces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cambiar la precendencia de las operaciones usando paréntesis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No surprises here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no es nada nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo (10 + 5) * 2
&lt;	30 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo (10 + 5) * 2
&lt;	30 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Strings can be concatenated with ".".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede unir cadenas usando «.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo "foo" .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo "foo" .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"bar"
&lt;	foobar ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"bar"
&lt;	foobar ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the ":echo" command gets multiple arguments, it separates them with a space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando recibe varios argumentos, la orden «:echo» los muestra en pantalla separados con espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the example the argument is a single expression, thus no space is inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo anterior el argumento es una única expresión, por lo que no se insertan espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a ? b : c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a ? b : c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If "a" evaluates to true "b" is used, otherwise "c" is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si «a» se evalúa como verdadero, la expresión corresponderá a «b», y en caso contrario a «c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let i = 4
	:echo i &gt; 5 ?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let i = 4
	:echo i &gt; 5 ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"i is big" : "i is small"
&lt;	i is small ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"i es grande" : "i es pequeño"
&lt;	i es pequeño ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(a) ?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(a) ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(b) : (c)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(b) : (c)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.4*	Conditionals</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.4*	Estructuras de decisión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":if" commands executes the following statements, until the matching ":endif", only when a condition is met.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:if» ejecuta las órdenes a continuación de ella, hasta el «:endif» correspondiente, cuando se cumple la condición especificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generic form is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma genérica es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if {condition}
	   {statements}
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if {condicion}
	   {instrucciones}
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las {instrucciones} se ejecutan únicamente cuando la expresión {condicion} es
verdadera, esto es, diferente de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These must still be valid commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dichas instrucciones deben ser órdenes
válidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If they
contain garbage, Vim won't be able to find the ":endif".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si las órdenes tienen errores de sintaxis, Vim no podrá encontrar el
«:endif» correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use ":else".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar «:else».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generic form for this is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma genérica es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if {condition}
	   {statements}
	:else
	   {statements}
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if {condicion}
	   {instrucciones}
	:else
	   {instrucciones}
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second {statements} is only executed if the first one isn't.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El segundo grupo de {instrucciones} sólo se ejecuta si el primero no lo hace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is ":elseif":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Finalmente, está «:elseif»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if {condicion}
	   {instrucciones}
	:elseif {condicion}
	   {instrucciones}
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works just like using ":else" and then "if", but without the need for an
extra ":endif".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden funciona como «:else» seguido de «:if», pero tiene la ventaja de no
requerir un «:endif» adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo útil que podría usar en su archivo vimrc es comprobar la opción
'term' y ejecutar órdenes diferentes de acuerdo a su valor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if &amp;term == "xterm"
	:  " Do stuff for xterm
	:elseif &amp;term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if &amp;term == "xterm"
	:  " Configuración para xterm
	:elseif &amp;term == "vt100"
	:  " Configuración para la terminal vt100
	:else
	:  " Configuración para otras terminales
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already used some of them in the examples.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya hemos usado algunas de ellas en los ejemplos anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the most often used ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación listamos las más utilizadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a == b		equal to
	a != b		not equal to
	a &gt;  b		greater than
	a &gt;= b		greater than or equal to
	a &lt;  b		less than
	a &lt;= b		less than or equal to</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a == b		igual a
	a != b		diferente de
	a &gt;  b		mayor que
	a &gt;= b		mayor o igual a
	a &lt;  b		menor que
	a &lt;= b		menor o igual a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is one if the condition is met and zero otherwise.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es uno si la condición se cumple, y cero en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if v:version &gt;= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if v:version &gt;= 700
	:  echo "felicitaciones"
	:else
	:  echo "¡está usando una versión vieja, actualícese!"
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logic operators work both for numbers and strings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los operadores lógicos funcionan con números y con cadenas de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When comparing two
strings, the mathematical difference is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al
comparar dos cadenas, se trabaja con la diferencia matemática de las mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This compares byte values,
which may not be right for some languages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto compara valores de bytes, lo que para algunos idiomas puede no entregar
resultados correctos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When comparing a string with a number, the string is first converted to a
number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al comparar cadenas con números, la cadena es convertida a un número antes
de hacer la comparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe tener en cuenta que, cuando el contenido de una
cadena no se asemeja a un número, se usa el número cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if 0 == "one"
	:  echo "yes"
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if 0 == "uno"
	:  echo "sí"
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a =~ b		matches with
	a !~ b		does not match with</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a =~ b		coincide con
	a !~ b		no coincide con</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The left item "a" is used as a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operando de la izquierda, «a», se trata como una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The right item "b" is used as a pattern, like what's used for searching.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operando de la derecha, «b», se trata como un patrón para una búsqueda de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if str =~ " "
	:  echo "str contiene un espacio"
	:endif
	:if str !~ '\.$'
	:  echo "str no termina con punto final"
	:endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of a single-quote string for the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta el uso de una cadena de comillas sencillas como patrón de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful, because backslashes would need to be doubled in a double-quote string and patterns tend to contain many backslashes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso es útil porque las barras inversas tendrían que insertarse por partida doble en una cadena de comillas dobles, y los patrones de búsqueda suelen contener muchas barras inversas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'ignorecase' option is used when comparing strings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al comparar cadenas se tiene en cuenta la opción 'ignorecase'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you don't want that, append "#" to match case and "?" to ignore case.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no desea este comportamiento, añada un «#» para diferenciar mayúsculas de minúsculas, o «?» para ignorar dicha diferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "==?" compares two strings to be equal while ignoring case.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, «==?» compara dos cadenas sin diferenciar mayúsculas de minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And "!~#" checks if a pattern doesn't match, also checking the case of letters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«!~#» revisa la no coincidencia de un patrón, teniendo en cuenta diferencias de mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the full table see |expr-==|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede consultar la tabla completa de operadores de comparación en |expr-==|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":while" command was already mentioned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya hemos mencionado la orden «:while».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two more statements can be used in between the ":while" and the ":endwhile":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos instrucciones adicionales que pueden usarse entre «:while» y el «:endwhile» correspondiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:continue		Jump back to the start of the while loop; the
				loop continues.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:continue		Salta hasta el inicio del ciclo «while»; el
				ciclo continúa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:break			Jump forward to the ":endwhile"; the loop is
				discontinued.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:break			Salta hasta después del «:endwhile»; provoca
				la terminación del ciclo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:while counter &lt; 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:while contador &lt; 40
	:  call hacer_algo()
	:  if opción_omitir
	:    continue
	:  endif
	:  if opción_terminado
	:    break
	:  endif
	:  sleep 50m
	:endwhile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":sleep" command makes Vim take a nap.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:sleep» hace que Vim tome una pausa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "50m" specifies fifty milliseconds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «50m» especifica una duración de 50 milisegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example is ":sleep 4", which sleeps for four seconds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro ejemplo es «:sleep 4», que especifica una pausa de cuatro segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.5*	Executing an expression</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.5*	Ejecución de expresiones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far the commands in the script were executed by Vim directly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora, todas las órdenes mostradas han sido ejecutadas directamente por
Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
":execute" command allows executing the result of an expression.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:execute» permite ejecutar el resultado de una expresión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a
very powerful way to build commands and execute them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta
es una forma poderosa de construir y ejecutar órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example is to jump to a tag, which is contained in a variable: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo es saltar a una etiqueta, cuyo nombre está almacenado en una
variable: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:execute "tag " . tag_name</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:execute "tag " . nombre_etiqueta</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." is used to concatenate the string "tag " with the value of variable "tag_name".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «.» se usa para concatenar la cadena «tag » con el valor de la variable «nombre_etiqueta».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose "tag_name" has the value "get_cmd", then the command that will be executed is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si suponemos que «nombre_etiqueta» tiene el contenido «obtener_orden», entonces la orden que se ejecutará es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:tag get_cmd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:tag obtener_orden</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":execute" command can only execute colon commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:execute» sólo puede ejecutar órdenes de la línea de órdenes (órdenes Ex, que empiezan con «:»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":normal" command executes Normal mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:normal» ejecuta órdenes del modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, its argument is not an expression but the literal command characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, su argumento no es una expresión, sino los caracteres literales de la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:normal gg=G</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:normal gg=G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This jumps to the first line and formats all lines with the "=" operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se mueve hasta la primera línea y formatea todas las líneas usando el operador
«=».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make ":normal" work with an expression, combine ":execute" with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para usar «:normal» con el resultado de una expresión, debe combinar
«:execute» con dicha orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:execute "normal " . normal_commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:execute "normal " . ordenes_modo_normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "normal_commands" must contain the Normal mode commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variables «ordenes_modo_normal» debe contener órdenes para el modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure that the argument for ":normal" is a complete command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asegúrese de que el argumento para «:normal» es una orden completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise
Vim will run into the end of the argument and abort the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso
contrario, Vim llegará al final del argumento e interrumpirá la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example,
if you start Insert mode, you must leave Insert mode as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, si inicia el modo Insertar, debe salir del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo siguiente
funciona adecuadamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:execute "normal Inew text \&lt;Esc&gt;"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:execute "normal Itexto nuevo \&lt;Esc&gt;"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This inserts "new text " in the current line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inserta «texto nuevo» en la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of the special key "\&lt;Esc&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe el uso de la tecla especial «\&lt;Esc&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This avoids having to enter a real &lt;Esc&gt; character in your script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así se evita la necesidad de escribir un &lt;Esc&gt; real en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let optname = "path"
	:let optval = eval('&amp;' . optname)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let nomopcion = "path"
	:let valopcion = eval('&amp;' . nomopcion)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "&amp;" character is prepended to "path", thus the argument to eval() is
"&amp;path".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se antepone un «&amp;» a «path», y así el argumento para eval() es «&amp;path».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result will then be the value of the 'path' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
resultado será el valor de la opción 'path'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same thing can be done with: &gt;
	:exe 'let optval = &amp;' . optname</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener el mismo resultado con: &gt;
	:exe 'let optval = &amp;' . optname</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.6*	Using functions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.1*	Funciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim defines many functions and provides a large amount of functionality that way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim define muchas funciones y provee bastante funcionalidad a través de este mecanismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few examples will be given in this section.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí daremos algunos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the whole list here: |functions|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La referencia para la lista completa se encuentra en |functions|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function is called with the ":call" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las funciones se llaman con la orden «:call».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The parameters are passed in between braces, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los parámetros se introducen entre paréntesis, separados por comas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:call search("Date: ", "W")</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:call search("Fecha: ", "W")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This calls the search() function, with arguments "Date: " and "W".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se invoca a la función search(), con los argumentos «Fecha: » y «W».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The search() function uses its first argument as a search pattern and the second one as flags.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función search() usa su primer argumento como patrón de búsqueda y el segundo como una serie de opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "W" flag means the search doesn't wrap around the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «W» hace que la búsqueda termine al alcanzar el final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A function can be called in an expression.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También es posible invocar funciones en expresiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let linea = getline(".")
	:let reempl = substitute(linea, '\a', "*", "g")
	:call setline(".", reempl)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:substitute/\a/*/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:substitute/\a/*/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FUNCTIONS						*function-list*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>FUNCIONES						*function-list*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim cuenta con muchas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will mention them here, grouped by what they are used for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las mencionaremos aquí, agrupadas de acuerdo a su funcionalidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find an alphabetical list here: |functions|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En |functions| se encuentra una lista de ellas ordenada alfabéticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use CTRL-] on the function name to jump to detailed help on it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ubicar el cursor sobre el nombre de una función y pulsar CTRL-] para ver documentación más detallada sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String manipulation:					*string-functions*
	nr2char()		get a character by its ASCII value
	char2nr()		get ASCII value of a character
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchlist()		like matchstr() and also return submatches
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in a ":substitute"
	strpart()		get part of a string
	expand()		expand special keywords
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de cadenas:				*string-functions*
	nr2char()		obtiene un carácter dado su valor ASCII
	char2nr()		obtiene el número ASCII del carácter dado
	str2nr()		convierte una cadena a Número
	str2float()		convierte una cadena a Flotante
	printf()		formatea una cadena de acuerdo a elementos %
	escape()		escapa caracteres en una cadena con '\'
	shellescape()		escapa una cadena para usarse una orden de
				consola
	fnameescape()		escapa un nombre de archivo para usar en una
				orden Vim
	tr()			traduce caracteres de un conjunto a otro
	strtrans()		traduce una cadena para que se pueda imprimir
	tolower()		convierte una cadena a minúsculas
	toupper()		convierte una cadena a mayúsculas
	match()			posición en la que un patrón coincide en una
				cadena
	matchend()		posición en la que un patrón termina en una
				cadena
	matchstr()		coincidencia de un patrón en una cadena
	matchlist()		similar a matchstr() y retorna
				subcoincidencias
	stridx()		primer índice de una cadena corta dentro de
				una larga
	strridx()		último índice de una cadena corta dentro de
				una larga
	strlen()		longitud de una cadena
	substitute()		sustituye la coincidencia de un patrón con una
				cadena
	submatch()		obtiene una subcoincidencia específica en un
				«:substitute»
	strpart()		obtiene parte de una cadena
	expand()		expande palabras clave
	iconv()			convierte texto entre distintas codificaciones
	byteidx()		índice de byte de un carácter en una cadena
	repeat()		repite una cadena múltiples veces
	eval()			evalúa una cadena como expresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List manipulation:					*list-functions*
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	split()			split a String into a List
	join()			join List items into a String
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de Listas:					*list-functions*
	get()			obtiene un elemento sin generar error al usar
				índices erróneos
	len()			número de elementos en una Lista
	empty()			comprueba si una Lista está vacía
	insert()		inserta un elemento en una Lista
	add()			añade un elemento a una Lista
	extend()		añade los contenidos de una Lista a otra Lista
	remove()		elimina uno o más elementos de una lista
	copy()			hace una copia superficial de una Lista
	deepcopy()		hace una copia completa de una Lista
	filter()		elimina elementos particulares de una Lista
	map()			cambia cada elemento de una Lista
	sort()			ordena una Lista
	reverse()		invierte el orden de una Lista
	split()			divide una cadena en una Lista
	join()			une los elementos de una Lista en una cadena
	range()			retorna una Lista con una secuencia de números
	string()		representación de una Lista en una cadena
	call()			invoca una función con una Lista como argumentos
	index()			índice de un valor en una Lista
	max()			valor máximo en una Lista
	min()			valor mínimo en una Lista
	count()			cuenta la cantidad de veces que un valor
				aparece en una Lista
	repeat()		repite una Lista múltiples veces</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dictionary manipulation:				*dict-functions*
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de Diccionarios:				*dict-functions*
	get()			obtiene una entrada sin generar error al usar
				claves erróneas
	len()			número de entradas en un Diccionario
	has_key()		comprueba si una clave aparece en un
				Diccionario
	empty()			comprueba si un Diccionario está vacío
	remove()		elimina una entrada de un Diccionario
	extend()		añade las entradas de un Diccionario a otro
	filter()		elimina entradas particulares de un
				Diccionario
	map()			cambia cada entrada de un Diccionario
	keys()			devuelve una Lista con las claves de un
				Diccionario
	values()		devuelve una Lista con los valores de un
				Diccionario
	items()			devuelve una Lista de pares clave-valor de un
				Diccionario
	copy()			hace una copia superficial de un Diccionario
	deepcopy()		hace una copia completa de un Diccionario
	string()		representación de cadena de un Diccionario
	max()			valor máximo en un Diccionario
	min()			valor mínimo en un Diccionario
	count()			cuenta la cantidad de veces que un valor
				aparece en un Diccionario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Floating point computation:				*float-functions*
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	log10()			logarithm to base 10
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	atan()			arc tangent</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Operaciones de punto flotante:				*float-functions*
	float2nr()		convertir Flotante a Número
	abs()			valor absoluto (también funciona para Números)
	round()			redondear
	ceil()			redondear hacia arriba (techo)
	floor()			redondear hacia abajo (piso)
	trunc()			eliminar valores después del punto decimal
	log10()			logaritmo en base 10
	pow()			valor de x elevado a la y potencia
	sqrt()			raíz cuadrada
	sin()			seno
	cos()			coseno
	atan()			arcotangente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables:						*var-functions*
	type()			type of a variable
	islocked()		check if a variable is locked
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window &amp; tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window &amp; tab page
	garbagecollect()	possibly free memory</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Variables:						*var-functions*
	type()			tipo de una variable
	islocked()		comprueba si una variable ha sido bloqueada
	function()		obtiene una referencia a función para el
				nombre de función dado
	getbufvar()		obtiene una variable de un búfer específico
	setbufvar()		define una variable en un búfer específico
	getwinvar()		obtiene una variable de una ventana específica
	gettabvar()		obtiene una variable de una pestaña específica
	gettabwinvar()		obtiene una variable de una ventana y pestaña
				específicas
	setwinvar()		define una variable en una ventana
				específica
	settabvar()		define una variable en una pestaña
				específica
	settabwinvar()		define una variable en una ventana y pestaña
				específicas
	garbagecollect()	potencialmente libera memoria</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cursor and mark position:		*cursor-functions* *mark-functions*
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	getpos()		get position of cursor, mark, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posición de marcas y del cursor:	*cursor-functions* *mark-functions*
	col()			número de columna del cursor o de una marca
	virtcol()		número de columna en pantalla del cursor o de
				una marca
	line()			número de línea del cursor o de una marca
	wincol()		número de columna de ventana del cursor
	winline()		número de línea de ventana del cursor
	cursor()		ubica el cursor en una linea/columna
	getpos()		obtiene la posición del cursor, marca, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setpos()		set position of cursor, mark, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>setpos()		define la posición del cursor, marca, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>byte2line()		obtiene el número de línea correspondiente a
				un índice en bytes
	line2byte()		índice en bytes correspondiente a una línea
				específica
	diff_filler()		obtiene la cantidad de líneas de relleno
				encima de una línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with text in the current buffer:		*text-functions*
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manipulación de texto en el búfer actual:		*text-functions*
	getline()		obtiene una línea o lista de líneas del búfer
	setline()		reemplaza una línea del búfer
	append()		añade una línea o lista de líneas al búfer
	indent()		sangrado de una línea específica
	cindent()		sangrado de una línea de acuerdo al estilo
				para C
	lispindent()		sangrado de una línea de acuerdo al estilo
				para Lisp
	nextnonblank()		ubica la siguiente línea no vacía
	prevnonblank()		ubica la anterior línea no vacía
	search()			ubica una coincidencia para un patrón
	searchpos()		ubica una coincidencia para un patrón
	searchpair()		ubica la parte correspondiente a un
				inicio/medio/final
	searchpairpos()	ubica la parte correspondiente a un
				inicio/medio/final
	searchdecl()		busca la declaración de un nombre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*system-functions* *file-functions*
System functions and manipulation of files:
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
	getfperm()		get the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd|
	tempname()		get the name of a temporary file
	mkdir()			create a new directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command
	hostname()		name of the system
	readfile()		read a file into a List of lines
	writefile()		write a List of lines into a file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*system-functions* *file-functions*
Funciones del sistema y manipulación de archivos:
	glob()			expande comodines
	globpath()	expande comodines en múltiples directorios
	findfile()		ubica un archivo en una lista de directorios
	finddir()		ubica un directorio en una lista de
				directorios
	resolve()		determina a dónde apunta un acceso o enlace
				directo
	fnamemodify()		modifica un nombre de archivo
	pathshorten()		abrevia nombres de directorio en una ruta
	simplify()		simplifica una ruta sin cambiar su significado
	executable()		comprueba si un programa ejecutable existe
	filereadable()		comprueba si se puede leer un archivo
	filewritable()		comprueba si se puede escribir a un archivo
	getfperm()		obtiene los permisos para un archivo
	getftype()		obtiene el tipo de un archivo
	isdirectory()		comprueba si un directorio existe
	getfsize()		obtiene el tamaño de un archivo
	getcwd()		obtiene el directorio de trabajo actual
	haslocaldir()		comprueba si se ha usado |:lcd| en la ventana
				actual
	tempname()		obtiene un nombre para un archivo temporal
	mkdir()			crea un nuevo directorio
	delete()		borra un archivo
	rename()		renombra un archivo
	system()		obtiene el resultado de una orden de consola
	hostname()		nombre del sistema
	readfile()		lee un archivo y devuelve una Lista de líneas
	writefile()		escribe una Lista de líneas a un archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Date and Time:				*date-functions* *time-functions*
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fecha y Hora:				*date-functions* *time-functions*
	getftime()		obtiene la hora de la última modificación de
				un archivo
	localtime()		obtiene la hora actual en segundos
	strftime()		convierte la hora a una cadena
	reltime()		devuelve la hora actual o el tiempo
				transcurrido desde una hora
	reltimestr()		convierte el resultado de reltime() a una
				cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	argv()			get one entry from the argument list
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
	winnr()			get the window number for the current window
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
	getbufline()		get a list of lines from the specified buffer</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*buffer-functions* *window-functions* *arg-functions*
Búferes, ventanas, y la lista de argumentos:
	argc()			número de entradas en la lista de argumentos
	argidx()		posición actual en la lista de argumentos
	argv()			obtiene un elemento de la lista de argumentos
	bufexists()		comprueba si un búfer existe
	buflisted()		comprueba si un búfer existe y está listado
	bufloaded()		comprueba si un búfer existe y está cargado
	bufname()		obtiene el nombre de un búfer específico
	bufnr()			obtiene el número de búfer de un búfer
				específico
	tabpagebuflist()	devuelve la Lista de búfers de una pestaña
	tabpagenr()		obtiene el número de una pestaña
	tabpagewinnr()		similar a winnr(), pero especificando la
				pestaña
	winnr()			obtiene el número de ventana de la ventana
				actual
	bufwinnr()		obtiene el número de ventana del búfer
				especificado
	winbufnr()		obtiene el número de búfer de una ventana
				específica
	getbufline()		obtiene una lista de líneas del búfer
				especificado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line:					*command-line-functions*
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Línea de órdenes:				*command-line-functions*
	getcmdline()		obtiene la línea de órdenes actual
	getcmdpos()		obtiene la posición del cursor en la línea de
				órdenes
	setcmdpos()		cambia la posición del cursor en la línea de
				órdenes
	getcmdtype()		devuelve el tipo de la línea de órdenes actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickfix and location lists:			*quickfix-functions*
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Listas de corrección rápida y de ubicación:		*quickfix-functions*
	getqflist()		obtiene una lista de errores de corrección
				rápida
	setqflist()		modifica una lista de corrección rápida
	getloclist()	obtiene la lista de elementos de una lista de
				ubicación
	setloclist()		modifica una lista de ubicación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode completion:				*completion-functions*
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	pumvisible()		check if the popup menu is displayed</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Completado automático en modo Insertar:		*completion-functions*
	complete()		define coincidencias encontradas
	complete_add()		añade elementos a la lista de coincidencias
				encontradas
	complete_check()	comprueba si debería interrumpir el
				completado
	pumvisible()		comprueba si se está mostrando el menú
				contextual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding:					*folding-functions*
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegado:					*folding-functions*
	foldclosed()		comprueba si hay un pliegue cerrado en una
				línea específica
	foldclosedend()	similar a foldclosed() pero devuelve la última
				línea
	foldlevel()		obtiene el nivel de plegado de la línea
				especificada
	foldtext()		genera el texto mostrado en un pliegue cerrado
	foldtextresult()	obtiene el texto mostrado en un pliegue
				cerrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sintaxis y resaltado:	  *syntax-functions* *highlighting-functions*
	clearmatches()	elimina las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	getmatches()		obtiene todas las coincidencias definidas por
				|matchadd()| y las órdenes |:match|
	hlexists()		comprueba la existencia de un grupo de
				resaltado
	hlID()			obtiene el ID de un grupo de resaltado
	synID()			obtiene el ID de sintaxis en una posición
				específica
	synIDattr()		obtiene un atributo específico correspondiente
				a un ID de sintaxis
	synIDtrans()		obtiene un ID de sintaxis traducido
	diff_hlID()		obtiene el ID de resaltado para el modo diff
				en una posición dada
	matchadd()		define un patrón a resaltar (una
				«coincidencia»)
	matcharg()		obtiene información acerca de los argumentos
				para |:match|
	matchdelete()		borra una coincidencia definida por
				|matchadd()| o una orden |:match|
	setmatches()		restaura una lista de coincidencias guardada
				por |getmatches()|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spelling:					*spell-functions*
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Corrección ortográfica:					*spell-functions*
	spellbadword()		ubica palabras mal escritas a partir de la
				posición actual del cursor
	spellsuggest()		devuelve las correcciones ortográficas
				sugeridas
	soundfold()		retorna el homófono de una palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>History:					*history-functions*
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Historia:					*history-functions*
	histadd()		añade un elemento a la historia
	histdel()		elimina un elemento a la historia
	histget()		obtiene un elemento a la historia
	histnr()		obtiene el índice más grande de la lista de una
				historia</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive:					*interactive-functions*
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interacción:					*interactive-functions*
	browse()		despliega un diálogo de selección de archivos
	browsedir()		despliega un diálogo de selección de
				directorios
	confirm()		solicita al usuario hacer una elección
	getchar()		solicita un carácter al usuario
	getcharmod()		obtiene los modificadores usados en el último
				carácter digitado
	feedkeys()		inserta caracteres en la cola de inserción
	input()			solicita una línea de texto al usuario
	inputlist()		permite al usuario elegir un elemento de una
				lista
	inputsecret()		solicita una línea de texto al usuario, sin
				mostrarla
	inputdialog()		solicita una línea de texto al usuario usando
				un diálogo
	inputsave()		guarda y limpia el búfer de cola de inserción
	inputrestore()		restaura el búfer de la línea de inserción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI:						*gui-functions*
	getfontname()		get name of current font being used
	getwinposx()		X position of the GUI Vim window
	getwinposy()		Y position of the GUI Vim window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaz gráfica:					*gui-functions*
	getfontname()		obtiene el nombre del tipo de letra actual
	getwinposx()		posición X de la ventana gráfica de Vim
	getwinposy()		posición Y de la ventana gráfica de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim server:					*server-functions*
	serverlist()		return the list of server names
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Servidor Vim:					*server-functions*
	serverlist()		devuelve una lista con nombres de servidores
	remote_send()		envía órdenes (caracteres) a un servidor Vim
	remote_expr()		evalúa una expresión en un servidor Vim
	server2client()		envía una respuesta a un cliente de un
				servidor Vim
	remote_peek()		comprueba si hay respuestas de un servidor Vim
	remote_read()		lee una respuesta de un servidor Vim
	foreground()		desplaza la ventana de Vim a primer plano
	remote_foreground()	desplaza la ventana de un servidor Vim a primer
				plano</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Window size and position:			*window-size-functions*
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tamaño y posición de ventanas:			*window-size-functions*
	winheight()		obtiene la altura de una ventana específica
	winwidth()		obtiene el ancho de una ventana específica
	winrestcmd()		devuelve una orden para restaurar los tamaños
				de ventana
	winsaveview()		obtiene una vista de la ventana actual
	winrestview()		devuelve una vista almacenada en la ventana
				actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various:					*various-functions*
	mode()			get current editing mode
	visualmode()		last visual mode used
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Varios:					*various-functions*
	mode()			obtiene el modo de edición actual
	visualmode()		último modo visual usado
	hasmapto()		comprueba la existencia de una macro
	mapcheck()		comprueba la existencia de una macro que
				coincida con el argumento dado
	maparg()		obtiene el rhs de una macro
	exists()		comprueba si la variable, función, etc.,
				existe
	has()			comprueba si Vim cuenta con la característica
				dada
	changenr()		devuelve el número correspondiente al cambio
				más reciente
	cscope_connection()	comprueba si hay una conexión a cscope
	did_filetype()		comprueba si se ha usado una orden automática
				FileType
	eventhandler()		comprueba si se ha sido invocado desde un
				manejador de eventos
	getpid()		obtiene el ID de proceso de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>libcall()		call a function in an external library
	libcallnr()		idem, returning a number</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>libcall()		llama a una función en una biblioteca externa
	libcallnr()		idéntica, pero devuelve un número en vez de una
				cadena</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>getreg()		obtiene el contenido de un registro
	getregtype()		obtiene el tipo de un registro
	setreg()		asigna el tipo y contenido de un registro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>taglist()		get list of matching tags
	tagfiles()		get a list of tags files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>taglist()		obtiene una lista de etiquetas coincidentes
	tagfiles()		obtiene una lista de archivos de etiquetas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mzeval()		evaluate |MzScheme| expression</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mzeval()		evalúa una expresión |MzScheme|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.7*	Defining a function</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.7*	Definición de funciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to define your own functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim permite definir nuevas funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic function declaration begins as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La definición básica de una función corresponde a lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
&lt;
	Note:
	Function names must begin with a capital letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function {nombre}({var1}, {var2}, ...)
	:  {instrucciones}
	:endfunction
&lt;
	Nota:
	Los nombres de funciones deben empezar con una letra mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define a short function to return the smaller of two numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a definir una función pequeña que retorne el más pequeño de dos números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It starts with this line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Su definición empieza con esta línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Min(num1, num2)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Min(num1, num2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta le indica a Vim que la función se llama «Min» y que recibe dos
argumentos: «num1» y «num2».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing you need to do is to check to see which number is smaller:
   &gt;
	:  if a:num1 &lt; a:num2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primer paso es comprobar qué número es el más pequeño:
   &gt;
	:   if a:num1 &lt; a:num2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The special prefix "a:" tells Vim that the variable is a function argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El prefijo especial «a:» le indica a Vim que la variable es un argumento de la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assign the variable "smaller" the value of the smallest number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asignemos ahora a la variable «menor» el valor del menor número: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "smaller" is a local variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable «menor» es una variable local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Variables used inside a function are local unless prefixed by something like "g:", "a:", or "s:".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las variables usadas dentro de una función son locales a menos que tengan un prefijo como «g:», «a:», o «s:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Para usar una variable global dentro de una función debe anteponer
	«g:» a su nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dentro de una función, «g:hoy» corresponde a la
	variable global «hoy», y «hoy» es otra variable, local respecto a la
	función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now use the ":return" statement to return the smallest number to the user.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora usamos la instrucción «:return» para devolver el menor de los dos números al usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, you end the function: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Finalmente, terminamos la función: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:  return smaller
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:  return menor
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    let menor = a:num1
	:  else
	:    let menor = a:num2
	:  endif
	:  return menor
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Min(num1, num2)
	:  if a:num1 &lt; a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A user defined function is called in exactly the same way as a built-in function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las funciones definidas por el usuario se invocan exactamente de la misma forma que las funciones internas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the name is different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La única diferencia es el nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Min function can be used like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la función Min como sigue: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo Min(5, 8)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo Min(5, 8)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only now will the function be executed and the lines be interpreted by Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo en este momento se ejecutará la función y Vim interpretará las instrucciones que la componen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are mistakes, like using an undefined variable or function, you will now get an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hay errores, como usar una variable o función no definida, se mostrará un mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When defining the function these errors are not detected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al definir una función estos errores no son detectados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Min(num1, num2, num3)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Min(num1, num2, num3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":call" command can be given a line range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:call» puede recibir un rango de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can have one of two
meanings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este rango puede tener dos
significados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a function has been defined with the "range" keyword, it will
take care of the line range itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando la definición de una función tiene la palabra clave
«range», ésta se hará cargo del rango de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function will be passed the variables "a:firstline" and "a:lastline".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función recibirá las variables «a:firstline» y «a:lastline».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These will have the line numbers from the range the function was called with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éstas
contendrán los números de línea del rango con el cual se invoca la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Contar_palabras() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum &lt;= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "encontradas " . n .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" words"
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" palabras"
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:10,30call Count_words()</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:10,30call Contar_palabras()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will be executed once and echo the number of words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función se ejecutará una vez, y mostrará en la pantalla el número de
palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other way to use a line range is by defining a function without the
"range" keyword.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La otra forma de usar un rango de líneas es definiendo una función sin la
palabra clave «range».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function will be called once for every line in the
range, with the cursor in that line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se invocará la función una vez por cada línea en el
rango, y el cursor estará en la línea correspondiente a cada invocación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function  Number()
	:  echo "line " . line(".") .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function  Numero()
	:  echo "la línea " . line(".") .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" contains: " . getline(".")
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" contiene: " . getline(".")
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:10,15call Number()</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:10,15call Numero()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to define functions that have a variable number of arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim permite la definición de funciones que reciben una cantidad variable de argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following command, for instance, defines a function that must have 1 argument (start) and can have up to 20 additional arguments: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la siguiente orden define una función que debe recibir un argumento (inicio) y puede recibir hasta 20 argumentos adicionales: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Show(start, ...)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Mostrar(inicio, ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable «a:1» contiene el primer argumento opcional, «a:2» contiene el
segundo, y así sucesivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The variable "a:0" contains the number of extra arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable «a:0» contiene la cantidad de
argumentos adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function Show(start, ...)
	:  echohl Title
	:  echo "Show is " . a:start
	:  echohl None
	:  let index = 1
	:  while index &lt;= a:0
	:    echo "  Arg " . index .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function Mostrar(inicio, ...)
	:  echohl Title
	:  echo "inicio es " . a:inicio
	:  echohl None
	:  let indice = 1
	:  while indice &lt;= a:0
	:    echo "  Arg " . indice .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" is " . a:{indice}
	:    let indice = indice + 1
	:  endwhile
	:  echo ""
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses the ":echohl" command to specify the highlighting used for the following ":echo" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí se usa la orden «:echohl», que especifica el resaltado a usar en la siguiente orden «:echo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":echohl None" stops it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:echohl None» hace que no se use resaltado alguno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":echon" command works like ":echo", but doesn't output a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden  «:echon» es similar a «:echo» pero no imprime el cambio de línea final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function
&lt;	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function
&lt;	function Mostrar(inicio, ...) ~
	function ObtenerSangradoVim() ~
	function DefinirSintaxis(nombre) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function SetSyn
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:name ~
	3     endif ~
	   endfunction ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function DefinirSintaxis
&lt;	1     if &amp;syntax == '' ~
	2       let &amp;syntax = a:nombre ~
	3     endif ~
	   endfunction ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line number is useful for when you get an error message or when debugging.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El número de línea de una instrucción es información útil cuando aparece un
mensaje de error o al depurar scripts.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |debug-scripts| about debugging mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Acerca del modo de depurado,
consulte |debug-scripts|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also set the 'verbose' option to 12 or higher to see all function
calls.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede darle un valor de 12 o más a la opción 'verbose' para ver todas las
invocaciones a funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set it to 15 or higher to see every executed line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con un valor de 15 o más verá cada línea ejecutada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:delfunction Show</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:delfunction Mostrar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it can be useful to have a variable point to one function or another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones es útil que una variable pueda hacer referencia a una u otra función .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do it with the function() function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacerlo usando la función function().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It turns the name of a function into a reference: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta función convierte el nombre de una función en una referencia a la misma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let result = 0		" or 1
	:function!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let resultado = 0		" o 1
	:function!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Right()
	:  return 'Right!'
	:endfunc
	:function!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Bien()
	:  return '¡Bien!'
	:endfunc
	:function!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
&lt;	Wrong!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mal()
	:  return '¡Mal!'
	:endfunc
	:
	:if resultado == 1
	:  let Unafunc = function('Bien')
	:else
	:  let Unafunc = function('Mal')
	:endif
	:echo call(Unafunc, [])
&lt;	¡Mal!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the name of a variable that holds a function reference must start
with a capital.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que el nombre de la variable que contiene la referencia a la
función debe empezar con una letra mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise it could be confused with the name of a builtin
function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, es posible
que se confunda con el nombre de una de las funciones integradas de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The way to invoke a function that a variable refers to is with the call()
function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para invocar una función usando una variable con una referencia a función
se usa la función call().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Its first argument is the function reference, the second argument
is a List with arguments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como primer argumento recibe la referencia a la
función, y como segundo argumento una Lista con los argumentos para la función
a invocar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.8*	Lists and Dictionaries</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.8*	Listas y Diccionarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have used the basic types String and Number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hasta ahora hemos usado los tipos básicos, Cadena de texto y Número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim also supports two composite types: List and Dictionary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim también ofrece otros dos: Lista y Diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A List is an ordered sequence of things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una Lista es una secuencia ordenada de elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The things can be any kind of value, thus you can make a List of numbers, a List of Lists and even a List of mixed items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos pueden ser de cualquier tipo, así que puede crear una Lista de números, una Lista de Listas e incluso una Lista de elementos de tipos diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a List with three strings: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para crear una Lista con tres cadenas de texto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = ['aap', 'mies', 'noot']</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = ['aap', 'mies', 'noot']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The List items are enclosed in square brackets and separated by commas.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos de la Lista se rodean con corchetes y se separan con comas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create an empty List: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para crear una Lista vacía: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = []</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = []</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
&lt;	['foo', 'bar'] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = []
	:call add(lista, 'foo')
	:call add(lista, 'bar')
	:echo lista
&lt;	['foo', 'bar'] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo alist + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo lista + ['foo', 'bar']
&lt;	['foo', 'bar', 'foo', 'bar'] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
&lt;	['one', 'two', 'three'] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = ['uno']
	:call extend(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', 'dos', 'tres'] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
&lt;	['one', ['two', 'three']] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = ['uno']
	:call add(lista, ['dos', 'tres'])
	:echo lista
&lt;	['uno', ['dos', 'tres']] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
&lt;	one ~
	two ~
	three ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = ['uno', 'dos', 'tres']
	:for n in lista
	:  echo n
	:endfor
&lt;	uno ~
	dos ~
	tres ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will loop over each element in List "alist", assigning the value to variable "n".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código mostrado iterará sobre cada elemento en la Lista «lista», asignando el valor del elemento a la variable «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generic form of a for loop is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma genérica de un ciclo «for» es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for {varname} in {listexpression}
	:  {commands}
	:endfor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for {nombrevar} in {expresiónlista}
	:  {instrucciones}
	:endfor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To loop a certain number of times you need a List of a specific length.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para iterar una cantidad determinada de veces necesita una Lista con una longitud específica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The range() function creates one for you: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función range() puede crearla por usted: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for a in range(3)
	:  echo a
	:endfor
&lt;	0 ~
	1 ~
	2 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que el primer elemento de la Lista creada por range() es cero, y por
tanto el último elemento tiene un valor de uno menos que la longitud de la
lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify the maximum value, the stride and even go backwards: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede especificar el valor máximo, y el incremento o decremento
deseado: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for a in range(8, 4, -2)
	:  echo a
	:endfor
&lt;	8 ~
	6 ~
	4 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for line in getline(1, 20)
	:  if line =~ "Fecha: "
	:    echo matchstr(line, 'Fecha: \zs.*')
	:  endif
	:endfor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Dictionary stores key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un Diccionario almacena pares clave-valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can quickly lookup a value if you know the key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite obtener un valor almacenado de manera rápida, si conoce la clave del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Dictionary is created with curly braces: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los Diccionarios se crean usando llaves: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let es2nl = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo uk2nl['two']
&lt;	twee ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo es2nl['dos']
&lt;	twee ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{&lt;key&gt; : &lt;value&gt;, ...}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{&lt;clave&gt; : &lt;valor&gt;, ...}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The possibilities with Dictionaries are numerous.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los Diccionarios ofrecen numerosas posibilidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various functions for them as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También dispone de varias funciones para operar sobre ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can obtain a list of the keys and loop over them: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, puede obtener una lista de las claves e iterar sobre ellas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for key in keys(uk2nl)
	:  echo key
	:endfor
&lt;	three ~
	one ~
	two ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for clave in keys(es2nl)
	:  echo clave
	:endfor
&lt;	tres ~
	uno ~
	dos ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the keys are not ordered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habrá notado que las claves no están ordenadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can sort the list to get a specific order: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ordenar la lista para obtener un orden específico: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
&lt;	one ~
	three ~
	two ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:for clave in sort(keys(es2nl))
	:  echo clave
	:endfor
&lt;	dos ~
	tres ~
	uno ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you can never get back the order in which items are defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es posible recuperar el orden en el cual se definieron los elementos del Diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that you need to use a List, it stores items in an ordered sequence.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eso necesita una Lista, que almacena los elementos en una secuencia ordenada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo uk2nl['one']
&lt;	een ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo es2nl['uno']
&lt;	een ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo uk2nl.one
&lt;	een ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo es2nl.uno
&lt;	een ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works for a key that is made of ASCII letters, digits and the underscore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funciona con claves compuestas de caracteres ASCII, dígitos, y el guión bajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also assign a new value this way: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar esta notación para asignar valores: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let uk2nl.four = 'vier'
	:echo uk2nl
&lt;	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let es2nl.cuatro = 'vier'
	:echo es2nl
&lt;	{'tres': 'drie', 'cuatro': 'vier', 'uno': 'een', 'dos': 'twee'} ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:function es2nl.traducir(linea) dict
	:  return join(map(split(a:linea), 'get(self, v:val, "???")'))
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo uk2nl.translate('three two five one')
&lt;	drie twee ??? een ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo es2nl.traducir('tres dos cinco uno')
&lt;	drie twee ??? een ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first special thing you notice is the "dict" at the end of the ":function"
line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que habrá notado primero es el «dict» al final de la línea «:function».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This marks the function as being used from a Dictionary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así se indica que la función será usada desde un Diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "self"
local variable will then refer to that Dictionary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La variable
local «self» se referirá a dicho diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's break up the complicated return command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, dividamos esa compleja instrucción de retorno: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>split(a:line)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>split(a:linea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The split() function takes a string, chops it into white separated words and returns a list with these words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función split() toma una cadena, la divide en palabras separadas por espacios en blanco, y entrega una lista con estas palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus in the example it returns: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo previo, entrega: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo split('three two five one')
&lt;	['three', 'two', 'five', 'one'] ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo split('tres dos cinco uno')
&lt;	['tres', 'dos', 'cinco', 'uno'] ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This list is the first argument to the map() function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta lista es el primer argumento para la función map().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will go through the list, evaluating its second argument with "v:val" set to the value of each item.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dicha función analizará la lista, evaluando su segundo argumento con la variable «v:val» definida con el valor de cada elemento en la lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a shortcut to using a for loop.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es una abreviación de un ciclo for.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta instrucción: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = map(split(a:line), 'get(self, v:val, "???")')</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = map(split(a:linea), 'get(self, v:val, "???")')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let lista = split(a:linea)
	:for ind in range(len(lista))
	:  let lista[ind] = get(self, lista[ind], "???")
	:endfor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The get() function checks if a key is present in a Dictionary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función get() comprueba si una clave existe en un Diccionario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is, then the value is retrieved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si existe, devuelve el valor asociado a la clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it isn't, then the default value is returned, in the example it's '???'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no existe, devuelve el valor definido como predeterminado, que en el ejemplo es '???'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a convenient way to handle situations where a key may not be present and you don't want an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite manejar de una forma conveniente las situaciones en que una clave no existe y no desea hacer el manejo del error que provocaría dicha situación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La función join() es el complemento de split(): une una lista de palabras,
separándolas con un espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La combinación de split(), map(), y join() es una forma elegante de filtrar
una cadena de palabras de manera sucinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que podemos guardar valores y funciones en un Diccionario, podemos usar
un Diccionario como un objeto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Above we used a Dictionary for translating Dutch to English.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Anteriormente hicimos uso de un Diccionario para traducir texto de Holandés
a Español.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We might want
to do the same for other languages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Querríamos hacer lo mismo para otros idiomas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero crearemos un
objeto (esto es, un Diccionario) que tenga la función traducir, pero no tenga
palabras para traducir: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let dicctraductor = {}
	:function dicctraductor.traducir(linea) dict
	:  return join(map(split(a:linea),
			\ 'get(self.palabras, v:val, "???")'))
	:endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's slightly different from the function above, using 'self.words' to lookup word translations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La definición es ligeramente diferente de la función anterior, ya que usa 'self.words' para buscar las traducciones de palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But we don't have a self.words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero no hay un self.words.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you could call this an abstract class.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por esto decir que el Diccionario es una clase abstracta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
&lt;	drie een ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let es2nl = copy(dicctraductor)
	:let es2nl.words = {'uno': 'een', 'dos': 'twee', 'tres': 'drie'}
	:echo es2nl.translate('tres uno')
&lt;	drie een ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
&lt;	drei ein ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let es2de = copy(dicctraductor)
	:let es2de.words = {'uno': 'ein', 'dos': 'zwei', 'tres': 'drei'}
	:echo es2de.translate('tres uno')
&lt;	drei ein ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You see that the copy() function is used to make a copy of the "transdict" Dictionary and then the copy is changed to add the words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver que la función copy() se usa para crear una copia del Diccionario «dicctraductor» y luego se cambia la copia, añadiendo las palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original remains the same, of course.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El original, por supuesto, permanece intacto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
&lt;	een twee drie ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if $LANG =~ "de"
	:  let trad = es2de
	:else
	:  let trad = es2nl
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	een twee drie ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here "trans" refers to one of the two objects (Dictionaries).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí «trad» se refiere a uno de dos posibles objetos (Diccionarios).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No copy is made.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se hace ninguna copia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about List and Dictionary identity can be found at |list-identity| and |dict-identity|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar más información acerca de la identidad de Listas y Diccionarios en |list-identity| y |dict-identity|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you might use a language that isn't supported.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que use un idioma que aún no esté incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can overrule the translate() function to do nothing: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para este caso, puede redefinir la función traducir() para que no haga nada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
&lt;	three one wladiwostok ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let es2es = copy(dicctraductor)
	:function! es2es.traducir(linea)
	:  return a:linea
	:endfunction
	:echo es2es.traducir('tres one wladiwostok')
&lt;	tres uno wladiwostok ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a ! was used to overwrite the existing function reference.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Note el «!» utilizado para redefinir la referencia a función existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use "uk2uk" when no recognized language is found: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar «es2es» cuando no se encuentra ningún idioma reconocido: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
&lt;	one two three ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if $LANG =~ "de"
	:  let trad = es2de
	:elseif $LANG =~ "nl"
	:  let trad = es2nl
	:else
	:  let trad = es2es
	:endif
	:echo trad.traducir('uno dos tres')
&lt;	uno dos tres ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.9*	Exceptions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.9*	Excepciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:try
	:   read ~/plantillas/pascal.tmpl
	:catch /E484:/
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":read" command will fail if the file does not exist.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:read» (leer) fallará si el archivo no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of generating an error message, this code catches the error and gives the user a nice message instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En vez de mostrar un mensaje de error, este código atrapa el error y le muestra al usuario un mensaje más agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the commands in between ":try" and ":endtry" errors are turned into exceptions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para las instrucciones entre «:try» y «:endtry» los errores se convierten en excepciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An exception is a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una excepción es una cadena de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of an error the string contains the error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando aparece un error esta cadena contiene el mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And every error message has a number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y cada mensaje de error tiene un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the error we catch contains "E484:".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, el error que atrapamos contiene «E484:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This number is guaranteed to stay the same (the text may change, e.g., it may be translated).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim garantiza que este número permanece inalterado (el texto del mensaje de error puede cambiar, por ejemplo, puede haber sido traducido.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the ":read" command causes another error, the pattern "E484:" will not match in it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando la orden «:read» genera un error distinto, el patrón «E484:» no coincidirá con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus this exception will not be caught and result in the usual error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La excepción no será atrapada y aparecerá el mensaje de error habitual en esos casos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:try
	:   read ~/plantillas/pascal.tmpl
	:catch
	:   echo «Lo siento, no encuentro el archivo plantilla para Pascal.»
	:endtry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means all errors are caught.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta forma se atrapan todos los errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But then you will not see errors that are useful, such as "E21: Cannot make changes, 'modifiable' is off".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero al hacerlo no verá errores que son útiles, como por ejemplo «E21: No se pudo modificar, 'modifiable' está desactivado»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This filters the lines from the cursor until the end of the file through the "filter" command, which takes a file name argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí se filtran las líneas desde el cursor hasta el final del archivo usando la orden «filter», que toma como argumento un nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No matter if the filtering works, something goes wrong in between ":try" and ":finally" or the user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is always executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa si el filtrado funciona, si algo sale mal entre «:try» y «:finally», o si el usuario cancela el filtrado presionando CTRL-C, la instrucción «call delete(tmp)» siempre se ejecuta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes sure you don't leave the temporary file behind.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así se asegura de que no queden archivos temporales al acabar el proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.10*	Various remarks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.10*	Observaciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a summary of items that apply to Vim scripts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación tiene un resumen de los elementos relevantes para escribir scripts de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They are also mentioned elsewhere, but form a nice checklist.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También se los menciona en otros lugares de la documentación, pero aquí se presentan como una conveniente lista.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end-of-line character depends on the system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter de fin de línea usado depende del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix a single &lt;NL&gt; character is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En sistemas Unix se usa &lt;NL&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For MS-DOS, Windows, OS/2 and the like, &lt;CR&gt;&lt;LF&gt; is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-DOS, Windows, OS/2 y similares, se usa &lt;CR&gt;&lt;LF&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is important when using mappings that end in a &lt;CR&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éste es un detalle importante a considerar al usar macros que terminan en &lt;CR&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |:source_crnl|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |:source_crnl|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Leading whitespace characters (blanks and TABs) are always ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los espacios en blanco al principio de cada línea (espacios y tabulados) siempre se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in the example below) are reduced to one blank character and plays the role of a separator, the whitespaces after the last (visible) character may or may not be ignored depending on the situation, see below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los espacios en blanco entre parámetros (por ejemplo, entre 'set' y 'cpoptions' en el ejemplo a continuación) se reducen a un solo espacio blanco que actúa como separador, los espacios en blanco después del último carácter (visible) se pueden o no ignorar dependiendo del caso, véase a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set cpoptions    =aABceFst</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set cpoptions    =aABceFst</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the whitespace immediately before the "=" sign is ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>se ignora el espacio en blanco inmediatamente antes del símbolo «=».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But there can be no whitespace after the "=" sign!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Pero no puede haber espacios a continuación del símbolo «=»!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=my\ nice\ file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=mi\ lindo\ archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=my nice file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=mi lindo archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tags=my
	:set nice
	:set file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tags=mi
	:set lindo
	:set archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character " (the double quote mark) starts a comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter " (comilla doble) marca el inicio de un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Everything after and including this character until the end-of-line is considered a comment and is ignored, except for commands that don't consider comments, as shown in examples below.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo lo que aparece a continuación de éste carácter hasta el fin de línea, e incluyéndola, se considera un comentario y es ignorado, a excepción de las órdenes que no tienen en cuenta los comentarios, como se puede ver en ejemplos de esta sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A comment can start on any character position on the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un comentario puede empezar en cualquier punto de una línea de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a little "catch" with comments for some commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño «pero» con los comentarios y ciertas órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbrev dev development		" shorthand
	:map &lt;F3&gt; o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbrev des desarrollo		" abreviación
	:map &lt;F3&gt; o#include		" insertar directiva include
	:execute orden			" ejecutar
	:!ls *.c			" listar archivos C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The abbreviation 'dev' will be expanded to 'development     " shorthand'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La abreviación 'dev' se expandirá a 'desarrollo     " abreviación'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
mapping of &lt;F3&gt; will actually be the whole line after the 'o# ....' including
the '" insert include'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
macro &lt;F3&gt; constará en realidad de toda la línea desde 'o# ....' incluyendo
'" insertar directiva include'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "execute" command will give an error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «execute» provocará un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
orden «!» enviará todos los caracteres a continuación al intérprete de
órdenes, provocando un error debido al carácter '"' sin la comilla de cierre
correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No pueden existir comentarios a continuación de las órdenes «:map»,
«:abbreviate», «:execute», ni «!» (hay algunas órdenes más con esta
restricción).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the
":map", ":abbreviate" and ":execute" commands there is a trick: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para el caso de las órdenes «:map», «:abbreviate», y «:execute»
hay un truco disponible: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbrev dev development|" shorthand
	:map &lt;F3&gt; o#include|" insert include
	:execute cmd			|" do it</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbrev des desarrollo|" abreviación
	:map &lt;F3&gt; o#include|" insertar directiva include
	:execute orden			|" ejecutar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the '|' character the command is separated from the next one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter «|» permite separar órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And that
next command is only a comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, la siguiente orden es
simplemente un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the last command you need to do two
things: |:execute| and use '|': &gt;
	:exe '!ls *.c'			|" list C files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para la última orden hay que hacer dos cosas:
|:execute| y usar «|»: &gt;
	:exe '!ls *.c'			|" listar archivos C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no white space before the '|' in the abbreviation and mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que no hay espacios en blanco antes de «|» en la abreviación ni en la macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For these commands, any character until the end-of-line or '|' is included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En estas órdenes, se incluye cualquier carácter hasta el fin de línea o hasta «|».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence of this behavior, you don't always see that trailing whitespace is included: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como consecuencia de este comportamiento, no siempre es visible cuándo se incluyen espacios en blanco al final del a línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;F4&gt; o#include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;F4&gt; o#include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix there is one special way to comment a line, that allows making a Vim
script executable: &gt;
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix hay una forma especial de hacer un comentario, que permite hacer que
un script de Vim sea ejecutable: &gt;
	#!/usr/bin/env vim -S
	echo "este es un script de Vim"
	quit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "#" command by itself lists a line with the line number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por sí misma, la orden «#» muestra una línea junto con su número de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding an exclamation mark changes it into doing nothing, so that you can add the shell command to execute the rest of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al añadirle un símbolo de exclamación su comportamiento cambia y no tiene efecto, así que puede añadir la orden de intérprete de órdenes para ejecutar el resto del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:#!| |-S|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:#!| |-S|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map ,ab o#include
	:unmap ,ab</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map ,ab o#include
	:unmap ,ab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the unmap command will not work, because it tries to unmap ",ab ".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí la orden unmap no funcionará, porque trata de eliminar la macro «,ab ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does not exist as a mapped sequence.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta no existe como secuencia de ninguna macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An error will be issued, which is very hard to identify, because the ending whitespace character in ":unmap ,ab " is not visible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se mostrará un error, que es muy difícil de identificar, porque el carácter de espacio final en «:unmap ,ab» no es visible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unmap ,ab     " comment</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unmap ,ab     " comentario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here the comment part will be ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte correspondiente al comentario será ignorada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, Vim will try to unmap
',ab     ', which does not exist.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, Vim tratará
de eliminar la macro ',ab     ', que no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rewrite it as: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe reescribir la orden como:  &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unmap ,ab|    " comment</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unmap ,ab|    " comentario</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you want to make a change and go back to where cursor was.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ocasiones es deseable hacer un cambio y volver al sitio en que el cursor se
encontraba inicialmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Restoring the relative position would also be nice, so that the same line
appears at the top of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuperar la posición relativa también sería
agradable, de tal forma que la misma línea inicial aparezca al inicio de la
ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This example yanks the current line, puts it above the first line in the
file and then restores the view: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este ejemplo copia la línea actual, la inserta antes de la primera línea en
el archivo y después restaura la vista original: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>map ,p ma"aYHmbgg"aP`bzt`a</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>map ,p ma"aYHmbgg"aP`bzt`a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What this does: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es lo que hace: &gt;
	ma"aYHmbgg"aP`bzt`a
&lt;	ma			pone una marca en la posición actual del
				cursor
	  "aY			copia la línea actual al registro a
	     Hmb		va hasta la primera línea que se ve en la
				ventana y pone la marca b allí
		gg		va a la primera línea del archivo
		  "aP		pega la línea copiada por encima de la línea
		     `b		vuelve a la línea superior de la vista inicial
		       zt	ubica dicha línea como la primera de la
				ventana
			 `a	vuelve a la posición del cursor almacenada
				originalmente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que los nombres de funciones que defina interfieran con
otras funciones, use el siguiente esquema:
- Anteponga una cadena única a cada nombre de función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I often use an
  abbreviation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A menudo uso una
  abreviatura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "OW_" is used for the option window functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, uso «OV» para las funciones relacionadas con
  opciones de ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Put the definition of your functions together in a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Ponga todas las definiciones de sus funciones en un mismo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set a global
  variable to indicate that the functions have been loaded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cree una
  variable global para indicar que las funciones ya fueron cargadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When sourcing the
  file again, first unload the functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando
  cargue el archivo de nuevo, elimine antes las definiciones de las funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" This is the XXX package</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" Este es el paquete XXX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if exists("XXX_cargado")
	  delfun XXX_uno
	  delfun XXX_dos
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function XXX_one(a)
		... body of function ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function XXX_uno(a)
		... cuerpo de la función ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function XXX_two(b)
		... body of function ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function XXX_dos(b)
		... cuerpo de la función ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let XXX_loaded = 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let XXX_loaded = 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.11*	Writing a plugin				*write-plugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.11*	Escribir extensiones				*write-plugin*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write a Vim script in such a way that many people can use it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear un script de Vim de tal forma que lo puedan usar varias personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called a plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se llama una extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim users can drop your script in their plugin directory and use its features right away |add-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los usuarios de Vim pueden copiar el script en su directorio «plugin/», y utilizarlo en el momento con |add-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section the first type is explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta sección se describirán las extensiones globales («global plugins»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most items are also relevant for writing filetype plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría de elementos también son necesarios para escribir extensiones de tipo de archivo («filetype plugins»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The specifics for filetype plugins are in the next section |write-filetype-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La sección a continuación, |write-filetype-plugin|, detalla las extensiones de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all you must choose a name for your plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero, debe elegir un nombre para su extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The features provided by the plugin should be clear from its name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre debería mostrar las funcionalidades ofrecidas por la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And it should be unlikely that someone else writes a plugin with the same name but which does something different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así mismo, debería ser poco probable que alguien escriba una extensión con el mismo nombre pero otras funcionalidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And please limit the name to 8 characters, to avoid problems on old Windows systems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, limite el nombre a ocho caracteres para evitar problemas en antiguos sistemas de Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A script that corrects typing mistakes could be called "typecorr.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un script que corrige errores tipográficos se podría llamar «correccort.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will use it here as an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo usaremos como ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>14	iabbrev csaa casa
 15	iabbrev ootr otro
 16	iabbrev qeu que
 17	iabbrev sicronizacion
 18		\ sincronización
 19	let s:cuenta = 4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will probably add new corrections to the plugin and soon have several versions laying around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo más probable es que añada nuevas correcciones a la extensión, y tenga en poco tiempo varias versiones de ésta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And when distributing this file, people will want to know who wrote this wonderful plugin and where they can send remarks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando distribuya el archivo, la gente querrá saber quién escribió esta maravillosa extensión, y dónde pueden enviar comentarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, put a header at the top of your plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, incluya un encabezado al principio de su extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1	" Extensión global de Vim para la corrección de errores
  2	" Último cambio:	15 de octubre de 2000
  3	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About copyright and licensing: Since plugins are very useful and it's hardly worth restricting their distribution, please consider making your plugin either public domain or use the Vim |license|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Derechos de autor y licencias: Debido a que las extensiones son útiles, y que no merece la pena restringir su distribución, considere que su extensión sea de dominio público, o use la licencia de Vim (|license|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A short note about this near the top of the plugin should be sufficient.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una breve nota cerca del inicio de la extensión debería servir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>4	" License:	This file is placed in the public domain.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>4	" Licencia:	Este fichero pertenece al dominio público.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CONTINUACIÓN DE LÍNEA, EVITAR EFECTOS SECUNDARIOS	*use-cpo-save*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In line 18 above, the line-continuation mechanism is used |line-continuation|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la línea 18 del ejemplo anterior se usa el mecanismo |line-continuation|, continuación de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users with 'compatible' set will run into trouble here, they will get an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los usuarios que definan 'compatible' pueden encontrar problemas con esto, y se les mostraría un mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can't just reset 'compatible', because that has a lot of side effects.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No podemos simplemente reiniciar 'compatible' porque tiene muchos efectos secundarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this, we will set the 'cpoptions' option to its Vim default value and restore it later.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitarlo, definimos la opción 'cpoptions' con el valor predeterminado de Vim para restaurarlo más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That will allow the use of line-continuation and make the script work for most people.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite el uso de «line-continuation» y que el script funcione en la mayoría de sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is done like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se hace de la siguiente forma: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>11	let s:save_cpo = &amp;cpo
 12	set cpo&amp;vim
 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>42	let &amp;cpo = s:save_cpo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>42	let &amp;cpo = s:save_cpo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We first store the old value of 'cpoptions' in the s:save_cpo variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero almacenamos el valor antiguo de 'cpoptions'  en la variable «s:save_cpo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the end of the plugin this value is restored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor se restaurará al final de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a script-local variable is used |s:var|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que se usa una variable local de script, |s:var|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A global variable could already be in use for something else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que se esté utilizando una variable global para otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Always use script-local variables for things that are only used in the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use siempre variables locales en el script para aquello que se usa sólo en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's possible that a user doesn't always want to load this plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible que el usuario no desee cargar la extensión en cada momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or the system administrator has dropped it in the system-wide plugin directory, but a user has his own plugin he wants to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O que el administrador del sistema lo haya copiado al directorio de extensiones del sistema, pero el usuario quiere usar el suyo propio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the user must have a chance to disable loading this specific plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ese caso, el usuario debe tener la posibilidad de desactivar cargar esta extensión en particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make it possible: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo siguiente lo hace posible: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>6	if exists("g:loaded_correccort")
  7	  finish
  8	endif
  9	let g:loaded_correccort = 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name is recommended to start with "loaded_" and then the file name of the plugin, literally.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda que el nombre empiece con «loaded_» y, a continuación, el nombre literal de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "g:" is prepended just to avoid mistakes when using the variable in a function (without "g:" it would be a variable local to the function).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «g:» se añade para evitar errores al usar la variable en una función (sin la «g:», sería una variable local a la función).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's make the plugin more interesting: We will add a mapping that adds a correction for the word under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, vamos a hacer que la extensión sea más interesante: vamos a añadir una macro que añade una corrección para la palabra bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We could just pick a key sequence for this mapping, but the user might already use it for something else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Podríamos escoger una secuencia de teclas para esta macro, pero puede que el usuario la esté usando para otra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To allow the user to define which keys a mapping in a plugin uses, the &lt;Leader&gt; item can be used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el elemento &lt;Leader&gt; para permitir que el usuario pueda definir las teclas que utiliza la macro de una extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user can set the "mapleader" variable to the key sequence that he wants this mapping to start with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario puede definir la variable «mapleader» con la secuencia de teclas con la que desea iniciar esta macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if the user has done: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, si el usuario define: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let mapleader = "_"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let mapleader = "_"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the mapping will define "_a".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>la macro se definirá como «_a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the user didn't do this, the default value will be used, which is a backslash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario se usará el valor predeterminado, que es una barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then a map for "\a" will be defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, se definiría una macro como «\a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that &lt;unique&gt; is used, this will cause an error message if the mapping already happened to exist.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta se usa &lt;unique&gt;, lo que provocaría un mensaje de error si la macro ya existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:map-&lt;unique&gt;|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:map-&lt;unique&gt;|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
 23	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>21	if !hasmapto('&lt;Plug&gt;CorreccortAñadir')
 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;CorreccortAñadir
 23	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This checks if a mapping to "&lt;Plug&gt;TypecorrAdd" already exists, and only defines the mapping from "&lt;Leader&gt;a" if it doesn't.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto comprueba si ya existe una macro para «&lt;Plug&gt;CorrecortAñadir», y sólo define la macro de «&lt;Leader&gt;a» si no existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user then has a chance of putting this in his vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, el usuario tiene la posibilidad de insertar esto en su archivo «vimrc»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>map ,c  &lt;Plug&gt;TypecorrAdd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>map ,c  &lt;Plug&gt;CorreccortAñadir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>30	function s:Anadir(desde, correccion)
 31	  let a = input("Introduzca la corrección para " . a:desde .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>": ")
 32	  exe ":iabbrev " . a:from .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>": ")
 32	  exe ":iabbrev " . a:desde .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" " . to
 ..</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" " . a
 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>36	endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>36	endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we can call the function s:Add() from within this script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora invocamos la función «s:Anadir()» desde el mismo script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If another script also defines s:Add(), it will be local to that script and can only be called from the script it was defined in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si otro script también define «s:Anadir()», será local a ese script y solo se invocará desde el script en el que se define.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can also be a global Add()  function (without the "s:"), which is again another function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede existir una función global «Anadir()» (sin la «s:»), que es otra función distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt; can be used with mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar &lt;SID&gt; en una macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a script ID, which identifies the current script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Genera un identificador de script, que identifica al script actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our typing correction plugin we use it like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En nuestra extensión de corrección usaremos algo similar a esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
 ..</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;CorreccortAñadir  &lt;SID&gt;Añadir
 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>28	noremap &lt;SID&gt;Añadir  :call &lt;SID&gt;Anadir(expand("&lt;cword&gt;"), 1)&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\a -&gt; &lt;Plug&gt;CorreccortAñadir -&gt; &lt;SID&gt;Añadir -&gt; :call &lt;SID&gt;Anadir()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that instead of s:Add() we use &lt;SID&gt;Add() here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que se usó «&lt;SID&gt;Anadir()» en lugar de «s:Anadir()» aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is because the mapping is typed by the user, thus outside of the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Eso es porque la macro es tecleada por el usuario, y por ello, se hace desde fuera del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;SID&gt; is translated to the script ID, so that Vim knows in which script to look for the Add() function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; se expande al identificador del script, de forma que Vim sabe en qué script buscar la función «Anadir()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a bit complicated, but it's required for the plugin to work together with other plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un poco complicado, pero es necesario para que la extensión funcione adecuadamente con otras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic rule is that you use &lt;SID&gt;Add() in mappings and s:Add() in other places (the script itself, autocommands, user commands).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La norma básica es que debe usar &lt;SID&gt;Anadir() en las macros y s:Anadir() en otros sitios (el mismo script, órdenes automáticas, órdenes de usuario).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>26	noremenu &lt;script&gt; Plugin.Añadir\ Corrección      &lt;SID&gt;Añadir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Plugin" menu is recommended for adding menu items for plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda el menú «Plugin» para añadir elementos de menú de extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case only one item is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, sólo se usa un elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding more items, creating a submenu is recommended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recomendamos crear un menú secundario si añade más elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "Plugin.CVS" could be used for a plugin that offers CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, podría usar «Plugin.CVS» para una extensión que ofrezca operaciones CVS como «Plugin.CVS.checkin», «Plugin.CVS.checkout», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt; AND &lt;Plug&gt;					*using-&lt;Plug&gt;*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; Y &lt;Plug&gt;						*using-&lt;Plug&gt;*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both &lt;SID&gt; and &lt;Plug&gt; are used to avoid that mappings of typed keys interfere with mappings that are only to be used from other mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; y &lt;Plug&gt; se usan para evitar que las macros de las teclas pulsadas interfieran con macros sólo usadas desde otras macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the difference between using &lt;SID&gt; and &lt;Plug&gt;:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Note la diferencia entre &lt;SID&gt; y &lt;Plug&gt;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Plug&gt;	is visible outside of the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Plug&gt;	es visible fuera del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is used for mappings which the
	user might want to map a key sequence to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se usa para macros que el usuario
	pueda querer ligar a un secuencia de teclas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Plug&gt; is a special code
	that a typed key will never produce.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Plug&gt; es un código
	especial que una tecla nunca podrá producir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: &lt;Plug&gt; scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que otras extensiones usen la misma secuencia de
	caracteres, use la estructura: &lt;Plug&gt; nombre-script nombre-macro
	En nuestro ejemplo, el nombre del script es «Correccort», y el nombre
	de la macro es «Añadir».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This results in "&lt;Plug&gt;TypecorrAdd".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es «&lt;Plug&gt;CorreccortAñadir».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solo el primer carácter de los
	nombres es mayúscula, facilitando ver el principio del nombre de la
	macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt;	is the script ID, a unique identifier for a script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt; es el identificador (ID) del script, un número único.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally Vim translates &lt;SID&gt; to "&lt;SNR&gt;123_", where "123" can be any
	number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Internamente, Vim traduce &lt;SID&gt; como «&lt;SNR&gt;123_», donde «123»
	puede ser cualquier número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus a function "&lt;SID&gt;Add()" will have a name "&lt;SNR&gt;11_Add()"
	in one script, and "&lt;SNR&gt;22_Add()" in another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, la función «&lt;SID&gt;Anadir()»
	tendría el nombre «&lt;SNR&gt;11_Anadir()» en un script, y «&lt;SNR&gt;22_Anadir()»
	en otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see this if
	you use the ":function" command to get a list of functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede verlo si usa la orden «:function» para obtener la lista de
	funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
	translation of &lt;SID&gt; in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La traducción de &lt;SID&gt; en las macros es idéntica, y así puede invocar
	una función local de un script mediante una macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
 40	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>38	if !exists(":Corregir")
 39	  command -nargs=1  Corregir  :call s:Anadir(&lt;q-args&gt;, 0)
 40	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user command is defined only if no command with the same name already exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden de usuario se define únicamente si no existe una orden con el mismo nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise we would get an error here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, provocaría un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overriding the existing user command with ":command!" is not a good idea, this would probably make the user wonder why the command he defined himself doesn't work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sobrescribir la orden de usuario existente con «:command!» no es una buena idea, ya que haría que el usuario se pregunte porqué no funciona la orden que ha definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:command|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:command|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fun is that these variables can also be used in functions, autocommands and user commands that are defined in the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo interesante es que estas variables se pueden usar en funciones, órdenes automáticas y órdenes de usuario definidas en el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our example we can add a few lines to count the number of corrections: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En nuestro ejemplo, añadimos unas pocas líneas para contar el número de correcciones: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>19	let s:count = 4
 ..</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>19	let s:cuenta = 4
 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>30	function s:Add(from, correct)
 ..</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>30	function s:Anadir(desde, correccion)
 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>34	  let s:count = s:count + 1
 35	  echo s:count .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>34	  let s:cuenta = s:cuenta + 1
 35	  echo s:cuenta .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" corrections now"
 36	endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" correcciones en este punto"
 36	endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First s:count is initialized to 4 in the script itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al principio, «s:cuenta» se inicializa en el mismo script con un valor de 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When later the s:Add() function is called, it increments s:count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al invocar la función «Anadir()» posteriormente, incrementa la variable «s:cuenta».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It doesn't matter from where the function was called, since it has been defined in the script, it will use the local variables from this script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No importa desde dónde se ha invocado la función, ya que está definida en el script, y usará las variables locales al script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Line 33 wasn't explained yet.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún no hemos explicado la línea 33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It applies the new correction to the word under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aplica la nueva corrección a la palabra bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:normal| command is used to use the new abbreviation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden |:normal| se emplea para usar la nueva abreviatura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that mappings and abbreviations are expanded here, even though the function was called from a mapping defined with ":noremap".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que aquí se expanden las macros y abreviaturas, a pesar de que la función se ha invocado desde una macro definida con «:noremap».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "unix" for the 'fileformat' option is recommended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda usar «unix» como valor para la opción 'fileformat'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim scripts will then work everywhere.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta forma, los scripts de Vim funcionarán en cualquier sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scripts with 'fileformat' set to "dos" do not work on Unix.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los scripts con 'fileformat' definido como «dos» no funcionarán en Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see |:source_crnl|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede consultar |:source_crnl|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be sure it is set right, do this before writing the file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para asegurar que hace lo correcto, haga lo siguiente antes de escribir el archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set fileformat=unix</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set fileformat=unix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DOCUMENTATION						*write-local-help*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DOCUMENTACIÓN   					*write-local-help*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1	*correcort.txt*	Una extensión para corregir errores ortográficos
  2
  3	Esta extensión corrige automáticamente cualquier error ortográfico
  4	que pueda escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>5
  6	There are currently only a few corrections.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>5
  6	Solo hay unas pocas correcciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add your own if you like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir las suyas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>7
  8	Mappings:
  9	&lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd
 10		Add a correction for the word under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>7
  8	Macros:
  9	&lt;Leader&gt;a   o   &lt;Plug&gt;CorreccortAñadir
 10		Añade una corrección para la palabra bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>11
 12	Órdenes:
 13	:Corregir {palabra}
 14		Añade una corrección para {palabra}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>15
 16							*correcort-opciones*
 17	Esta extensión no tiene opciones de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first line is actually the only one for which the format matters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, la primera línea es la única en la que el formato importa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of help.txt |local-additions|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se extraerá del archivo de ayuda para su ubicación en la sección «LOCAL ADDITIONS:» de help.txt |local-additions|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first "*" must be in the first column of the first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primer asterisco debe estar en la primera columna de la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After adding your help file do ":help" and check that the entries line up nicely.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecute «:help» después de añadir su archivo de ayuda y compruebe que las entradas están alineadas adecuadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using references to other parts of the help in || is recommended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda utilizar referencias a otras partes de archivos de ayuda mediante barras, ||.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes it easy for the user to find associated help.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto facilita que el usuario encuentre ayuda relacionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FILETYPE DETECTION					*plugin-filetype*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIÓN DE TIPO DE ARCHIVO			*plugin-filetype*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your filetype is not already detected by Vim, you should create a filetype detection snippet in a separate file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim no detecta su tipo de archivo, debería crear un fragmento de código de detección de tipo de archivo en un archivo separado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is usually in the form of an autocommand that sets the filetype when the file name matches a pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, tiene la forma de una orden automática que define el tipo de archivo cuando su nombre concuerda con un patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>au BufNewFile,BufRead *.foo			set filetype=foofoo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>au BufNewFile,BufRead *.foo			set filetype=foofoo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write this single-line file as "ftdetect/foofoo.vim" in the first directory that appears in 'runtimepath'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba este archivo de una sola línea como «ftdetect/foofoo.vim» en el primer directorio que aparece en su 'runtimepath'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix that would be "~/.vim/ftdetect/foofoo.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, sería «~/.vim/ftdetect/foofoo.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The convention is to use the name of the filetype for the script name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La convención es nombrar el script como el nombre del tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make more complicated checks if you like, for example to inspect the contents of the file to recognize the language.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo desea, puede hacer comprobaciones más complejas como inspeccionar los contenidos de un archivo para reconocer el tipo del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see |new-filetype|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte también |new-filetype|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUMMARY							*plugin-special*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>RESUMEN							*plugin-special*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>s:name			Variables local to the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>s:nombre		Variables locales al script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;SID&gt;			Script-ID, used for mappings and functions local to
			the script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;SID&gt;			El identificador del script (Script-ID), utilizado en
			macros y funciones locales al script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>hasmapto()		Una función que comprueba si el usuario ya ha definido
			una macro para la funcionalidad que el script ofrece.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Leader&gt;		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Leader&gt;		El valor de «mapleader», que el usuario define como
			las teclas con las que iniciar las macros de extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;unique&gt;		Give a warning if a mapping already exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>::map &lt;unique&gt;		Emite un aviso si la macro ya existe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap &lt;script&gt;	Use only mappings local to the script, not global
			mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap &lt;script&gt;	Sólo usa macros locales al script, no macros globales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exists(":Cmd")		Check if a user command already exists.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>exists(":Orden")	Comprueba la existencia de una orden de usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*write-filetype-plugin* *ftplugin*
*41.12*	Escribir extensiones de tipo de archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A filetype plugin is like a global plugin, except that it sets options and defines mappings for the current buffer only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una extensión de tipo de archivo («filetype plugin») es como una extensión global, a diferencia de que define opciones y macros que solo afectan al búfer local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |add-filetype-plugin| for how this type of plugin is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saber más acerca del uso de este tipo de extensión, consulte  |add-filetype-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First read the section on global plugins above |41.11|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En primer lugar, consulte la sección anterior sobre extensiones globales, |41.11|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All that is said there also applies to filetype plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todo lo detallado ahí también afecta a las extensiones de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few extras, which are explained here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algunos elementos adicionales, que se explican aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The essential thing is that a filetype plugin should only have an effect on the current buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo esencial es que una extensión de tipo de archivo sólo debe tener efecto en el búfer actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are writing a filetype plugin to be used by many people, they need a chance to disable loading it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esta escribiendo una extensión de tipo de archivo que mucha gente usará, necesitarán la capacidad de desactivar su carga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this at the top of the plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Inserte lo siguiente al principio de la extensión: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" Solo hace esto cuando aún no ha finalizado con este búfer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let b:did_ftplugin = 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let b:did_ftplugin = 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setlocal textwidth=70</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>setlocal textwidth=70</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now write this in the "after" directory, so that it gets sourced after the distributed "vim.vim" ftplugin |after-directory|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba esto en el directorio «after», para que se lea después de la extensión de tipo de archivo predeterminado distribuido, «vim.vim» |after-directory|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix this would be "~/.vim/after/ftplugin/vim.vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En sistemas Unix, sería «~/.vim/after/ftplugin/vim.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the default plugin will have set "b:did_ftplugin", but it is ignored here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que la extensión predeterminada habrá definido «b:did_ftplugin», pero aquí se ignora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an option has a value that is a list of flags or items, consider using "+=" and "-=" to keep the existing value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando una opción tiene un valor que es una lista de opciones o elementos, considere usar «+=» y «-=» para conservar el valor existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that the user may have changed an option value already.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sea consciente de que puede que el usuario ya haya cambiado el valor de una opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First resetting to the default value and then changing it often a good idea.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es una buena idea restablecer el valor original y después cambiarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal formatoptions&amp; formatoptions+=ro</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal formatoptions&amp; formatoptions+=ro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;buffer&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;buffer&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if !hasmapto('&lt;Plug&gt;JavaImport')
	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
	endif
	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|hasmapto()| is used to check if the user has already defined a map to &lt;Plug&gt;JavaImport.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|hasmapto()| sirve para comprobar si el usuario ya ha definido una macro para «&lt;Plug&gt;JavaImport».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not, then the filetype plugin defines the default mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no ha sido definida, la extensión de tipo de archivo define la macro actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts with |&lt;LocalLeader&gt;|, which allows the user to select the key(s) he wants filetype plugin mappings to start with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta empieza con |&lt;LocalLeader&gt;|, que permite al usuario seleccionar una o mas teclas con las que iniciar las macros de la extensión de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default is a backslash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado es una barra inversa, «\».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"&lt;unique&gt;" is used to give an error message if the mapping already exists or overlaps with an existing mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«&lt;unique&gt;» sirve para emitir un mensaje de error si la macro ya existe o entra en conflicto con otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:noremap| is used to avoid that any other mappings that the user has defined interferes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:noremap| sirve para evitar que las macros definidas por el usuario interfieran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to use ":noremap &lt;script&gt;" to allow remapping mappings defined in this script that start with &lt;SID&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desee usar «:noremap &lt;script&gt;» para permitir redefinir macros en el script que comienza con &lt;SID&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user must have a chance to disable the mappings in a filetype plugin, without disabling everything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene que ofrecer al usuario la opción de desactivar macros en una extensión de tipo de archivo, sin desactivar el resto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of how this is done for a plugin for the mail filetype: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene un ejemplo de como hacerlo con una extensión para el tipo de archivo mail: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" Add mappings, unless the user didn't want this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" Añade macros, a menos que el usuario defina lo contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Quote text by inserting "&gt; "
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
	  " Cita el texto insertando «&gt; »
	  if !hasmapto('&lt;Plug&gt;MailQuote')
	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
	  endif
	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two global variables are used:
no_plugin_maps		disables mappings for all filetype plugins
no_mail_maps		disables mappings for a specific filetype</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se utilizan dos variables globales:
no_plugin_maps		desactiva las macros de todas las extensiones de tipo
			de archivo
no_mail_maps		desactiva las macros para un tipo de archivo
			particular</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a user command for a specific file type, so that it can only be used in one buffer, use the "-buffer" argument to |:command|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-buffer» de |:command| permite añadir una orden de usuario para un tipo de archivo específico y que solo afecta al búfer local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -buffer  Make  make %:r.s</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -buffer  Make  make %:r.s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When defining a function, this only needs to be done once.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada función necesita ser definida una sola vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the filetype plugin will be sourced every time a file with this filetype will be opened.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero la extensión de tipo de archivo se cargará cada vez que se abra un archivo del tipo correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This construct makes sure the function is only defined once: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta estructura asegura que la función se defina una sola vez: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:  endfunction
	:endif
&lt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:  endfunction
	:endif
&lt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>UNDO							*undo_ftplugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DESHACER 					*undo_ftplugin*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the user does ":setfiletype xyz" the effect of the previous filetype should be undone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando el usuario hace «:setfiletype xyz», el efecto del tipo de archivo anterior debería desaparecer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the b:undo_ftplugin variable to the commands that will undo the settings in your filetype plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina la variable «b:undo_ftplugin» con las órdenes que deshacen los cambios de configuración de su extensión de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
		\ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"| unlet b:match_ignorecase b:match_words b:match_skip"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"| unlet b:match_ignorecase b:match_words b:match_skip"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using ":setlocal" with "&lt;" after the option name resets the option to its global value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «:setlocal» con «&lt;» después del nombre de la opción restablece la opción a su valor global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is mostly the best way to reset the option value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, es la mejor forma de restablecer el valor de una opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The filetype must be included in the file name |ftplugin-name|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del archivo debe incluir el tipo de archivo |ftplugin-name|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use one of these three forms:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar una de las tres formas a continuación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>.../ftplugin/algo.vim
	.../ftplugin/algo_foo.vim
	.../ftplugin/algo/bar.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUMMARY							*ftplugin-special*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>RESUMEN							*ftplugin-special*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;LocalLeader&gt;		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;LocalLeader&gt;		El valor de «maplocalleader», que el usuario define
			como la tecla que inicia las macros de extensión de
			tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;buffer&gt;		Define a mapping local to the buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;buffer&gt;		Define una macro local al búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noremap &lt;script&gt;	Only remap mappings defined in this script that start
			with &lt;SID&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noremap &lt;script&gt;	Sólo modifica macros definidas en el script que
			comienzan con &lt;SID&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal		Set an option for the current buffer only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal		Define una opción para el búfer actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:command -buffer	Define a user command local to the buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:command -buffer	Define una orden de usuario local al búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>exists("*s:Func")	Check if a function was already defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>exists("*s:Funcion")	Comprueba si una función ya se ha definido
			anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.13*	Writing a compiler plugin		*write-compiler-plugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.13*	Escribir extensiones para compiladores	*write-compiler-plugin*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A compiler plugin sets options for use with a specific compiler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una extensión de compilador define opciones a usar con un compilador específico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user can load it with the |:compiler| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario puede cargarlo con la orden |:compiler|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main use is to set the 'errorformat' and 'makeprg' options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El uso principal es definir las opciones 'errorformat' y 'makeprg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easiest is to have a look at examples.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo más sencillo es ver unos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will edit all the default compiler plugins: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden editará todas las extensiones de compilador predeterminadas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:next $VIMRUNTIME/compiler/*.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:next $VIMRUNTIME/compiler/*.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two special items about these files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos aspectos a tener en cuenta con estas extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First is a mechanism to allow a user to overrule or add to the default file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En primer lugar, deben contar con un mecanismo que permita al usuario anular o añadir cambios a la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default files start with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las extensiones predeterminadas comienzan con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando escribe un archivo de compilador, y lo ubica en su directorio de
ejecución personal (esto es, «~/.vim/compiler» en sistemas Unix), debe definir
la variable «current_compiler» para que la extensión de compilador
predeterminada evite hacer cambios en la configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*:CompilerSet*
El segundo mecanismo es usar «:set» con «:compiler!», y «:setlocal» con
«:compiler».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim defines the ":CompilerSet" user command for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello, Vim define la orden de usuario «:CompilerSet».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However,
older Vim versions don't, thus your plugin should define it then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
otra parte, las versiones anteriores de Vim no cuentan de ella, y por ello su
extensión debe definirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an
example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene un ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" use the default 'errorformat'
  CompilerSet makeprg=nmake</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal &lt;args&gt;
  endif
  CompilerSet errorformat&amp;		" usa 'errorformat' predeterminado
  CompilerSet makeprg=nmake</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler plugin for the Vim distribution or for a system-wide runtime directory, use the mechanism mentioned above.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use el mecanismo mostrado aquí cuando escriba una extensión de compilador para la distribución Vim o para un directorio de tiempo de ejecución del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When "current_compiler" was already set by a user plugin nothing will be done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se hará nada si «current_compiler» ya está definido por una extensión de usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you write a compiler plugin to overrule settings from a default plugin, don't check "current_compiler".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando escribe una extensión de compilador para cambiar las opciones definidas por una extensión predeterminada, evite comprobar «current_compiler».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This plugin is supposed to be loaded last, thus it should be in a directory at the end of 'runtimepath'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta extensión se debería cargar al final, y por ello debería estar en un directorio al final de 'runtimepath'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix that could be ~/.vim/after/compiler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En sistemas Unix, podría ser «~/.vim/after/compiler».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.14*	Escribir extensiones que carguen rápidamente  *write-plugin-quickload*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A plugin may grow and become quite long.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que una extensión crezca, y que sea demasiado larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The startup delay may become noticeable, while you hardly ever use the plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que el tiempo de carga empiece a hacerse notorio, y además, que usted apenas use la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then it's time for a quickload plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, hay que usar una extensión de carga rápida («quickload»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The basic idea is that the plugin is loaded twice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La idea principal es que la extensión se carga dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first time user commands and mappings are defined that offer the functionality.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera vez, se definen las órdenes de usuario y macros que ofrecen la funcionalidad de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second time the functions that implement the functionality are defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda vez, se definen las funciones que implementan tales funcionalidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may sound surprising that quickload means loading a script twice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que sorprenda que «carga rápida» signifique cargar una extensión dos veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we mean is that it loads quickly the first time, postponing the bulk of the script to the second time, which only happens when you actually use it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que queremos decir es que se carga rápidamente la primera, demorando la carga de la mayoría de la extensión a la segunda vez, lo que sólo ocurre cuando realmente la usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you always use the functionality it actually gets slower!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Si usa siempre la funcionalidad que provee la extensión, no obtendrá ninguna ventaja!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" License:	This file is placed in the public domain.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>" Extensión global de Vim para mostrar la carga rápida
	" Último cambio:	2005 Feb 25
	" Desarrollador:	Bram Moolenaar &lt;Bram@vim.org&gt;
	" Licencia:	Este archivo se encuentra en el dominio público</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
		map &lt;F19&gt; :call BufNetWrite('algo')&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
		finish
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>')'
		" read functionality here
	endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>')'
		" Funcionalidad de lectura aquí
	endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>')'
		" write functionality here
	endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>')'
		" Funcionalidad de escritura aquí
	endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second time the script is loaded "s:did_load" exists and the commands after the "endif" are executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda vez que se carga, «s:did_load» existe y se ejecutan las órdenes después de «endif».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines the (possible long)  BufNetRead() and BufNetWrite() functions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto define las (posiblemente largas) funciones BufNetRead() y BufNetWrite().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you drop this script in your plugin directory Vim will execute it on startup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ubica este script en su directorio «plugin», Vim lo ejecutará al inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the sequence of events that happens:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación la secuencia de los eventos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "BNRead" command is defined and the &lt;F19&gt; key is mapped when the script
   is sourced at startup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se define la orden «BNRead» y la tecla &lt;F19&gt; se asigna a una macro al cargar
el script al inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A |FuncUndefined| autocommand is defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se define una orden automática |FuncUndefined|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
   ":finish" command causes the script to terminate early.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden
  «:finish» hace que el script finalice antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user types the BNRead command or presses the &lt;F19&gt; key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El usuario introduce la orden «BNRead» o pulsa la tecla &lt;F19&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
   BufNetRead() or BufNetWrite() function will be called.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se
  invoca la función «BufNetRead()» o «BufNetWrite()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no puede encontrar la función y ejecuta la orden automática
  |FuncUndefined|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que el patrón «BufNet*» coincide con la función invocada,
  se ejecutará la orden «source nombre-archivo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "&lt;sfile&gt;" (see |expand()|).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«nombre-archivo» debe ser
  igual al nombre del script, sin importar su ubicación, ya que procede de
  expandir «&lt;sfile&gt;» (consulte |expand()|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El script se carga otra vez, la variable «s:did_load» existe, y se
   definen las funciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the functions that are loaded afterwards match the pattern in the |FuncUndefined| autocommand.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que las funciones se cargan después de comparar el patrón en la orden automática |FuncUndefined|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must make sure that no other plugin defines functions that match this pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe comprobar que ninguna otra extensión define funciones que coincidan con este patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.15*	Writing library scripts			*write-library-script*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.15*	Crear bibliotecas				*write-library-script*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some functionality will be required in several places.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas funcionalidades son necesarias en varios lugares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When this becomes more than a few lines you will want to put it in one script and use it from many scripts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se trata de algo más que unos pocas líneas, querrá ubicarlo en un script, y usarlo desde varios otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will call that one script a library script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a denominar ese script como biblioteca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually loading a library script is possible, so long as you avoid loading it when it's already done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cargar una biblioteca manualmente es posible, siempre que evite cargarla cuando ya lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this with the |exists()| function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede evitarlo con la función |exists()|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if !exists('*MiFuncionBiblioteca')
	   runtime library/biblioteca.vim
	endif
	call MiFuncionBiblioteca(arg)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make this a bit simpler Vim offers the autoload mechanism.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer esto más sencillo, Vim ofrece el mecanismo «autoload» (carga automática).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the example looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, el ejemplo tendría este aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>call mylib#myfunction(arg)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>call mibiblioteca#mifuncion(arg)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a lot simpler, isn't it?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mucho más sencillo, ¿verdad?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will recognize the function name and when it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim reconoce el nombre de la función y, cuando no esté definida, la buscará el script «autoload/mibiblioteca.vim» en 'runtimepath'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That script must define the "mylib#myfunction()" function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El script debe definir la función «mibiblioteca#mifuncion()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can put many other functions in the mylib.vim script, you are free to organize your functions in library scripts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede almacenar varias funciones en el script mibiblioteca.vim, y puede organizar como desee las funciones en sus bibliotecas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you must use function names where the part before the '#' matches the script name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero debe usar nombres de funciones en las que la parte que precede a «#» coincide con el nombre del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise Vim would not know what script to load.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, Vim no sabrá qué script cargar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you get really enthusiastic and write lots of library scripts, you may want to use subdirectories.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto le entusiasma, y escribe muchas bibliotecas, puede que quiera usar subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>call netlib#ftp#read('somefile')</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>call netlib#ftp#read('somefile')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vim/autoload/netlib/ftp.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vim/autoload/netlib/ftp.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>function netlib#ftp#read(nombre_archivo)
		"  Lee al archivo mediante FTP
	endfunction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the name the function is defined with is exactly the same as the name used for calling the function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que el nombre con el que se define la función es idéntico al utilizado para invocar la función.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the part before the last '#' exactly matches the subdirectory and script name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y la parte a continuación del último «#» coincide con el subdirectorio y el nombre del script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let weekdays = dutch#weekdays</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let dias_semana = colombia#dias_semana</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let colombia#dias_semana = ['lunes', 'martes', 'miércoles', 'jueves',
		\ 'viernes', 'sábado', 'domingo']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*41.16*	Distributing Vim scripts			*distribute-script*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*41.16*	Distribuir scripts de Vim			*distribute-script*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim users will look for scripts on the Vim website: http://www.vim.org.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los usuarios de Vim buscarán scripts en el sitio web de Vim: http://www.vim.org.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you made something that is useful for others, share it!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha creado algo útil para otros, ¡compártalo!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim scripts can be used on any system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los scripts de Vim se pueden usar en cualquier sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might not be a tar or gzip command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes tar o gzip pueden no estar disponibles en dichos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to pack files together and/or compress them the "zip" utility is recommended.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea empaquetar o comprimir los archivos, se recomienda usar la herramienta «zip».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For utmost portability use Vim itself to pack scripts together.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para obtener la máxima portabilidad use Vim para empaquetar los scripts.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done with the Vimball utility.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer esto con la herramienta Vimball.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |vimball|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |vimball|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's good if you add a line to allow automatic updating.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es una buena idea añadir una línea para pemitir la actualización automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |glvs-plugins|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |glvs-plugins|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set softtabstop=4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set softtabstop=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_30.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_30.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2007 Nov 10</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 10/11/2007</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Editing programs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edición de programas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|30.1|	Compiling
|30.2|	Indenting C files
|30.3|	Automatic indenting
|30.4|	Other indenting
|30.5|	Tabs and spaces
|30.6|	Formatting comments</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|30.1|	Compilar
|30.2|	Sangrado en archivos C
|30.3|	Sangrado automático
|30.4|	Otros sangrados
|30.5|	Tabulados y espacios
|30.6|	Formatear comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_31.txt|  Exploiting the GUI
 Previous chapter: |usr_29.txt|  Moving through programs
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_31.esx|  Sacar partido a la interfaz gráfica
  Capítulo anterior: |usr_29.esx|  Moverse a través de programas
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.1*	Compiling</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.1*	Compilar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a set of so called "quickfix" commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene un conjunto de órdenes de arreglos rápidos («quickfix»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They enable you to compile a program from within Vim and then go through the errors generated and fix them (hopefully).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Permiten compilar un programa desde Vim y después navegar a través de los errores generados y (posiblemente) arreglarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then recompile and fix any new errors that are found until finally your program compiles without any error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede después recompilar y arreglar cualquier error nuevo detectado hasta que finalmente su programa se compile sin problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:make {arguments}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:make {arguments}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If errors were generated, they are captured and the editor positions you where
the first error occurred.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se genera algún error, se captura y el editor le posicionará sobre el primer error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take a look at an example ":make" session.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un ejemplo de una sesión típica de «:make».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Typical :make sessions generate
far more errors and fewer stupid ones.)  After typing ":make" the screen looks
like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Las sesiones típicas de
«:make» generan muchos menos errores y menos errores estúpidos.) La pantalla
presentará este aspecto después de teclear «:make»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!make | &amp;tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!make | &amp;tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From this you can see that you have errors in the file "main.c".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver que tiene errores en el archivo «main.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you press &lt;Enter&gt;, Vim displays the file "main.c", with the cursor positioned on line 6, the first line with an error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando pulse &lt;Intro&gt;, Vim mostrará el archivo «main.c», con el cursor posicionado en la línea 6, la primera con un error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You did not need to specify the file or the line number, Vim knew where to go by looking in the error messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No necesitó definir el archivo o el número de línea, ya que Vim sabe dónde ir analizando los mensajes de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -&gt; |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -&gt; |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cnext</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cnext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim jumps to line 10, the last line in the file, where there is an extra '}'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim salta a la línea 10, la última línea en el archivo, donde hay un «}»
adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there is not enough room, Vim will shorten the error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no hay suficiente espacio Vim acorta el mensaje de error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see
the whole message use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver
el mensaje completo, use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get an overview of all the error messages with the ":clist" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede obtener una visión general de todos los mensajes de error con la orden «:clist».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida tiene el siguiente aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:clist
&lt;	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:clist
&lt;	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the lines where Vim recognized a file name and line number are listed here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se muestran las líneas donde Vim reconoció un nombre de archivo y un número de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It assumes those are the interesting lines and the rest is just boring messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asume que aquéllas son las líneas de interés, mientras que toma el resto como mensajes aburridos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, sometimes unrecognized lines do contain something you want to see.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así, a veces las líneas no reconocidas contiene algo que desea ver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Output from the linker, for example, about an undefined function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la salida del enlazador acerca de una función no definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see all the messages add a "!" to the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver todos los mensajes, añada «!» a la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:clist!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡	:clist!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will highlight the current error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim resaltará el error actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go back to the previous error, use:
&gt;
	:cprevious</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente para volver al error anterior: &gt;
	:cprevious</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfirst		to first error
	:clast		to last error
	:cc 3		to error nr 3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cfirst		primer error
	:clast		último error
	:cc 3		error número 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the program to run when the ":make" command is executed is defined by the 'makeprg' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre del programa a ejecutar cuando usa la orden «:make» se define con la opción 'makeprg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually this is set to "make", but Visual C++ users should set this to "nmake" by executing the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, esto se define como «make», pero usuarios de Visual C++ deberían definir esto como «nmake» ejecutando la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set makeprg=nmake</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set makeprg=nmake</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also include arguments in this option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede incluir argumentos en esta opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special characters need to be escaped with a backslash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los caracteres especiales se deben escapar con una barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set makeprg=nmake\ -f\ project.mak</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set makeprg=nmake\ -f\ project.mak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can include special Vim keywords in the command specification.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede incluir palabras clave especiales de Vim al especificar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The %
character expands to the name of the current file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El
carácter «%» se expande con el nombre del archivo actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you execute the
command: &gt;
	:set makeprg=make\ %</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así que se
ejecuta la siguiente orden: &gt;
	:set makeprg=make\ %</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make main.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>make main.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set makeprg=make\ %:r.o</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set makeprg=make\ %:r.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>make main.o</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>make main.o</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you ":make" a program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que compila un programa con «:make».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a warning message in one file and an error message in another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un mensaje de aviso en un archivo y un mensaje de error en otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You fix the error and use ":make" again to check if it was really fixed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Arregla el mensaje y usa «:make» otra vez para comprobar que lo ha arreglado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you want to look at the warning message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora desea ver el mensaje de aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It doesn't show up in the last error list, since the file with the warning wasn't compiled again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No aparece en la última lista de errores ya que aún no se ha compilado el archivo con el aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go back to the previous error list with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede volver a la lista de errores previa con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:colder</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:colder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use ":clist" and ":cc {nr}" to jump to the place with the warning.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora «:clist» y «:cc {nr}» para saltar al lugar con el aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go forward to the next error list: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente para avanzar a la siguiente lista de errores: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cnewer</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cnewer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to tell Vim what format the error messages are that your compiler produces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene que indicar a Vim el formato de los mensajes de error que produce su compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done with the 'errorformat' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede hacer con la opción 'errorformat'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax of this option is quite complicated and it can be made to fit almost any compiler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La sintaxis de esta opción es algo complicada, y puede hacer que encaje con prácticamente cualquier compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the explanation here: |errorformat|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar la explicación aquí: |errorformat|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might be using various different compilers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que esté usando varios compiladores diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the 'makeprg' option, and especially the 'errorformat' each time is not easy.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir la opción 'makeprg' y especialmente la opción 'errorformat' cada vez no es un tarea sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim offers a simple method for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece una forma sencilla de hacer esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to switch to using the Microsoft Visual C++ compiler: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para cambiar al compilador Microsoft Visual C++: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:compiler msvc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:compiler msvc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will find the Vim script for the "msvc" compiler and set the appropriate
options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden encontrará el script de Vim para el compilador «msvc» y definirá
las opciones adecuadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can write your own compiler files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede escribir sus propios archivos de compilador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |write-compiler-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte
|write-compiler-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":make" command redirects the output of the executed program to an error file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:make» redirige la salida del programa ejecutado a un archivo error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How this works depends on various things, such as the 'shell'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo en que esto último funciona depende de varias cosas, tales como la consola ('shell').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your ":make" command doesn't capture the output, check the 'makeef' and 'shellpipe' options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su orden «:make» no captura la salida, compruebe las opciones 'makeef' y 'shellpipe'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'shellquote' and 'shellxquote' options might also matter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las opciones 'shellquote' y 'shellxquote' también son de importancia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you can't get ":make" to redirect the file for you, an alternative is to compile the program in another window and redirect the output into a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el caso de que no pueda hacer que «:make» redirija la salida del archivo, una alternativa es compilar el programa en otra ventana y redirigir la salida al archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then have Vim read this file with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después, haga que Vim lea este archivo con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:cfile {filename}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:cfile {filename}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.2*	Indenting C style text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.2*	Sangrado en archivos C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A program is much easier to understand when the lines have been properly indented.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un programa es mucho más fácil de entender cuando las líneas tienen un sangrado adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim offers various ways to make this less work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece varias formas de facilitar esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For C or C style programs like Java or C++, set the 'cindent' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para programas C o con estilo C como Java o C++, defina la opción 'cindent'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim knows a lot about C programs and will try very hard to automatically set the indent for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim sabe mucho acerca de programas C e intentará definir el sangrado automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the 'shiftwidth' option to the amount of spaces you want for a deeper level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina la opción 'shiftwidth'  con el número de espacios que desea para cada nivel de profundidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Four spaces will work fine.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuatro espacios funcionarán bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One ":set" command will do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacerlo con una orden 'set': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set cindent shiftwidth=4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set cindent shiftwidth=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (flag)
	Automatic indent   ---&gt;		do_the_work();
	Automatic unindent &lt;--	    if (other_flag) {
	Automatic indent   ---&gt;		do_file();
	keep indent			do_some_more();
	Automatic unindent &lt;--	    }</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if (opción)
	Sangrado automático  ---&gt;		do_the_work();
	Eliminar sangrado automático &lt;--	    if (otra_opción) {
	Sangrado automático   ---&gt;		do_file();
	Preservar el sangrado			do_some_more();
	Eliminar sangrado automático &lt;--	    }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type something in curly braces ({}), the text will be indented at the start and unindented at the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando teclee algo entre llaves ({}), el texto tendrá un sangrado al inicio, pero no al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The unindenting will happen after typing the '}', since Vim can't guess what you are going to type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La eliminación de sangrado («unindenting») aparecerá después de teclear '}', ya que Vim no puede adivinar qué va a escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One side effect of automatic indentation is that it helps you catch errors in
your code early.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un efecto secundario del sangrado automático es que le permite encontrar
los errores en su código de manera temprana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type a } to finish a function, only to find that
the automatic indentation gives it more indent than what you expected, there
is probably a } missing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea «}» para finalizar
una función y ve que el sangrado automático la da más del esperado,
puede que falte un «}».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the "%" command to find out which { matches the
} you typed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «%» para encontrar qué «{»
encaja con la «}» que introdujo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A missing ) and ; also cause extra indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «)» y «;» omitido también causan un sangrado adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if you get more white
space than you would expect, check the preceding lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si
obtiene más espacios en blanco del esperado, compruebe la líneas precedentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have code that is badly formatted, or you inserted and deleted lines, you need to re-indent the lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando tiene código mal formateado, o si ha insertado o eliminado líneas, tendrá que sangrar las líneas nuevamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "=" operator does this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operador «=» hace esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest form is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma más simple es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>==</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>==</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>=a{</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>=a{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I you have really badly indented code, you can re-indent the whole file with:
&gt;
	gg=G</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene código con un pésimo sangrado, puede sangrar nuevamente el archivo
completo con: &gt;
	gg=G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, don't do this in files that have been carefully indented manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, no lo haga en los archivos que han sido cuidadosamente sangrados manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The automatic indenting does a good job, but in some situations you might want to overrule it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El sangrado automático hace un buen trabajo, pero en algunas situaciones puede que desee anularlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different people have different styles of indentation.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Diferentes personas tienen diferentes estilos de sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Vim does a
pretty good job of indenting in a way that 90% of programmers do.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión,
Vim realiza un buen trabajo de sangrado de la manera en que lo hace el
90% de los programadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are
different styles, however; so if you want to, you can customize the
indentation style with the 'cinoptions' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aun así, hay diferentes estilos; así que si lo desea, puede personalizar el
estilo de sangrado con la opción 'cinoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default 'cinoptions' is empty and Vim uses the default style.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, 'cinoptions' está vacío, usando Vim el estilo
 predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can
add various items where you want something different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir varios elementos cuando desee algo
diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to make
curly braces be placed like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para ubicar llaves de la siguiente forma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if (opción) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set cinoptions+={2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set cinoptions+={2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are many of these items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay muchos de estos elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |cinoptions-values|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |cinoptions-values|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.3*	Automatic indenting</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.3*	Sangrado automático</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't want to switch on the 'cindent' option manually every time you edit a C file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No desea activar la opción 'cindent' manualmente cada vez que edite un archivo C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is how you make it work automatically: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la forma de hacer que funcione automáticamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:filetype indent on</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:filetype indent on</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, this does a lot more than switching on 'cindent' for C files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, esto hace mucho más que activar 'cindent'  para archivos C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First
of all, it enables detecting the type of a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En primer lugar, activa la detección de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's the same as what is
used for syntax highlighting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es igual a lo
usado para el resaltado de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the filetype is known, Vim will search for an indent file for this
type of file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el tipo de archivo es conocido, Vim buscará un archivo de sangrado para
este tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim distribution includes a number of these for various
programming languages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La distribución de Vim incluye un número para estos
lenguajes de programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indent file will then prepare for automatic
indenting specifically for this file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este archivo de sangrado preparará automáticamente el sangrado específico
para este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:filetype indent off</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:filetype indent off</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like the indenting for one specific type of file, this is how you avoid it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gusta el sangrado para un tipo específico de archivo, esta es la forma de evitarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a file with just this one line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cree un archivo con sólo esta línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:let b:did_indent = 1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:let b:did_indent = 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{directory}/indent/{filetype}.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{directorio}/indent/{tipo-de-archivo}.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The {filetype} is the name of the file type, such as "cpp" or "java".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El {tipo-de-archivo} es el nombre del tipo de archivo, por ejemplo, «cpp» o «java».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the exact name that Vim detected with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver el nombre exacto de archivo que Vim ha detectado con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set filetype</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set filetype</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>filetype=help ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>filetype=help ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you would use "help" for {filetype}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, usaría «help» para {tipo-de-archivo}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the {directory} part you need to use your runtime directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para la parte de {directorio}, necesita usar su directorio de tiempo de
ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look at
the output of this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mire la salida de esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set runtimepath</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set runtimepath</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the first item, the name before the first comma.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora use el primer elemento, el nombre que precede a la primera coma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if the output looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, la salida tiene el siguiente aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You use "~/.vim" for {directory}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «~/.vim» para el {directorio}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the resulting file name is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, el nombre del archivo resultante es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vim/indent/help.vim ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vim/indent/help.vim ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of switching the indenting off, you could write your own indent file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de desactivar el sangrado, podría escribir su propio archivo de sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to do that is explained here: |indent-expression|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera de hacerlo se explica aquí: |indent-expression|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.4*	Other indenting</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.4*	Otros sangrados</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are using 'autoindent' or 'smartindent' to get the indent of the
previous line, there will be many times when you need to add or remove one
'shiftwidth' worth of indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use 'autoindent' o 'smartindent' para obtener el sangrado de línea
anterior, habrá ocasiones en que necesite añadir o eliminar un 'shiftwidth'
de sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick way to do this is using the CTRL-D and
CTRL-T commands in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma rápida de hacerlo es usando las órdenes «CTRL-D»
y «CTRL-T» en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you are typing a shell script that is supposed to look like
this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, está escribiendo un script de consola con el siguiente
aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set autoindent shiftwidth=3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set autoindent shiftwidth=3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if test -n a; then ~
	echo ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if test -n a; then ~
	echo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you see that you need an extra indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora ve que necesita un sangrado adicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type CTRL-T.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse«CTRL-T».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if test -n a; then ~
	   echo ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if test -n a; then ~
	   echo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-T command, in Insert mode, adds one 'shiftwidth' to the indent, no
matter where in the line you are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «CTRL-T», en modo Insertar, añade un 'shiftwidth' al sangrado sin
importar en que línea está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You continue typing the second line, &lt;Enter&gt; and the third line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Continua escribiendo en la segunda línea, &lt;Intro&gt;, y la tercera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time
the indent is OK.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta
vez el sangrado es correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then &lt;Enter&gt; and the last line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse &lt;Intro&gt; y salte a la última línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you have this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora
tiene lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove the superfluous indent in the last line press CTRL-D.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar el sangrado innecesario en la última línea pulse «CTRL-D».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This deletes
one 'shiftwidth' worth of indent, no matter where you are in the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Elimina
un 'shiftwidth' de sangrado, sin importar dónde está dentro de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are in Normal mode, you can use the "&gt;&gt;" and "&lt;&lt;" commands to
shift lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando está en modo Normal, puede usar las órdenes «&gt;&gt;» y «&lt;&lt;» para cambiar
las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"&gt;" and "&lt;" are operators, thus you have the usual three ways to
specify the lines you want to indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«&gt;» y «&lt;» son operadores, y por ello tiene las tres formas
habituales de definir las líneas que desea sangrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A useful combination is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una combinación útil
es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;i{</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;i{</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>original text		after "&gt;i{"		after "&gt;a{"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>texto original		después de «&gt;i{»	    después de «&gt;a{»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if (opción)		if (opción)		if (opción) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	opción = 0;		    opción = 0;		    opción = 0;  ~
	}			}			    } ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.5*	Tabs and spaces</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.5*	Tabulados y espacios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a mix of &lt;Tab&gt; and space characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use una mezcla de &lt;Tab&gt; y caracteres de espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since a &lt;Tab&gt; takes the place of
    eight spaces, you have fewer characters in your file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que &lt;Tab&gt; toma el
    el lugar de 8 espacios, tendrá menos caracteres en su archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inserting a &lt;Tab&gt;
    is quicker than eight spaces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Insertar un
    &lt;Tab&gt; es más rápido que 8 espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backspacing works faster as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla de retroceso también es
    más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use spaces only.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Utilice espacios solamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This avoids the trouble with programs that use a
    different tabstop value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto evita los problemas con los
    programas que utilizan un valor de «tabstop» diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a combination of tabs and spaces, you just edit normally.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa una combinación de tabulados y espacios, puede editar con normalidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim defaults do a fine job of handling things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El comportamiento predeterminado de Vim realiza un trabajo inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make life a little easier by setting the 'softtabstop' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede facilitar su vida definiendo la opción 'softtabstop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This option tells Vim to make the &lt;Tab&gt; key look and feel as if tabs were set
at the value of 'softtabstop', but actually use a combination of tabs and
spaces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta opción le dice a Vim que la tecla &lt;Tab&gt; tenga el comportamiento como si
los tabulados estuviesen definidos como un valor 'softtabstop', aunque use en
realidad una combinación de tabulados y espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you execute the following command, every time you press the &lt;Tab&gt; key
the cursor moves to the next 4-column boundary: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después de ejecutar la siguiente, orden, cada vez que pulse la tecla &lt;Tab&gt; el
cursor se moverá al siguiente límite de cuatro columnas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you start in the first column and press &lt;Tab&gt;, you get 4 spaces inserted
in your text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando empiece en la primera columna y pulse &lt;Tab&gt; obtendrá la inserción de
cuatro espacios en su texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second time, Vim takes out the 4 spaces and puts in a &lt;Tab&gt;
(thus taking you to column 8).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La segunda vez, Vim eliminará los cuatro espacios
e insertará un &lt;Tab&gt; (llevándole a la columna 8).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus Vim uses as many &lt;Tab&gt;s as possible, and
then fills up with spaces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, Vim usa tantos
&lt;Tab&gt; como sea posible, rellenándolos con espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When backspacing it works the other way around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar la tecla de retroceso, funcionará al revés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A &lt;BS&gt; will always delete
the amount specified with 'softtabstop'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un &lt;Bs&gt; (tecla de
retroceso) siempre elimina la cantidad definida con 'softtabstop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then &lt;Tab&gt;s are used as many as
possible and spaces to fill the gap.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, se
usarán tantos &lt;Tab&gt; como sea posible, rellenando el hueco resultante
con espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following shows what happens pressing &lt;Tab&gt; a few times, and then using
&lt;BS&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo siguiente muestra lo que ocurre cuando pulsa &lt;Tab&gt; varias veces, y
después usando &lt;Bs&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "." stands for a space and "-------&gt;" for a &lt;Tab&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «.» simboliza un espacio, y «-------&gt;» un &lt;Tab&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>type			  result ~
	&lt;Tab&gt;			  ....</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>tipo			          resultado ~
	&lt;Tab&gt;			  ....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;....</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;		  -------&gt;....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;	  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;   ....</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;	  -------&gt;
	&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;   ....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to use the 'smarttab' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una alternativa es usar la opción 'smartab'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it's set, Vim uses 'shiftwidth' for a &lt;Tab&gt; typed in the indent of a line, and a real &lt;Tab&gt; when typed after the first non-blank character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se define, Vim usa 'shiftwidth' para un &lt;Tab&gt; introducida en el sangrado de una línea, y un &lt;Tab&gt; real cuando se introduce en el primer carácter no vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, &lt;BS&gt; doesn't work like with 'softtabstop'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo &lt;BS&gt; no funciona de la misma forma que con 'softtabstop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set expandtab</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set expandtab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When this option is set, the &lt;Tab&gt; key inserts a series of spaces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando se define esta opción, la tecla &lt;Tab&gt; inserte una serie de espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you
get the same amount of white space as if a &lt;Tab&gt; character was inserted, but
there isn't a real &lt;Tab&gt; character in your file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, obtiene el mismo espacio en blanco que un carácter &lt;Tab&gt; inserta,
aunque en realidad no hay ningún carácter &lt;Tab&gt; en su archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backspace key will delete each space by itself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla de retroceso eliminará cada espacio por sí mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus after typing one
&lt;Tab&gt; you have to press the &lt;BS&gt; key up to eight times to undo it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello,
después de teclear un &lt;Tab&gt;, tendrá que pulsar la tecla &lt;BS&gt; (retroceso)
hasta ocho veces para deshacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are
in the indent, pressing CTRL-D will be a lot quicker.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está dentro de la sangría, pulsar
«CTRL-D» es mucho más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting 'expandtab' does not affect any existing tabs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir 'expandtab' no afecta a las tabulaciones existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, any tabs in the document remain tabs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, todas las tabulaciones del documento siguen siéndolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to convert tabs to spaces, use the ":retab" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea convertir esas tabulaciones en espacios, use la orden «:retab».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use these commands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use las siguientes órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set expandtab
	:%retab</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set expandtab
	:%retab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Vim will have changed all indents to use spaces instead of tabs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, Vim ha cambiado todas las sangrías para que usen espacios en lugar de tabulados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, all tabs that come after a non-blank character are kept.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, se respetan todos los tabulados a continuación de un carácter no vacío.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want these to be converted as well, add a !: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Añada «!» si desea convertir éstos también: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%retab!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%retab!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a little bit dangerous, because it can also change tabs inside a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es algo peligroso, ya que también puede cambiar los tabulados dentro de una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To check if these exist, you could use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar lo siguiente para comprobar la existencia de éstos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/"[^"\t]*\t[^"]*"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/"[^"\t]*\t[^"]*"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's recommended not to use hard tabs inside a string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se recomienda no usar tabulados rígidos dentro de una cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace them with "\t" to avoid trouble.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Reemplácelos con «\t» para evitar problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set noexpandtab
	:%retab!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set noexpandtab
	:%retab!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*30.6*	Formatting comments</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*30.6*	Formatear comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the great things about Vim is that it understands comments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una de las mayores virtudes de Vim es que entiende comentarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can
ask Vim to format a comment and it will do the right thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede pedir
a Vim que dé formato a un comentario, y hará lo correcto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose, for example, that you have the following comment:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene el siguiente comentario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* ~
	 * This is a test ~
	 * of the text formatting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* ~
	 * Esta es una prueba ~
	 * de formateo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gq]/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gq]/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"gq" is the operator to format text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«gq» es el operador para formatear texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"]/" is the motion that takes you to the end of a comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«]/» es el movimiento que le lleva al final del comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that Vim properly handled the beginning of each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que Vim manipuló adecuadamente el principio de cada línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to select the text that is to be formatted in Visual mode
and type "gq".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una alternativa es seleccionar el texto a formatear en modo Visual,
y teclear «gq».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a new line to the comment, position the cursor on the middle line and press "o".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para añadir una nueva línea al comentario, posicione el cursor en la línea central y pulse «o».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has automatically inserted a star and a space for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ha insertado un «*» y un espacio automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can type the comment text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede escribir el texto de comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it gets longer than 'textwidth', Vim will break the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la línea excede el valor de 'textwidth', Vim romperá la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, the star is inserted automatically:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una vez más, se inserta «*» automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	 * Teclear mucho texto hará que Vim divida ~
	 * la línea ~
	 */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>r	insert the star when typing &lt;Enter&gt; in Insert mode
	o	insert the star when using "o" or "O" in Normal mode
	c	break comment text according to 'textwidth'</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>r	inserta «*» al pulsar &lt;Enter&gt; en modo Insertar
	o	inserta «*» a usar «o» o «O» en modo Normal
	c	rompe el texto de comentario de acuerdo a 'textwidth'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'comments' option defines what a comment looks like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'comments' define el aspecto de un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim distingue
entre un comentario de una sola línea y un comentario cuyo principio, parte
central y final son distintas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many single-line comments start with a specific character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchos comentarios de una sola línea empiezan con carácter específico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C++ // is
used, in Makefiles #, in Vim scripts ".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En C++ se usa «//», «#» en archivos «Makefile», y «"» en scripts de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to make Vim understand
C++ comments: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para que Vim entienda comentarios en C++: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set comments=://</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set comments=://</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The colon separates the flags of an item from the text by which the comment is recognized.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los dos puntos separan las opciones de un elemento del texto por el cual se reconoce un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The general form of an item in 'comments' is:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La forma habitual de un elemento en 'comments' es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{flags}:{text}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{opcio}:{texto}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set comments=n:&gt;,n:!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set comments=n:&gt;,n:!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two items, one for comments starting with "&gt;" and one for comments that start with "!".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos elementos, uno para los comentarios que empiezan con «&gt;» y otro para los comentarios que comienzan con «!».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both use the flag "n".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ambos usan la opción «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that these comments nest.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que estos comentarios se anidan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus a line starting with "&gt;" may have another comment after the "&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, una línea comenzando con «&gt;» puede tener otro comentario después de «&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows formatting a message like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite dar formato a un mensaje como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	&gt; !</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	&gt; !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ~
	&gt; colors are terrible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los ~
	&gt; colores son horribles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	What is the URL of that ~
	site?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	¿Cual es la URL de esa ~
	página web?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try setting 'textwidth' to a different value, e.g., 80, and format the text by Visually selecting it and typing "gq".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe configurando 'textwidth' con un valor diferente, de 80, y formatee el texto seleccionándolo en modo Visual y escribiendo «gq».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The colors are terrible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los colores son horribles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	What is the URL of that site?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	¿Cual es la URL de esa página web?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that Vim did not move text from one type of comment to another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará que Vim no desplazó el texto de un tipo de comentario a otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "I" in the second line would have fit at the end of the first line, but since that line starts with "&gt; !" and the second line with "&gt;", Vim knows that this is a different kind of comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «No» en la segunda línea puede encajar al final de la primera línea, pero ya que la línea comienza con «&gt; !», y la segunda con «&gt;», Vim detectará que es otro tipo de comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A C comment starts with "/*", has "*" in the middle and "*/" at the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un comentario de C empieza con «/*»,  «*» en el medio, y «/*» al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry in 'comments' for this looks like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La entrada en 'comments' tendría este aspecto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set comments=s1:/*,mb:*,ex:*/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set comments=s1:/*,mb:*,ex:*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The start is defined with "s1:/*".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El principio se define con «s1:/*».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "s" indicates the start of a
three-piece comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «s» indica el principio de un
comentario en tres partes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The colon separates the flags from the text by which the
comment is recognized: "/*".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los dos puntos separan las marcas del texto
por el cual se detecta que es un comentario: «/*».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one flag: "1".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una marca, «1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim that the
middle part has an offset of one space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Indica
a Vim que la parte central tiene un «offset» de un espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The middle part "mb:*" starts with "m", which indicates it is a middle
part.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte central «mb:*» comienza con «m», que indica que es la parte
central.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "b" flag means that a blank must follow the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «b» indica que el texto debe ir seguido de un espacio
en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise Vim
would consider text like "*pointer" also to be the middle of a comment.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, Vim considerará que el texto como «*pointer»
también es la parte central de un comentario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The end part "ex:*/" has the "e" for identification.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte final «ex:*/» tiene «e» como identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "x" flag has a
special meaning.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «x» tiene
un significado especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It means that after Vim automatically inserted a star,
typing / will remove the extra space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Indica que pulsar «/» eliminará el espacio
adicional después de que Vim haya insertado automáticamente un asterisco, «*».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_28.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_28.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|28.1|	What is folding?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|28.1|	¿Qué es plegar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|28.2|	Manual folding
|28.3|	Working with folds
|28.4|	Saving and restoring folds
|28.5|	Folding by indent
|28.6|	Folding with markers
|28.7|	Folding by syntax
|28.8|	Folding by expression
|28.9|	Folding unchanged lines
|28.10| Which fold method to use?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|28.2|	Plegar manualmente
|28.3|	Trabajar con pliegues
|28.4|	Guardar y restaurar pliegues
|28.5|	Plegar por sangrado
|28.6|	Plegar con marcadores
|28.7|	Plegar por sintaxis
|28.8|	Plegar por expresión
|28.9|	Plegar líneas sin cambios
|28.10¿| ¿Qué método de plegar debería usar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_29.txt|  Moving through programs
 Previous chapter: |usr_27.txt|  Search commands and patterns
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_29.esx|  Moverse a través de programas
  Capítulo anterior: |usr_27.esx|  Órdenes de búsqueda y patrones
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.1*	What is folding?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.1¿*	¿Qué es plegar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding is used to show a range of lines in the buffer as a single line on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar se usa para mostrar un rango de líneas en un búfer como una sola línea en la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like a piece of paper which is folded to make it shorter:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como un trozo de papel plegado para acortarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+------------------------+
	| line 1		 |
	| line 2		 |
	| line 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / folded lines		  /
	/________________________/
	| line 12		 |
	| line 13		 |
	| line 14		 |
	+------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+------------------------+
	| línea 1		 |
	| línea 2		 |
	| línea 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / líneas plegadas	  /
	/________________________/
	| línea 12		 |
	| línea 13		 |
	| línea 14		 |
	+------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text is still in the buffer, unchanged.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto aún está en el búfer, sin cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the way lines are displayed is affected by folding.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar sólo afecta a la manera en que se muestran las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.2*	Manual folding</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.2*	Plegar manualmente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zfap</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zfap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see that the paragraph is replaced by a highlighted line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá que una línea resaltada reemplaza al párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have created a fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ha creado un pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|zf| is an operator and |ap| a text object selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|zf| es un operando y |ap| una selección de un objeto textual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the |zf| operator with any movement command to create a fold for the text that it moved over.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el operando |zf| con cualquier orden de desplazamiento para crear un pliegue para el texto reemplazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|zf| also works in Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|zf| funciona también en el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the folding commands start with "z".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas las órdenes de plegado empiezan con «z».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With some fantasy, this looks like a folded piece of paper, seen from the side.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa la imaginación, se asemeja a un papel plegado visto de lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The letter after the "z" has a mnemonic meaning to make it easier to remember the commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La letra a continuación de «z» tiene un significado nemónico que facilita recordar las órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zf	F-old creation
	zo	O-pen a fold
	zc	C-lose a fold</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zf	F-old creation (crear pliegue)
	zo	O-pen a fold (abrir pliegue)
	zc	C-lose a fold (cerrar pliegue)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have created several folds, and now want to view all the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imagine que ha creado varios pliegues, y que ahora desea ver todo el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could go to each fold and type "zo".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ir a cada pliegue y teclear «zo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this faster, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la siguiente orden para hacer esto mismo con rapidez: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zr</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will R-educe the folding.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto r_educe el plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The opposite is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo opuesto es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zm</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This folds M-ore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto pliega m_ás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat "zr" and "zm" to open and close nested folds of several levels.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir «zr» y «zm» para abrir y cerrar pliegues anidados en varios niveles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zR</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>zM</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>zM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can quickly disable the folding with the |zn| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desactivar el plegado rápidamente con la orden |zn|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then |zN| brings back the folding as it was.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|Zn| devuelve el plegado a su estado previo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|zi| toggles between the two.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|zi| pasa de uno a otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a useful way of working: - create folds to get overview on your file - move around to where you want to do your work - do |zi| to look at the text and edit it - do |zi| again to go back to moving around</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una buena forma de trabajar: creación de pliegues para obtener una visión general de su archivo - desplazarse a las áreas que desea modificar - visionado y edición del texto con |zi| - repita |zi| para seguir desplazándose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.3*	Working with folds</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.3*	Trabajar con pliegues</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When some folds are closed, movement commands like "j" and "k" move over a fold like it was a single, empty line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De haber algunos pliegues cerrados, las órdenes de movimiento como «j» y «k» se desplazarán sobre el pliegue como si fuese una única línea vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to quickly move around over folded text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite un desplazamiento más rápido sobre texto plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is sometimes difficult to see or remember where a fold is located, thus where a |zo| command would actually work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces es difícil ver o recordar la ubicación de un pliegue; la orden |zo| es de utilidad en estos caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the defined folds: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver los pliegues definidos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldcolumn=4</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldcolumn=4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will show a small column on the left of the window to indicate folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto muestra una pequeña columna a la izquierda de la ventana que indica los pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "+" is shown for a closed fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «+» simboliza un pliegue cerrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A "-" is shown at the start of each open fold and "|" at following lines of the fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «-» aparece al principio de cada pliegue abierto y «|» simboliza líneas del pliegue a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the mouse to open a fold by clicking on the "+" in the foldcolumn.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el ratón para abrir un pliegue pulsando sobre la «+» en la columna de plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clicking on the "-" or a "|" below it will close an open fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar sobre «-» o el «|» que aparece debajo cierra un pliegue abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To open all folds at the cursor line use |zO|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |zO| para abrir todos los pliegues en la línea del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To close all folds at the cursor line use |zC|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |zC| para cerrar todos los pliegues en la línea del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete a fold at the cursor line use |zd|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede eliminar un pliegue en la línea del cursor con |zd|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete all folds at the cursor line use |zD|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |zD| para borrar todos los pliegues bajo la línea del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When in Insert mode, the fold at the cursor line is never closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea del cursor nunca se cierra en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That allows you to see what you type!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite ver lo que teclea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folds are opened automatically when jumping around or moving the cursor left or right.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los pliegues se abren automáticamente al desplazarse o moviendo el cursor a la izquierda o a la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the "0" command opens the fold under the cursor (if 'foldopen' contains "hor", which is the default).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, la orden «0» abre el pliegue bajo el cursor (si 'foldopen' contiene 'hor', el valor predeterminado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'foldopen' option can be changed to open folds for specific commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede modificar la opción 'foldopen' para abrir los pliegues con órdenes específicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want the line under the cursor always to be open, do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga lo siguiente si desea que la línea bajo el cursor esté siempre abierta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldopen=all</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldopen=all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Warning: You won't be able to move onto a closed fold then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aviso: en esta situación, no será capaz de desplazarse a un pliegue cerrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to use this only temporarily and then set it back to the default: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desea usar esto temporalmente para después devolverlo al valor original: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldopen&amp;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldopen&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldclose=all</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldclose=all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will re-apply 'foldlevel' to all folds that don't contain the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ejecutará 'foldlevel' en todos los pliegues que no contengan el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to try it out if you like how this feels.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene que probar para ver si le gusta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use |zm| to fold more and |zr| to fold less (reduce folds).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |zm| para plegar más, y |zr| para plegar menos (reducir los pliegues).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The folding is local to the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El pliegue es local para la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to open two windows on the same buffer, one with folds and one without folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite abrir dos ventanas en el mismo búfer, uno con pliegues y otro sin ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or one with all folds closed and one with all folds open.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O uno con todos los pliegues cerrados y otro con todos los pliegues abiertos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.4*	Saving and restoring folds</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.4*	Guardar y restaurar pliegues</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you abandon a file (starting to edit another one), the state of the folds is lost.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al cerrar un archivo para iniciar la edición de otro, el estado del pliegue es eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you come back to the same file later, all manually opened and closed folds are back to their default.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si vuelve al mismo archivo más tarde, todos aquellos pliegues cerrados y abiertos manualmente volverán a su estado predeterminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When folds have been created manually, all folds are gone!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Perderá todos los pliegues creados manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To save the folds use the |:mkview| command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden |:mkview| para guardar el estado de los archivos: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will store the settings and other things that influence the view on the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto guardará la configuración y otras que cosas que modifican el visionado del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change what is stored with the 'viewoptions' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede modificar lo guardado con  la opción 'viewoptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you come back to the same file later, you can load the view again: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cargar el mismo visionado al volver al archivo más tarde: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can store up to ten views on one file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede guardar hasta diez visionados distintos de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to save the current setup as the third view and load the second view: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para guardar la configuración actual como el tercer visionado, y cargar después el segundo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:mkview 3
	:loadview 2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:mkview 3
	:loadview 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that when you insert or delete lines the views might become invalid.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que, al insertar o eliminar líneas, las vistas dejarán de ser válidas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also check out the 'viewdir' option, which specifies where the views are stored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise también la opción 'viewdir', que define donde se guardan los visionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to delete old views now and then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desee eliminar viejos visionados de vez en cuando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.5*	Folding by indent</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.5*	Plegar según el sangrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining folds with |zf| is a lot of work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir pliegues con |zf| supone mucho trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your text is structured by giving lower level items a larger indent, you can use the indent folding method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el texto está estructurado de forma que los elementos de un nivel inferior tienen un mayor sangrado, puede usar el método de pliegue por sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create folds for every sequence of lines with the same indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésto crea pliegues para cada secuencia de líneas dentro del mismo sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lines with a larger indent will become nested folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas con un sangrado mayor se convertirán en pliegues anidados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works well with many programming languages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona muy bien con varios lenguajes de programación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldmethod=indent</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldmethod=indent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use the |zm| and |zr| commands to fold more and reduce folding.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede después usar las órdenes |zm| y |zr| para aumentar y reducir el plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's easy to see on this example text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es fácil de ver con este texto de ejemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line is not indented
	This line is indented once
		This line is indented twice
		This line is indented twice
	This line is indented once
This line is not indented
	This line is indented once
	This line is indented once</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea no tiene sangrado
	Esta línea tiene un sangrado
		Esta línea tiene doble sangrado
		Esta línea tiene doble sangrado
	Esta línea tiene un sangrado
La línea no tiene sangrado
	Esta línea tiene un sangrado
	Esta línea tiene un sangrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the relation between the amount of indent and the fold depth depends on the 'shiftwidth' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que la relación entre la cantidad de sangrado y la profundidad del pliegue depende de la opción 'shiftwidth'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each 'shiftwidth' worth of indent adds one to the depth of the fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada 'shiftwidth' con el valor de un sangrado añade uno a la profundidad del pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is called a fold level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este se denomina nivel de plegado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use the |zr| and |zm| commands you actually increase or decrease the 'foldlevel' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, cuando usa las órdenes |zr| y |zm| aumento o disminuye la opción 'foldlevel'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also set it directly: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede también definirlo directamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldlevel=3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldlevel=3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that all folds with three times a 'shiftwidth' indent or more will be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que todos los pliegues con un sangrado tres veces el valor de 'shiftwidth' se cerrarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lower the foldlevel, the more folds will be closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuanto más bajo es 'foldlevel', más pliegues se cerrarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When 'foldlevel' is zero, all folds are closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el valor de 'foldlevel' es cero, se cerrarán todos los pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|zM| does set 'foldlevel' to zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|zM| define 'foldlevel' como cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The opposite command |zR| sets 'foldlevel' to the deepest fold level that is present in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden opuesta |zR| define 'foldlevel' con el valor de nivel de pliegue más bajo presente en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus there are two ways to open and close the folds:
(A) By setting the fold level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, hay dos maneras de abrir y cerrar los pliegues:
(a) Definiendo el nivel de pliegue (foldlevel).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This gives a very quick way of "zooming out" to view the structure of the
    text, move the cursor, and "zoom in" on the text again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ofrece un rápida manera de alejar la vista para ver la estructura
    general del texto, desplazar el cursor, acercar la vista y de vuelta al
    texto otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(B) By using |zo| and |zc| commands to open or close specific folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(B) Usando las órdenes |zo| y |zc| para abrir o cerrar pliegues específicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows opening only those folds that you want to be open, while other
    folds remain closed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite abrir sólo aquellos pliegues que desea abrir, manteniendo
    los otros cerrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be combined: You can first close most folds by using |zm| a few times and then open a specific fold with |zo|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede combinar: primero puede cerrar la mayoría de los pliegues usando |zm| unas cuantas veces, y después abrir un pliegue en particular con |zo|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or open all folds with |zR| and then close specific folds with |zc|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O abrir todos los pliegues con |zR| y después cerrar pliegues específicos con |zc|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.6*	Folding with markers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.6*	Plegar con marcadores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldmethod=marker</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldmethod=marker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the folded line will display the text before the marker.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la líena plegada mostrará el texto previo al marcador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is very useful to tell what the fold contains.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil para informar de los contenidos del pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite annoying when the markers don't pair up correctly after moving some lines around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es bastante molesto cuando los marcadores no encajan correctamente tras desplazar algunas líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be avoided by using numbered markers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede evitar usando marcadores numerados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* global variables {{{1 */
	int varA, varB;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* global variables {{{1 */
	int varA, varB;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At every numbered marker a fold at the specified level begins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un pliegue se iniciará con el nivel definido por cada marcador numerado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make any fold at a higher level stop here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto detiene en este punto cualquier pliegue de nivel superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can just use numbered start markers to define all folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar marcadores de inicio numerados para definir todos los pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only when you want to explicitly stop a fold before another starts you need to add an end marker.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que añadir un marcador de fin sólo cuando desee detener un pliegue antes de iniciar otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.7*	Folding by syntax</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.7*	Plegar por sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.8*	Folding by expression</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.8*	Plegar por expresión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is similar to folding by indent, but instead of using the indent of a line a user function is called to compute the fold level of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es similar a plegar por sangrado pero usa una función de usuario para computar el nivel de pliegue de una línea, en lugar del sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use this for text where something in the text indicates which lines belong together.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar esto con texto en el que éste indica qué líneas están juntas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example is an e-mail message where the quoted text is indicated by a "&gt;" before the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo es un correo electrónico en el que el texto citado se indica con un «&gt;» al inicio de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fold these quotes use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto para plegar esas citas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^&gt;].*','',''))</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^&gt;].*','',''))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explanation for the 'foldexpr' used in the example (inside out):
   getline(v:lnum)			gets the current line
   substitute(...,'\\s','','g')		removes all white space from the line
   substitute(...,'[^&gt;].*','','')	removes everything after leading '&gt;'s
   strlen(...)				counts the length of the string, which
					is the number of '&gt;'s found</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Explicación del 'foldexpr' usado en el ejemplo (de dentro a fuera):
   getline(v:lnum)			obtiene la línea actual
   substitute(...,'\\s','','g')		elimina los espacios blancos de la línea
   substitute(...,'[^&gt;].*','','')	elimina todo lo que '&gt; precede
   strlen(...)				cuenta la longitud de la cadena,
					el cual es el número de '&gt;'
					encontrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that a backslash must be inserted before every space, double quote and backslash for the ":set" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que al usar la orden «:set» debe insertar una barra inversa antes de cada espacio, comilla doble y barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this confuses you, do &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto le confunde, haga &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldexpr</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldexpr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to check the actual resulting value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>para revisar el valor actual resultante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To correct a complicated expression, use the command-line completion: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para corregir una expresión compleja, use el auto completa de línea de órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set foldexpr=&lt;Tab&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set foldexpr=&lt;Tab&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where &lt;Tab&gt; is a real Tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí, &lt;Tab&gt; es una tabulación real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will fill in the previous value, which you can then edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim rellenará el valor previo, el cual puede después editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.9*	Folding unchanged lines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.9*	Plegar líneas sin cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful when you set the 'diff' option in the same window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil cuando define la opción 'diff' en la misma ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |vimdiff| command does this for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden |vimdiff| hace esto por usted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this in every window that shows a different version of the same file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga esto en cada ventana que muestre una versión distinta del mismo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will clearly see the differences between the files, while the text that didn't change is folded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá claramente las diferencias entre archivos, plegando a su vez aquellas líneas que no contienen cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*28.10* Which fold method to use?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*28.10* ¿Qué método de plegado debería usar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these possibilities make you wonder which method you should choose.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas estas posibilidades le hacen preguntarse qué método escoger.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, there is no golden rule.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por desgracia, no existe ninguna regla de oro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are some hints.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene algunas pistas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is a syntax file with folding for the language you are editing, that is probably the best choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De existir un archivo de sintaxis con plegado para el lenguaje en el que está editando, puede que sea la mejor opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there isn't one, you might try to write it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De no ser así, puede intentar crear uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This requires a good knowledge of search patterns.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto requiere un buen conocimiento de patrones de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not easy, but when it's working you will not have to define folds manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No resulta sencillo, pero una vez que funciona no tendrá definir los pliegues manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing commands to manually fold regions can be used for unstructured text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede escribir órdenes para plegar manualmente ciertas regiones al tratar con un texto sin estructura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use the |:mkview| command to save and restore your folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use después la orden |:mkview| para guardar y restaurar los pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The marker method requires you to change the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El método de marcado requiere que modifique el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are sharing the
files with other people or you have to meet company standards, you might not
be allowed to add them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si comparte archivos
con más personas, o tiene que cumplir con las directrices de una compañía,
cabe que no se le permita añadirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main advantage of markers is that you can put them exactly where you
want them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La principal ventaja de los marcadores es que puede insertarlas
exactamente donde desee.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That avoids that a few lines are missed when you cut and paste
folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto evita que se pierdan algunas líneas al copiar
y pegar pliegues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And you can add a comment about what is contained in the fold.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede después añadir un comentario acerca de los contenidos
del pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding by indent is something that works in many files, but not always very well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar por sangrado funciona en muchos ficheros, aunque con resultados variables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use it when you can't use one of the other methods.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Úselo cuando no puede usar ninguno de los otros métodos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, it is very useful for outlining.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así, es de utilidad con los diseños preliminares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you specifically use one 'shiftwidth' for each nesting level.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede entonces usar un 'shiftwidth' en particular para cada nivel de anidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Folding with expressions can make folds in almost any structured text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Plegar con expresiones puede crear pliegues en prácticamente cualquier texto
estructurado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is
quite simple to specify, especially if the start and end of a fold can easily
be recognized.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es sencillo de definir, particularmente se se pueden discernir con facilidad el principio y final de un pliegue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the "expr" method to define folds, but they are not exactly how
you want them, you could switch to the "manual" method.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si al definir los pliegues usa el método «expr», pero no con los
resultados deseados, puede pasar al método «manual».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will not remove
the defined folds.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no elimina los
pliegues ya definidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can delete or add folds manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede entonces añadir o eliminar pliegues de
manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*help.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*help.esx* *ayuda*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM - main help file
									 k
      Move around:  Use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VIM - archivo principal de ayuda
							  k
     Desplazamiento: Use las teclas de dirección,	h   l
		     o «h» para ir a la izquierda,	  j
		     «j» para ir hacia abajo, «k» hacia arriba
		     y «l» a la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>j
Close this window:  Use ":q&lt;Enter&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cerrar esta ventana: Use «:q&lt;Intro&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get out of Vim:  Use ":qa!&lt;Enter&gt;" (careful, all changes are lost!).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Salir de Vim: Use «:qa!&lt;Intro&gt;» (¡Atención, perderá todos
		     los cambios realizados!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get specific help:  It is possible to go directly to whatever you want help
		    on, by giving an argument to the |:help| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtener ayuda específica:
		     Es posible acudir directamente donde necesite ayuda,
		     introduciéndolo como un argumento de la orden |:help|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to further specify the context:
							*help-context*
			  WHAT			PREPEND    EXAMPLE	~
		      Normal mode command      (nothing)   :help x
		      Visual mode command	  v_	   :help v_u
		      Insert mode command	  i_	   :help i_&lt;Esc&gt;
		      Command-line command	  :	   :help :quit
		      Command-line editing	  c_	   :help c_&lt;Del&gt;
		      Vim command argument	  -	   :help -r
		      Option			  '	   :help 'textwidth'
  Search for help:  Type ":help word", then hit CTRL-D to see matching
		    help entries for "word".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible especificar detalladamente el contexto:
							*help-context*
			  QUÉ			ANEXAR    EJEMPLO	~
		      Orden modo Normal         (nada)    :help x
		      Orden modo Visual	           v_     :help v_u
		      Orden modo insertar	   i_	  :help i_&lt;Esc&gt;
		      Orden de línea de órdenes	   :	  :help :quit
		      Edición de línea de órdenes  c_	  :help c_&lt;Supr&gt;
		      Argumento de la orden VIM	   -	  :help -r
		      Opción			   '	  :help 'textwidth'
  Buscar ayuda:  Teclee «:help palabra» y pulse CTRL-D para ver las
		    entradas de ayuda coincidentes con «palabra».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use ":helpgrep word".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O use «:helpgrep palabra».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|:helpgrep|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|:helpgrep|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VIM stands for Vi IMproved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>VIM significa «Vi IMproved» (Vi mejorado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of VIM was made by Bram Moolenaar, but only
through the help of many others.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Bram Moolenaar es el principal
creador de Vim, pero sólo con la ayuda de muchos otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |credits|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |credits|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_toc.txt|	Table Of Contents</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_toc.esx|	Tabla de contenidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REFERENCE MANUAL: These files explain every detail of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MANUAL DE REFERENCIA: Estos archivos explican cada detalle de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*reference_toc*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*reference_toc*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>General subjects ~
|intro.txt|	general introduction to Vim; notation used in help files
|help.txt|	overview and quick reference (this file)
|helphelp.txt|	about using the help files
|index.txt|	alphabetical index of all commands
|help-tags|	all the tags you can jump to (index of tags)
|howto.txt|	how to do the most common editing tasks
|tips.txt|	various tips on using Vim
|message.txt|	(error) messages and explanations
|quotes.txt|	remarks from users of Vim
|todo.txt|	known problems and desired extensions
|develop.txt|	development of Vim
|debug.txt|	debugging Vim itself
|uganda.txt|	Vim distribution conditions and what to do with your money</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Temas generales ~
|intro.esx|	Introducción general a Vim; notación usada en los
                archivos de ayuda
|help.esx|	Información general y referencia rápida (este archivo)
|helphelp.txt|	Acerca del uso de los archivos de ayuda
|index.txt|	Índice alfabético de todas las órdenes
|help-tags|	Todas las etiquetas a las que puede saltar
		(índice de etiquetas)
|howto.txt|	Como realizar las tareas de edición más comunes
|tips.txt|	Varios consejos de uso de Vim
|message.txt|	Los mensajes de error y su explicación
|quotes.txt|	Comentarios de usuarios de Vim
|todo.txt|	Problemas conocidos y extensiones deseadas
|develop.txt|	Desarrollo de Vim
|debug.txt|	Depurando fallos de Vim
|uganda.txt|	Las condiciones de distribución de Vim
		y qué hacer con su dinero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic editing ~
|starting.txt|	starting Vim, Vim command arguments, initialisation
|editing.txt|	editing and writing files
|motion.txt|	commands for moving around
|scroll.txt|	scrolling the text in the window
|insert.txt|	Insert and Replace mode
|change.txt|	deleting and replacing text
|indent.txt|	automatic indenting for C and other languages
|undo.txt|	Undo and Redo
|repeat.txt|	repeating commands, Vim scripts and debugging
|visual.txt|	using the Visual mode (selecting a text area)
|various.txt|	various remaining commands
|recover.txt|	recovering from a crash</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edición básica ~
|starting.txt|	Iniciar Vim, argumentos de la orden Vim, inicialización
|editing.txt|	Editar y escribir archivos
|motion.txt|	Órdenes de desplazamiento
|scroll.txt|	Desplazar el texto en una ventana
|insert.txt|	Modos insertar y reemplazar
|change.txt|	Borrar y reemplazar texto
|indent.txt|	Tabulación automática para C y otros lenguajes
|undo.txt|	Deshacer y rehacer
|repeat.txt|	Repetir órdenes, Vim scripts y depuración de fallos
|visual.txt|	Usar el modo Visual (seleccionar un área de texto)
|various.txt|	Otras órdenes restantes
|recover.txt|	Recuperar datos después de un fallo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced editing ~
|cmdline.txt|	Command-line editing
|options.txt|	description of all options
|pattern.txt|	regexp patterns and search commands
|map.txt|	key mapping and abbreviations
|tagsrch.txt|	tags and special searches
|quickfix.txt|	commands for a quick edit-compile-fix cycle
|windows.txt|	commands for using multiple windows and buffers
|tabpage.txt|	commands for using multiple tab pages
|syntax.txt|	syntax highlighting
|spell.txt|	spell checking
|diff.txt|	working with two to four versions of the same file
|autocmd.txt|	automatically executing commands on an event
|filetype.txt|	settings done specifically for a type of file
|eval.txt|	expression evaluation, conditional commands
|fold.txt|	hide (fold) ranges of lines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edición avanzada ~
|cmdline.txt|	Edición en línea de órdenes
|options.txt|	Descripción de todas las opciones
|pattern.txt|	Patrones de expresiones regulares y órdenes de búsqueda
|map.txt|	Macros y abreviaturas
|tagsrch.txt|	Etiquetas y búsquedas especiales
|quickfix.txt|	Órdenes para un rápido ciclo editar-compilar-arreglar
|windows.txt|	Órdenes de uso de múltiples ventanas y búfers
|tabpage.txt|	Órdenes de uso de múltiples pestañas
|syntax.txt|	Resaltado de sintaxis
|spell.txt|	Corrección ortográfica
|diff.txt|	Trabajar con un número de entre 2 y 4 copias del mismo archivo
|autocmd.txt|	Ejecutar órdenes de manera automática
|filetype.txt|	Configuración específica según el tipo de archivo
|eval.txt|	Evaluación de expresión, órdenes condicionales
|fold.txt|	Ocultar (plegar) rangos de líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GUI ~
|gui.txt|	Graphical User Interface (GUI)
|gui_w16.txt|	Windows 3.1 GUI
|gui_w32.txt|	Win32 GUI
|gui_x11.txt|	X11 GUI</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>GUI/IGU ~
|gui.txt|	Interfaz gráfica de usuario
|gui_w16.txt|	Interfaz gráfica de usuario de Windows 3.1
|gui_w32.txt|	Interfaz gráfica de usuario de Win32
|gui_x11.txt|	Interfaz gráfica de usuario de X11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interfaces ~
|if_cscop.txt|	using Cscope with Vim
|if_lua.txt|	Lua interface
|if_mzsch.txt|	MzScheme interface
|if_perl.txt|	Perl interface
|if_pyth.txt|	Python interface
|if_sniff.txt|	SNiFF+ interface
|if_tcl.txt|	Tcl interface
|if_ole.txt|	OLE automation interface for Win32
|if_ruby.txt|	Ruby interface
|debugger.txt|	Interface with a debugger
|workshop.txt|	Sun Visual Workshop interface
|netbeans.txt|	NetBeans External Editor interface
|sign.txt|	debugging signs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Interfaces ~
|if_cscop.txt|	Usar Cscope con Vim
|if_lua.txt|	Interfaz Lua
|if_mzsch.txt|	Interfaz de MzScheme
|if_perl.txt|	Interfaz de Perl
|if_pyth.txt|	Interfaz de Python
|if_sniff.txt|	Interfaz de SNiFF+
|if_tcl.txt|	Interfaz de Tcl
|if_ole.txt|	Interfaz de automatización de OLE para Win32
|if_ruby.txt|	Interfaz de Ruby
|debugger.txt|	Interfaz con un depurador de fallos
|workshop.txt|	Interfaz de Sun Visual Workshop
|netbeans.txt|	Interfaz de NetBeans External Editor (editor externo)
|sign.txt|	Signos de depuración de fallos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Versions ~
|vi_diff.txt|	Main differences between Vim and Vi
|version4.txt|	Differences between Vim version 3.0 and 4.x
|version5.txt|	Differences between Vim version 4.6 and 5.x
|version6.txt|	Differences between Vim version 5.7 and 6.x
|version7.txt|	Differences between Vim version 6.4 and 7.x
						*sys-file-list*
Remarks about specific systems ~
|os_390.txt|	OS/390 Unix
|os_amiga.txt|	Amiga
|os_beos.txt|	BeOS and BeBox
|os_dos.txt|	MS-DOS and MS-Windows NT/95 common items
|os_mac.txt|	Macintosh
|os_mint.txt|	Atari MiNT
|os_msdos.txt|	MS-DOS (plain DOS and DOS box under Windows)
|os_os2.txt|	OS/2
|os_qnx.txt|	QNX
|os_risc.txt|	RISC-OS
|os_unix.txt|	Unix
|os_vms.txt|	VMS
|os_win32.txt|	MS-Windows 95/98/NT
						*standard-plugin-list*
Standard plugins ~
|pi_getscript.txt| Downloading latest version of Vim scripts
|pi_gzip.txt|	   Reading and writing compressed files
|pi_netrw.txt|	   Reading and writing files over a network
|pi_paren.txt|	   Highlight matching parens
|pi_tar.txt|	   Tar file explorer
|pi_vimball.txt|   Create a self-installing Vim script
|pi_zip.txt|	   Zip archive explorer</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Versiones ~
|vi_diff.txt|	Diferencias principales entre Vim y Vi
|version4.txt|	Diferencias entre las versiones de Vim 3.0 y 4.x
|version5.txt|	Diferencias entre las versiones de Vim 4.6 y 5.x
|version6.txt|	Diferencias entre las versiones de Vim 5.7 y 6.x
|version7.txt|	Diferencias entre las versiones de Vim 6.4 y 7.x
						*sys-file-list*
Apuntes sobre sistemas específicos ~
|os_390.txt|	OS/390 Unix
|os_amiga.txt|	Amiga
|os_beos.txt|	BeOS and BeBox
|os_dos.txt|	Elementos comunes entre MS-DOS y MS-Windows NT/95
|os_mac.txt|	Macintosh
|os_mint.txt|	Atari MiNT
|os_msdos.txt|	MS-DOS - DOS puro y terminal de DOS bajo Windows)
|os_os2.txt|	OS/2
|os_qnx.txt|	QNX
|os_risc.txt|	RISC-OS
|os_unix.txt|	Unix
|os_vms.txt|	VMS
|os_win32.txt|	MS-Windows 95/98/NT
						*standard-plugin-list*
Extensiones estándar ~
|pi_getscript.txt| Descargar la última versión de Vim scripts
|pi_gzip.txt|	Leer y escribir archivos comprimidos
|pi_netrw.txt|	Leer y escribir archivos en una red
|pi_paren.txt|	Resaltar «parens» coincidentes
|pi_tar.txt|	Explorador de archivos Tar
|pi_vimball.txt|Crear un script de Vim autoinstalable
|pi_zip.txt|	Explorador de archivos Zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>LOCAL ADDITIONS:				*local-additions*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ADICIONES LOCALES:				*local-additions*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*bars*		Bars example</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*bars*		Ejemplo de barras verticales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that tags are within | characters, but when highlighting is enabled these characters are hidden.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que las etiquetas se encuentran entre caracteres «|», que se ocultarán si activa el resaltado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That makes it easier to read a command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ello hace más sencillo leer una orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_toc.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_toc.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Table Of Contents			*user-manual*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tabla de contenidos		*manual-de-usuario* *user-manual*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reference manual
|reference_toc|     More detailed information for all commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Manual de referencia
|reference_toc|     Más información detallada de todas las órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user manual is available as a single, ready to print HTML and PDF file
here:
	http://vimdoc.sf.net</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de usuario está disponible en un único archivo listo para su
impresión, en formato PDF y HTML, en está ubicación:
	http://vimdoc.sf.net</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_01.txt|  About the manuals
		|01.1|	Two manuals
		|01.2|	Vim installed
		|01.3|	Using the Vim tutor
		|01.4|	Copyright</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_01.esx|  Acerca de los manuales
		|01.1|	Dos manuales
		|01.2|	Vim instalado
		|01.3|	Usar el tutor de Vim
		|01.4|	Copyright</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_02.txt|  The first steps in Vim
		|02.1|	Running Vim for the First Time
		|02.2|	Inserting text
		|02.3|	Moving around
		|02.4|	Deleting characters
		|02.5|	Undo and Redo
		|02.6|	Other editing commands
		|02.7|	Getting out
		|02.8|	Finding help</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_02.esx|  Primeros pasos en Vim
		|02.1|	Ejecutar Vim por primera vez
		|02.2|	Insertar texto
		|02.3|	Movimiento
		|02.4|	Eliminar caracteres
		|02.5|	Deshacer y rehacer
		|02.6|	Otras órdenes de edición
		|02.7|	Salir
		|02.8|	Encontrar ayuda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_03.txt|  Moving around
		|03.1|	Word movement
		|03.2|	Moving to the start or end of a line
		|03.3|	Moving to a character
		|03.4|	Matching a paren
		|03.5|	Moving to a specific line
		|03.6|	Telling where you are
		|03.7|	Scrolling around
		|03.8|	Simple searches
		|03.9|	Simple search patterns
		|03.10|	Using marks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_03.esx|  Desplazamiento
		|03.1|	Desplazarse sobre palabras
		|03.2|	Desplazarse al principio o al final de la línea
		|03.3|	Desplazarse a un carácter
		|03.4|	Emparejar un paréntesis
		|03.5|	Desplazarse a una línea específica
		|03.6|	Indicar dónde estás
		|03.7|	Desplazar el texto
		|03.8|	Búsquedas simples
		|03.9|	Patrones sencillos de búsqueda
		|03.10|	Uso de marcadores o marcas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_04.txt|  Making small changes
		|04.1|	Operators and motions
		|04.2|	Changing text
		|04.3|	Repeating a change
		|04.4|	Visual mode
		|04.5|	Moving text
		|04.6|	Copying text
		|04.7|	Using the clipboard
		|04.8|	Text objects
		|04.9|	Replace mode
		|04.10|	Conclusion</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_04.esx|  Making small changes
		|04.1|	Operadores y movimiento
		|04.2|	Cambiar texto
		|04.3|	Repetir un cambio
		|04.4|	Modo Visual
		|04.5|	Mover texto
		|04.6|	Copiar texto
		|04.7|	Uso del portapapeles
		|04.8|	Objetos de texto
		|04.9|	Modo reemplazar
		|04.10|	Conclusión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_05.txt|  Set your settings
		|05.1|	The vimrc file
		|05.2|	The example vimrc file explained
		|05.3|	Simple mappings
		|05.4|	Adding a plugin
		|05.5|	Adding a help file
		|05.6|	The option window
		|05.7|	Often used options</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_05.esx|  Configuración
		|05.1|	El archivo vimrc
		|05.2|	El archivo vimrc de ejemplo, explicado
		|05.3|	Macros sencillas
		|05.4|	Añadir una extensión
		|05.5|	Añadir un archivo de ayuda
		|05.6|	La ventana de opciones
		|05.7|	Opciones más comunes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_06.txt|  Using syntax highlighting
		|06.1|	Switching it on
		|06.2|	No or wrong colors?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_06.esx|  Uso del resaltado de sintaxis
		|06.1|	Activar
		|06.2|	¿Colores incorrectos o ausentes?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|06.3|	Different colors
		|06.4|	With colors or without colors
		|06.5|	Printing with colors
		|06.6|	Further reading</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|06.3|	Diferentes colores
		|06.4|	Con colores o sin colores
		|06.5|	Imprimir con colores
		|06.6|	Más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_07.txt|  Editing more than one file
		|07.1|	Edit another file
		|07.2|	A list of files
		|07.3|	Jumping from file to file
		|07.4|	Backup files
		|07.5|	Copy text between files
		|07.6|	Viewing a file
		|07.7|	Changing the file name</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_07.esx|  Editar más de un archivo
		|07.1|	Editar otro archivo
		|07.2|	Una lista de archivos
		|07.3|	Pasar de archivo a archivo
		|07.4|	Copias de seguridad
		|07.5|	Copiar texto entre archivos
		|07.6|	Ver un archivo
		|07.7|	Cambiar el nombre de archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_08.txt|  Splitting windows
		|08.1|	Split a window
		|08.2|	Split a window on another file
		|08.3|	Window size
		|08.4|	Vertical splits
		|08.5|	Moving windows
		|08.6|	Commands for all windows
		|08.7|	Viewing differences with vimdiff
		|08.8|	Various</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_08.esx|  Dividir en ventanas
		|08.1|	Dividir una ventana
		|08.2|	Dividir una ventana con otro archivo
		|08.3|	Tamaño de ventana
		|08.4|	Divisiones verticales
		|08.5|	Mover ventanas
		|08.6|	Órdenes sobre todas las ventanas
		|08.7|	Ver las diferencias con «vimdiff»
		|08.8|	Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_09.txt|  Using the GUI
		|09.1|	Parts of the GUI
		|09.2|	Using the mouse
		|09.3|	The clipboard
		|09.4|	Select mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_09.esx|  Uso de la interfaz gráfica (GUI)
		|09.1|	Partes de la interfaz gráfica
		|09.2|	Uso del ratón
		|09.3|	El portapapeles
		|09.4|	Modo Seleccionar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_10.txt|  Making big changes
		|10.1|	Record and playback commands
		|10.2|	Substitution
		|10.3|	Command ranges
		|10.4|	The global command
		|10.5|	Visual block mode
		|10.6|	Reading and writing part of a file
		|10.7|	Formatting text
		|10.8|	Changing case
		|10.9|	Using an external program</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_10.esx|  Realizar cambios grandes
		|10.1|	Órdenes de grabación y reproducción
		|10.2|	Sustitución
		|10.3|	Rangos de aplicación
		|10.4|	Las órdenes globales
		|10.5|	El modo de bloque Visual
		|10.6|	Leer y escribir parte de un archivo
		|10.7|	Formatear texto
		|10.8|	Cambiar mayúsculas y minúsculas
		|10.9|	Uso de un programa externo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_11.txt|  Recovering from a crash
		|11.1|	Basic recovery
		|11.2|	Where is the swap file?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_11.esx|  Recuperarse de un fallo
		|11.1|  Recuperación básica
		|11.2|  ¿Dónde está el archivo de recuperación?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_12.txt|  Clever tricks
		|12.1|	Replace a word
		|12.2|	Change "Last, First" to "First Last"
		|12.3|	Sort a list
		|12.4|	Reverse line order
		|12.5|	Count words
		|12.6|	Find a man page
		|12.7|	Trim blanks
		|12.8|	Find where a word is used</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_12.esx|  Trucos
		|12.1|	Reemplazar una palabra
		|12.2|	Cambiar «Último, Primero» a «Primero Último»
		|12.3|	Ordenar una lista
		|12.4|	Invertir el orden de las líneas
		|12.5|	Contar palabras
		|12.6|	Encontrar una página de manual
		|12.7|	Eliminar espacios en blanco sobrantes
		|12.8|	Buscar dónde se emplea una palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_20.txt|  Typing command-line commands quickly
		|20.1|	Command line editing
		|20.2|	Command line abbreviations
		|20.3|	Command line completion
		|20.4|	Command line history
		|20.5|	Command line window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_20.esx|  Ser eficaz en la línea de órdenes
		|20.1|	Edición en línea de órdenes
		|20.2|	Abreviaturas en línea de órdenes
		|20.3|	Autocompletado en la línea de órdenes
		|20.4|	Histórico de la línea de órdenes
		|20.5|	Ventana de la línea de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_21.txt|  Go away and come back
		|21.1|	Suspend and resume
		|21.2|	Executing shell commands
		|21.3|	Remembering information; viminfo
		|21.4|	Sessions
		|21.5|	Views
		|21.6|	Modelines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_21.esx|  Abandonar el editor y volver
		|21.1|	Suspender y continuar
		|21.2|	Ejecutar órdenes de consola
		|21.3|	Recordar información; viminfo
		|21.4|	Sesiones
		|21.5|	Vistas
		|21.6|	«Modelines»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_22.txt|  Finding the file to edit
		|22.1|	The file explorer
		|22.2|	The current directory
		|22.3|	Finding a file
		|22.4|	The buffer list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_22.esx| Encontrar el archivo a editar
		|22.1|	El explorador de archivos
		|22.2|	El directorio actual
		|22.3|	Encontrar un archivo
		|22.4|	La lista de búfers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_23.txt|  Editing other files
		|23.1|	DOS, Mac and Unix files
		|23.2|	Files on the internet
		|23.3|	Encryption
		|23.4|	Binary files
		|23.5|	Compressed files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_23.esx|  Editar otros archivos
		|23.1|	Archivos de DOS, Mac y Unix
		|23.2|	Archivos en Internet
		|23.3|	Cifrado
		|23.4|	Archivos binarios
		|23.5|	Archivos comprimidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_24.txt|  Inserting quickly
		|24.1|	Making corrections
		|24.2|	Showing matches
		|24.3|	Completion
		|24.4|	Repeating an insert
		|24.5|	Copying from another line
		|24.6|	Inserting a register
		|24.7|	Abbreviations
		|24.8|	Entering special characters
		|24.9|	Digraphs
		|24.10|	Normal mode commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_24.esx|  Insertar con rapidez
		|24.1|	Corregir
|		24.2|	Mostrar coincidencias
		|24.3|	Autocompletado
		|24.4|	Repetir una inserción
		|24.5|	Copiar desde otra línea
		|24.6|	Insertar un registro
		|24.7|	Abreviaturas
		|24.8|	Introducir caracteres especiales
		|24.9|	Dígrafos
		|24.10|	Órdenes del modo Normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_25.txt|  Editing formatted text
		|25.1|	Breaking lines
		|25.2|	Aligning text
		|25.3|	Indents and tabs
		|25.4|	Dealing with long lines
		|25.5|	Editing tables</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_25.txt|  Editar texto con formato
		|25.1|	Dividir líneas
		|25.2|	Alinear texto
		|25.3|	Sangrado y tabulación
		|25.4|	Tratar líneas largas
		|25.5|	Editar tablas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_26.txt|  Repeating
		|26.1|	Repeating with Visual mode
		|26.2|	Add and subtract
		|26.3|	Making a change in many files
		|26.4|	Using Vim from a shell script</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_26.txt|  Repetición
		|26.1|	Repetir en modo Visual
		|26.2|	Sumar y restar
		|26.3|	Realizar un cambio en varios archivos
		|26.4|	Usar Vim desde un script de intérprete de órdenes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_27.txt|  Search commands and patterns
		|27.1|	Ignoring case
		|27.2|	Wrapping around the file end
		|27.3|	Offsets
		|27.4|	Matching multiple times
		|27.5|	Alternatives
		|27.6|	Character ranges
		|27.7|	Character classes
		|27.8|	Matching a line break
		|27.9|	Examples</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_27.esx| Órdenes y patrones de búsqueda
		|27.1|	Ignorar la distinción entre mayúsculas y minúsculas
		|27.2|	Justificar el fin del archivo
		|27.3|	Dirección relativa («offsets»)
		|27.4|	Emparejar varios elementos
		|27.5|	Alternativas
		|27.6|	Rangos de caracteres
		|27.7|	Clases de caracteres
		|27.8|	Coincidir con un salto de línea
		|27.9|	Ejemplos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_28.txt|  Folding
		|28.1|	What is folding?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_28.txt|  Plegar
		|28.1|	¿Qué es plegar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|28.2|	Manual folding
		|28.3|	Working with folds
		|28.4|	Saving and restoring folds
		|28.5|	Folding by indent
		|28.6|	Folding with markers
		|28.7|	Folding by syntax
		|28.8|	Folding by expression
		|28.9|	Folding unchanged lines
		|28.10| Which fold method to use?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|28.2|	Plegar manualmente
		|28.3|	Trabajar con pliegues
		|28.4|	Guardar y restaurar pliegues
		|28.5|	Plegar por sangrado
		|28.6|	Plegar con marcadores
		|28.7|	Plegar por sintaxis
		|28.8|	Plegar por expresión
		|28.9|	Plegar líneas sin cambios
		|28.10¿| ¿Qué método de plegar debería usar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_29.txt|  Moving through programs
		|29.1|	Using tags
		|29.2|	The preview window
		|29.3|	Moving through a program
		|29.4|	Finding global identifiers
		|29.5|	Finding local identifiers</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_29.txt|  Moverse a través de programas
		|29.1|	Usar etiquetas
		|29.2|	La ventana de previsualización
		|29.3|	Moverse a través de un programa
		|29.4|	Buscar identificadores globales
		|29.5|	Buscar identificadores locales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_30.txt|  Editing programs
		|30.1|	Compiling
		|30.2|	Indenting C files
		|30.3|	Automatic indenting
		|30.4|	Other indenting
		|30.5|	Tabs and spaces
		|30.6|	Formatting comments</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_30.txt|  Editar programas
		|30.1|	Compilar
		|30.2|	Sangrado en archivos C
		|30.3|	Sangrado automático
		|30.4|	Otros sangrados
		|30.5|	Tabulados y espacios
		|30.6|	Formatear comentarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_31.txt|  Exploiting the GUI
		|31.1|	The file browser
		|31.2|	Confirmation
		|31.3|	Menu shortcuts
		|31.4|	Vim window position and size
		|31.5|	Various</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_31.txt|  Sacar partido a la interfaz gráfica
		|31.1|	El explorador de archivos
		|31.2|	Confirmación
		|31.3|	Atajos de teclado para menús
		|31.4|	Posición y tamaño de la ventana de Vim
		|31.5|	Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_32.txt|  The undo tree
		|32.1|	Undo up to a file write
		|32.2|	Numbering changes
		|32.3|	Jumping around the tree
		|32.4|	Time travelling</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_32.txt|  El árbol de deshacer
		|32.1|Volver a un punto de edición anterior
		|32.2|Numerar los cambios
		|32.3|Desplazarse en el árbol
		|32.4|Viajar en el tiempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_40.txt|  Make new commands
		|40.1|	Key mapping
		|40.2|	Defining command-line commands
		|40.3|	Autocommands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_40.txt|  Crear órdenes nuevas
		|40.1|Macros de teclado
		|40.2|Definir órdenes de línea de órdenes
		|40.3|Órdenes automáticas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_41.txt|  Write a Vim script
		|41.1|	Introduction
		|41.2|	Variables
		|41.3|	Expressions
		|41.4|	Conditionals
		|41.5|	Executing an expression
		|41.6|	Using functions
		|41.7|	Defining a function
		|41.8|	Lists and Dictionaries
		|41.9|	Exceptions
		|41.10|	Various remarks
		|41.11|	Writing a plugin
		|41.12|	Writing a filetype plugin
		|41.13|	Writing a compiler plugin
		|41.14|	Writing a plugin that loads quickly
		|41.15|	Writing library scripts
		|41.16|	Distributing Vim scripts</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_41.txt|  Escribir scripts para Vim
		|41.1|	Introducción
		|41.2|	Variables
		|41.3|	Expresiones
		|41.4|	Estructuras de decisión
		|41.5|	Ejecución de expresiones
		|41.6|	Funciones
		|41.7|	Definición de funciones
		|41.8|	Listas y Diccionarios
		|41.9|	Excepciones
		|41.10|	Observaciones
		|41.11|	Escribir extensiones
		|41.12|	Escribir extensiones para tipo de archivo		|41.13|	Escribir extensiones para compiladores		|41.14|	Escribir extensiones que carguen rápidamente
		|41.15|	Escribir bibliotecas
		|41.16|	Distribuir scripts de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_06.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_06.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2009 Oct 28</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 24/5/2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using syntax highlighting</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uso del resaltado de sintaxis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Black and white text is boring.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto en blanco y negro es aburrido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With colors your file comes to life.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con colores los archivos tienen más vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This not only looks nice, it also speeds up your work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No sólo adquieren mejor apariencia, si no que acelera la producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change the colors used for the different sorts of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cambie los colores para distintos tipos de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Print your text, with the colors you see on the screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imprima sus textos con los colores que ve en pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|06.1|	Switching it on
|06.2|	No or wrong colors?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|06.1|	Activar
|06.2|	¿Colores incorrectos o ausentes?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|06.3|	Different colors
|06.4|	With colors or without colors
|06.5|	Printing with colors
|06.6|	Further reading</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|06.3|	Diferentes colores
|06.4|	Con colores o sin colores
|06.5|	Imprimir con colores
|06.6|	Más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_07.txt|  Editing more than one file
 Previous chapter: |usr_05.txt|  Set your settings
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_07.esx|  Editar más de un archivo
  Capítulo anterior: |usr_05.esx|  Configuración
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.1*	Switching it on</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.1*	Activar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:syntax enable</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:syntax enable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That should work in most situations to get color in your files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto debería funcionar en la mayoría de las situaciones para obtener el coloreado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will automagically detect the type of file and load the right syntax highlighting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim detectará automágicamente el tipo de archivo y cargará la sintaxis correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suddenly comments are blue, keywords brown and strings red.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De repente, los comentarios, las palabras clave y las cadenas se colorean.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes it easy to overview the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto facilita una vista general del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After a while you will find that black&amp;white text slows you down!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Tras usarlo un poco se dará cuenta de lo que le ralentizaba la edición el blanco y negro!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if &amp;t_Co &gt; 1
	   syntax enable
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if &amp;t_Co &gt; 1
	   syntax enable
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.2*	No or wrong colors?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.2*	¿Colores incorrectos o ausentes?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Your terminal does not support colors.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Su terminal no soporta colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will use bold, italic and underlined text, but this doesn't look
	very nice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usará negrita, itálica y texto subrayado, pero esto no es muy
	agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You probably will want to try to get a terminal with
	colors.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Probablemente quiera probar una terminal con colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix, I recommend the xterm from the XFree86 project:
	|xfree-xterm|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para Unix, se recomienda usar la xterm del proyecto XFree86:
	|xfree-xterm|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Your terminal does support colors, but Vim doesn't know this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Su terminal soporta colores, pero Vim no lo sabe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure your $TERM setting is correct.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asegúrese de que la variable $TERM es correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when using an
	xterm that supports colors: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, cuando
	use una xterm que soporte colores: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>setenv TERM xterm-color
&lt;
	or (depending on your shell): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>setenv TERM xterm-color
&lt;
	o (dependiendo de su consola): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TERM=xterm-color; export TERM</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>TERM=xterm-color; export TERM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	The terminal name must match the terminal you are using.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	El nombre de la terminal debe coincidir con la terminal que esté
	usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it
	still doesn't work, have a look at |xterm-color|, which shows a few
	ways to make Vim display colors (not only for an xterm).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si aún así no funciona, consulte |xterm-color|,
	donde puede ver unas cuantas maneras de hacer que se vean colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- The file type is not recognized.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El tipo de archivo no es reconocido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim doesn't know all file types, and sometimes it's near to impossible
	to tell what language a file uses.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no conoce todos los tipos de archivos, y a veces es casi imposible
	decir que lenguaje usa un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Try this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set filetype
&lt;
	If the result is "filetype=" then the problem is indeed that Vim
	doesn't know what type of file this is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set filetype
&lt;
	Si el resultado es «filetype=» entonces el problema es que Vim no sabe
	que de qué tipo de archivo se trata.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set the type
	manually: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede decirle el tipo de archivo
	de forma manual: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set filetype=fortran</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set filetype=fortran</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	To see which types are available, look in the directory
	$VIMRUNTIME/syntax.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Para ver qué tipos de archivos están disponibles,  mire en el
	directorio «$VIMRUNTIME/syntax».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the GUI you can use the Syntax menu.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para la GUI puede usar el menú Syntax.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the filetype can also be done with a |modeline|, so that the
	file will be highlighted each time you edit it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede activar el tipo de archivo con un |modeline|, de forma
	que el archivo se resaltará cada vez que lo edite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, this
	line can be used in a Makefile (put it near the start or end of the
	file): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, puede
	emplear esta línea para los Makefiles (insértela cerca del principio o
	el final del archivo): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># vim: syntax=make</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg># vim: syntax=make</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	You might know how to detect the file type yourself.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Quizá sepa cómo detectar el tipo de archivo por cuenta propia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often the file
	name extension (after the dot) can be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A
	menudo se puede emplear la extensión del nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |new-filetype| for how to tell Vim to detect that file type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |new-filetype| para ver cómo decirle a Vim que detecte el tipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- There is no highlighting for your file type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- No hay resaltado para su tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could try using a similar file type by manually setting it as
	mentioned above.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede intentar usar un archivo similar activándolo manualmente como se
	explica más arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If that isn't good enough, you can write your own
	syntax file, see |mysyntaxfile|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no tiene suficiente, puede escribir su propio
	archivo de sintaxis, consulte |mysyntaxfile|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- The colored text is very hard to read.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- El texto coloreado es muy difícil de leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim guesses the background color that you are using.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim trata de averiguar el color de fondo que está usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is black
	(or another dark color) it will use light colors for text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es negro
	(u otro color oscuro) usará colores claros para el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is
	white (or another light color) it will use dark colors for text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si es blanco
	(u otro color claro) usará colores oscuros para el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If
	Vim guessed wrong the text will be hard to read.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si Vim no ha
	acertado, el texto se hará difícil de leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To solve this, set
	the 'background' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para solucionar esto,
	active la opción 'background'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a dark background: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para un fondo oscuro: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set background=dark</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set background=dark</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	And for a light background: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Y para un fondo claro: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set background=light</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set background=light</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	Make sure you put this _before_ the ":syntax enable" command,
	otherwise the colors will already have been set.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Asegúrese de que lo pone _antes_ de «:syntax enable», en caso
	contrario, los colores ya se habrán definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could do
	":syntax reset" after setting 'background' to make Vim set the default
	colors again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer «:syntax
	reset» tras activar 'background' para hacer que Vim vuelva a redefinir
	los colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.3*	Different colors				*:syn-default-override*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.3*	Diferentes colores				*:syn-default-override*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like the default colors, you can select another color scheme.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gustan los colores predeterminados, puede seleccionar otro esquema de colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the GUI use the Edit/Color Scheme menu.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En GVim, use el menú Edit/Color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also type the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:colorscheme evening</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:colorscheme evening</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"evening" is the name of the color scheme.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«evening» es el nombre del esquema de colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several others you might want to try out.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay muchos otros que quizá quiera probar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look in the directory $VIMRUNTIME/colors.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mire en el directorio «$MYVIMRUNTIME/colors».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also write your own color scheme.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede escribir su propio esquema de colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is how you do it:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así es que como se hace:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select a color scheme that comes close.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Seleccione un esquema que se parezca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy this file to your own Vim
   directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie ese archivo a su propio
   directorio de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Unix, this should work: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Bajo Unix, esto debería funcionar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>!mkdir ~/.vim/colors
	!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim
&lt;
   This is done from Vim, because it knows the value of $VIMRUNTIME.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>!mkdir ~/.vim/colors
	!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim
&lt;
   Esto se hace desde Vim, porque conoce el valor de $VIMRUNTIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the color scheme file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Editar el archivo del esquema de colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These entries are useful:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas entradas son
   útiles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>term		attributes in a B&amp;W terminal
	cterm		attributes in a color terminal
	ctermfg		foreground color in a color terminal
	ctermbg		background color in a color terminal
	gui		attributes in the GUI
	guifg		foreground color in the GUI
	guibg		background color in the GUI</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>term		atributos en una terminal B/N
	cterm		atributos en una terminal a color
	ctermfg		color frontal de una terminal a color
	ctermbg		color de fondo de una terminal a color
	gui		atributos de la GUI
	guifg		color frontal de la GUI
	guibg		color de fondo de la GUI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to make comments green: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para hacer los comentarios en verde: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:highlight Comment ctermfg=green guifg=green
&lt;
   Attributes you can use for "cterm" and "gui" are "bold" and "underline".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:highlight Comment ctermfg=green guifg=green
&lt;
   Los atributos que puede usar para «cterm» y «gui» son «bold» y «underline».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want both, use "bold,underline".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere los dos, escriba «bold,underline».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details see the |:highlight|
   command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más detalles, consulte la
   orden |:highlight|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tell Vim to always use your color scheme.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Decir a Vim que use siempre su esquema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this line in your |vimrc|: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Incluya esto en su |vimrc|: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>colorscheme mine</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>colorscheme mine</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:runtime syntax/colortest.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:runtime syntax/colortest.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see text in various color combinations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá texto en varias combinaciones de colores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can check which ones are readable and look nice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede comprobar cuáles son legibles y que tienen un apariencia agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.4*	With colors or without colors</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.4*	Con colores o sin colores</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Displaying text in color takes a lot of effort.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mostrar texto en color conlleva un gran uso del procesador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you find the displaying too slow, you might want to disable syntax highlighting for a moment: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si le parece que el texto se muestra muy lentamente, puede desactivar el resaltado momentáneamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:syntax clear</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:syntax clear</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*:syn-off*
If you want to stop highlighting completely use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*:syn-off*
Si quiere desactivar el resaltado por completo use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:syntax off</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:syntax off</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*:syn-manual*
If you want syntax highlighting only for specific files, use this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*:syn-manual*
Si desea resaltado de sintaxis sólo para archivos específicos, use esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:syntax manual</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:syntax manual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will enable the syntax highlighting, but not switch it on automatically when starting to edit a buffer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permitirá el resaltado, pero no lo activará automáticamente cuando edites un búfer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To switch highlighting on for the current buffer, set the 'syntax' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para activarla en el búfer actual, asigne la opción 'syntax' del siguiente modo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set syntax=ON
&lt;
==============================================================================</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set syntax=ON
==============================================================================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.5*	Printing with colors				*syntax-printing*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.5*	Imprimir con colores				*syntax-printing*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:hardcopy</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:hardcopy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will get the usual printer dialog, where you can select the printer and a few settings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le aparecerá el típico diálogo de impresora, donde puede seleccionarla junto con algunas opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a color printer, the paper output should look the same as what you see inside Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene una impresora a color, la salida impresa debe ser similar a lo que aparece en pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But when you use a dark background the colors will be adjusted to look good on white paper.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, cuando tiene un fondo oscuro, los colores se ajustarán para verse bien sobre blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several options that change the way Vim prints:
	'printdevice'
	'printheader'
	'printfont'
	'printoptions'</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay diversas opciones que modifican el modo en el que Vim imprime:
	'printdevice'
	'printheader'
	'printfont'
	'printoptions'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>v100j:hardcopy</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>v100j:hardcopy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v" starts Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«v» inicia el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"100j" moves a hundred lines down, they will be highlighted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«100j» le mueve 100 líneas hacia abajo, que se resaltarán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then ":hardcopy" will print those lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último «:hardcopy» imprimirá las líneas destacadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use other commands to move in Visual mode, of course.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar otras órdenes para moverse en modo Visual, por supuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works on Unix, if you have a PostScript printer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona en Unix si tiene una impresora PostScript.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, you will have to do a bit more work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, tendrá que hacer un poco más de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to convert the text to HTML first, and then print it from a web browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que convertir a HTML primero y luego imprimirlo desde un navegador web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:TOhtml</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:TOhtml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:source $VIMRUNTIME/syntax/2html.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:source $VIMRUNTIME/syntax/2html.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see it crunching away, this can take quite a while for a large file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo verá trabajar, esto puede llevar un buen tiempo para archivos grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some time later another window shows the HTML code.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un rato después otra ventana muestra el código HTML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now write this somewhere
(doesn't matter where, you throw it away later):
&gt;
	:write main.c.html</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora guarde esto en algún
lugar (no importa dónde, lo eliminará en cuanto termine de imprimir):
&gt;
	:write main.c.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open this file in your favorite browser and print it from there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Abra este archivo en su navegador favorito e imprímalo desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If all goes well, the output should look exactly as it does in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si todo ha salido bien, la salida debe tener la misma apariencia que tenía en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |2html.vim| for details.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |2html.vim| para más detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to delete the HTML file when you are done with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se olvide de eliminar el archivo HTML.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*06.6*	Further reading</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*06.6*	Más información</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|usr_44.txt|  Your own syntax highlighted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|usr_44.txt|  Su propio resaltado de sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|syntax|      All the details.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|syntax|      Todos los detalles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_12.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_12.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clever tricks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Trucos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By combining several commands you can make Vim do nearly everything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes conseguir que Vim haga casi cualquier cosa,.mediante la combinación varias órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this chapter a number of useful combinations will be presented.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este capítulo, presentaremos una serie de combinaciones útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses the commands introduced in the previous chapters and a few more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto emplea las órdenes introducidos en capítulos anteriores y algunos más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|12.1|	Replace a word
|12.2|	Change "Last, First" to "First Last"
|12.3|	Sort a list
|12.4|	Reverse line order
|12.5|	Count words
|12.6|	Find a man page
|12.7|	Trim blanks
|12.8|	Find where a word is used</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|12.1|	Reemplazar una palabra
|12.2|	Cambiar «Último, Primero» a «Primero Último»
|12.3|	Ordenar una lista
|12.4|	Invertir el orden de las líneas
|12.5|	Contar palabras
|12.6|	Encontrar una página de manual
|12.7|	Eliminar espacios en blanco sobrantes
|12.8|	Buscar dónde se emplea una palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_20.txt|  Typing command-line commands quickly
 Previous chapter: |usr_11.txt|  Recovering from a crash
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_20.esx|  Ser eficaz con la línea de órdenes
  Capítulo anterior: |usr_11.esx|  Recuperarse de un fallo
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.1*	Replace a word</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.1*  Reemplazar una palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/four/4/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/cuatro/4/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\&lt;four/4/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\&lt;cuatro/4/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, this still goes wrong on "fourteen".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, esto también funcionará mal con «cuatrocientos».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "\&gt;" to match the end of a word: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «\&gt;» para concordar el final de una palabra: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\&lt;four\&gt;/4/g</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\&lt;cuatro\&gt;/4/g</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are programming, you might want to replace "four" in comments, but not in the code.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está programando, quizá desee reemplazar «cuatro» en los comentarios, pero no en el código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since this is difficult to specify, add the "c" flag to have the substitute command prompt you for each replacement: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que es difícil de especificar, añada la opción «c» para que se le pida una confirmación cada vez que se vaya a reemplazar la palabra: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\&lt;four\&gt;/4/gc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\&lt;cuatro\&gt;/4/gc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you want to replace a word in more than one file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiere reemplazar una palabra en más de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could edit each
file and type the command manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede
editar cada archivo y escribir la orden manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a lot faster to use record and
playback.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es mucho más fácil
usar la grabación y reproducción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assume you have a directory with C++ files, all ending in ".cpp".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a suponer que tiene un directorio con archivos C++ en el que todos
terminan en «.cpp».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a function called "GetResp" that you want to rename to "GetAnswer".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quiere renombrar la función «GetResp» a «GetAnswer».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the last file you will get an error message, because ":wnext" cannot move to the next file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el último archivo obtendrá un mensaje de error, porque «wnext» no puede ir a un archivo siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stops the execution, and everything is done.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto parará la ejecución y todo terminará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	When playing back a recorded sequence, an error stops the execution.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Cuando vuelva a reproducir una secuencia grabada, un error detendrá la
	ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, make sure you don't get an error message when recording.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuide de no producir errores cuando grabes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one catch: If one of the .cpp files does not contain the word "GetResp", you will get an error and replacing will stop.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra «GetResp», obtendrá un error y la ejecución se detendrá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this, add the "e" flag to the substitute command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar esto, añada la opción «e» a la orden de sustituir: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\&lt;GetResp\&gt;/GetAnswer/ge</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\&lt;GetResp\&gt;/GetAnswer/ge</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.2*	Change "Last, First" to "First Last"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.2*	Cambiar «Último, Primero» a «Primero Último»</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Doe, John ~
	Smith, Peter ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pepe, Juan ~
	Amancio, Pedro ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>John Doe ~
	Peter Smith ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Juan Pepe ~
	Pedro Amancio ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\([^,]*\), \(.*\)/\2 \1/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\([^,]*\), \(.*\)/\2 \1/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's break this down in parts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veámoslo por partes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously it starts with a substitute
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente comienza con la orden «substitute».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "%" is the line range, which stands for the whole file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «%» es el rango de líneas, que se refiere al archivo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus
the substitution is done in every line in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo
tanto la sustitución se producirá en cada línea del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arguments for the substitute command are "/from/to/".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los argumentos para la orden sustituir son «/desde/a/».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The slashes
separate the "from" pattern and the "to" string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las barras
separan el patrón «desde» y la cadena "hacia".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is what the "from"
pattern contains:
							\([^,]*\), \(.*\) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es lo que el patrón
«desde» contiene:
							\([^,]*\), \(.*\) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first part between \( \) matches "Last"	\(     \)
	    match anything but a comma			  [^,]
	    any number of times				      *
	matches ", " literally					 ,
	The second part between \( \) matches "First"		   \(  \)
	    any character					     .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera parte entre \( \) concuerda «Último» \(     \)
	    concordar cualquier cosa excepto una coma     [^,]
	    cualquier número de veces                         *
	concuerda literalmente ", "                              ,
	La segunda parte entre \(  \) concuerda «Primero»	   \(  \)
	    cualquier carácter                                       .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>any number of times					      *</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>cualquier número de veces 					     *</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the "to" part we have "\2" and "\1".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la parte «a» tenemos «\2» y «\1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are called backreferences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A esto se le llaman referencias
«inversas».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They refer to the text matched by the "\( \)" parts in the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se refieren al texto encontrado por los «\( \)» del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"\2"
refers to the text matched by the second "\( \)", which is the "First" name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«\2» se
refiere al texto del segundo «\( \)», que es el nombre «Primero».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"\1" refers to the first "\( \)", which is the "Last" name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«\1» se
refiere al primer «\( \)», que es el nombre «Último».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use up to nine backreferences in the "to" part of a substitute
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar hasta nueve referencias «inversas» en la parte «a» de una
orden de sustitución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"\0" stands for the whole matched pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«\0x se refiere a la cadena coincidente completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few more
special items in a substitute command, see |sub-replace-special|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay
otros elementos especiales en una orden sustituir,
consulte |sub-replace-special|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.3*	Sort a list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.3*	Ordenar una lista</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a Makefile you often have a list of files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A menudo, en un archivo Makefile tiene una lista de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/^OBJS
	j
	:.,/^$/-1!sort</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/^OBJS
	j
	:.,/^$/-1!sort</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This goes to the first line, where "OBJS" is the first thing in the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto va a la primera línea, donde «OBJS» es lo primero que se encuentra en una
línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then it goes one line down and filters the lines until the next empty line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego baja una línea y filtra las líneas hasta encontrar una línea
vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also select the lines in Visual mode and then use "!sort".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También podría seleccionar las líneas en modo Visual y escribir
«!sort».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's
easier to type, but more work when there are many lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es más fácil pero conlleva más trabajo cuando hay muchas líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es el siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that a backslash at the end of each line is used to indicate the line
continues.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que una barra inversa al final de cada línea se usa para indicar
que la línea continúa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After sorting, this is wrong!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras ordenar, está mal puesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "backup.o" line that was at
the end didn't have a backslash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea de «backup.o»
que estaba al final no tenía una barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that it sorts to another place, it
must have a backslash.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que se sitúa en otro
lugar debe tener una barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest solution is to add the backslash with "A \&lt;Esc&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La solución más sencilla es añadirla con «A \&lt;Esc&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can
keep the backslash in the last line, if you make sure an empty line comes
after it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mantener la
barra en la última línea si se asegura de que una línea en blanco viene justo
después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That way you don't have this problem again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo no tendrá este problema de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.4*	Reverse line order</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.4*	Invertir el orden de las líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:global| command can be combined with the |:move| command to move all the lines before the first line, resulting in a reversed file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «|:global|» se debe combinar con la orden «|:move|» para mover todas las líneas antes de la primera línea, invirtiendo el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:global/^/m 0</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:global/^/m 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:g/^/m 0</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:g/^/m 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" regular expression matches the beginning of the line (even if the line is blank).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La expresión regular «^» coincide con el comienzo de línea (incluso si la línea está en blanco).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:move| command moves the matching line to after the mythical zeroth line, so the current matching line becomes the first line of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «|:move|» mueve la línea justo después de la mítica «línea cero», de forma que se convierte en la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the |:global| command is not confused by the changing line numbering, |:global| proceeds to match all remaining lines of the file and puts each as the first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Como la orden «|:global|» no se confunde al cambiar la numeración de las líneas, «|:global|» procede a concordar el resto de líneas del archivo y pone cada una como la primera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works on a range of lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona sobre un rango de líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First move to above the first line and mark it with "mt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya primero a la línea de encima de la primera y márcala con "mt".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then move the cursor to the last line in the range and type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego pon el cursor en la última línea del rango y escribe: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:'t+1,.g/^/m 't</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:'t+1,.g/^/m 't</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.5*	Count words</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.5*	Contar palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you have to write a text with a maximum number of words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces puede escribir un texto con un número máximo de palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can
count the words for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim
puede contar las palabras por Ud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the whole file is what you want to count the words in, use this
command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando quiera usar el archivo completo para contar las palabras, use la
siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>g CTRL-G</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>g CTRL-G</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not type a space after the g, this is just used here to make the command
easy to read.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No teclee un espacio tras la «g», esto está aquí para hacer que la orden sea
fácil de leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida tendrá este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Col 1 of 0; Línea 141 of 157; Palabra 748 of 774; Carácter 4489 of 4976 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the text is only part of a file, you could move to the start of the text, type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then use your brain to compute the difference in the word position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando el texto sea sólo una parte del archivo, puede ir al comienzo del texto, pulsar «g CTRL-G», ir al final del texto y volver a escribir «g CTRL-G» y usar la cabeza para calcular la diferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a good exercise, but there is an easier way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es un buen ejercicio, pero hay un modo más sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Visual mode, select the text you want to count words in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el modo Visual, seleccione el texto sobre el que quiera contar las palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then type g CTRL-G.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba «g CTRL-G».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Selección 5 of 293 Líneas; 70 of 1884 Palabras; 359 of 10928 Bytes ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.6*	Find a man page					*find-manpage*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.6*	Encontrar una página de manual		*find-manpage*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>K</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>K</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will run the external "man" program on the word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ejecutará el programa externo «man» sobre la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the man page is found, it is displayed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si se encuentra la página de manual, se mostrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses the normal pager to scroll through the text (mostly the "more" program).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto usa el paginador normal para desplazarse por el texto (con el programa «more»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you get to the end pressing &lt;Enter&gt; will get you back into Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando llegue al final, presionando &lt;Intro&gt; le devolverá a Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage is that you can't see the man page and the text you are working on at the same time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una desventaja es que no puede ver la página de manual y el texto en el que trabaja al mismo tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a trick to make the man page appear in a Vim window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un truco para hacer que la página de manual aparezca en una ventana de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, load the man filetype plugin: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero cargue la extensión del tipo de archivo man: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:runtime! ftplugin/man.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:runtime! ftplugin/man.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Put this command in your vimrc file if you intend to do this often.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga esta orden en su archivo «vimrc» si tiene la intención de hacer esto a menudo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the ":Man" command to open a window on a man page: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar «:Man» para ver una página man en una ventana: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Man csh</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Man csh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can scroll around and the text is highlighted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede desplazarse alrededor y el texto se resaltará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to find
the help you were looking for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite
encontrar la ayuda que estaba buscando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use CTRL-W w to jump to the window with the
text you were working on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «CTRL-W w» para saltar a la
ventana con el texto en el que trabajaba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find a man page in a specific section, put the section number first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar la página de manual en una sección específica, ponga el
número de sección primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to look in section 3 for "echo": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para ver «echo» en la sección 3: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:Man 3 echo</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:Man 3 echo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To jump to another man page, which is in the text with the typical form "word(1)", press CTRL-] on it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para saltar a otra página de manual, la cuál está en el texto con la forma típica «word(1)», pulse «CTRL-]» sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further ":Man" commands will use the same window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otras llamadas a «:Man» emplearán la misma ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\K</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\K</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If you redefined the &lt;Leader&gt;, use it instead of the backslash).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si ha redefinido &lt;Leader&gt;, úselo en lugar de la barra inversa).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you want to know the return value of "strstr()" while editing this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, puede que quiera saber el valor que le devuelve «strstr()» mientras edita esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if ( strstr (input, "aap") == ) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if ( strstr (input, "aap") == ) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to somewhere on "strstr" and type "\K".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga el cursor en alguna parte de «strstr» y escriba «\K».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A window will open to display the man page for strstr().</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una ventana se abrirá a continuación para mostrar la página de manual de «strstr()».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.7*	Trim blanks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.7*	Eliminar espacios en blanco sobrantes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some people find spaces and tabs at the end of a line useless, wasteful, and ugly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas personas encuentran los espacios y los tabuladores al final de línea inútiles y feos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove whitespace at the end of every line, execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar el espacio en blanco al final de cada línea, ejecute la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%s/\s\+$//</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%s/\s\+$//</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line range "%" is used, thus this works on the whole file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El rango de línea «%» es empleado, funcionando sobre todo en el archivo
completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The pattern
that the ":substitute" command matches with is "\s\+$".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El patrón que la orden «:substitute» concuerda es el «\s\+$».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds white
space characters (\s), 1 or more of them (\+), before the end-of-line ($).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra los caracteres en blanco (\s), 1 o más (\+), antes del final
de línea ($).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Later will be explained how you write patterns like this |usr_27.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "to" part of the substitute command is empty: "//".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte «hacia» de la orden de sustituxión está vacía: «//».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it replaces
with nothing, effectively deleting the matched white space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto
reemplaza con nada, lo que de hecho elimina el espacio en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another wasteful use of spaces is placing them before a tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro uso desafortunado de los espacios es colocarlos antes de un tabulador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often these can be deleted without changing the amount of white space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A menudo, se pueden eliminar sin cambiar la cantidad de espacio en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But not always!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Pero no siempre!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, you can best do this manually.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, lo mejor es que lo haga a mano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this search command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esta orden de búsqueda: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot see it, but there is a space before a tab in this command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede verlo, pero hay un espacio antes de un tabulador en esta orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus
it's "/&lt;Space&gt;&lt;Tab&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De
hecho, es «/&lt;Espacio&gt;&lt;Tabulador&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use "x" to delete the space and check that the
amount of white space doesn't change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use ahora «x» para eliminar el espacio
y comprobar que la cantidad de espacio en blanco no cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have to insert a tab if it
does change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que
tenga que insertar un tabulador si cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type "n" to find the next match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee «n» para encontrar la
próxima coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeat this until no more
matches can be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repita esto hasta que no se encuentren más
concordancias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*12.8*	Find where a word is used</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*12.8*	Buscar donde se emplea una palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si eres un usuario de sistemas UNIX, puede usar una combinación de Vim
y «grep» para editar todos los archivos que contengan la palabra dada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es extremadamente útil si está trabajando en un programa y quiere
ver o editar todos los archivos que contienen una variable específica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, suppose you want to edit all the C program files that contain
the word "frame_counter".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, suponga que desea editar todos los archivos C que contengan
la palabra «frame_counter».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you use the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer esto, use la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim `grep -l frame_counter *.c`</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim `grep -l frame_counter *.c`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command only finds the files in which the word is found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden anterior sólo dice los archivos en los cuáles se encuentra la
palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You still
have to find the word within the files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todavía tendrás que encontrar la palabra entre los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a built-in command that you can use to search a set of files for a
given string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una orden integrada que puede usar para buscar una cadena
en un conjunto de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to find all occurrences of "error_string" in all C
program files, for example, enter the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea encontrar todas las coincidencias de
«error_string» en todos los archivos C, por ejemplo, introduzca lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:grep error_string *.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:grep error_string *.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This causes Vim to search for the string "error_string" in all the specified
files (*.c).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim busque la cadena «error_string» en cada uno de los
archivos especificados (*.c).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The editor will now open the first file where a match is found
and position the cursor on the first matching line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor abrirá el primer archivo donde se
produzca una concordancia y posicionará el cursor en la primera línea
coincidente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go to the next
matching line (no matter in what file it is), use the ":cnext" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ir a la siguiente línea (no importa en que archivo se encuentre), use la
orden «:cnext».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go
to the previous match, use the ":cprev" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ir a la anterior, use «:cprev».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ":clist" to see all the
matches and where they are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «:clist» para ver
todas las coincidencias y dónde están.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":grep" command uses the external commands grep (on Unix) or findstr
(on Windows).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:grep"» usa la orden externa «grep» en Unix y «findstr» en
Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change this by setting the option 'grepprg'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes cambiar esto modificando la opción 'grepprg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_04.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_04.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2008 Sep 06</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 7/6/2008</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Making small changes</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hacer cambios pequeños</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter shows you several ways of making corrections and moving text around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo le muestra diferentes formas de hacer correcciones y moverse en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It teaches you the three basic ways to change text: operator-motion, Visual mode and text objects.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le muestra los tres modos básicos de cambiar texto: operador-movimiento, modo Visual y objetos de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|04.1|	Operators and motions
|04.2|	Changing text
|04.3|	Repeating a change
|04.4|	Visual mode
|04.5|	Moving text
|04.6|	Copying text
|04.7|	Using the clipboard
|04.8|	Text objects
|04.9|	Replace mode
|04.10|	Conclusion</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|04.1|	Operadores y movimiento
|04.2|	Cambiar texto
|04.3|	Repetir un cambio
|04.4|	Modo Visual
|04.5|	Mover texto
|04.6|	Copiar texto
|04.7|	Uso del portapapeles
|04.8|	Objetos de texto
|04.9|	Modo reemplazar
|04.10|	Conclusión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_05.txt|  Set your settings
 Previous chapter: |usr_03.txt|  Moving around
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_05.esx|  Configuración
  Capítulo anterior: |usr_03.esx|  Desplazamiento
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.1*	Operators and motions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.1*	Operadores y movimiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In chapter 2 you learned the "x" command to delete a single character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el capítulo 2 aprendió que la orden «x» elimina un único carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And
using a count: "4x" deletes four characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y
que usar un multiplicador: «4x» elimina cuatro caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "dw" command deletes a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «dw» elimina una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may recognize the "w" command as the
move word command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Reconocerá la orden «w» como el de
movimiento sobre palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In fact, the "d" command may be followed by any motion
command, and it deletes from the current location to the place where the
cursor winds up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, la orden «d» se ha completar con
una orden de movimiento, y elimina desde la posición actual hasta donde
marque el movimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "4w" command, for example, moves the cursor over four words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «4w», por ejemplo, mueve el cursor cuatro palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The d4w
command deletes four words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden
d4w elimina cuatro palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
			 ------------------&gt;
				 d4w</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
			  ----------------------&gt;
				 d4w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim only deletes up to the position where the motion takes the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim sólo elimina hasta la posición donde la orden de movimiento le lleva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's because Vim knows that you probably don't want to delete the first character of a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Eso es porque Vim sabe que probablemente no desea eliminar la primera letra de una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the "e" command to move to the end of a word, Vim guesses that you do want to include that last character:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa la orden «ex para desplazarse hasta el final de una palabra, Vim adivina que quiere incluir el último carácter:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the character under the cursor is included depends on the command you used to move to that character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El que el carácter bajo el cursor se incluya o no depende de la orden de movimiento empleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reference manual calls this "exclusive" when the character isn't included and "inclusive" when it is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El manual de referencia llama a esto «exclusivo» cuando el carácter no se incluye e «inclusivo» en caso contrario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" command moves to the end of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «$» le desplaza hasta el final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "d$" command deletes from the cursor to the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «d$» elimina desde el cursor hasta el final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an inclusive motion, thus the last character of the line is included in the delete operation:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un movimiento inclusivo, por lo que el último carácter de la línea se incluye en la operación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		       ------------&gt;
			    d$</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		       -----------&gt;
			    d$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To err is human ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Errar es humano ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a pattern here: operator-motion.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sigue siempre la misma estructura: operador-movimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You first type an operator command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero introduce el operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "d" is the delete operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «d» es el operador de eliminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you type a motion command like "4l" or "w".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego introduce una orden de movimiento «4l» o «w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This way you can operate on any text you can move over.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De esta manera, puede operar sobre cualquier texto en el que se pueda desplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.2*	Changing text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.2*	Cambiar texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another operator is "c", change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro operador es «c», cambiar (change).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It acts just like the "d" operator, except it leaves you in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Actúa justo como el operador «d», excepto que le deja en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "cw" changes a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo «cw» cambia una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or more specifically, it deletes a word and then puts you in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es decir, elimina una palabra y le deja en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To err is human ~
	   -------&gt;
	     c2wbe&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Errar es humano ~
	---------&gt;
	 c2wEl ser&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be human ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El ser humano ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>c	the change operator
	2w	move two words (they are deleted and Insert mode started)
	be	insert this text
	&lt;Esc&gt;	back to Normal mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>c	el operador de cambio
	2w	moverse dos palabras (se eliminan y va al modo Insertar)
	El ser	inserta el siguiente texto
	&lt;Esc&gt;	de vuelta al modo Normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have paid attention, you will have noticed something strange: The space before "human" isn't deleted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha prestado atención, se habrá dado cuenta de que hay algo raro: El espacio antes de «humano» no se ha eliminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a saying that for every problem there is an answer that is simple, clear, and wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un dicho: para cada problema hay una solución que es simple, clara y errónea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is the case with the example used here for the "cw" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el caso con el ejemplo usado aquí con la orden «cw».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The c operator works just like the d operator, with one exception: "cw".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operador «c» funciona justo como el operador «d», con una excepción: «cw».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It actually works like "ce", change to end of word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, funciona justo igual que «ce», cambiar hasta el final de la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the space after the word isn't included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio después de la palabra no se incluye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an exception that dates back to the old Vi.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta excepción data de Vi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since many people are used to it now, the inconsistency has remained in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que mucha gente se ha acostumbrado a ella, ha permanecido con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like "dd" deletes a whole line, "cc" changes a whole line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Del mismo modo que «dd» elimina una línea completa, «cc» la cambia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It keeps the existing indent (leading white space) though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además, mantiene la sangría (los espacios en blanco precedentes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like "d$" deletes until the end of the line, "c$" changes until the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así como «d$» elimina hasta el final de la línea, «c$» la cambia hasta el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's like doing "d$" to delete the text and then "a" to start Insert mode and append new text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es como pulsar «d$» para eliminar el texto y luego «a» para activar el modo Insertar y añadir más texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>x  stands for  dl  (delete character under the cursor)
	X  stands for  dh  (delete character left of the cursor)
	D  stands for  d$  (delete to end of the line)
	C  stands for  c$  (change to end of the line)
	s  stands for  cl  (change one character)
	S  stands for  cc  (change a whole line)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>x  equivale a  dl  (eliminar carácter bajo el cursor)
	X  equivale a  dh  (eliminar carácter a la izquierda del cursor)
	D  equivale a  d$  (eliminar hasta el final de la línea)
	C  equivale a  c$  (cambiar hasta el final de la línea)
	s  equivale a  cl  (cambiar un carácter)
	S  equivale a  cc  (cambiar una única línea)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands "3dw" and "d3w" delete three words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes «3dw» y «d3wx eliminan tres palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to get really picky about things, the first command, "3dw", deletes one word three times; the command "d3w" deletes three words once.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere ponerse detallista, la primera ordem, «3dw», elimina una palabra tres veces; la orden «d3w» elimina tres palabras de una vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a difference without a distinction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta diferencia no se puede distinguir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can actually put in two counts, however.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, puede poner dos multiplicadores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "3d2w" deletes two words, repeated three times, for a total of six words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo «3d2w» elimina dos palabras y lo repite 3 veces, un total de seis palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "r" command is not an operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «r» no es un operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It waits for you to type a character, and will replace the character under the cursor with it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Espera a que introduzca un carácter, y reemplazará el carácter bajo el cursor con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could do the same with "cl" or with the "s" command, but with "r" you don't have to press &lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes hacer lo mismo con la orden «cl» o con «s», pero con «r» no tendrá que pulsar &lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is somerhing grong here ~
	rT	     rt    rw</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>aquí hay algo tue esná mal ~
	rA	      rq    rt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is something wrong here ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí hay algo que está mal ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a count with "r" causes that many characters to be replaced with the same character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar un multiplicador con «r» causa que se reemplacen muchos caracteres con el mismo carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is something wrong here ~
			   5rx</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí hay algo que está mal ~
			   5rx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is something xxxxx here ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí hay algo que exxxxxal ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To replace a character with a line break use "r&lt;Enter&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para reemplazar un carácter con un salto de línea use «r&lt;Entrar&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This deletes one character and inserts a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina un carácter e inserta un salto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a count here only applies to the number of characters deleted: "4r&lt;Enter&gt;" replaces four characters with one line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar un multiplicador aquí sólo afecta al número de caracteres eliminados: «4r&lt;Entrar&gt;» reemplaza cuatro caracteres con un salto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.3*	Repeating a change</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.3*	Repetir un cambio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." command is one of the most simple yet powerful commands in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «.» es uno de los más sencillos pero más potentes de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It repeats the last change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repite el último cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, suppose you are editing an HTML file and want to delete all the &lt;B&gt; tags.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, suponga que está editando un archivo HTML y desea eliminar todas las etiquetas &lt;B&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You position the cursor on the first &lt; and delete the &lt;B&gt; with the command "df&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello, coloque el cursor sobre el primer &lt; y luego elimine el &lt;B&gt; con la orden «df&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You then go to the &lt; of the next &lt;/B&gt; and kill it using the "." command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces va al &lt; del &lt;/B&gt; y lo elimina con la orden «.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "." command executes the last change command (in this case, "df&gt;").</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «.» ejecuta el último cambio (en este caso «df&gt;»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete another tag, position the cursor on the &lt; and use the "." command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar otra etiqueta, coloque el cursor sobre el &lt; y vuelve a pulsar la orden «.».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To &lt;B&gt;generate&lt;/B&gt; a table of &lt;B&gt;contents ~
	f&lt;   find first &lt;     ---&gt;
	df&gt;  delete to &gt;	 --&gt;
	f&lt;   find next &lt;	   ---------&gt;
	.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para &lt;B&gt;generar&lt;/B&gt; una tabla de &lt;B&gt;contenidos ~
	f&lt;   ir al primer  &lt;    ---&gt;
	df&gt;  elimina hasta &gt;       --&gt;
	f&lt;   ir al segundo &lt;	   ----------&gt;
	.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>repeat df&gt;			    ---&gt;
	f&lt;   find next &lt;		       -------------&gt;
	.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>repetir df&gt;		     ---&gt;
	f&lt;   ir al siguiente &lt;		     ------------------&gt;
	.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>repeat df&gt;					    --&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>repetir df&gt;				       --&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example: You want to change the word "four" to "five".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro ejemplo: Desea cambiar la palabra «cuatro» por «cinco».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It appears several times in your text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aparece varias veces en su texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this quickly with this sequence of commands:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer esto rápidamente en una secuencia de órdenes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/four&lt;Enter&gt;	find the first string "four"
	cwfive&lt;Esc&gt;	change the word to "five"
	n		find the next "four"
	.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/cuatro&lt;Entrar&gt;	encuentra la primera cadena «cuatro»
	cwcinco&lt;Esc&gt;	cambia la palabra a «cinco»
	n		encuentra la siguiente cadena «cuatro»
	.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>repeat the change to "five'
	n		find the next "four"
	.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>repite el cambio a «cinco»
	n		encuentra la siguiente cadena «cuatro»
	.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>repeat the change
			etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>repite el cambio
			etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.4*	Visual mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.4*	Modo visual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete simple items the operator-motion changes work quite well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los cambios operador-movimiento funcionan bastante bien para eliminar elementos sencillos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But often it's not so easy to decide which command will move over the text you want to change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero a menudo, no es fácil decidir que orden de movimiento le desplazará hasta el texto que quiere modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es el momento de usar el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start Visual mode by pressing "v".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar el modo Visual pulsando «v».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You move the cursor over the text you
want to work on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mover el cursor sobre el
texto que desea modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you do this, the text is highlighted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mientras haces esto, el texto se resalta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally type
the operator command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Finalmente, teclee la orden del operador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to delete from halfway one word to halfway another word:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para eliminar de la mitad de una palabra a la mitad de otra:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an examination sample of visual mode ~
			       ----------&gt;
				 velllld</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una muestra cualquiera del modo Visual ~
				 ----------&gt;
				 veehhd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example of visual mode ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es una muestra del modo Visual ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When doing this you don't really have to count how many times you have to press "l" to end up in the right position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hace esto, no tiene que contar cuántas veces pulsa «e» o «h» para llegar a la posición deseada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can immediately see what text will be deleted when you press "d".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede verlo de forma inmediata antes de pulsar «d».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work on whole lines, use "V" to start Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere trabajar con líneas completas, use «V» para iniciar el modo
Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will
see right away that the whole line is highlighted, without moving around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá que toda la línea se resalta, sin ni siquiera mover el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you move left or right nothing changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando mueva el cursor a la izquierda o derecha, nada cambiará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you move up or down the
selection is extended whole lines at a time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo mueve
hacia arriba o hacia abajo, la selección se extenderá a líneas completas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, select three lines with "Vjj":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, seleccione tres líneas con «Vjj»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+------------------------+
			  | text more text	   |
		       &gt;&gt; | more text more text    | |
	selected lines &gt;&gt; | text text text	   | | Vjj
		       &gt;&gt; | text more		   | V
			  | more text more	   |
			  +------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+------------------------+
			  | texto más texto	   |
		       &gt;&gt; | más texto más texto    | |
  líneas seleccionadas &gt;&gt; | texto texto texto	   | | Vjj
		       &gt;&gt; | texto más		   | V
			  | más texto más	   |
			  +------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work on a rectangular block of characters, use CTRL-V to start Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea trabajar en un bloque rectangular de caracteres, use CTRL-V para iniciar el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is very useful when working on tables.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es muy útil si trabaja con tablas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>name		Q1	Q2	Q3
		pierre		123	455	234
		john		0	90	39
		steve		392	63	334</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>nombre		Q1	Q2	Q3
		pedro		123	455	234
		juan		0	90	39
		estéban		392	63	334</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To delete the middle "Q2" column, move the cursor to the "Q" of "Q2".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar la columna central «Q2» desplaze el cursor a la «Q» de «Q2».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Press CTRL-V to start blockwise Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse CTRL-V para iniciar el modo Visual de bloques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now move the cursor three lines down with "3j" and to the next word with "w".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora mueva el cursor tres líneas abajo con «3j» y a la siguiente palabra con «w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the first character of the last column is included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede comprobar que el primer carácter de la última columna se ha incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To exclude it, use "h".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para excluirlo, use «h».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press "d" and the middle column is gone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora pulsa «d» la columna central desaparecerá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have selected some text in Visual mode, and discover that you need to change the other end of the selection, use the "o" command (Hint: o for other end).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha seleccionado algo de texto en modo Visual, y descubre que necesita cambiar el otro lado de la selección, use la orden «o» (Truco: o para el «otro» lado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor will go to the other end, and you can move the cursor to change where the selection starts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor irá hasta el otro final de la selección, y podrá modificar dónde comienza la selección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing "o" again brings you back to the other end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsa «o» de nuevo para volver al otro lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using blockwise selection, you have four corners.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando usa el modo Visual de bloques, tiene cuatro esquinas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"o" only takes you to one of the other corners, diagonally.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«o» le llevará a una de las otras líneas diagonalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "O" to move to the other corner in the same line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «O» para moverse hacia el otro final de la misma línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.5*	Moving text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.5*	Mover texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you delete something with the "d", "x", or another command, the text is
saved.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimina algo con «d», «x», u otra orden, el texto se guarda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can paste it back by using the p command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede pegarlo usando la orden «p».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(The Vim name for
this is put).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(El nombre de Vim para esto es «poner»,
del inglés «put»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take a look at how this works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Échale un vistazo a cómo funciona esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you will delete an entire line, by
putting the cursor on the line you want to delete and typing "dd".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Elimine primero una línea
completa poniendo el cursor en la línea y pulsando «dd».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you
move the cursor to where you want to put the line and use the "p" (put)
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva ahora el
cursor allá donde quiera poner la línea y use la orden «p».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The line is inserted on the line below the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La línea se
insertará en la línea siguiente a donde se encuentra el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a line		a line	      a line
	line 2	  dd	line 3	  p   line 3
	line 3			      line 2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>una línea	una línea     una línea
	línea 2	   dd	línea 3	   p  línea 3
	línea 3			      línea 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because you deleted an entire line, the "p" command placed the text line below the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que eliminó una línea completa, la orden «p» colocó la línea de texto debajo del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you delete part of a line (a word, for instance), the "p" command puts it just after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si elimina parte de una línea (una palabra, por ejemplo), la orden «px la pone justo después del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "P" command puts text like "p", but before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «P» pone una línea como «p», pero antes del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you deleted a whole line with "dd", "P" will put it back above the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimine una línea con «dd», «P» lo pondrá de vuelta sobre el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you deleted a word with "dw", "P" will put it back just before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando elimine una palabra con «dw», «P» lo pondrá antes del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat putting as many times as you like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir la orden tantas veces como quiera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same text will be used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se usará el mismo texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a count with "p" and "P".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar un multiplicador con «p» y «P».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text will be repeated as many times as specified with the count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto se repetirá tantas veces como especifique con el multiplicador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "dd" and then "3p" puts three copies of the same deleted line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, usar «dd» y luego «3p» pone tres copias de la misma línea eliminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Frequently when you are typing, your fingers get ahead of your brain (or the other way around?).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más de una vez, mientras teclea, sus dedos irán por delante de su cerebro (¿o al revés?).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is a typo such as "teh" for "the".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es un error del tipo «uqe» en lugar de «que».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim makes it easy to correct such problems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim hace que corregir estos problemas sea sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just put the cursor on the e of "teh" and execute the command "xp".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Simplemente ponga el cursor sobre la «u» de «uqe» y ejecute la orden «xp».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works as follows: "x" deletes the character e and places it in a register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona del siguiente modo: «x» elimina el carácter «u» y lo coloca en un registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"p" puts the text after the cursor, which is after the h.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«p» pone el texto después del cursor, justo después de la «q».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>teh     th     the ~
	 x       p</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>uqe     qe     que ~
	x       p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.6*	Copying text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.6*	Copiar texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To copy text from one place to another, you could delete it, use "u" to undo
the deletion and then "p" to put it somewhere else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para copiar texto de un lugar a otro, puede eliminarlo, usar «u» para
deshacer la eliminación y después usar «p» para colocarlo en otro lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an easier way:
yanking.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay
un modo mejor: «yank» (dar un tirón).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "y" operator copies text into a register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operador «y» copia texto en un
registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then a "p" command
can be used to put it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar una orden «p» para ponerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yanking is just a Vim name for copying.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«Yanking» es simplemente el nombre de Vim para copiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "c" letter was already used
for the change operator, and "y" was still available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La letra «c» ya
estaba en uso por el operador «cambiar», y la «y» estaba aún disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling this
operator "yank" made it easier to remember to use the "y" key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Llamar a este el operador «yank» hizo que fuera más fácil recordar la «y».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since "y" is an operator, you use "yw" to yank a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que «y» es un operador, se usa «yw» para copiar una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A count is possible as usual.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se puede usar un multiplicador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To yank two words use "y2w".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para copiar dos palabras usa «y2w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let sqr = LongVariable * ~
		 --------------&gt;
		       y2w</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let sqr = LongVariable * ~
		 --------------&gt;
		       y2w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let sqr = LongVariable * ~
			       p</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let sqr = LongVariable * ~
			       p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>let sqr = LongVariable * LongVariable ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>let sqr = LongVariable * LongVariable ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that "yw" includes the white space after a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que «yw» incluye el espacio en blanco después de la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want this, use "ye".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no quiere que esto ocurra, us «ye».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "yy" command yanks a whole line, just like "dd" deletes a whole line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «yy» copia una sola línea, al igual que «dd» la elimina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unexpectedly, while "D" deletes from the cursor to the end of the line, "Y" works like "yy", it yanks the whole line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, mientras que «D» elimina desde el cursor hasta el final de la línea, «Y» funciona como «yy», copiando la línea completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out for this inconsistency!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Cuidado con esta inconsistencia!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "y$" to yank to the end of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «y$» para copiar sólo hasta el final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a text line   yy	a text line	       a text line
	line 2			line 2		p      line 2
	last line		last line	       a text line
						       last line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>línea de texto   yy	línea de texto         línea de texto
	línea 2			línea 2		p      línea 2
	última línea		última línea	       línea de texto
						       última línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.7*	Using the clipboard</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.7*	Uso del portapapeles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have copied text to the clipboard in another application, you can paste it in Vim with the Edit/Paste menu.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ha copiado texto en el portapapeles desde otra aplicación, puede pegarlo en Vim con el menú Editar/Pegar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This works in Normal mode and Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona en modo Normal y en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Visual mode the selected text is replaced with the pasted text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En modo Visual el texto seleccionado es reemplazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Cut" menu item deletes the text before it's put on the clipboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «Cortar» del menú elimina el texto antes de ponerlo en el portapapeles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Copy", "Cut" and "Paste" items are also available in the popup menu (only when there is a popup menu, of course).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las opciones «Cortar», «Copiar» y «Pegar» están también disponibles en el menú contextual (sólo cuando esté disponible).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Vim has a toolbar, you can also find these items there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su Vim tiene barra de tareas, puede encontrar estos botones allí también.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using the GUI, or if you don't like using a menu, you have to use another way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no usa la GUI o no te gusta usar el menú, tiene otro modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You use the normal "y" (yank) and "p" (put) commands, but prepend "* (double-quote star) before it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «y» normal (copiar) y «p» (poner), pero antes escriba «"*» (comillas dobles, asterisco).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To copy a line to the clipboard: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para copiar una línea en el portapapeles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"*yy</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"*yy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works on versions of Vim that include clipboard support.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funciona en versiones de Vim que incluyen soporte para portapapeles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about the clipboard in section |09.3| and here: |clipboard|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más sobre el portapapeles en la sección |09.3| y aquí: |clipboard|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.8*	Text objects</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.8*	Objetos de texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the cursor is in the middle of a word and you want to delete that word, you need to move back to its start before you can do "dw".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el cursor está en medio de una palabra y la quiere eliminar, tiene que desplazarse hasta su comienzo antes de que pueda hacer «dw».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a simpler way to do this: "daw".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un modo más sencillo de hacer esto: «daw».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this is some example text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>esto es texto de ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		       daw</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		 daw</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this is some text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>esto es de ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "d" of "daw" is the delete operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «d» de «daw» es el operador de eliminación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"aw" is a text object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«aw» es el objeto de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: "aw" stands for "A Word".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Truco: «aw» viene de «A Word».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "daw" is "Delete A Word".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo que «daw» es «Delete A Word».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be precise, the white space after the word is also deleted (the white space before the word at the end of the line).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ser más precisos, el espacio después de la palabra se elimina también (el espacio antes de la palabra si ésta se encuentra al final de una línea).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change a whole sentence use "cis".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para cambiar una oración completa use «cis».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take this text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga este texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ~
	is an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ~
	es un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move to the start of the second line, on "is an".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya al comienzo de la segunda línea, sobre el «es un».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use "cis":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, use «cis»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is in between the blanks in the first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está entre los espacios de la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you type the new sentence "Another line.":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba ahora la nueva frase «Otra línea.»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"cis" consists of the "c" (change) operator and the "is" text object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«cis» consiste del operador «c» (cambiar) y el objeto de texto «is».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stands for "Inner Sentence".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto viene de «Inner Sentence».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also the "as" (a sentence) object.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También hay un objeto «as» (a sentence).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The difference is that "as" includes the white space after the sentence and "is" doesn't.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La diferencia es que «as» incluye el espacio en blanco después de la frase e «is» no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would delete a sentence, you want to delete the white space at the same time, thus use "das".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea eliminar la frase y quiere eliminar al mismo tiempo el espacio en blanco posterior, use entonces «das».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to type new text the white space can remain, thus you use "cis".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere escribir otro texto, el espacio puede permanecer, con lo que puedes usar «cis».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use text objects in Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar los objetos de texto on modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will include the text object in the Visual selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Incluirá el objeto de texto en la selección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual mode continues, thus you can do this several times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Visual permanece, así que puede hacerlo varias veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, start Visual mode with "v" and select a sentence with "as".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, inicie el modo Visual con «v» y seleccione una frase con «as».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can repeat "as" to include more sentences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede repetir «as» para incluir más frases.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally you use an operator to do something with the selected sentences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, use un operador para hacer algo con las frases seleccionadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.9*	Replace mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.9*	Modo reemplazar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "R" command causes Vim to enter replace mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «R» hace que Vim entre en modo reemplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this mode, each
character you type replaces the one under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este modo, cada
carácter que introduzca reemplaza al que está debajo del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This continues until
you type &lt;Esc&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto
continúa hasta que pulse &lt;Esc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example you start Replace mode on the first "t" of "text":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este ejemplo, Ud. comienza el modo Reemplazar en la primera «t» de «texto»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		Rinteresting.&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		Rinteresante.&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is interesting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es interesante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may have noticed that this command replaced 5 characters in the line with twelve others.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que haya notado que ha reemplazado 5 caracteres en la línea con otros doce.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "R" command automatically extends the line if it runs out of characters to replace.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «R» extiende automáticamente la línea si se queda sin caracteres que reemplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will not continue on the next line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no ocurrirá en la siguiente línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you use &lt;BS&gt; (backspace) to make correction, you will notice that the old text is put back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando use &lt;Retroceso&gt; para hacer una corrección comprobará que el texto anterior reaparece.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it works like an undo command for the last typed character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, funciona como la orden deshacer para el último carácter tecleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*04.10*	Conclusion</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*04.10*	Conclusión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The operators, movement commands and text objects give you the possibility to make lots of combinations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los operadores, órdenes de movimiento y los objetos de texto le dan múltiples posibilidades para hacer muchas combinaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you know how it works, you can use N operators with M movement commands to make N * M commands!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora que sabe cómo funciona, puede usar N operadores con M órdenes de movimiento para hacer M * N órdenes!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, there are many other ways to delete pieces of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, hay otras muchas maneras de eliminar porciones de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are a few often used ones:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene algunas de las más empleadas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>x	delete character under the cursor (short for "dl")
X	delete character before the cursor (short for "dh")
D	delete from cursor to end of line (short for "d$")
dw	delete from cursor to next start of word
db	delete from cursor to previous start of word
diw	delete word under the cursor (excluding white space)
daw	delete word under the cursor (including white space)
dG	delete until the end of the file
dgg	delete until the start of the file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>x	elimina el carácter bajo el cursor (abreviado de "dl")
X	elimina el carácter antes del cursor (abreviado de "dh")
D	elimina desde el cursor hasta el final de línea (abreviado de "d$")
dw	elimina desde el cursor hasta el próximo comienzo de palabra
db	elimina desde el cursor hasta el anterior comienzo de palabra
diw	elimina la palabra bajo el cursor (excluyendo el espacio en blanco)
daw	elimina la palabra bajo el cursor (incluyendo el espacio en blanco)
dG	elimina hasta el final del archivo
dgg	elimina hasta el final del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use "c" instead of "d" they become change commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «c» en lugar de «d»,estos se convierten en órdenes de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And with "y" you yank the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y con «y» copias el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And so forth.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y así en adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~	change case of the character under the cursor, and move the
		cursor to the next character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~	cambia el carácter bajo el cursor de minúsculas a mayúsculas y
		al revés, moviéndose al siguiente carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not an operator (unless
		'tildeop' is set), thus you can't use it with a motion
		command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es un operador
		(a menos que 'tildeop' esté activado), por lo que no lo puede
		usar con un movimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does work in Visual mode and changes case for
		all the selected text then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sí funciona en modo Visual y cambia
		todo lo que está seleccionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I	Start Insert mode after moving the cursor to the first
		non-blank in the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>I	Inicia el modo insertar y desplaza el cursor al primer
		carácter no vacío de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A	Start Insert mode after moving the cursor to the end of the
		line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A	Inicia el modo insertar y desplaza el cursor al último
		carácter de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_03.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_03.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving around</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplazamiento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you can insert or delete text the cursor has to be moved to the right place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antes de que pueda insertar o eliminar texto, el cursor tiene que desplazarse al lugar adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has a large number of commands to position the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene una gran cantidad de órdenes para situar el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter shows you how to use the most important ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo muestra cómo usar los más importantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find a list of these commands below |Q_lr|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar una lista de estas órdenes a continuación |Q_lr|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|03.1|	Word movement
|03.2|	Moving to the start or end of a line
|03.3|	Moving to a character
|03.4|	Matching a parenthesis
|03.5|	Moving to a specific line
|03.6|	Telling where you are
|03.7|	Scrolling around
|03.8|	Simple searches
|03.9|	Simple search patterns
|03.10|	Using marks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|03.1|	Desplazarse sobre palabras
|03.2|	Desplazarse al principio o al final de la línea
|03.3|	Desplazarse a un carácter
|03.4|	Emparejar un paréntesis
|03.5|	Desplazarse a una línea específica
|03.6|	Indicar dónde estás
|03.7|	Desplazar el texto
|03.8|	Búsquedas simples
|03.9|	Patrones sencillos de búsqueda
|03.10|	Uso de marcadores o marcas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_04.txt|  Making small changes
 Previous chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_04.esx|  Hacer cambios pequeños
  Capítulo anterior: |usr_02.esx|  Primeros pasos en Vim
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.1*	Word movement</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.1*	Desplazarse sobre palabras</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move the cursor forward one word, use the "w" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para mover el cursor una palabra hacia delante, use la orden «w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like most Vim commands, you can use a numeric prefix to move past multiple words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Del mismo modo que la mayoría de órdenes Vim, puede usar un prefijo numérico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "3w" moves three words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplos, «3w» se mueve tres palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This figure shows how it works:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta figura muestra cómo funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a line with example text ~
	  ---&gt;--&gt;-&gt;-----------------&gt;
	   w  w  w    3w</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta es una línea con texto de ejemplo ~
	  ---&gt;--&gt;---&gt;---------------&gt;
	   w  w  w    3w</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that "w" moves to the start of the next word if it already is at the
start of a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fíjese en que «w» le mueve al comienzo de la siguiente palabra si ya se
encuentra al comienzo de una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "b" command moves backward to the start of the previous word:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «b» le desplaza al comienzo de la palabra anterior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a line with example text ~
	&lt;----&lt;--&lt;-&lt;---------&lt;---
	   b   b b    2b      b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta es una línea con texto de ejemplo ~
	&lt;----&lt;--&lt;---&lt;---------&lt;---
	   b   b b    2b    b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a line with example text ~
	   &lt;-   &lt;--- -----&gt;   ----&gt;
	   ge    ge     e       e</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ésta es una línea con texto de ejemplo ~
	   &lt;- &lt;--- -----&gt;     ----&gt;
	   ge  ge     e        e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A word ends at a non-word character, such as a ".", "-" or ")".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una palabra termina en un carácter de separación, como «.», «-» o «)».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change
what Vim considers to be a word, see the 'iskeyword' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para
cambiar lo que Vim considera una palabra, consulte la opción 'iskeyword'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to move by white-space separated WORDs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También es posible desplazarse por palabras separadas por espacios en
blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not a
word in the normal sense, that's why the uppercase is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no es una PALABRA en el sentido habitual, por ello se usan las
mayúsculas para designarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands for
moving by WORDs are also uppercase, as this figure shows:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes para desplazarse por PALABRAS están
también en mayúsculas, como muestra la siguiente figura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ge      b	  w				e
	       &lt;-     &lt;-	 ---&gt;			       ---&gt;
	This is-a line, with special/separated/words (and some more).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ge      b	  w				e
	       &lt;-     &lt;-	 ---&gt;			       ---&gt;
	Ésta es-una línea, con palabras separadas/de forma/especial
(y algo más).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	   &lt;----- &lt;-----	 --------------------&gt;	       -----&gt;
	     gE      B			 W			 E</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	   &lt;----- &lt;-----	 --------------------&gt;	       -----&gt;
	     gE      B			 W			 E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.2*	Moving to the start or end of a line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.2*	Desplazarse al principio o al final de la línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" command moves the cursor to the end of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «$» mueve el cursor al final de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your keyboard has an &lt;End&gt; key it will do the same thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si su teclado tiene la tecla &lt;Fin&gt;, conseguirá el mismo resultado pulsándola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "^" command moves to the first non-blank character of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «^» le lleva hacia el primer carácter no vacío de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "0" command (zero) moves to the very first character of the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «0» (cero) le mueve al primer carácter de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Home&gt; key does the same thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Inicio&gt; hace lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a picture:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En una imagen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>^
	     &lt;------------
	.....This is a line with example text ~
	&lt;-----------------   ---------------&gt;
		0		   $</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>^
	     &lt;------------
	.....Ésta es una línea con texto de ejemplo ~
	&lt;-----------------   ---------------&gt;
		0		   $</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "$" command takes a count, like most movement commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «$» admite un multiplicador, como la mayoría de órdenes de evento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But moving to
the end of the line several times doesn't make sense.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero moverse hacia el final de la línea varias veces no tiene sentido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore it causes the
editor to move to the end of another line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo
tanto, lo que hace es moverle hacia el final de la siguiente línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "1$" moves you to
the end of the first line (the one you're on), "2$" to the end of the next
line, and so on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, «1$» le mueve hacia el final de la primera línea (en la que está),
«2$» te mueve al final de la siguiente línea, y así en adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "0" command doesn't take a count argument, because the "0" would be
part of the count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «0» no admite ningún multiplicador, porque el «0» podría ser parte
del número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unexpectedly, using a count with "^" doesn't have any
effect.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar un multiplicador con «^» tampoco tiene ningún efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.3*	Moving to a character</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.3*	Desplazarse a un carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the most useful movement commands is the single-character search
command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno de las órdenes de movimiento más útiles es la orden de búsqueda de un
único carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command "fx" searches forward in the line for the single
character x.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «fx» busca hacia delante en la línea el carácter
x.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: "f" stands for "Find".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Truco: «f» viene de «Find» (en inglés, buscar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you are at the beginning of the following line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, está al principio de la línea siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you
want to go to the h of human.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que quiere
ir a la «h» de «humano».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just execute the command "fh" and the cursor
will be positioned over the h:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecute la orden «fh» y el cursor se posicionará
sobre la h:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	----------&gt;---------------&gt;
	    fh		 fy</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	----------&gt;---------------&gt;
	    fh		 fy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also shows that the command "fy" moves to the end of the word really.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también muestra que la orden «d» le lleva al comienzo de la palabra «de».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can specify a count; therefore, you can go to the "l" of "foul" with
"3fl":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede especificar un multiplicador; por lo tanto, puede ir a la «r»
de «verdad» con «3fr»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		  ---------------------&gt;
			   3fl</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		  ---------------------&gt;
			   3fl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		  &lt;---------------------
			    Fh</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		  &lt;---------------------
			    Fh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "tx" command works like the "fx" command, except it stops one character before the searched character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «tx» funciona como la orden «fx», salvo que para un carácter antes del buscado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: "t" stands for "To".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Truco: «t» viene de «To».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backward version of this command is "Tx".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La versión inversa de esta orden es «Tx».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
		   &lt;------------  -------------&gt;
			Th		tn</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
		   &lt;------------  -------------&gt;
			Th		tn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These four commands can be repeated with ";".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas cuatro órdenes se pueden repetir con «;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"," repeats in the other direction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«,» repite en la otra dirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is never moved to another line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor nunca se mueve a otra línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not even when the sentence continues.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ni siquiera cuando la frase continúa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will start a search, only to realize that you have typed the wrong command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ciertas ocasiones comenzará la búsqueda y se dará cuenta de que ha tecleado la orden errónea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You type "f" to search backward, for example, only to realize that you really meant "F".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, pulsa «f» para buscar hacia atrás, y se da cuenta de que tenía que haber pulsado «F».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To abort a search, press &lt;Esc&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para abortar la búsqueda, pulse &lt;Esc&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So "f&lt;Esc&gt;" is an aborted forward search and doesn't do anything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, «f&lt;Esc&gt;» es una búsqueda abortada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: &lt;Esc&gt; cancels most operations, not just searches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota: &lt;Esc&gt; cancela la mayoría de las operaciones, no sólo búsquedas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.4*	Matching a parenthesis</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.4*	Emparejar un paréntesis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing a program you often end up with nested () constructs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al escribir código, a menudo usa constructos anidados del tipo ().</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the "%" command is very handy: It moves to the matching paren.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello la orden «%x resulta muy útil: le desplaza hasta el paréntesis opuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the cursor is on a "(" it will move to the matching ")".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el cursor está en un «(», le moverá hasta el «)».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's on a ")" it will move to the matching "(".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está en un «)» le moverá hasta el «(» correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%
			 &lt;-----&gt;
		if (a == (b * c) / d) ~
		   &lt;----------------&gt;
			    %</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>%
			 &lt;-----&gt;
		if (a == (b * c) / d) ~
		   &lt;----------------&gt;
			    %</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also works for [] and {} pairs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también funciona para parejas de [] y {}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(This can be defined with the 'matchpairs' option.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Esto se puede definido con la opción 'matchpairs'.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if (a == (b * c) / d) ~
		---+----------------&gt;
			   %</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if (a == (b * c) / d) ~
		---+----------------&gt;
			   %</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.5*	Moving to a specific line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.5*	Desplazarse a una línea específica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>prog.c:33: j   undeclared (first use in this function) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>prog.c:33: j   undeclared (first use in this function) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells you that you might want to fix something on line 33.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le indica que probablemente quiera arreglar algo en la línea 33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So how do you
find line 33?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, ¿cómo encuentra la línea 33?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way is to do "9999k" to go to the top of the file and "32j"
to go down thirty two lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un modo es hacer «9999k» para ir a la
parte superior del archivo y «32j» para ir hacia abajo 32 líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not a good way, but it works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este no es
el mejor modo, pero funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A much
better way of doing things is to use the "G" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno mucho mejor es usar la orden «G».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With a count, this
command positions you at the given line number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con un
multiplicador, esta orden le posiciona en la línea indicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "33G" puts you
on line 33.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo,
«33G» le lleva a la línea 33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(For a better way of going through a compiler's error list, see
|usr_30.txt|, for information on the :make command.)
   With no argument, "G" positions you at the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Hay un modo aún mejor de ir por la lista de
errores del compilador, consulte |usr_30.txt| para información sobre «:make».)
   Sin argumentos, «G» le posiciona al final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick way to
go to the start of a file use "gg".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma rápida de
ir al comienzo de la línea es usar «gg».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"1G" will do the same, but is a tiny bit
more typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«1G» hará lo mismo, pero es una
pizca más lento de escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|	primera línea de un archivo    ^
	    |	texto texto texto texto        |
	    |	texto texto texto texto        |  gg
	7G  |	texto texto texto texto        |
	    |	texto texto texto texto
	    |	texto texto texto texto
	    V	texto texto texto texto        |
		texto texto texto texto        |  G
		texto texto texto texto        |
		última línea de un archivo     V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way to move to a line is using the "%" command with a count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra manera de ir a una línea es con la orden «%» y un multiplicador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example "50%" moves you to halfway the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo «50%» le mueve a la mitad del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"90%" goes to near the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«90%» va casi al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous assumes that you want to move to a line in the file, no matter if it's currently visible or not.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo anterior asume que se quiere mover a una línea en un archivo, no importa si está visible o no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What if you want to move to one of the lines you can see?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero ¿qué pasa si se quiere mover a una de las líneas que puede ver?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This figure shows the three commands you can use:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta figura le muestra las tres órdenes que puede emplear:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------+
		H --&gt;	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M --&gt;	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L --&gt;	| text sample text	    |
			+---------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------+
		H --&gt;	| texto ejemplo texto	    |
			| ejemplo texto		    |
			| texto ejemplo texto	    |
			| ejemplo texto		    |
		M --&gt;	| texto ejemplo texto	    |
			| ejemplo texto		    |
			| texto ejemplo texto	    |
			| ejemplo texto		    |
		L --&gt;	| texto ejemplo texto	    |
			+---------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.6*	Telling where you are</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.6*	Indicar donde está</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the CTRL-G command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden CTRL-G.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You get a message like this (assuming the 'ruler'
    option is off):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá un mensaje como este (asumiendo que la
      opción 'ruler' está desactivada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows the name of the file you are editing, the line number where the
    cursor is, the total number of lines, the percentage of the way through
    the file and the column of the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le muestra el nombre del archivo que está editando, el número de
    línea en el que se encuentra su cursor, la posición relativa (en
    porcentaje) y la columna del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will see a split column number.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces verá dos números separados por guión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, "col 2-9".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «col 2-9».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates that the cursor is positioned on the second character, but
    because character one is a tab, occupying eight spaces worth of columns,
    the screen column is 9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto indica que el cursor está posicionado en el segundo carácter, pero ya
    que el primer carácter es un tabulador, ocupará ocho espacios de columnas,
    y la columna en pantalla será 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the 'number' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Definir la opción 'number'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display a line number in front of
    every line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto mostrará el número de línea al
    principio de cada línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set number
&lt;
    To switch this off again: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set number
&lt;
    Para desactivar esto de nuevo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nonumber
&lt;
    Since 'number' is a boolean option, prepending "no" to its name has the
    effect of switching it off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nonumber
&lt;
    Ya que 'number' es una opción booleana, al escribirla con el prefijo «no»
    produce el efecto de apagarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A boolean option has only these two values,
    it is either on or off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una opción booleana tiene sólo estos dos
    posibles valores, «apagado» o «encendido».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has many options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene muchas opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Besides the boolean ones there are options with
    a numerical value and string options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Además de las booleanas, hay opciones con un
    valor numérico y otras de cadenas de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will see examples of this where
    they are used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá ejemplos de esto
    donde sean usados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the 'ruler' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Activar la opción 'ruler'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display the cursor position in the
    lower right corner of the Vim window: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto mostrará la posición del cursor
            en la esquina inferior a la derecha de la ventana de Vim: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set ruler</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set ruler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.7*	Scrolling around</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.7*	Desplazar el texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-U command scrolls down half a screen of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-U desplaza el texto hacia abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Imagine que mira a
través de una ventana hacia un texto y mueve esta ventana hacia arriba una
distancia igual a la mitad de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the window moves up over the text, which is
backward in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces la ventana se mueve hacia
arriba sobre el texto, lo cuál es hacia arriba en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't worry if you have a little trouble remembering
which end is up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se preocupe
si no recuerda qué es hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most users have the same problem.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A la mayoría de los usuarios les pasa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-D command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-D mueve la ventana de visualización media pantalla hacia
abajo, con lo que desplaza el texto hacia arriba media pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --&gt; |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D --&gt;  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------+
				       | un texto	|
				       | un texto	|
				       | un texto	|
	+---------------+	       | un texto	|
	| un texto	|  CTRL-U  --&gt; |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| ejemplo	|  CTRL-D --&gt;  | 7890		|
	+---------------+	       |		|
				       | ejemplo	|
				       | ejemplo	|
				       | ejemplo	|
				       | ejemplo	|
				       +----------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To scroll one line at a time use CTRL-E (scroll up) and CTRL-Y (scroll down).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para bajar una sola línea use CTRL-E (avanzar) y CTRL-Y (retroceder).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of CTRL-E to give you one line Extra.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Piense en CTRL-E como si le diese una línea Extra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If you use MS-Windows compatible key mappings CTRL-Y will redo a change instead of scroll.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si usa un mapa de teclado compatible con MS-Windows CTRL-Y rehará un cambio en lugar de desplazar el texto.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To scroll forward by a whole screen (except for two lines) use CTRL-F.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para avanzar una pantalla completa (menos dos líneas) use CTRL-F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other way is backward, CTRL-B is the command to use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La otra manera es hacia atrás, y se usa CTRL-B.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately CTRL-F is Forward and CTRL-B is Backward, that's easy to remember.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Afortunadamente CTRL-F es Forward y CTRL-B es Backward, lo cuál lo hace fácil de recordar si sabe algo de inglés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+------------------+		 +------------------+
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |   zz  --&gt;	 | line with cursor |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| line with cursor |		 | some text	    |
	+------------------+		 +------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------+		 +---------------------+
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| un texto	      |  zz --&gt;  | línea con el cursor |
	| un texto	      |		 | un texto	       |
	| un texto	      |		 | un texto	       |
	| línea con el cursor |		 | un texto	       |
	+---------------------+		 +---------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "zt" command puts the cursor line at the top, "zb" at the bottom.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «zt» pone la línea del cursor arriba, «zb» la situa en la parte inferior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few more scrolling commands, see |Q_sc|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algunas órdenes más de desplazamiento de texto, consulte |Q_sc|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To always keep a few lines of context around the cursor, use the 'scrolloff' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para mantener siempre contexto alrededor del cursor, use la opción 'scrolloff'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.8*	Simple searches</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.8*	Búsquedas simples</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search for a string, use the "/string" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para buscar una cadena, use la orden «/cadena».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find the word include, for example, use the command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar la palabra «include», por ejemplo, use la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that when you type the "/" the cursor jumps to the last line
of the Vim window, like with colon commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará que cuando pulsa «/» el cursor salta a la última línea de la ventana
Vim, como con la orden «:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is where you type the word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahí es donde teclea la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can press the backspace key (backarrow or &lt;BS&gt;) to make corrections.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede pulsar
la tecla de retroceso (flecha hacia atrás o &lt;Retroceso&gt;) para corregir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use
the &lt;Left&gt; and &lt;Right&gt; cursor keys when necessary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use
las teclas de cursor cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing &lt;Enter&gt; executes the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Presione &lt;Intro&gt; para ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To find the next occurrence of the same string use the "n" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar la próxima cadena use la orden «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this to find the first #include after the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto para encontrar el primer #include después del cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/#include</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/#include</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then type "n" several times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora pulse «n» varias veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will move to each #include in the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le llevará a cada #include en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use a count if you know which match you want.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede también usar un multiplicador si sabe qué cadenas coincidentes quiere.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "3n" finds the third match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto «3n» va a la tercera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a count with "/" doesn't work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se puede usar con «/».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>?word</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>?word</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "N" command repeats the last search the opposite direction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «N» repite la última búsqueda en la dirección opuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus using "N" after a "/" command search backwards, using "N" after "?" searches forward.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, usar «N» después de una orden «/» busca hacia atrás, usar «N» tras «?» busca hacia delante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally you have to type exactly what you want to find.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Normalmente tiene que teclear exactamente lo que quieres encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't care about upper or lowercase in a word, set the 'ignorecase' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le importa si los caracteres están en mayúscula/minúscula, active 'ignorecase': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set ignorecase</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set ignorecase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now search for "word", it will also match "Word" and "WORD".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora busca «palabra», también le identificará «Palabra» y «PALABRA».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match case again: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para concordar con mayúsculas y minúsculas de nuevo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set noignorecase</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set noignorecase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/one
	/two
	/three</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/uno
	/dos
	/tres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's start searching by typing a simple "/" without pressing &lt;Enter&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora comience a buscar tecleando un simple «/» sin presionar &lt;Intro&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If
you press &lt;Up&gt; (the cursor key), Vim puts "/three" on the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si
presiona &lt;Arriba&gt; (la tecla de cursor), Vim introduce «tres» en la línea de
órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing &lt;Enter&gt; at this point searches for three.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Presionar &lt;Intro&gt; en este punto busca «tres».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not press
&lt;Enter&gt;, but press &lt;Up&gt; instead, Vim changes the prompt to "/two".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no pulsa
&lt;Intro&gt; y presiona &lt;Arriba&gt;, Vim cambia el texto a «/dos».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another
press of &lt;Up&gt; moves you to "/one".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa de nuevo
&lt;Arriba&gt;, verá «/uno».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use the &lt;Down&gt; cursor key to move through the history of
search commands in the other direction.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar también la tecla de cursor &lt;Abajo&gt; para moverse por el historial
de órdenes de búsqueda en la otra dirección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you know what a previously used pattern starts with, and you want to use it again, type that character before pressing &lt;Up&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sabe cómo comienza una de sus búsquedas anteriores y la quiere usar de nuevo, introduzca ese carácter antes de presionar &lt;Arriba&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the previous example, you can type "/o&lt;Up&gt;" and Vim will put "/one" on the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo anterior, teclea «/u&lt;Arriba&gt;» y Vim pondrá «/uno» en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The commands starting with ":" also have a history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes que comienzan con «:» también tienen un historial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That allows you to recall a previous command and execute it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ayuda a reutilizar órdenes que ha usado antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These two histories are separate.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos dos historiales son independientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type "/the" it will also match "there".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea «/el» también le identificará «ellos».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To only find words that end in "the" use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para buscar sólo palabras que terminen en «el», use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the\&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/el\&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "\&gt;" item is a special marker that only matches at the end of a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento z\&gt;» es un marcador especial que sólo identifica el final de una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly "\&lt;" only matches at the begin of a word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De igual modo, «\&lt;» identifica el comienzo de una palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus to search for the word "the" only: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto para buscar únicamente la palabra completa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\&lt;the\&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\&lt;el\&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does not match "there" or "soothe".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no encontrará «ellos» o «mantel».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the "*" and "#" commands use these start-of-word and end-of-word markers to only find whole words (you can use "g*" and "g#" to match partial words).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fíjese en que las órdenes «*» y «#» usan estos marcadores de comienzo y final de palabra para encontrar únicamente palabras completas (puede usar «g*» y «g#» para concordancias parciales).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While editing a program you see a variable called "nr".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al editar un programa verá una variable llamada «nr».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to check
where it's used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Quiere comprobar dónde se
usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mover el cursor a «nr» y usar la orden «*» y presionar «n» para
ir de cadena en cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is another way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero hay otro modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set hlsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set hlsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now search for "nr", Vim will highlight all matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora busca «nr»,  Vim le destacará todas las concordancias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is a very
good way to see where the variable is used, without the need to type commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un
método muy bueno para ver dónde se emplea la variable, sin la necesidad de «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To switch this off: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desactivarlo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nohlsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nohlsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to switch it on again if you want to use it for the next search command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita activarlo de nuevo si quiere usarlo para la siguiente orden de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you only want to remove the highlighting, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si sólo quiere que desaparezca, use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:nohlsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:nohlsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This doesn't reset the option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no modifica la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, it disables the highlighting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En su lugar, quita las marcas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As soon as you execute a search command, the highlighting will be used again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tan pronto como vuelva a buscar algo, las marcas se volverán a emplear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also for the "n" and "N" commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También ocurrirá con las órdenes «n» y «N».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few options that change how searching works.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algunas opciones que modifican el modo en el que la búsqueda se realiza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the
essential ones:
&gt;
	:set incsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas son las esenciales:
&gt;
	:set incsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes Vim display the match for the string while you are still typing it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim muestre la concordancia de la cadena mientras aún la teclea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this to check if the right match will be found.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto para ver si la cadena correcta será encontrada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then press &lt;Enter&gt; to
really jump to that location.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse luego &lt;Intro&gt;
para saltar a su localización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or type more to change the search string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede también modificar la cadena.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	:set nowrapscan</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	:set nowrapscan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This stops the search at the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto detiene la búsqueda al final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or, when you are searching backwards, at the start of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O, cuando buscas hacia atrás, al comienzo del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'wrapscan' option is on by default, thus searching wraps around the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'wrapscan' se activa por omisión, por lo que buscará dando la vuelta al texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si le gusta alguna de las opciones mencionadas previamente, y la activa cada
vez que usa Vim, puede poner la orden en el archivo de arranque de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the file, as mentioned at |not-compatible|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite el archivo, como se describe en |not-compatible|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use this command to
find out where it is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la
siguiente orden para ver dónde se encuentra: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit ~/.vimrc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit ~/.vimrc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then add a line with the command to set the option, just like you typed it in Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora añada una línea con la orden para activar la opción, del mismo modo que lo introdujo en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go:set hlsearch&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Go:set hlsearch&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ZZ</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ZZ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.9*	Simple search patterns</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.9*	Patrones sencillos de búsqueda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ^ character matches the beginning of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter «^» identifica el comienzo de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On an English-US keyboard
you find it above the 6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un teclado Español-España lo
encontrará a la derecha de la «p».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The pattern "include" matches the word include
anywhere on the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El patrón «include» concuerda la palabra
«include» en cualquier parte de una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But the pattern "^include" matches the word include
only if it is at the beginning of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero el patrón «^include»
concuerda la palabra «include» sólo si se encuentra al comienzo de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The $ character matches the end of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El carácter $ coincide el final de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, "was$" matches the
word was only if it is at the end of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo tanto, "era$" concuerda
la palabra «era» sólo si esta se encuentra al final de una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>que este sobredicho hidalgo, los ratos que estaba ocioso (que ~
	xxx			  xxx		       xxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the solder holding one of the chips melted and the ~
						       xxx</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>que este sobredicho hidalgo, los ratos que estaba ocioso (que~
						       xxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And with "/^the" we find this one:
	the solder holding one of the chips melted and the ~
	xxx</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y con «/^que» encontramos el siguiente:
	que este sobredicho hidalgo, los ratos que estaba ocioso (que ~
	xxx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try searching with "/^the$", it will only match a single line consisting of "the".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede intentar buscar con «/^que$», que sólo se emparejará con una única línea consistente en «que».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>White space does matter here, thus if a line contains a space after the word, like "the ", the pattern will not match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio en blanco se considera, por lo que si contiene un espacio tras la palabra, como «que», el patrón no coincide.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente desea coinciordar un punto, debe suprimir su significado especial
poniendo antes una barra inversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you search for "ter.", you will find these matches:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si busca «an.», obtendría las siguientes coincidencias:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*03.10*	Using marks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*03.10*	Uso de marcadores o marcas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you make a jump to a position with the "G" command, Vim remembers the position from before this jump.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hace un salto a una posición con la orden «G», Vim recuerda la posición antes de el salto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This position is called a mark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta posición se llama marca o marcador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go back where you came from, use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para volver al punto anterior del que te encuentras, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ` is a backtick or open single-quote character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta ` es una tilde invertida o carácter de abrir comillas simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the same command a second time you will jump back again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa esta misma orden de nuevo, volverá hacia atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's
because the ` command is a jump itself, and the position from before this jump
is remembered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es
porque la orden «`» es un salto en si mismo, y la posición anterior al
salto también se registra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `` command jumps back and forth, between two points.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «``» salta hacia atrás y hacia delante, entre dos puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-O command jumps to older positions (Hint: O for older).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-O salta a posiciones anteriores (Truco: O de «older», viejo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-I then jumps back to newer positions (Hint: I is just next to O on the keyboard).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-I salta de vuelta a posiciones más recientes (Truco: la I está justo al lado de la O en el teclado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consider this sequence of commands: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe esta secuencia de órdenes: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>33G
	/^The
	CTRL-O</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>33G
	/^El
	CTRL-O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You first jump to line 33, then search for a line that starts with "The".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero salta a la línea 33, luego salta a una línea que comienza con «El».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then with CTRL-O you jump back to line 33.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces vuelva con CTRL-O a la línea 33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another CTRL-O takes you back to where you started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otro CTRL-O le devuelve a donde comenzó.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now use CTRL-I you jump to line 33 again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora usa CTRL-I, volverá a la línea 33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And to the match for "The" with another CTRL-I.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con otro CTRL-I vuelve al «El» identificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|	texto de ejemplo      ^	       |
	33G  |	texto de ejemplo      | CTRL-O | CTRL-I
	     |	texto de ejemplo      |	       |
	     V	texto de la línea 33  ^	       V
	     |	texto de ejemplo      |	       |
       /^The |	texto de ejemplo      | CTRL-O | CTRL-I
	     V	Aquí estás            |	       V
		texto de ejemplo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	CTRL-I is the same as &lt;Tab&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	CTRL-I hace lo mismo que &lt;Tab&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":jumps" command gives a list of positions you jumped to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:jumps» le da una lista de posiciones a las que ha saltado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry which you used last is marked with a "&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La última entrada que ha usado está marcada con un «&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NAMED MARKS							*bookmark*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MARCADORES							*bookmark*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to place your own marks in the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le permite colocar sus propias marcas en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command "ma" marks
the place under the cursor as mark a.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «m» marca el
lugar sobre el que se encuentra el cursor como «a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can place 26 marks (a through z) in
your text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede poner hasta 26
marcas (a-z).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can't see them, it's just a position that Vim remembers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede verlas, son simplemente posiciones que Vim recuerda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go to a mark, use the command `{mark}, where {mark} is the mark letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ir a una marca, use la orden `{marca}, donde {marca} es la letra del
marcador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus to move to the a mark:
&gt;
	`a</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para moverse a la marca «a»:
&gt;
	`a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command 'mark (single quotation mark, or apostrophe) moves you to the beginning of the line containing the mark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden '{marca} (apóstrofe o signo de comillas simples) le lleva al comienzo de la línea que contiene la marca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This differs from the `mark command, which moves you to marked column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto difiere de la orden `{marca}, que le desplaza a la columna donde se hizo la marca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The marks can be very useful when working on two related parts in a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los marcadores pueden ser muy útiles cuando se trabaja en dos partes del archivo
relacionadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene un texto cerca del comienzo del archivo que
necesitas mirar mientras trabaja en otra parte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move to the text at the start and place the s (start) mark there: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vaya al texto del comienzo y ponga un marcador «s» (start) allí: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ms</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>me</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>me</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'s</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego puede usar '' para saltar de vuelta a donde estaba, o 'e para saltar al
texto donde estuvo trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about using s for start and e for end, they are
just easy to remember.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No hay nada especial en usar s para el comienzo o e para el final, son
simplemente fáciles de recordar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:marks</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:marks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice a few special marks.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá unos cuantos marcadores especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These include:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entre ellos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'	The cursor position before doing a jump
	"	The cursor position when last editing the file
	[	Start of the last change
	]	End of the last change</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'	La posición del cursor antes del último salto
	"	La posición del cursor antes de la última edición
	[	Comienzo del último cambio
	]	Final del último cambio</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_27.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_27.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2010 Mar 28</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 28/3/2010</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Search commands and patterns</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Órdenes y patrones de búsqueda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|27.1|	Ignoring case
|27.2|	Wrapping around the file end
|27.3|	Offsets
|27.4|	Matching multiple times
|27.5|	Alternatives
|27.6|	Character ranges
|27.7|	Character classes
|27.8|	Matching a line break
|27.9|	Examples</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|27.1|	Ignorar la distinción entre mayúsculas y minúsculas
|27.2|	Justificar el fin del archivo
|27.3|	Dirección relativa («offsets»)
|27.4|	Emparejar varios elementos
|27.5|	Alternativas
|27.6|	Rangos de caracteres
|27.7|	Clases de caracteres
|27.8|	Coincidir con un salto de línea
|27.9|	Ejemplos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_28.txt|  Folding
 Previous chapter: |usr_26.txt|  Repeating
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_28.txt|  Plegar
  Capítulo anterior: |usr_25.esx|  Repetición
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.1*	Ignoring case</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.1*	Ignorar la distinción entre mayúsculas y minúsculas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Vim's searches are case sensitive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim distingue entre mayúsculas y minúsculas al realizar un búsqueda de forma
predeterminada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, "include",
"INCLUDE", and "Include" are three different words and a search will match
only one of them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«INCLUDE», «Include» e «include»  son por ello tres palabras
distintas, y una búsqueda encontraría sólo una de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now switch on the 'ignorecase' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Active ahora la opción 'ignorecase': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But let's keep it set, and search for "INCLUDE".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a dejar esta opción activada, y realizar una búsqueda de «INCLUDE».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will match exactly the same text as "include" did.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrará el mismo texto que «include».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now set the 'smartcase' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Active ahora la opción 'smartcase': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set ignorecase smartcase</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set ignorecase smartcase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a pattern with at least one uppercase character, the search
becomes case sensitive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene un patrón con al menos un carácter en mayúscula, la búsqueda no
distinguirá entre mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The idea is that you didn't have to type that
uppercase character, so you must have done it because you wanted case to
match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La idea es que no necesitaba
escribir ese carácter en mayúscula, y que por ello lo que deseaba era
encontrar coincidencias con distinción entre mayúsculas y minúsculas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's smart!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Qué
inteligente!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With these two options set you find the following matches:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendría las siguientes coincidencias de activar ambas opciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pattern			matches	~
	word			word, Word, WORD, WoRd, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>patrón			coincidencias	~
	palabra			palabra, Palabra, PALABRA, PaLaBRa etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Word			Word
	WORD			WORD
	WoRd			WoRd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Palabra			Palabra
	PALABRA			PALABRA
	PaLaBRa			PaLaBRa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to ignore case for one specific pattern, you can do this by prepending the "\c" string.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede anexar la cadena «\c» si desea ignorar esta distinción para un patrón en particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using "\C" will make the pattern to match case.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar «\C» activará la distinción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This overrules the 'ignorecase' and 'smartcase' options, when "\c" or "\C" is used their value doesn't matter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto invalida las opciones 'ignorecase' y 'smartcase', ya que usar «\c» o «\C» obvia el valor de estas opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pattern			matches	~
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>patrón			coincidencias	~
	\Cpalabra		palabra
	\CPalabra		Palabra
	\cpalabra		palabra, Palabra, PALABRA, PaLaBrA, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\cWord			word, Word, WORD, WoRd, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\cPalabra		palabra, Palabra, PALABRA, PaLaBrA, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A big advantage of using "\c" and "\C" is that it sticks with the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una enorme ventaja de usar «\c» y «\C» es que se mantienen ligadas al patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if you repeat a pattern from the search history, the same will happen, no matter if 'ignorecase' or 'smartcase' was changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si repite un patrón desde el registro de búsquedas obtendrá el mismo resultado sin importar si cualquier cambio de 'ignorecase' y 'smartcase'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	The use of "\" items in search patterns depends on the 'magic' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	El uso del elemento «\» en patrones de búsqueda depende de la opción
	'magic'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this chapter we will assume 'magic' is on, because that is the
	standard and recommended setting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En estos capítulos daremos por sentado que 'magic' está activado, ya
	que es la configuración estándar y recomendad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would change 'magic', many
	search patterns would suddenly become invalid.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De cambiar 'magic'
	muchos patrones de búsqueda no serían válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	If your search takes much longer than you expected, you can interrupt
	it with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Si la búsqueda lleva más tiempo del esperado, puede interrumpir esta
	con CTRL-C en Unix y CTRL-Break en MS-DOS y MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.2*	Wrapping around the file end</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.2*	Justificar el fin del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a forward search starts searching for the given string at the
current cursor location.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, una búsqueda hacia adelante se inicia buscando la cadena dada
en la ubicación presente del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It then proceeds to the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después continua hasta el final del
archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it has
not found the string by that time, it starts from the beginning and searches
from the start of the file to the cursor location.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no ha encontrado ninguna cadena, vuelve al inicio y busca desde
el principio del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that when repeating the "n" command to search for the next
match, you eventually get back to the first match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que, de repetir la orden «n» para buscar la siguiente
coincidencia, al final volverá a la primera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't notice this
you keep searching forever!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Buscará para siempre si no nota
esto!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To give you a hint, Vim displays this message:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le da una pista con la forma del siguiente mensaje:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>search hit BOTTOM, continuing at TOP ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La búsqueda ha llegado al FINAL, continuando desde el PRINCIPIO ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>search hit TOP, continuing at BOTTOM ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La búsqueda ha llegado al FINAL, continuando desde el PRINCIPIO ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Still, you don't know when you are back at the first match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así,no sabe cuando vuelve a la primera coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to see this is by switching on the 'ruler' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una forma de ver esto es activando la opción 'ruler'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will display the cursor position in the lower righthand corner of the window (in the status line if there is one).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muestra siempre la posición actual en la esquina inferior derecha de la ventana (en la línea de estado, de existir).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>101,29       84% ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>101,29       84% ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first number is the line number of the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primer número es el número de la línea del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember the line number where you started, so that you can check if you passed this position again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuerde el número de la línea inicial, de manera pueda comprobar si ya pasó por esta posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nowrapscan</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nowrapscan</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E385: search hit BOTTOM without match for: forever ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E385: La búsqueda ha llegado al FINAL sin una coincidencia para:
	forever ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can find all matches by going to the start of the file with "gg" and
keep searching until you see this message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, puede encontrar todas las coincidencias desplazándose al inicio del
archivo con «gg», y buscar hasta ver este mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you search in the other direction, using "?", you get:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si busca en otra dirección, usando, «?», obtendrá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E384: search hit TOP without match for: forever ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>E385: La búsqueda ha llegado al PRINCIPIO sin una coincidencia
	para: forever ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.3*	Offsets</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.3*	Dirección relativa («Offsets»)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the search command leaves the cursor positioned on the beginning of the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, la orden de búsqueda posiciona el cursor al inicio del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can tell Vim to leave it some other place by specifying an offset.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer que Vim lo posicione en algún lugar especificando una dirección relativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the forward search command "/", the offset is specified by appending a slash (/) and the offset: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para la orden de búsqueda hacia delante «/», la dirección relativa se especifica añadiendo una barra inversa («/») y la dirección relativa: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/default/2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/omisión/2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command searches for the pattern "default" and then moves to the beginning of the second line past the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden busca el patrón «omisión», y después se desplaza al inicio de la segunda línea, más allá del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using this command on the paragraph above, Vim finds the word "default" in the first line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De usar esta orden en el párrafo anterior, Vim encontraría la palabra «omisión» en la primera línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the cursor is moved two lines down and lands on "an offset".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Acto seguido, el cursor se posicionaría dos líneas más abajo, para acabar en la dirección relativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the offset is a simple number, the cursor will be placed at the beginning of the line that many lines from the match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor se posicionara al inicio de la línea presente un número n de líneas a partir de la coincidencia, si la dirección relativa es un simple número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The offset number can be positive or negative.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El número de dirección relativa puede ser positivo o negativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is positive, the cursor moves down that many lines; if negative, it moves up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De ser positivo, el cursor se desplaza hacia abajo un número n de líneas; si es negativo, se desplaza hacia arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "e" offset indicates an offset from the end of the match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La dirección relativa «e» indica una dirección a partir del final de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It moves the cursor onto the last character of the match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplaza el cursor al último carácter de la coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/const/e</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/const/e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>puts the cursor on the "t" of "const".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>pone el cursor sobre la «t» de «const».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From that position, adding a number moves forward that many characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Añadir un número le desplazará hacia delante tantos caracteres desde la
posición inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command moves to the character just after the match: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden desplaza el carácter a la posición anterior
a la coincidencia: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/const/e+1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/const/e+1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A positive number moves the cursor to the right, a negative number moves it to the left.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un número positivo desplaza el cursor a la derecha, un número negativo lo desplaza a la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/const/e-1</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/const/e-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the offset begins with "b", the cursor moves to the beginning of the pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si la dirección empieza con una «b», el cursor se desplazará al inicio del patrón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's not very useful, since leaving out the "b" does the same thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es muy útil, ya que se logra lo mismo dejando la «b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does get useful when a number is added or subtracted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es de utilidad al añadir o sustraer un número.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor then goes forward or backward that many characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entonces, el cursor se desplaza hacia delante o atrás tantos caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/const/b+2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/const/b+2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moves the cursor to the beginning of the match and then two characters to the right.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplaza el cursor al principio de la coincidencia, dos caracteres a la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it lands on the "n".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, finaliza en «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/that
	//e</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/that
	//e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/that/e</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/that/e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"n" does the same thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«n» hace lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To repeat while removing a previously used offset: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para repetir mientras elimina una dirección usada anteriormente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>//</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>//</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>?const?e-2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>?const?e-2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When starting a search, it normally starts at the cursor position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al iniciar una búsqueda, generalmente comienza por la posición del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you specify a line offset, this can cause trouble.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto puede causar problemas cuando especifica un desplazamiento relativo de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/const/-2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/const/-2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This finds the next word "const" and then moves two lines up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra la siguiente aparición de «const», y después se desplaza dos
líneas haci arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you
use "n" to search again, Vim could start at the current position and find the same
"const" match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «n» para repetir la búsqueda, puede que Vim la
inicie en la posición actual, encontrando la misma coincidencia de «const».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then using the offset again, you would be back where you started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar el mismo desplazamiento relativo, ha vuelto al punto inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You would be stuck!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Se quedaría atascado!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It could be worse: Suppose there is another match with "const" in the next
line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún pero: supongo que existe otra aparición de «const» en la siguiente
línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then repeating the forward search would find this match and move two
lines up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Repetir la búsqueda hacia adelante encontraría esta coincidencia,
y desplazaría el cursor dos líneas atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you would actually move the cursor back!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Estaría desplazando el cursor
hacia atrás todo el rato!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you specify a character offset, Vim will compensate for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al especificar un carácter de desplazamiento relativo, Vim dará una compensación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the search starts a few characters forward or backward, so that the same match isn't found again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, la búsqueda se inicia unos cuantos caracteres delante o detrás, para no encontrar otra vez la misma coincidencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.4*	Matching multiple times</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.4*	Emparejar varios elementos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "*" item specifies that the item before it can match any number of times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento «*» especifica que el elemento precedente puede emparejarse un número ilimitado de veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/a*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/a*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>matches "a", "aa", "aaa", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>coincide con «a», «aa», «aaa», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But also "" (the empty string), because zero
times is included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero también « » (una cadena vacía), ya
que se incluye por omisión cero veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "*" only applies to the item directly before it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«*» sólo afecta al su elemento precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "ab*" matches
"a", "ab", "abb", "abbb", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, «ab*» encuentra «a»,
«ab», «abb», «abbb», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match a whole string multiple times, it
must be grouped into one item.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar varias apariciones de una cadena
completa, ésta ha de estar agrupada bajo un mismo elemento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done by putting "\(" before it and
"\)" after it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se hace
colocando «\(» antes de la cadena, y «\)» después.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, la siguiente
orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\(ab\)*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\(ab\)*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches: "ab", "abab", "ababab", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>encuentra «ab», «abab», «ababab», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And also "".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También « ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid matching the empty string, use "\+".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar que coincida con una cadena vacía, use «\+».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes the previous item match one or more times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra una o
más apariciones del elemento precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/ab\+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/ab\+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches "ab", "abb", "abbb", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encuentra «ab», «abb», «abbb», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not match "a" when no "b" follows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No coincide con «a» si no va seguido de «b».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match an optional item, use "\=".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer coincidir un elemento opcional, utilice «\=».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/folders\=</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/directorio\=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match a specific number of items use the form "\{n,m}".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la forma «\{n,m}» para emparejar un número específico de elementos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"n" and "m" are numbers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«n» y «m» son números.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The item before it will be matched "n" to "m" times |inclusive|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento anterior a éstos se emparejará con «n» un número «m» de veces |inclusive|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/ab\{3,5}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/ab\{3,5}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>matches "abbb", "abbbb" and "abbbbb".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>empareja «abbb», «abbbb» y «abbbbb».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When "n" is omitted, it defaults to zero.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado cero en ausencia de «n».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When "m" is omitted it defaults
to infinity.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado
es infinito en ausencia de «m».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When ",m" is omitted, it matches exactly "n" times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En ausencia de «m», se empareja
exactamente «n» veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pattern		match count ~
	\{,4}		0, 1, 2, 3 or 4
	\{3,}		3, 4, 5, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>patrón		número de coincidencias ~
	\{,4}		0, 1, 2, 3 o 4
	\{3,}		3, 4, 5, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\{0,1}		0 or 1, same as \=
	\{0,}		0 or more, same as *
	\{1,}		1 or more, same as \+
	\{3}		3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\{0,1}		0 o 1, igual que \=
	\{0,}		0 o más, igual que *
	\{1,}		1 o más, igual que \+
	\{3}		3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/ab\{-1,3}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/ab\{-1,3}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will match "ab" in "abbb".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontraría «ab» en «abbb».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Actually, it will never match more than one b,
because there is no reason to match more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En realidad, nunca coincidirá con mas de una «b»,
ya que no hay razón para coincidir con más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It requires something else to force
it to match more than the lower limit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se precisa algo más para forzar
un número de coincidencias mayor que el límite más bajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same rules apply to removing "n" and "m".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las mismas reglas están presentes al eliminar «n» y «m».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's even possible to remove
both of the numbers, resulting in "\{-}".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También es posible
eliminar ambos números, dejando «\{-}».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches the item before it
zero or more times, as few as possible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra el elemento anterior
a él cero o más veces, pero cuantas menos posibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The item by itself always matches
zero times.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento en sí siempre
se empareja cero veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is useful when combined with something else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es de utilidad en combinación con algo más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/a.\{-}b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/a.\{-}b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "axb" in "axbxb".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincide con «axb» en «axbxb».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this pattern would be used: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De usar este patrón &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/a.*b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/a.*b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.5*	Alternatives</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.5*	Alternativas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "or" operator in a pattern is "\|".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El operador «or» dentro de un patrón es «\|».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/foo\|bar</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/foo\|bar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "foo" or "bar".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra «foo» o «bar».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More alternatives can be concatenated: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede concatenar más alternativas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/one\|two\|three</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/uno\|dos\|tres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Matches "one", "two" and "three".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Coincide con «uno», «dos» y «tres».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match multiple times, the whole thing must be placed in "\(" and "\)": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar varias coincidencias debe insertar la cadena completa entre
«\(» y «\)»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\(foo\|bar\)\+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\(foo\|bar\)\+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "foo", "foobar", "foofoo", "barfoobar", etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra «foo», «foobar», «foofoo», «barfoobar», etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/end\(if\|while\|for\)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/end\(if\|while\|for\)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A related item is "\&amp;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un elemento relacionado es «\&amp;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This requires that both alternatives match in the same place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto requiere que ambas alternativas coincidan en el mismo lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The resulting match uses the last alternative.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La coincidencia resultante usa la última alternativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/forever\&amp;...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/forever\&amp;...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matches "for" in "forever".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincide on «for» en «forever».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It will not match "fortuin", for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No coincide con «fortuin», por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.6*	Character ranges</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.6*	Rangos de caracteres</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match "a", "b" or "c" you could use "/a\|b\|c".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar «/a|b\|c» para encontrar «a», «b» o «c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to match all letters from "a" to "z" this gets very long.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se extiende si desea encontrar todas las letras de la «a» a la «z».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a shorter method: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una manera más corta: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/[a-z]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/[a-z]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The [] construct matches a single character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La construcción [] encuentra un sólo carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inside you specify which characters to match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Especifique dentro de este los caracteres a encontrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can include a list of characters, like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede incluir una lista larga de caracteres, como esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/[0123456789abcdef]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/[0123456789abcdef]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will match any of the characters included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto encuentra cualquier carácter incluido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For consecutive characters you can specify the range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede especificar un rango para encontrar caracteres consecutivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"0-3" stands for "0123".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«0-3» significa «01234».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"w-z" stands for "wxyz".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«w-z» significa «wxyz».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the same command as above can be shortened to: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, puede acortar la orden anterior: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/[0-9a-f]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/[0-9a-f]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match the "-" character itself make it the first or last one in the range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar el carácter «-», tiene que aparecer al principio o final del rango.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These special characters are accepted to make it easier to use them inside a [] range (they can actually be used anywhere in the search pattern):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos caracteres especiales se aceptan para facilitar su uso dentro de un rango [] (en realidad, puede usarlos en cualquier lugar dentro del patrón de búsqueda):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>\e	&lt;Esc&gt;
	\t	&lt;Tab&gt;
	\r	&lt;CR&gt;
	\b	&lt;BS&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>\e	&lt;Esc&gt;
	\t	&lt;Tab&gt;
	\r	&lt;CR&gt;
	\b	&lt;BS&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid matching a specific character, use "^" at the start of the range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «^» al principio del rango para evitar emparejar un carácter en particular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The [] item then matches everything but the characters included.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El elemento [] emparejará todo menos los caracteres incluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/"[^"]*"
&lt;
	 "	  a double quote
	  [^"]	  any character that is not a double quote
	      *	  as many as possible
	       "  a double quote again</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/"[^"]*"
&lt;
	 "	  dobles comillas
	  [^"]	  todo carácter que no es una comilla doble
	      *	  tantos como sea posible
	       "  otras dobles comillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A number of ranges are used very often.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe un número de rangos usados a menudo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim provides a shortcut for these.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece accesos directos para esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\a</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finds alphabetic characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encuentra caracteres alfabéticos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is equal to using "/[a-zA-Z]".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto equivale a usar «/[a-zA-Z]».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are a few more of these:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí hay más ejemplos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item	matches			equivalent ~
	\d	digit			[0-9]
	\D	non-digit		[^0-9]
	\x	hex digit		[0-9a-fA-F]
	\X	non-hex digit		[^0-9a-fA-F]
	\s	white space		[ 	]     (&lt;Tab&gt; and &lt;Space&gt;)
	\S	non-white characters	[^ 	]     (not &lt;Tab&gt; and &lt;Space&gt;)
	\l	lowercase alpha		[a-z]
	\L	non-lowercase alpha	[^a-z]
	\u	uppercase alpha		[A-Z]
	\U	non-uppercase alpha	[^A-Z]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>elemento coincidencias		equivalente ~
	\d	dígito			[0-9]
	\D	no-dígito		[^0-9]
	\x	dígito hexadecimal	[0-9a-fA-F]
	\X	dígito no hexadecimal	[^0-9a-fA-F]
	\s	espacio vacío		[ 	]     (&lt;Tab&gt; y &lt;Space&gt;)
	\S	caracteres no vacíos	[^ 	]     (no &lt;Tab&gt; y &lt;Space&gt;)
	\l	alfa minúscula		[a-z]
	\L	alfa no mayúscula	[^a-z]
	\u	alfa mayúscula		[A-Z]
	\U	alfa no mayúscula	[^A-Z]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	Using these predefined ranges works a lot faster than the character
	range it stands for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	El uso de estos rangos predeterminados es más rápido que el rango de
	caracteres que simbolizan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These items can not be used inside [].</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estos elementos no se pueden usar dentro de [].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus "[\d\l]" does NOT work to
	match a digit or lowercase alpha.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, «[\d\l]» NO
	funciona para encontrar un dígito o un alfa minúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "\(\d\|\l\)" instead.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar
	de ello, use «\(\d\|\l\)».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.7*	Character classes</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.7*	Clase de carácter</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The character range matches a fixed set of characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El rango de carácter empareja un conjunto específico de caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A character class is
similar, but with an essential difference: The set of characters can be
redefined without changing the search pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se
parece una clase de carácter, pero con una importante diferencia: puede
redefinir el conjunto de caracteres sin cambiar el patrón de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, search for this pattern: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, busque este patrón: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\f\+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\f\+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "\f" items stands for file name characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los elementos «\f» simbolizan caracteres de nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus this matches a sequence
of characters that can be a file name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, esto
empareja una secuencia de caracteres que pueden ser un nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which characters can be part of a file name depends on the system you are
using.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Qué caracteres pueden formar parte de un nombre de archivo dependen del
sistema que esté usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-Windows, the backslash is included, on Unix it is not.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-Windows, la barra inversa está incluida, pero
no en Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is
specified with the 'isfname' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede especificar esto con la opción 'isfname'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value for Unix is: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor por
omisión en Unix es: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For other systems the default value is different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado depende del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you can make a search pattern with "\f" to match a file name, and it will automatically adjust to the system you are using it on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, puede crear un patrón de búsqueda con «\f» para emparejar un nombre de archivo, y ajustarse automáticamente al sistema en el que lo está usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item	matches				option ~
	\i	identifier characters		'isident'
	\I	like \i, excluding digits
	\k	keyword characters		'iskeyword'
	\K	like \k, excluding digits
	\p	printable characters		'isprint'
	\P	like \p, excluding digits
	\f	file name characters		'isfname'
	\F	like \f, excluding digits</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>elemento	coinicidencias			opción ~
	\i	caracteres de identificación	'isident'
	\I	como \i, excluyendo dígitos
	\k	carácter de palabra clave	'iskeyword'
	\K	como \k, excluyendo dígitos
	\p	caracteres imprimibles		'isprint'
	\P	como \p, excluyendo dígitos
	\f	caracteres de nombre de archivo	'isfname'
	\F	como \f, excluyendo dígitos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.8*	Matching a line break</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.8*	Coincidir con un salto de línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can find a pattern that includes a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede encontrar un patrón que incluye un salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to specify where
the line break happens, because all items mentioned so far don't match a line
break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe especificar
la aparición del salto de línea, ya que todos los elementos mencionados hasta
ahora no se emparejan con un salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To check for a line break in a specific place, use the "\n" item: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para comprobar si hay un salto de línea en un lugar específico, use el
elemento «\n»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the\nword</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/la\npalabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will match at a line that ends in "the" and the next line starts with "word".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto coincidiría en una línea que termina con «la», seguida de una que comienza con «palabra».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To match "the word" as well, you need to match a space or a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para encontrar también «la palabra», tendrá que emparejar el espacio o el salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The item to use for it is "\_s": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello, use el elemento «\_s»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the\_sword</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/la\_spalabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/the\_s\+word</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/la\_s\+palabra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also matches when "the  " is at the end of a line and "   word" at the
start of the next one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también coincide cuando «la » está al final de la línea, y «palabra» al
inicio de la siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"\s" matches white space, "\_s" matches white space or a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«\s» coincide con espacio en blanco, «\_s» coincide con espacio en blanco o un salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, "\a" matches an alphabetic character, and "\_a" matches an alphabetic character or a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De forma parecida, «\a» coincide con un carácter alfabético o un salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other character classes and ranges can be modified in the same way by inserting a "_".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las otras clases de caracteres y rangos se pueden modificar de la misma forma insertando un «_».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many other items can be made to match a line break by prepending "\_".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer coincidir muchos otros elementos con un salto de línea prefijando «\_».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example: "\_." matches any character or a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, «\_.» coincide con cualquier carácter o salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	"\_.*" matches everything until the end of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	«\_.*» empareja todo hasta el final del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful with
	this, it can make a search command very slow.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use esto con
	cuidado, ya que puede reducir la velocidad de una orden de búsqueda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/"\_[^"]*"</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/"\_[^"]*"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*27.9*	Examples</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*27.9*	Ejemplos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are a few search patterns you might find useful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí dispone de unos cuantos patrones de búsqueda que puede encontrar útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows how the items mentioned above can be combined.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto muestra cómo combinar los elementos anteriormente mencionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A sample license plate number is "1MGU103".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un ejemplo de un número de matrícula es «1MGU103».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It has one digit, three uppercase letters and three digits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene un dígito, tres letras mayúsculas y tres dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Directly putting this into a search pattern: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede insertar esto en un patrón búsqueda de la siguiente manera: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\d\u\u\u\d\d\d</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\d\u\u\u\d\d\d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\d\u\{3}\d\{3}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\d\u\{3}\d\{3}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/[0-9][A-Z]\{3}[0-9]\{3}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/[0-9][A-Z]\{3}[0-9]\{3}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Which one of these you should use?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Cual debería usar?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whichever one you can remember.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Él que recuerde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simple way you can remember is much faster than the fancy way that you can't.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La manera sencilla que puede recordar es más rápida que la compleja que no puede.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you can remember them all, then avoid the last one, because it's both more typing and slower to execute.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si los puede recordar todos, evite el último, ya que es más lento de teclear y de ejecutar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In C programs (and many other computer languages) an identifier starts with a letter and further consists of letters and digits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En programas C (y muchos otros lenguajes de programación), un identificador empieza con una letra seguida de letras y dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Underscores can be used too.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar subrayados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be found with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar esto con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\&lt;\h\w*\&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\&lt;\h\w*\&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	"\&lt;" and "\&gt;" depend on the 'iskeyword' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	«\&lt;» y «\&gt;» dependen de la opción 'iskeyword'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it includes "-",
	for example, then "ident-" is not matched.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De incluir un «-»,
	por ejemplo, «ident-» no se encontrará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this situation use: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use lo siguiente en esta
	situación: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/\w\@&lt;!\h\w*\w\@!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/\w\@&lt;!\h\w*\w\@!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;
	This checks if "\w" does not match before or after the identifier.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;
	Esto revisa se «\w» no se empareja antes o después de un
	identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |/\@&lt;!| and |/\@!|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |/\@&lt;!| and |/\@!|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_05.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_05.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2009 Jun 04</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 4/6/2009</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set your settings</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Configuración</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|05.1|	The vimrc file
|05.2|	The example vimrc file explained
|05.3|	Simple mappings
|05.4|	Adding a plugin
|05.5|	Adding a help file
|05.6|	The option window
|05.7|	Often used options</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|05.1|	El archivo vimrc
|05.2|	Explicación del archivo vimrc de ejemplo
|05.3|	Macros sencillas
|05.4|	Añadir una extensión
|05.5|	Añadir un archivo de ayuda
|05.6|	La ventana de opciones
|05.7|	Opciones más comunes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_06.txt|  Using syntax highlighting
 Previous chapter: |usr_04.txt|  Making small changes
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_06.esx|  Uso del resaltado de sintaxis
  Capítulo anterior: |usr_04.esx|  Hacer cambios pequeños
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.1*	The vimrc file					*vimrc-intro*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.1*	El archivo «vimrc»				*vimrc-intro*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You probably got tired of typing commands that you use very often.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Probablemente se haya cansado de introducir órdenes que usa muy a menudo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start Vim with all your favorite option settings and mappings, you write them in what is called the vimrc file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para iniciar Vim con todas sus opciones y macros favoritas, defínalos en lo que se llama el archivo «vimrc».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim executes the commands in this file when it starts up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ejecuta las órdenes en este archivo al inicio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit $MYVIMRC</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit $MYVIMRC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a vimrc file yet, see |vimrc| to find out where you can create a vimrc file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si todavía no tiene un archivo vimrc, consulte |vimrc| para saber dónde puede crear un archivo vimrc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, the ":version" command mentions the name of the "user vimrc file" Vim looks for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:version» también menciona el nombre del «archivo vimrc de usuario» que Vim busca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vimrc ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vimrc ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$HOME/_vimrc ~
	$VIM/_vimrc ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>$HOME/_vimrc ~
	$VIM/_vimrc ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The vimrc file can contain all the commands that you type after a colon.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo vimrc puede contener todas las órdenes que se pueden teclear tras «:».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The most simple ones are for setting options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los más sencillos son los que se usan para ajustar opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you want Vim to always start with the 'incsearch' option on, add this line you your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, si quiere que Vim comience siempre con la opción 'incsearch' activada, añada la siguiente línea al archivo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set incsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set incsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this new line to take effect you need to exit Vim and start it again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita salir de Vim e iniciarlo otra vez para que esta nueva línea tenga efecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Later you will learn how to do this without exiting Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego verá cómo hacer esto sin salir de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter only explains the most basic items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo sólo explica los elementos más básicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information on how to write a Vim script file: |usr_41.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más información sobre cómo escribir un archivo de script de Vim: |usr_41.txt|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.2*	The example vimrc file explained		*vimrc_example.vim*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.2*	El archivo vimrc de ejemplo, explicado		*vimrc_example.vim*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the first chapter was explained how the example vimrc (included in the Vim distribution) file can be used to make Vim startup in not-compatible mode (see |not-compatible|).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el primer capítulo se explicó como el archivo vimrc de ejemplo (incluido en la distribución de Vim) se puede emplear para iniciar Vim en modo no-compatible (ver |not-compatible|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file can be found here:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrar el archivo aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$VIMRUNTIME/vimrc_example.vim ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>$VIMRUNTIME/vimrc_example.vim ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section we will explain the various commands used in this file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En esta sección explicaremos las diferentes órdenes empleadas en este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will give you hints about how to set up your own preferences.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le dará pistas sobre cómo preparar su propia configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not everything will be explained though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No todo se explicará, en cualquier caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the ":help" command to find out more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden ":help" e investigue.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set nocompatible</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set nocompatible</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the first chapter, these manuals explain Vim working in an improved way, thus not completely Vi compatible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal y como se mencionó en el primer capítulo, estos manuales explican un Vim funcionando en un modo mejorado, y por lo tanto no completamente Vi-compatible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the 'compatible' option off, thus 'nocompatible' takes care of this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desactivar la opción 'compatible' o activar 'nocompatible' se encarga de esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set backspace=indent,eol,start</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set backspace=indent,eol,start</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This specifies where in Insert mode the &lt;BS&gt; is allowed to delete the character in front of the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto especifica que se permita en el modo Insertar que &lt;Retroceso&gt; pueda eliminar el carácter delante del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The three items, separated by commas, tell Vim to delete the white space at the start of the line, a line break and the character before where Insert mode started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los tres elementos, separados por comas, le dicen a Vim que puede eliminar el espacio en blanco al comienzo de la línea, un salto de línea y el carácter anterior a donde inició el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set autoindent</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set autoindent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if has("vms")
	  set nobackup
	else
	  set backup
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>if has("vms")
	  set nobackup
	else
	  set backup
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Vim to keep a backup copy of a file when overwriting it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le dice a Vim que mantenga una copia de seguridad de un archivo cuando lo sobreescribe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But not on the VMS system, since it keeps old versions of files already.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero no en el sistema VMS, ya que éste mantiene versiones anteriores por su cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backup file will have the same name as the original file with "~" added.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El backup tendrá el mismo nombre con un «~» delante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |07.4| &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |07.4| &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set history=50</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set history=50</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep 50 commands and 50 search patterns in the history.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mantiene 50 órdenes y 50 patrones de búsqueda en el historial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another number if you want to remember fewer or more lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use otro número si quiere almacenar más o menos líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set ruler</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set ruler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set showcmd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set showcmd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Display an incomplete command in the lower right corner of the Vim window, left of the ruler.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muestra una orden incompleta en la esquina inferior derecha de la ventana de Vim, a la izquierda del «ruler» (regla).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, when you type "2f", Vim is waiting for you to type the character to find and "2f" is displayed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, cuando pulsa «2f», Vim está esperando que introduzcas el carácter a encontrar y muestra «2f» es mostrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you press "w" next, the "2fw" command is executed and the displayed "2f" is removed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando pulse «w», la orden «2fw» es ejecutará y el «2f» se eliminará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+-------------------------------------------------+
	|text in the Vim window				  |
	|~						  |
	|~						  |
	|-- VISUAL --			2f     43,8   17% |
	+-------------------------------------------------+
	 ^^^^^^^^^^^		      ^^^^^^^^ ^^^^^^^^^^
	  'showmode'		     'showcmd'	'ruler'</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+-------------------------------------------------+
	|texto en la ventana de Vim			  |
	|~						  |
	|~						  |
	|-- VISUAL --			2f     43,8   17% |
	+-------------------------------------------------+
	 ^^^^^^^^^^^		      ^^^^^^^^ ^^^^^^^^^^
	  'showmode'		     'showcmd'	'ruler'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	set incsearch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	set incsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	map Q gq</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	map Q gq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	vnoremap _g y:exe "grep /" . escape(@", '\\/') .</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	vnoremap _g y:exe "grep /" . escape(@", '\\/') .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"/ *.c *.h"&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"/ *.c *.h"&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mapping yanks the visually selected text and searches for it in C files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta macro copia el texto seleccionado visualmente y lo busca en archivos C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a complicated mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es una macro complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see that mappings can be used to do quite complicated things.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver que los macro se pueden emplear para hacer cosas realmente complicadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Still, it is just a sequence of commands that are executed like you typed them.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En cualquier caso, es simplemente una secuencia de órdenes que se ejecutan justo como los tecleas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	if &amp;t_Co &gt; 2 || has("gui_running")
	  syntax on
	  set hlsearch
	endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	if &amp;t_Co &gt; 2 || has("gui_running")
	  syntax on
	  set hlsearch
	endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This switches on syntax highlighting, but only if colors are available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto activa el resaltado de sintaxis, pero sólo si hay colores disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the 'hlsearch' option tells Vim to highlight matches with the last used search pattern.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y la opción 'hlsearch' le dice a Vim que resalte las coincidencias con el último patrón de búsqueda empleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "if" command is very useful to set options only when some condition is met.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «if» es muy útil para activar opciones sólo cuando se cumple alguna condición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about that in |usr_41.txt|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |usr_41.txt|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*vimrc-filetype*  &gt;
	filetype plugin indent on</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*vimrc-filetype*  &gt;
	filetype plugin indent on</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using filetype plugin files
   Many different filetypes are edited with different options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar extensiones de tipo de archivo («filetype plugin»)
   Muchos tipos de archivo se editan con diferentes opciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example,
   when you edit a "c" file, it's very useful to set the 'cindent' option to
   automatically indent the lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo,
   cuando edita un archivo «c», es muy útil activar la opción «cindent»
   para sangrar las líneas automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These commonly useful option settings are
   included with Vim in filetype plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas opciones empleadas
   comúnmente están incluidas con Vim en las extensiones de tipos de
   archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add your own, see
   |write-filetype-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede incluir las tuyas propias, consulte
   |write-filetype-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using indent files
   When editing programs, the indent of a line can often be computed
   automatically.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar archivos de tabulación
   Cuando edita programas, la sangría de una línea puede a menudo ser
   computada de manera automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim comes with these indent rules for a number of
   filetypes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim viene con esas reglas de sangrado
   para diversos tipos de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |:filetype-indent-on| and 'indentexpr'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |:filetype-indent-on| y 'indentexpr'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&gt;
	autocmd FileType text setlocal textwidth=78</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&gt;
	autocmd FileType text setlocal textwidth=78</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes Vim break text to avoid lines getting longer than 78 characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hace que Vim divida el texto para evitar que las líneas sean más largas de 78 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But only for files that have been detected to be plain text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero sólo para archivos que se han identificado como de texto regular.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are actually two parts here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aqui hay dos aspectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"autocmd FileType text" is an autocommand.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«autocmd FileType text» es una autoorden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This defines that when the file type is set to "text" the following command is automatically executed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto define que cuando el tipo de archivo sea «texto», la orden posterior se ejecute automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"setlocal textwidth=78" sets the 'textwidth' option to 78, but only locally in one file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«setlocal textwidth=78» ajusta la opción 'textwidth' a 78, pero sólo localmente a un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*restore-cursor*  &gt;
	autocmd BufReadPost *
	    \ if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") |
	    \   exe "normal! g`\"" |
	    \ endif</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*restore-cursor*  &gt;
	autocmd BufReadPost *
	    \ if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") |
	    \   exe "normal! g`\"" |
	    \ endif</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another autocommand.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra autoorden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time it is used after reading any file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta vez se ejecuta tras leer cualquier archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complicated stuff after it checks if the '" mark is defined, and jumps to it if so.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las cosas tan complicadas que hay después de él comprueban si la marca '" está definida, y salta hacia ella si lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backslash at the start of a line is used to continue the command from the previous line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La barra inversa al comienzo de la línea se emplea para continuarla desde la anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That avoids a line getting very long.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto ayuda a acortar las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |line-continuation|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |line-continuation|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This only works in a Vim script file, not when typing commands at the command-line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona sólo dentro de un script de Vim, no cuando se teclean órdenes en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.3*	Simple mappings</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.3*	Macros sencillas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A mapping enables you to bind a set of Vim commands to a single key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una macro le permite ligar un conjunto de órdenes de Vim a una sola tecla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose, for example, that you need to surround certain words with curly braces.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga, por ejemplo, que necesita poner una palabra entre llaves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, you need to change a word such as "amount" into "{amount}".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras necesita cambiar una palabra como «cantidad» a «{cantidad}».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the :map command, you can tell Vim that the F5 key does this job.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con la orden :map, puede decirle a Vim que la tecla F5 haga precisamente eso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command is as follows: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden es la siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;
&lt;
	Note:
	When entering this command, you must enter &lt;F5&gt; by typing four
	characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;
&lt;
	Nota:
	Cuando introduzca esta orden, debe introducir &lt;F5&gt; tecleando
        cuatro caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, &lt;Esc&gt; is not entered by pressing the &lt;Esc&gt;
	key, but by typing five characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De igual manera, &lt;Esc&gt; no se introduce pulsando
        la tecla &lt;Esc&gt;, sino tecleando cinco caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out for this difference
	when reading the manual!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De hecho, ¡¡has de
	poner los nombres en inglés, no la versión traducida!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's break this down:
    &lt;F5&gt;	The F5 function key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veámoslo por partes:
    &lt;F5&gt;	La tecla de función F5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the trigger key that causes the
		command to be executed as the key is pressed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es la tecla que lanzará la
                orden para que éste se ejecute al ser pulsada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i{&lt;Esc&gt;	Insert the { character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>i{&lt;Esc&gt;	Insertar el carácter {.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Esc&gt; key ends Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Esc&gt; sale del modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>e		Move to the end of the word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>e		Moverse al final de la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a}&lt;Esc&gt;	Append the } to the word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>a}&lt;Esc&gt;	Añadir el } a la palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;
	:map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;
	:map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":map" command (with no arguments) lists your current mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:map» (sin argumentos) le da un listado de sus macros actuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At least the ones for Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al menos aquellos en el modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about mappings in section |40.1|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más sobre macros en la sección |40.1|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.4*	Adding a plugin					*add-plugin* *plugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.4*	Añadir una extensión				*add-plugin* *plugin*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim's functionality can be extended by adding plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La funcionalidad de Vim puede ser extendida añadiendo extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A plugin is nothing more than a Vim script file that is loaded automatically when Vim starts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una extensiones no es nada más que un script de Vim que se carga automáticamente cuando Vim arranca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a plugin very easily by dropping it in your plugin directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir nuevas extensiones añadiéndolos al directorio de extensiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{not available when Vim was compiled without the |+eval| feature}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{no disponible si no se ha compilad con Vim con la opción |+eval|}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>global plugin: Used for all kinds of files
  filetype plugin: Only used for a specific type of file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Extensión global: Empleado para todos los tipos de archivo
   Extensión de tipo de archivo: Empleado para un tipo de archivo específico</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GLOBAL PLUGINS						*standard-plugin*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIONES GLOBALES					*standard-plugin*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you start Vim, it will automatically load a number of global plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando arranque Vim, verá que carga automáticamente un grupo de extensiones globales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to do anything for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No tiene que hacer nada al respecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They add functionality that most people will want to use, but which was implemented as a Vim script instead of being compiled into Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éstos añaden funcionalidad que le interesan a la mayoría de gente, pero que se implementaron como scripts de Vim en lugar de compilarlos en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find them listed in the help index |standard-plugin-list|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes verlos listados en el índice de ayuda |standard-plugin-list|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also see |load-plugins|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase también |load-plugins|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*add-global-plugin*
You can add a global plugin to add functionality that will always be present
when you use Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*add-global-plugin*
Puede poner un extensión global para añadir funcionalidad que deba estar
siempre presente cuando use Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are only two steps for adding a global plugin:
1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo tiene que seguir dos pasos para
añadir una extensión global:
1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get a copy of the plugin.
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Conseguir una copia de la extensión.
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can you find plugins?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Dónde encontrar extensiones?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Some come with Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Algunos vienen con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find them in the directory $VIMRUNTIME/macros
  and its sub-directories.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrarlos en el directorio
  $VIMRUNTIME/macro y sus subdirectorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- Download from the net.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Descargarlos de la red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a large collection on http://www.vim.org.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una buena colección en http://www.vim.org.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- They are sometimes posted in a Vim |maillist|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Algunas veces se envían a la |maillist| de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>- You could write one yourself, see |write-plugin|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>- Puede escribir uno usted mismo, consulte |write-plugin|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some plugins come as a vimball archive, see |vimball|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas extensiones vienen como un archivo comprimido, consulte |vimball|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some plugins can be updated automatically, see |getscript|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas extensiones pueden ser actualizados automáticamente, consulte |getscript|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First read the text in the plugin itself to check for any special conditions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lea primero el texto en la extensión descargada para comprobar cualquier requerimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then copy the file to your plugin directory:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación copielo al directorio de extensiones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>system		plugin directory ~
	Unix		~/.vim/plugin/
	PC and OS/2	$HOME/vimfiles/plugin or $VIM/vimfiles/plugin
	Amiga		s:vimfiles/plugin
	Macintosh	$VIM:vimfiles:plugin
	Mac OS X	~/.vim/plugin/
	RISC-OS		Choices:vimfiles.plugin</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>sistema		directorio de extensiones  ~
	Unix		~/.vim/plugin/
	PC and OS/2	$HOME/vimfiles/plugin or $VIM/vimfiles/plugin
	Amiga		s:vimfiles/plugin
	Macintosh	$VIM:vimfiles:plugin
	Mac OS X	~/.vim/plugin/
	RISC-OS		Choices:vimfiles.plugin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mkdir ~/.vim
	mkdir ~/.vim/plugin
	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mkdir ~/.vim
	mkdir ~/.vim/plugin
	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the commands defined in this plugin to justify text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar las órdenes definidas en esta extensión para justificar texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of putting plugins directly into the plugin/ directory, you may better organize them by putting them into subdirectories under plugin/.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de poner las extensiones directamente en el directorio «plugins/», quizá prefiera organizarlos poniéndolos en subdirectorios dentro de «plugins/».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, consider using "~/.vim/plugin/perl/*.vim" for all your Perl plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, ponga todas sus extensiones de Perl bajo el subdirectorio «~/.vim/plugin/perl/*.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>FILETYPE PLUGINS			*add-filetype-plugin* *ftplugins*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EXTENSIONES DE TIPO DE ARCHIVO		*add-filetype-plugin* *ftplugins*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:filetype plugin on</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:filetype plugin on</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |vimrc-filetype|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |vimrc-filetype|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are missing a plugin for a filetype you are using, or you found a better one, you can add it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si echa de menos una extensión para un tipo de archivo que esté usando, o encontró uno mejor, puede añadirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two steps for adding a filetype plugin: 1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay dos pasos para conseguirlo: 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get a copy of the plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Conseguir una copia de la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find them in the same places as the global plugins.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede encontrarlos en los mismos sitios que las extensiones globales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out if the type of file is mentioned, then you know if the plugin is a global or a filetype one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Compruebe si el tipo de archivo se menciona o no, de ese modo puede saber si la extensión es global o de tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scripts in $VIMRUNTIME/macros are global ones, the filetype plugins are in $VIMRUNTIME/ftplugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los scripts en «$VIMRUNTIME/macros» son globales, los específicos están en «$VIMRUNTIME/ftplugin».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>USING A FILETYPE PLUGIN					*ftplugin-name*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>USAR UNA EXTENSIÓN DE TIPO DE ARCHIVO			*ftplugin-name*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a filetype plugin by dropping it in the right directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir una extensión de tipo de archivo ubicándolo en el directorio adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of this directory is in the same directory mentioned above for global plugins, but the last part is "ftplugin".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre de este directorio está en el mismo directorio mencionado previamente para extensiones globales, pero la última parte es «ftplugin».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have found a plugin for the "stuff" filetype, and you are on Unix.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que ha encontrado una extensión para el tipo de archivo «cosas» y que está bajo Unix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can move this file to the ftplugin directory: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede mover este archivo al directorio «ftplugin/»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mv thefile ~/.vim/ftplugin/stuff.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mv thefile ~/.vim/ftplugin/cosas.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If that file already exists you already have a plugin for "stuff".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ese archivo ya existe, es que ya tiene una extensión para «cosas».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to check if the existing plugin doesn't conflict with the one you are adding.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal vez desee comprobar si la extensión existente no es conflictivo con el que añade.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's OK, you can give the new one another name: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no hay conflicto, puede darle otro nombre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mv thefile ~/.vim/ftplugin/stuff_too.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mv thefile ~/.vim/ftplugin/cosas_dos.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The underscore is used to separate the name of the filetype from the rest, which can be anything.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El guión bajo se usa para separar el nombre del tipo de archivo del resto, que puede ser cualquier cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use "otherstuff.vim" it wouldn't work, it would be loaded for the "otherstuff" filetype.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si usa «otrascosas.vim» no funcionaría, ya que se cargaría como tipo de archivo «otrascosas».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-DOS you cannot use long filenames.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-DOS no puede usar nombres de archivo largos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You would run into trouble if you add a second plugin and the filetype has more than six characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá problemas si añades una segunda extensión el tipo de archivo tiene más de seis caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use an extra directory to get around this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede añadir un directorio extra para evitar este problema: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mkdir $VIM/vimfiles/ftplugin/fortran
	copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>mkdir $VIM/vimfiles/ftplugin/fortran
	copy thefile $VIM/vimfiles/ftplugin/fortran/dos.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ftplugin/&lt;filetype&gt;.vim
	ftplugin/&lt;filetype&gt;_&lt;name&gt;.vim
	ftplugin/&lt;filetype&gt;/&lt;name&gt;.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ftplugin/&lt;tipo_de_archivo&gt;.vim
	ftplugin/&lt;tipo_de_archivo&gt;_&lt;nombre&gt;.vim
	ftplugin/&lt;tipo_de_archivo&gt;/&lt;nombre&gt;.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here "&lt;name&gt;" can be any name that you prefer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí, «&lt;nombre&gt;» puede ser cualquier nombre que quieras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples for the "stuff" filetype on Unix: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejemplos para el tipo de archivo «cosas» en Unix: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~/.vim/ftplugin/stuff.vim
	~/.vim/ftplugin/stuff_def.vim
	~/.vim/ftplugin/stuff/header.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~/.vim/ftplugin/cosas.vim
	~/.vim/ftplugin/cosas_def.vim
	~/.vim/ftplugin/cosas/header.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;filetype&gt; part is the name of the filetype the plugin is to be used for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte &lt;tipo_de_archivo&gt; es el nombre del tipo de archivo para el cuál se usa la extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only files of this filetype will use the settings from the plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo los archivos de este tipo cargarán esta extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;name&gt; part of the plugin file doesn't matter, you can use it to have several plugins for the same filetype.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La parte &lt;nombre&gt; de la extensión no importa, puede usarlo para tener varias extensiones del mismo tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that it must end in ".vim".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que debe terminar con la extensión «.vim».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further reading:
|filetype-plugins|	Documentation for the filetype plugins and information
			about how to avoid that mappings cause problems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lecturas de ampliación:
|filetype-plugins|	Documentación para las extensiones de tipo de
			archivo e información sobre como evitar problemas
			con macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|load-plugins|		When the global plugins are loaded during startup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|load-plugins|		Cuándo las extensiones globales se cargan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|ftplugin-overrule|	Overruling the settings from a global plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|ftplugin-overrule|	Sobreescribir las opciones de una extensión global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|write-plugin|		How to write a plugin script.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|write-plugin|		Cómo escribir un script de extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|plugin-details|	For more information about using plugins or when your
			plugin doesn't work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|plugin-details|	Para más información sobre cómo usar extensiones o
			cuando la extensión no funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|new-filetype|		How to detect a new file type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|new-filetype|		Cómo detectar un nuevo tipo de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.5*	Adding a help file		*add-local-help* *matchit-install*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.5*	Añadir un archivo de ayuda	*add-local-help* *matchit-install*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are lucky, the plugin you installed also comes with a help file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene suerte, la extensión que instaló viene con un archivo de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We
will explain how to install the help file, so that you can easily find help
for your new plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le
explicaremos cómo instalar el archivo de ayuda, para que pueda encontrar
ayuda fácilmente para su nueva extensión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let us use the "matchit.vim" plugin as an example (it is included with
Vim).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usemos el plugin «matchit.vim» como ejemplo (viene incluido con Vim).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This plugin makes the "%" command jump to matching HTML tags,
if/else/endif in Vim scripts, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta extensión hace que la orden «%» salte a tags emparejados de HTML,
«if/else/endif» en scripts de Vim, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Very useful, although it's not backwards
compatible (that's why it is not enabled by default).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muy útil, pero no es compatible
con versiones anteriores (por lo que no está activado por defecto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This plugin comes with documentation: "matchit.txt".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta extensión viene con la documentación «matchit.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's first copy the
plugin to the right directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero
copiemos la extensión al directorio adecuado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time we will do it from inside Vim, so
that we can use $VIMRUNTIME.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta vez lo haremos desde
dentro de Vim, así podremos usar $VIMRUNTIME.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(You may skip some of the "mkdir" commands if
you already have the directory.) &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Puede omitir la orden
«mkdir» si ya tiene el directorio.) &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!mkdir ~/.vim
	:!mkdir ~/.vim/plugin
	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!mkdir ~/.vim
	:!mkdir ~/.vim/plugin
	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a "doc" directory in one of the directories in 'runtimepath'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cree un directorio «doc» en una de los directorios de 'runtimepath'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!mkdir ~/.vim/doc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!mkdir ~/.vim/doc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the help file to the "doc" directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie el archivo de ayuda al directorio «doc».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now comes the trick, which allows you to jump to the subjects in the new help file: Generate the local tags file with the |:helptags| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último el truco que le permite ir a los temas en el nuevo archivo de ayuda: Genere el archivo de tags locales con la orden |:helptags|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:helptags ~/.vim/doc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:helptags ~/.vim/doc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help g%</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help g%</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command to find help for "g%" in the help file you just added.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>para buscar ayuda para «g%» en el archivo de ayuda que acaba de añadir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see an entry for the local help file when you do: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede ver una entrada correspondiente al archivo local cuando escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help local-additions</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help local-additions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The title lines from the local help files are automagically added to this section.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las líneas con los títulos de los archivos de ayuda locales son añadidos automágicamente a la sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There you can see which local help files have been added and jump to them through the tag.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Allí puede ver que archivos locales se han añadido e ir a ellos a través del tag creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.6*	The option window</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.6*	La ventana de opciones</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for an option that does what you want, you can search in the help files here: |options|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si busca una opción que haga lo que quiere, puede buscarla en los archivos de ayuda aquí: |options|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another way is by using this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otra forma es usar la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:options</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:options</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the value of an option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cambiar el valor de una opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, move to the "displaying text" subject.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, vaya al tema «displaying text».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then move the cursor down to this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego ponga el cursor abajo, en esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set wrap	nowrap ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set wrap	nowrap ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set nowrap	wrap ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set nowrap	wrap ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just above this line is a short description of the 'wrap' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Justo sobre esta línea hay una descripción corta de la opción 'wrap'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor one line up to place it in this line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ponga el cursor una línea arriba para colocarlos sobre esta línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now hit &lt;Enter&gt; and you jump to the full help on the 'wrap' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora pulse &lt;Intro&gt; e irá hacia la descripción completa de la opción 'wrap'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For options that take a number or string argument you can edit the value.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para opciones que toman un número o una cadena de caracteres puede editar el valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, move the cursor a few lines up to this line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, mueva el cursor unas cuantas líneas arriba hasta esta línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set so=0 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set so=0 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Position the cursor on the zero with "$".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posicione el cursor sobre el cero con «$».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change it into a five with "r5".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Modifiqueló a un cinco con «r5».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now move the cursor around you will notice that the text starts scrolling before you reach the border.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando mueva el cursor por un texto, notará que el texto se desplazará (scroll) antes de que llegue al borde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is what the 'scrolloff' option does, it specifies an offset from the window border where scrolling starts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es lo que la opción 'scrolloff' hace, especifica una compensación (offset) del punto donde comienza el desplazamiento (respecto al borde).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*05.7*	Often used options</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*05.7*	Opciones más comunes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are an awful lot of options.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una cantidad de opciones inmensa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of them you will hardly ever use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Difícilmente llegará a usar gran parte de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of the more useful ones will be mentioned here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas de las más comunes se citarán a continuación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget you can find more help on these options with the ":help" command, with single quotes before and after the option name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se olvide de que puede encontrar más ayuda con la orden «:help», con comillas simples alrededor del nombre de la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:help 'wrap'</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:help 'wrap'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you have messed up an option value, you can set it back to the default by putting an ampersand (&amp;) after the option name.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de que haya descolocado el valor de una opción, puede devolverlo a la opción por defecto con un et (&amp;) tras el nombre de la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword&amp;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword&amp;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim normally wraps long lines, so that you can see all of the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim normalmente dobla líneas largas, de forma que pueda ver todo el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it's better to let the text continue right of the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces es mejor dejar que el texto continúe a la derecha de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to scroll the text left-right to see all of a long line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De este modo tiene que desplazarse de izquierda a derecha para ver toda una línea larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch wrapping off with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede intercambiar el valor con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set nowrap</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set nowrap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will automatically scroll the text when you move to text that is not displayed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim automáticamente desplazará el texto cuando se desplace hacia el texto que no se muestra en pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see a context of ten characters, do this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver un contexto de diez caracteres: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set sidescroll=10</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set sidescroll=10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most commands for moving around will stop moving at the start and end of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría de las órdenes para desplazarse dejarán de funcionar al comienzo o al final de una línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change that with the 'whichwrap' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede cambiar esto con la opción 'whichwrap'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This sets it to the default value: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto la cambia al valor predeterminado: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set whichwrap=b,s</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set whichwrap=b,s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows the &lt;BS&gt; key, when used in the first position of a line, to move the cursor to the end of the previous line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite que la tecla &lt;Retroceso&gt;, cuando se emplea en la primera posición de una línea se mueva al final de la línea anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the &lt;Space&gt; key moves from the end of a line to the start of the next one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También la tecla &lt;Espacio&gt; le desplazará desde el final de una línea hasta el comienzo de la siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set whichwrap=b,s,&lt;,&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set whichwrap=b,s,&lt;,&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is still only for Normal mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es exclusivamente en el modo Normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let &lt;Left&gt; and &lt;Right&gt; do this in Insert mode as well: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para permitir que &lt;Izq&gt; y &lt;Der&gt; haga esto en también modo Insertar, escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set whichwrap=b,s,&lt;,&gt;,[,]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set whichwrap=b,s,&lt;,&gt;,[,]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are tabs in a file, you cannot see where they are.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hay pestañas en un archivo, no puede ver dónde están.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make them visible: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacerlas visibles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set list</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set list</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every tab is displayed as ^I.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora todas las pestañas se mostrarán como ^I.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And a $ is displayed at the end of each
line, so that you can spot trailing spaces that would otherwise go unnoticed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un «$» se mostrará al final de
cada línea, permitiéndole ver espacios finales que de otra forma pasarían
desapercibidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage is that this looks ugly when there are many Tabs in a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una desventaja de esto es que tiene una apariencia desagradable cuando
hay muchas pestañas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a color terminal, or are using the GUI, Vim can show the spaces
and tabs as highlighted characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si tiene una terminal con colores o usa GVim, puede
ver los espacios y las pestañas como marcas de color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the 'listchars' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la opción
'listchars': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set listchars=tab:&gt;-,trail:-</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set listchars=tab:&gt;-,trail:-</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every tab will be displayed as "&gt;---" (with more or less "-") and trailing white space as "-".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cada pestaña se mostrará como «&gt;---» (con más o menos «-») y los espacios al final de la línea como «-».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks a lot better, doesn't it?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Más agradable, o no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "@" stands for all alphabetic letters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El «@» implica todas las letras del alfabeto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"48-57" stands for ASCII
characters 48 to 57, which are the numbers 0 to 9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«48-57» significa los
caracteres ASCII 48 a 57, que son los números 0 a 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"192-255" are the
printable latin characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«192-255» son los
caracteres latinos imprimibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you will want to include a dash in keywords, so that commands
like "w" consider "upper-case" to be one word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces querrá incluir un guión en las palabras clave, para que órdenes
como «w» consideren «upper-case» como una sola palabra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do it like this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacerlo así: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword+=-
	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255,- ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword+=-
	:set iskeyword
&lt;	  iskeyword=@,48-57,_,192-255,- ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the new value, you will see that Vim has added a comma for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si miras el nuevo valor, comprobará que Vim ha añadido una coma por Ud.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove a character use "-=".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar un carácter usa «-=».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to remove the underscore: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, el guión bajo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set iskeyword-=_
	:set iskeyword
&lt;	  iskeyword=@,48-57,192-255,- ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set iskeyword-=_
	:set iskeyword
&lt;	  iskeyword=@,48-57,192-255,- ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Vim starts there is one line at the bottom that is used for messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando Vim arranca hay una línea en la parte de abajo que se usa para
mensajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a message is long, it is either truncated, thus you can only see part of
it, or the text scrolls and you have to press &lt;Enter&gt; to continue.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando un mensaje es largo, o se trunca (con lo que sólo puede
ver una parte) o el texto se desplaza y tienes que pulsar &lt;Intro&gt; para
continuar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can set the 'cmdheight' option to the number of lines used for
messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes asignar a la opción 'cmdheight' el número de líneas usado para
mensajes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set cmdheight=3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set cmdheight=3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_32.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_32.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The undo tree</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El árbol de deshacer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim provides multi-level undo.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim ofrece varios niveles de deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you undo a few changes and then make a new change you create a branch in the undo tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si deshace unos cuantos cambios y después realiza uno nuevo, creará una rama en el árbol de deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This text is about moving through the branches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto a continuación trata acerca de desplazarse por las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|32.1|	Undo up to a file write
|32.2|	Numbering changes
|32.3|	Jumping around the tree
|32.4|	Time travelling</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|32.1|	Volver a un punto de edición anterior
|32.2|	Numerar los cambios
|32.3|	Desplazarse en el árbol
|32.4|	Viajar en el tiempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_40.txt|  Make new commands
 Previous chapter: |usr_31.txt|  Exploiting the GUI
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_40.esx|  Crear órdenes nuevas
  Capítulo anterior: |usr_31.esx|  Aprovechar la interfaz gráfica
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.1*	Undo up to a file write</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.1*	Volver a un punto de edición anterior</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you make several changes, and then discover you want to go back to when you have last written the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A veces realiza una serie de cambios, y se da cuenta que desea volver al punto en el que editó el archivo por última vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do that with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer esto con la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:earlier 1f</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:earlier 1f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat this command to go further back in the past.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir esta orden para retroceder aun más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or use a count different from 1 to go back faster.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>O usar un número diferente de 1 para retroceder más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:later 1f</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:later 1f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that these commands really work in time sequence.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que estas órdenes funcionan secuencialmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This matters if you made changes after undoing some changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Importa si realiza cambios después de deshacer otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's explained in the next section.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se explica en la siguiente sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that we are talking about text writes here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga también en cuenta que nos referimos a ediciones de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For writing the undo information in a file see |undo-persistence|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para escribir la información de deshacer de en un archivo, consulte |undo-persistence|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.2*	Numbering changes</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.2*	Numerar los cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In section |02.5| we only discussed one line of undo/redo.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |02.5| sólo tratamos una línea temporal de deshacer o rehacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it is also possible to branch off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero también es posible crear una nueva «rama».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This happens when you undo a few changes and then make a new change.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ocurre cuando deshace algunos cambios y después realiza un nuevo cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new changes become a branch in the undo tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los cambios nuevos se convierten en una rama del árbol de deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the text "one".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Empecemos con el texto «one».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first change to make is to append " too".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El primer cambio es añadir «too».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then move to the first 'o' and change it into 'w'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después, ir a la primera «o» y cambiarla a «w».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We then have two changes, numbered 1 and 2, and three states of the text:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenemos ahora dos cambios, 1 y 2, y tres estados del texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
		 |
	      change 2
		 |
	      one two ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
		 |
	      change 2
		 |
	      one two ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now use the |u| command to undo.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede usar la orden |u| para deshacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do this twice you get to "one".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo hace dos veces, obtendrá «one».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use |CTRL-R| to redo, and you will go to "one too".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |CTRL-R| para rehacer, y obtendrá «one too».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One more |CTRL-R| takes you to "me too".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar |CTRL-R| una vez más le lleva a  «me too».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus undo and redo go up and down in the tree, using the branch that was last used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es, deshacer y rehacer suben y bajan un árbol usando la rama usada por última vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What matters here is the order in which the changes are made.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que importa es el orden de las cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Undo and redo are not considered changes in this context.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Deshacer y rehacer no se consideran cambios en este contexto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After each change you have a new state of the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras cada cambio tiene un nuevo estado del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that only the changes are numbered, the text shown in the tree above has no identifier.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que sólo se enumeran los cambios, y el texto que aparece en el árbol anterior no tiene identificador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They are mostly referred to by the number of the change above it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se hace referencia a ellos según el número del cambio por encima suyo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But sometimes by the number of one of the changes below it, especially when moving up in the tree, so that you know which change was just undone.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero, a veces, según el número por debajo de él, particularmente al subir el árbol, para así saber qué cambio se ha deshecho recientemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.3*	Jumping around the tree</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.3*	Desplazarse en el árbol</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So how do you get to "one two" now?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Cómo podemos obtener «one two» ahora?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:undo 2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:undo 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text is now "one two", you are below change 2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, el texto es «one two», y está bajo el cambio 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the |:undo| command to jump to below any change in the tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la orden |:undo| para saltar a cualquier cambio dentro del árbol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
	    |
	 change 4
	    |
	 not two ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>one ~
		 |
	      change 1
		 |
	      one too ~
	      /     \
	 change 2  change 3
	    |	      |
	 one two    me too ~
	    |
	 change 4
	    |
	 not two ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you change your mind and want to go back to "me too".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cambia de idea, y desea volver a «me too».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the |g-| command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden |g-|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This moves back in time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto vuelve a un momento anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus it doesn't walk the tree upwards or downwards, but goes to the change made before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se desplaza por el árbol en una dirección u otra, sino que vuelve al último cambio realizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can repeat |g-| and you will see the text change:
	me too ~
	one two ~
	one too ~
	one ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede repetir |g-| y ver como cambia el texto:
	me too ~
	one two ~
	one too ~
	one ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use |g+| to move forward in time:
	one ~
	one too ~
	one two ~
	me too ~
	not two ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use |g+| para ir hacia delante en el tiempo:
	one ~
	one too ~
	one two ~
	me too ~
	not two ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using |:undo| is useful if you know what change you want to jump to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar |:undo| es útil si sabe a qué cambio quiere pasar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|g-| and |g+| are useful if you don't know exactly what the change number is.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|g-| y |g+| son útiles si no sabe exactamente el número del cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*32.4*	Time travelling</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*32.4*	Viajar en el tiempo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you have been working on text for a while the tree grows to become big.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando ha estado trabajando en el texto durante un rato el árbol crece hasta ser bastante grande.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you may want to go to the text of some minutes ago.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, puede que desee volver a como era el texto hace unos minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:undolist
&lt;	number changes  time ~
	     3       2  16 seconds ago
	     4       3  5 seconds ago</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:undolist
&lt;	número cambios  hora ~
	     3       2  hace 16 segundos
	     4       3  hace 5 segundos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can see the number of the leaves in each branch and when the change was made.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver el número de hojas en cada rama el momento en que se realizó el cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assuming we are below change 4, at "not two", you can go back ten seconds with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponiendo que estamos bajo el nivel 4, en «not two», puede retroceder 10 segundos con la siguiente orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:earlier 10s</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:earlier 10s</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on how much time you took for the changes you end up at a certain position in the tree.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dependiendo del tiempo que le tomó realizar los cambios, acabará en una posición determinada del árbol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The |:earlier| command argument can be "m" for minutes, "h" for hours and "d" for days.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento de la orden |:earlier| puede ser «m», de minutos, «h» de horas y «d» de días.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go all the way back use a big number: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para volver al principio use un número grande: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:earlier 100d</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:earlier 100d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:later 1m</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:later 1m</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want even more details, or want to manipulate the information, you can use the |undotree()| function.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea más detalles, o manipular la información, puede usar la función |undotree()|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see what it returns: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ver qué devuelve: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:echo undotree()</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:echo undotree()</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_25.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_25.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Editing formatted text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Editar texto con formato</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Text hardly ever comes in one sentence per line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto rara vez aparece como una oración por línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter is about breaking sentences to make them fit on a page and other formatting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo trata acerca de formatear oraciones para su correcta apariencia en un papel, así como otros formatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim also has useful features for editing single-line paragraphs and tables.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim también ofrece útiles características para editar párrafos de una sola línea y tablas-</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|25.1|	Breaking lines
|25.2|	Aligning text
|25.3|	Indents and tabs
|25.4|	Dealing with long lines
|25.5|	Editing tables</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|25.1|	Dividir líneas
|25.2|	Alinear texto
|25.3|	Sangrado y tabulación
|25.4|	Tratar líneas largas
|25.5|	Editar tablas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_26.txt|  Repeating
 Previous chapter: |usr_24.txt|  Inserting quickly
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Siguiente capítulo: |usr_26.txt|  Repetición
  Capítulo anterior: |usr_24.esx|  Insertar con rapidez
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.1*	Breaking lines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.1*	Dividir líneas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set textwidth=30</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set textwidth=30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a whi ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1	   2	     3
	12345678901234567890123456789012345
	Enseñé programación durante un ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you type "l" next, this makes the line longer than the 30-character limit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si teclea ahora «os», la línea sobrepasaría el límite de 30 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Vim sees this, it inserts a line break and you get the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En cuanto Vim detecta esto, inserta un salto línea, obteniendo lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a ~
	whil ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>1	   2	     3
	12345678901234567890123456789012345
	Enseñé programación durante ~
	unos ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	The 'wrap' option makes Vim display lines with a line break, but this
	doesn't insert a line break in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	La opción 'wrap' hace que Vim muestre las líneas con un salto de
	línea, pero no inserta realmente un salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor is not a word processor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim no es un editor de documentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a word processor, if you delete something at the beginning of the paragraph, the line breaks are reworked.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un editor de documentos, si elimina algo al inicio del párrafo, se reorganizan los saltos de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim they are not; so if you delete the word "programming" from the first line, all you get is a short line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es así en Vim; así que se borra la palabra «programación» en la primera línea, obtendría los siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This does not look good.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no es elegante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get the paragraph into shape you use the "gq"
operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para dar formato a un párrafo puede usar el operador
«gq».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's first use this with a Visual selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usemos esto primero con una selección en modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from the first
line, type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Empezando por la
primera línea, escriba: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>v4jgq</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>v4jgq</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v" to start Visual mode, "4j' to move to the end of the paragraph and then the "gq" operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«v» inicial el modo Visual, «4j» para desplazarse al final del párrafo, y después el operador «gq».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"ap" stands for "a-paragraph".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«ap» significa un párrafo («a-paragraph»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This formats the text of one paragraph
(separated by empty lines).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto da formato al texto de un
párrafo (separado por líneas vacías).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also the part before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También el área anterior al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have your paragraphs separated by empty lines, you can format the
whole file by typing this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si los párrafos están separados por líneas vacías, puede dar formato a
todo el archivo con lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"gg" to move to the first line, "gqG" to format until the last line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«gg» para ir a la primera línea, «gqG» para dar formato hasta la última
línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Warning: If your paragraphs are not properly separated, they will be joined
together.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aviso: si sus párrafos no están apropiadamente separados, no se unirán.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A common mistake is to have a line with a space or tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un error común es tener una línea con un espacio o tabulación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a
blank line, but not an empty line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esa es una
línea en blanco, pero no una línea vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim is able to format more than just plain text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim es capaz de dar formato a más que texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |fo-table| for how to
change this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |fo-table| para ver
cómo cambiar esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the 'joinspaces' option to change the number of spaces used
after a full stop.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte la opción 'joinspaces' para modificar el número
de espacios antes de un punto final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to use an external program for formatting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible dar formato con un programa externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful
if your text can't be properly formatted with Vim's builtin command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil si el texto
no puede recibir un formato adecuado con la orden integrada en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the
'formatprg' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte
la opción 'formatprg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.2*	Aligning text</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.2*	Alinear texto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:{range}center [width]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:{range}center [width]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{range} is the usual command-line range.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{range} (rango) is el valor de rango normal en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[width] is an optional line width to
use for centering.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>[width]
(ancho) es el valor opcional del ancho usado al centrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If [width] is not specified, it defaults to the value of
'textwidth'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De no especificar
[width], su valor por omisión será el de 'textwidth'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If 'textwidth' is 0, the default is 80.)
   For example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si 'textwith' es
cero, el valor será 80.)
   Por ejemplo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:1,5center 40</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:1,5center 40</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:1,5right 37</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:1,5right 37</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:{range}left [margin]</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:{range}left [margin]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:1left 5
	:2,5left</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:1left 5
	:2,5left</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has no built-in way of justifying text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no posee una herramienta integrada para justificar texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, there is a neat macro package that does the job.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otro lado, ofrece un excelente macro que realiza esta labor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this package, execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecute la siguiente orden para usar este conjunto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:runtime macros/justify.vim</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:runtime macros/justify.vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This Vim script file defines a new visual command "_j".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este archivo script de Vim define una nueva orden visual, «_j».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To justify a block of
text, highlight the text in Visual mode and then execute "_j".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para
justificar un bloque de texto, resalte el texto en modo Visual y ejecute «_j».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Look in the file for more explanations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte el archivo para una explicación más completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To go there, do "gf" on this name:
$VIMRUNTIME/macros/justify.vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ir a ese punto,
pulse «gf» en este nombre:
$VIMRUNTIME/macros/justify.vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An alternative is to filter the text through an external program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una alternativa es filtrar el texto a través de un programa externo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%!fmt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%!fmt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.3*	Indents and tabs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.3*	Sangrado y tabulación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indents can be used to make text stand out from the rest.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar el sangrado para destacar texto con respecto al resto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example texts
in this manual, for example, are indented by eight spaces or a tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los textos
de ejemplo en este manual, por ejemplo, están sangrados con ocho espacios, o
una tabulación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You would
normally enter this by typing a tab at the start of each line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, introduce el sangrado con una tabulación al
inicio de cada línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Take this
text:
	the first line ~
	the second line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga este texto:
	la primera línea ~
	la segunda línea ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is entered by typing a tab, some text, &lt;Enter&gt;, tab and more text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede introducir esto pulsando el botón de tabulado, algo de texto, &lt;Intro&gt;,
tabulado, y más texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'autoindent' option inserts indents automatically: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'autoindent' inserta sangrado automáticamente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set autoindent</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set autoindent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a new line is started it gets the same indent as the previous line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al iniciar una nueva línea, este recibirá el mismo sangrado que la línea anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above example, the tab after the &lt;Enter&gt; is not needed anymore.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En el ejemplo anterior, el tabulado tras &lt;Intro&gt; ya no es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increase the amount of indent in a line, use the "&gt;" operator.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para aumentar la cantidad de sangrado en una línea, use el operador «&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Often this
is used as "&gt;&gt;", which adds indent to the current line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A
menudo usará esto como «&gt;&gt;», que añade sangrado a la línea actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The amount of indent added is specified with the 'shiftwidth' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La cantidad de sangrado añadida se especifica con la opción 'shiftwidth'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The
default value is 8.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor por omisión es 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make "&gt;&gt;" insert four spaces worth of indent, for
example, type this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para lograr que «&gt;&gt;» inserte cuatro espacios de
sangrado, por ejemplo, use lo siguiente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the first line ~
	    the second line ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>la primera línea ~
	    la segunda línea ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to make indents a multiple of 4, you set 'shiftwidth' to 4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea que el sangrado sea un múltiplo de 4, defina 'shiftwidth' a 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But when pressing a &lt;Tab&gt; you still get 8 spaces worth of indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún obtendría ocho espacios de sangrado al pulsar &lt;Tab&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change this, set the 'softtabstop' option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina la opción 'softtabstop' para modificar esto: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will make the &lt;Tab&gt; key insert 4 spaces worth of indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto hará que la tecla &lt;Tab&gt; inserte 4 espacios de sangrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are already four spaces, a &lt;Tab&gt; character is used (saving seven characters in the file).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EL carácter &lt;Tab&gt; se usará en caso ya existir cuatro espacios (ahorrando 7 espacios en el archivo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(If you always want spaces and no tab characters, set the 'expandtab' option.)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(Si desea siempre espacios y no caracteres de tabulado, defina la opción 'expandtab').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	You could set the 'tabstop' option to 4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Puede definir la opción 'tabstop' con valor de 4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you edit the
	file another time, with 'tabstop' set to the default value of 8, it
	will look wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De todas formas, si
	edita el archivo en otro momento teniendo 'tabstop' su valor
	predeterminado de 8, el aspecto no será el deseado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other programs and when printing the indent will
	also be wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otros programas,
	así como imprimir el sangrado presentarán un aspecto equivocado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore it is recommended to keep 'tabstop' at eight
	all the time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
	ello, recomendamos mantener 'tabstop' con valor de 8 en todo momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's the standard value everywhere.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es el valor estándar en otras aplicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set tabstop=3
	:retab 8</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set tabstop=3
	:retab 8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":retab" command will change 'tabstop' to 8, while changing the text such
that it looks the same.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:retab» cambia 'tabstop' a 8, a la vez que modifica el texto para
que encaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It changes spans of white space into tabs and spaces
for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para ello, modifica los tramos de espacio blanco a tabulados y
espacios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now write the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede escribir en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next time you edit it the indents will
be right without setting an option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente vez que lo edite,
la tabulación será la correcta sin necesidad de definir la opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Warning: When using ":retab" on a program, it may change white space inside
a string constant.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aviso: Si usa «:retab» sobre un programa, cabe que modifique el espacio
en blanco dentro de una cadena entrecomillas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore it's a good habit to use "\t" instead of a
real tab.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, es una buena
costumbre usar «\t» en lugar de un tabulado real.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.4*	Dealing with long lines</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.4*	Tratar líneas largas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set guioptions+=b</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set guioptions+=b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't have a scrollbar or don't want to use it, use these commands to scroll the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no tiene una barra de desplazamiento o no quiere usarla, puede usar estas  órdenes para desplazar el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor will stay in the same place, but it's moved back into the visible text if necessary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor permanecerá en el mismo lugar, pero permitiendo también desplazarlo al texto visible, de ser necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's attempt to show this with one line of text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a intentar mostrar esto con una línea de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is on the "w" of "which".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está sobre la «w» de «which».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "current window" above the line indicates the text that is currently visible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «ventana actual» sobre la línea indica el texto actualmente visible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "window"s below the text indicate the text that is visible after the command left of it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las «ventana» bajo el texto indican el texto visible después de ejecutar la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|&lt;-- current window --&gt;|
		some long text, part of which is visible in the window ~
	ze	  |&lt;--	   window     --&gt;|
	zH	   |&lt;--     window     --&gt;|
	4zh		  |&lt;--	   window     --&gt;|
	zh		     |&lt;--     window	 --&gt;|
	zl		       |&lt;--	window	   --&gt;|
	4zl			  |&lt;--	   window     --&gt;|
	zL				|&lt;--	 window     --&gt;|
	zs			       |&lt;--	window	   --&gt;|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|&lt;-- ventana actual --&gt;|
		some long text, part of which is visible in the window ~
	ze	  |&lt;--	   ventana    --&gt;|
	zH	   |&lt;--     ventana    --&gt;|
	4zh		  |&lt;--	   ventana    --&gt;|
	zh		     |&lt;--     ventana	 --&gt;|
	zl		       |&lt;--	ventana	   --&gt;|
	4zl			  |&lt;--	   ventana    --&gt;|
	zL				|&lt;--	 ventana    --&gt;|
	zs			       |&lt;--	ventana	   --&gt;|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When 'wrap' is off and the text has scrolled horizontally, you can use the following commands to move the cursor to a character you can see.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando ha desplazado el texto horizontalmente y 'wrap' está desactivado, puede usar las siguientes órdenes para mover el cursor a un carácter que puede ver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus text left and right of the window is ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, se ignorará el texto a la izquierda y derecha de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These never cause the text to scroll:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto nunca causa un desplazamiento del texto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>g0		to first visible character in this line
	g^		to first non-blank visible character in this line
	gm		to middle of this line
	g$		to last visible character in this line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>g0		Desplazarse al primer carácter en esta línea
	g^		Al primer carácter que no está en blanco de la línea
	gm		Al centro de esta línea
	g$		Al ultimo carácter visible en esta línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|&lt;--	 window    --&gt;|
	some long    text, part of which is visible ~
		 g0  g^    gm	     g$</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|&lt;--	 ventan    --&gt;|
	algún texto    largo, parte del cual visible ~
		   g0  g^     gm     g$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BREAKING AT WORDS				*edit-no-break*</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>DIVIDIR LÍNEAS EN PALABRAS		*edición-sin-partir* *edit-no-break*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When preparing text for use by another program, you might have to make
paragraphs without a line break.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando prepara el texto para su uso con otro programa, puede que tenga que
crear los párrafos sin salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A disadvantage of using 'nowrap' is that you
can't see the whole sentence you are working on.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una desventaja de usar 'nowrap' es
que no puede ver la oración completa sobre la que trabaja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When 'wrap' is on, words are
broken halfway, which makes them hard to read.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si 'wrap' está,
activada, las palabras se dividen por la mitad, dificultando la lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A good solution for editing this kind of paragraph is setting the
'linebreak' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una buena solución para editar este tipo de párrafos es definir la opción
'linebreak'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim then breaks lines at an appropriate place when
displaying the line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim dividirá las líneas en los puntos apropiados al mostrar
la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The text in the file remains unchanged.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto en el archivo no se modifica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without 'linebreak' text might look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin 'linebreak', el texto presentará este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------+
	|letter generation program for a b|
	|ank.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------+
	|letter generation program for a b|
	|ank.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They wanted to send out a s|
	|pecial, personalized letter to th|
	|eir richest 1000 customers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>They wanted to send out a s|
	|pecial, personalized letter to th|
	|eir richest 1000 customers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfo|
	|rtunately for the programmer, he |
	+---------------------------------+
After: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Unfo|
	|rtunately for the programmer, he |
	+---------------------------------+
Después: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set linebreak</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set linebreak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+---------------------------------+
	|letter generation program for a  |
	|bank.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+---------------------------------+
	|letter generation program for a  |
	|bank.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They wanted to send out a |
	|special, personalized letter to  |
	|their richest 1000 customers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>They wanted to send out a |
	|special, personalized letter to  |
	|their richest 1000 customers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	|Unfortunately for the programmer,|
	+---------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	|Unfortunately for the programmer,|
	+---------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Related options: 'breakat' specifies the characters where a break can be inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Opciones relacionadas: 'breakat' especifica los caracteres donde insertar el salto de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'showbreak' specifies a string to show at the start of broken line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'showbreak' especifica una cadena a mostrar al principio de una línea dividida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set 'textwidth' to zero to avoid a paragraph to be split.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Defina 'textwitdh' como cero para evitar dividir un párrafo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "j" and "k" commands move to the next and previous lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes «j» y «k» desplazan el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used on
a long line, this means moving a lot of screen lines at once.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto desplaza varias líneas en la
pantalla en caso de usarlo sobre una larga línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move only one screen line, use the "gj" and "gk" commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desplazarse sólo una línea en la pantalla, use las órdenes «gj» y «gk».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a line
doesn't wrap they do the same as "j" and "k".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas órdenes hacen lo mismo que «j» y «k» si la línea no está justificada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the line does wrap, they
move to a character displayed one line below or above.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De activar 'wrap', se desplazan a un carácter visible en una línea inferior
o superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might like to use these mappings, which bind these movement commands to
the cursor keys: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desee usar estas macros, que relacionan estas órdenes de
desplazamiento a las teclas de cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:map &lt;Up&gt; gk
	:map &lt;Down&gt; gj</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:map &lt;Up&gt; gk
	:map &lt;Down&gt; gj</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to import text into a program like MS-Word, each paragraph should be a single line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea importar texto desde un programa como MS-Word, cada párrafo debería ser una sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your paragraphs are currently separated with empty lines, this is how you turn each paragraph into a single line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De existir una separación entre los párrafos en forma de de líneas vacías, debe realizar lo siguiente para convertir cada párrafo en una sola línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:g/./,/^$/join</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:g/./,/^$/join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That looks complicated.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Parece complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's break it up in pieces:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vamos a dividirlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:g/./		A ":global" command that finds all lines that contain
			at least one character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:g/./		Una orden «:global» que encuentra todas las cadenas
			que contienen al menos un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>,/^$/	A range, starting from the current line (the non-empty
			line) until an empty line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>,/^$/	Un rango, que empieza en la línea actual (no vacía),
			y acaba en una línea vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>join	The ":join" command joins the range of lines together
			into one line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>join	La orden «:join» (unir) une el rango de líneas en una
			sola línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	|A letter generation program	   |
	|for a bank.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	|A letter generation program	   |
	|for a bank.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They wanted to	   |
	|send out a special,		   |
	|personalized letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>They wanted to	   |
	|send out a special,		   |
	|personalized letter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	|				   |
	|To their richest 1000		   |
	|customers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	|				   |
	|To their richest 1000		   |
	|customers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>+----------------------------------+
	|A letter generation program for a |
	|bank.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>+----------------------------------+
	|A letter generation program for a |
	|bank.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They wanted to send out a s|
	|pecial, personalized letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>They wanted to send out a s|
	|pecial, personalized letter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	|To their richest 1000 customers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	|To their richest 1000 customers.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	|Unfortunately for the programmer, |
	+----------------------------------+</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	|Unfortunately for the programmer, |
	+----------------------------------+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that this doesn't work when the separating line is blank but not empty;
when it contains spaces and/or tabs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga en cuenta que esto no funciona si la línea de separación está en blanco,
pero no vacía; cuando contiene espacios y/o tabulados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command does work with blank lines:
&gt;
	:g/\S/,/^\s*$/join</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden funciona
con líneas en blanco:
&gt;
	:g/\S/,/^\s*$/join</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*25.5*	Editing tables</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*25.5*	Editar tablas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nice table	  test 1	test 2	    test 3 ~
	input A		  0.534 ~
	input B		  0.913 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tabla ordenada	  test 1	test 2	    test 3 ~
	entrada A	  0.534 ~
	entrada B	  0.913 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to enter numbers in the third column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita introducir números en la tercera columna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could move to the second
line, use "A", enter a lot of spaces and type the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Podría desplazarse a la
segunda línea, usar «A», introducir espacios y escribir el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this kind of editing there is a special option: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una orden especial para este tipo de edición: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>set virtualedit=all</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>set virtualedit=all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/test 3</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>/test 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press "j" and you are right where you can enter the value for "input A".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse ahora «j» y estará dónde puede introducir el valor para «input A».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing "0.693" results in:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear «0.693» da como resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nice table	  test 1     test 2	 test 3 ~
	input A		  0.534			 0.693 ~
	input B		  0.913 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tabla ordenada	  test 1     test 2	 test 3 ~
	entrada A	  0.534			 0.693 ~
	entrada B	  0.913 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has automatically filled the gap in front of the new text for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim a rellenado automáticamente el espacio en frente del texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, to enter the next field in this column use "Bj".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, para introducir el siguiente campo de esta columna use «Bj».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"B" moves back to the start of a white space separated word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«B» le devuelve al inicio de una palabra separada por un espacio en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then "j" moves to the place where the next field can be entered.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«j» le desplaza al lugar dónde puede introducir el siguiente campo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	You can move the cursor anywhere in the display, also beyond the end
	of a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Puede mover el cursor a cualquier lugar de la pantalla, también más
	allá del final de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But Vim will not insert spaces there, until you insert a
	character in that position.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero Vim no insertará aquí espacios hasta
	que inserte un carácter en esa posición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You want to add a column, which should be a copy of the third column and
placed before the "test 1" column.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea añadir una columna, que debe ser la copia de la tercera columna
y deberá situarse antes de la columna «test 1».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do this in seven steps:
1.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Haga estos 7 pasos:
1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to the left upper corner of this column, e.g., with
    "/test 3".
2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a la esquina superior izquierda de esta columna, p. ej.,
    con «/test 3».
2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Press CTRL-V to start blockwise Visual mode.
3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse CTRL-V para empezar el modo de bloque visual.
3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor down two lines with "2j".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor dos líneas hacia abajo con «2j».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are now in "virtual space":
    the "input B" line of the "test 3" column.
4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora se encuentra en
    espacio virtual («virtual space»): la línea «entrada B» de la columna
    «test 3».
4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor right, to include the whole column in the selection, plus
    the space that you want between the columns.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a la derecha para incluir toda la columna en la selección
    además del espacio que desea entre las columnas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"9l" should do it.
5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«9l» hará esto.
5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yank the selected rectangle with "y".
6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Copie el rectángulo seleccionado con «y» (yank).
6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to "test 1", where the new column must be placed.
7.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Mueva el cursor a «test 1», donde se debería situar la nueva columna.
7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Press "P".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse «P».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>nice table	  test 3    test 1     test 2	   test 3 ~
	input A		  0.693     0.534		   0.693 ~
	input B			    0.913 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tabla ordenada	  test 3    test 1     test 2	   test 3 ~
	entrada A	  0.693     0.534		   0.693 ~
	entrada B		    0.913 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set virtualedit=</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set virtualedit=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The disadvantage of using 'virtualedit' is that it "feels" different.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La desventaja de usar 'virtualedit' es que parece distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
can't recognize tabs or spaces beyond the end of line when moving the cursor
around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede
reconocer tabulados o espacios más allá del final de línea si desplaza el
cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another method can be used: Virtual Replace mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar otro método: Modo Virtual de Reemplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have a line in a table that contains both tabs and other
characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene una línea en una tabla que contienen tabulados y otros
caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "rx" on the first tab:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «rx» en el primer tabulado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inp	0.693   0.534	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inp	0.693   0.534	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	   rx  |
	       V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	   rx  |
	       V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inpx0.693   0.534	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inpx0.693   0.534	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The layout is messed up.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>EL diseño está desordenado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid that, use the "gr" command:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use la orden «gr» para evitarlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	  grx  |
	       V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	  grx  |
	       V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inpx	0.693   0.534	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inpx	0.693   0.534	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens is that the "gr" command makes sure the new character takes the
right amount of screen space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lo que ocurre es que la orden «gr» se asegura que el nuevo carácter tomará
la cantidad de espacio de pantalla correcta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra spaces or tabs are inserted to fill the
gap.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los espacios y tabulados
adicionales se insertarán en el hueco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus what actually happens is that a tab is replaced by "x" and then
blanks added to make the text after it keep its place.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, lo que realmente ocurre es
que el tabulado se reemplaza por «x», y después se añaden espacios en blanco
para que el texto a continuación siga en el mismo sitio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case a
tab is inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso se
inserta un tabulado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to replace more than one character, you use the "R" command
to go to Replace mode (see |04.9|).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando necesita reemplazar más de un carácter, use la orden «R» para pasar
al modo Reemplazar (consulte |04.9|).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This messes up the layout and replaces
the wrong characters:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto desordena la presentación y
reemplaza los caracteres erróneos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inp	0	0.534	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inp	0	0.534	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	 R0.786 |
		V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	 R0.786 |
		V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inp	0.78634	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inp	0.78634	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "gR" command uses Virtual Replace mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «gR» usa el modo Virtual Reemplazar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This preserves the layout:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto respeta el diseño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|
	gR0.786 |
		V</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|
	gR0.786 |
		V</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>inp	0.786	0.534	0.693 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>inp	0.786	0.534	0.693 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_09.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_09.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the GUI</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uso de la interfaz gráfica (GUI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim works in an ordinary terminal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim funciona en una terminal normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GVim can do the same things and a few more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>GVim puede hacer las mismas cosas y algunas más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The GUI offers menus, a toolbar, scrollbars and other items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La interfaz gráfica ofrece menús, una barra de menú, barras de desplazamiento y otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter is about these extra things that the GUI offers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo trata de las funcionalidades adicionales que la interfaz gráfica ofrece.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|09.1|	Parts of the GUI
|09.2|	Using the mouse
|09.3|	The clipboard
|09.4|	Select mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|09.1|	Partes de la interfaz gráfica
|09.2|	Uso del ratón
|09.3|	El portapapeles
|09.4|	Modo Seleccionar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_10.txt|  Making big changes
 Previous chapter: |usr_08.txt|  Splitting windows
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_10.esx|  Realizar grandes cambios
  Capítulo anterior: |usr_08.esx|  Dividir en ventanas
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.1*	Parts of the GUI</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.1*	Partes de la interfaz gráfica (GUI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might have an icon on your desktop that starts gVim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que tenga un icono en su escritorio que arranca gVim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, one of these commands should do it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso contrario, una de estas órdenes lo hará: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim file.txt
	vim -g file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim archivo.txt
	vim -g archivo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this doesn't work you don't have a version of Vim with GUI support.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si esto no funciona es que no tiene la versión de Vim con soporte para GUI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
will have to install one first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tendrá que instalar una primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will open a window and display "file.txt" in it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá una ventana y mostrará «archivo.txt».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What the window looks
like depends on the version of Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El aspecto de la
ventana dependerá de la versión de Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It should resemble the following picture
(for as far as this can be shown in ASCII!).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se debería parecer a la siguiente
figura (¡tanto como se pueda parecer con texto ASCII!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The largest space is occupied by the file text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El espacio más grande está ocupado por el archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows the file in the same way as in a terminal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto muestra el archivo de una manera similar a una terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With some different colors and another font perhaps.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con algunas diferencias de tipo de letra y color, quizá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>-	The file cannot be modified (e.g., a help file)
	+	The file contains changes
	=	The file is read-only
	=+	The file is read-only, contains changes anyway</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>-	El archivo no se puede modificar (por ej. la ayuda)
	+	El archivo contiene cambios
	=	El archivo es de sólo lectura
	=+	El archivo es de sólo lectura pero contiene cambios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You know how menus work, right?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya sabe como funcionan los menús, ¿no?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim has the usual items, plus a few more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim tiene los elementos habituales, además de otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Browse them to get an idea of what you can use them for.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Explórelos para tener una idea de cómo podría usarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A relevant submenu is Edit/Global Settings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un submenú relevante es «Editar/Opciones globlales».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will find these entries:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Encontrará los siguientes elementos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This contains icons for the most often used actions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este contiene los iconos para las acciones más empleadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully the icons are self-explanatory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La intención es que los iconos se expliquen a sí mismos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are tooltips to get an extra hint (move the mouse pointer to the icon without clicking and don't move it for a second).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay globos de ayuda que le aconsejan (pon el puntero sobre un botón y no lo muevas durante un segundo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "Edit/Global Settings/Toggle Toolbar" menu item can be used to make the toolbar disappear.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción «Editar/Opciones globales/Ocultar/Mostrar barra de herramientas» se puede emplear para hacer que la barra de herramientas desaparezca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you never want a toolbar, use this command in your vimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no desea tener una barra de herramientas en ningún momento, escriba esto en su «vimrc»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set guioptions-=T</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set guioptions-=T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This removes the 'T' flag from the 'guioptions' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto elimina la opción 'T' de la opción 'guioptions'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other parts of the GUI can also be enabled or disabled with this option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otras partes de la interfaz gráfica se pueden también activar o desactivar del mismo modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the help for it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte la ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default there is one scrollbar on the right.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión sólo hay una barra de desplazamiento en la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does the obvious thing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hace lo que
se espera de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you split the window, each window will get its own scrollbar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cada ventana tendrá su barra de desplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make a horizontal scrollbar appear with the menu item
Edit/Global Settings/Toggle Bottom Scrollbar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer que una barra horizontal aparezca con la opción «Editar/
Opciones globales/Ocultar/Mostrar barra de desplazamiento inferior».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful in diff mode, or
when the 'wrap' option has been reset (more about that later).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil en el modo diff, o cuando la opción 'wrap' está desactivada
(eso lo veremos más adelante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When there are vertically split windows, only the windows on the right side
will have a scrollbar.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando hay ventanas divididas verticalmente, sólo las de la derecha tendrán
barra de desplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when you move the cursor to a window on the
left, it will be this one the that scrollbar controls.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, si mueve el cursor a una ventana en la
izquierda, será esta la que la barra controle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This takes a bit of
time to get used to.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Lleva cierto tiempo
acostumbrarse a esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you work with vertically split windows, consider adding a scrollbar on
the left.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando trabaje con ventanas divididas verticalmente, considere la
posibilidad de añadir barras en la izquierda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done with a menu item, or with the 'guioptions' option:
&gt;
	:set guioptions+=l</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pruebe con esta opción: 
&gt;
		:set guioptions+=1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.2*	Using the mouse</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.2*	Uso del ratón</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Standards are wonderful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los estándares son maravillosos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Microsoft Windows, you can use the mouse to
select text in a standard manner.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Microsoft Windows, puede usar el ratón
para seleccionar texto de una forma estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The X Window system also has a standard
system for using the mouse.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El sistema de ventanas X
Window System también tiene un estándar para el uso del ratón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, these two standards are not the
same.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
desgracia, estos dos estándares no son compatibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, you can customize Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Afortunadamente, puede personalizarlo en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can make the behavior of the mouse
work like an X Window system mouse or a Microsoft Windows mouse.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede hacer que el
comportamiento del ratón sea el mismo que bajo X o el de Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following
command makes the mouse behave like an X Window mouse: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
siguiente orden hace que el ratón se comporte como bajo X: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:behave xterm</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:behave xterm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:behave mswin</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:behave mswin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behavior of the mouse on UNIX systems is xterm.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El comportamiento predeterminado de un ratón en los sistemas UNIX es xterm.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default behavior on a Microsoft Windows system is selected during the installation process.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El comportamiento predeterminado en un sistema Windows se selecciona durante la instalación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details about what the two behaviors are, see |:behave|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más detalles sobre estos comportamientos, consulte |:behave|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here follows a summary.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene un pequeño resumen:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Left mouse click		position the cursor
Left mouse drag			select text in Visual mode
Middle mouse click		paste text from the clipboard
Right mouse click		extend the selected text until the mouse
				pointer</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Click botón izquierdo		posicionar el cursor
Arrastrar botón izquierdo	seleccionar texto en modo Visual
Click botón central		pegar texto desde el portapapeles
Click botón derecho		extender el texto seleccionado hasta el
				puntero del ratón</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Left mouse click		position the cursor
Left mouse drag			select text in Select mode (see |09.4|)
Left mouse click, with Shift	extend the selected text until the mouse
				pointer
Middle mouse click		paste text from the clipboard
Right mouse click		display a pop-up menu</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Click botón izquierdo		posicionar el cursor
Arrastrar botón izquierdo	seleccionar texto en modo Seleccionar (|09.4|)
Click botón izquierdo, con May. extender el texto seleccionado hasta el
				puntero del ratón
Click botón central		pegar texto desde el portapapeles
Click botón derecho		mostrar un menú pop-up</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mouse can be further tuned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede configurar el ratón con más detalle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out these options if you want to change the way how the mouse works:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte estas opciones si desea cambiar el funcionamiento del ratón:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>'mouse'			in which mode the mouse is used by Vim
	'mousemodel'		what effect a mouse click has
	'mousetime'		time between clicks for a double-click
	'mousehide'		hide the mouse while typing
	'selectmode'		whether the mouse starts Visual or Select mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'mouse'			en qué modo Vim usa el ratón
	'mousemodel'		qué efectos tiene pulsar con el ratón
	'mousetime'		tiempo entre dos pulsacionespara un doble
				click
	'mousehide'		esconde el ratón mientras teclea
	'selectmode'		si el ratón comienza el modo Visual o
				Seleccionar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.3*	The clipboard</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.3*	El portapapeles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In section |04.7| the basic use of the clipboard was explained.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la sección |04.7| se explica el uso básico del portapapeles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one essential thing to explain about X-windows: There are actually two places to exchange text between programs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay algo esencial que debe ser explicado sobre las X-windows: Hay dos lugares para intercambiar texto entre programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MS-Windows doesn't have this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>MS-Windows sólo tiene uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In X-Windows there is the "current selection".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En X-Windows hay una «selección actual».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the text that is
currently highlighted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es el texto que está
actualmente marcado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim this is the Visual area (this assumes you are
using the default option settings).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim esto es el área Visual (suponiendo que usa las
opciones predeterminadas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can paste this selection in another
application without any further action.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede pegar esta selección en otra aplicación sin
ninguna acción posterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, in this text select a few words with the mouse.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, en este texto seleccione unas cuantas palabras con el
ratón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will
switch to Visual mode and highlight the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim pasará al modo Visual y resaltará el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now start another gVim, without
a file name argument, so that it displays an empty window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora inicie otro
gVim, sin un nombre de archivo, de forma que muestre una ventana vacía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click the middle
mouse button.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse el botón central del ratón.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The selected text will be inserted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto seleccionado se insertará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "current selection" will only remain valid until some other text is selected.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «selección actual» sólo será válida hasta que seleccione otro texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After doing the paste in the other gVim, now select some characters in that window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tras pegar el texto en otro gVim, seleccione ahora algunos caracteres en esa ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice that the words that were previously selected in the other gVim window are displayed differently.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se dará cuenta de que las palabras que estaban previamente seleccionadas en otra ventana gVim se muestran de otro modo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that it no longer is the current selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto significa que ya no están en la «selección actual».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This use of both the "current selection" and the "real clipboard" might sound a bit confusing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto de usar simultáneamente la «selección actual» y el «verdadero portapapeles» puede sonar un poco confuso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it is very useful.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero es muy útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's show this with an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Veámoslo con un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use one gVim with a text file and perform these actions:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Abra un gVim con un archivo de texto y haga lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't like using the mouse, you can access the current selection and
the real clipboard with two registers.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no le gusta usar el ratón, puede acceder a la selección actual y al
verdadero portapapeles con dos registros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "* register is for the current
selection.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El registro "* es para la
selección actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make text become the current selection, use Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que el texto se convierta en selección actual, use el modo
Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example,
to select a whole line just press "V".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para seleccionar una línea completa use «V».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To insert the current selection before the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para insertar la selección actual antes del cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"*P</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"*P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the uppercase "P".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que es una «P» mayúscula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lowercase "p" puts the text after the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «p» minúscula la pone tras el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "+ register is used for the real clipboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El registro "+ se usa para el verdadero portapapeles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to copy the text from the cursor position until the end of the line to the clipboard: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para copiar el texto desde la posición del cursor hasta el final de línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"+y$</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"+y$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, "y" is yank, which is Vim's copy command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Recuerde, «y» es copiar («yank»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To insert the contents of the real clipboard before the cursor: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para insertar los contenidos del verdadero portapapeles antes del cursor: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"+P</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"+P</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*09.4*	Select mode</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*09.4*	Modo Seleccionar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And now something that is used more often on MS-Windows than on X-Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora algo que se emplea más habitualmente en MS-Windows que en X-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But both can do it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aún así, ambos pueden hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You already know about Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya conoce el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select mode is like Visual mode, because it is also used to select text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Seleccionar es como el modo Visual, también empleado para la selección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But there is an obvious difference: When typing text, the selected text is deleted and the typed text replaces it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero hay una diferencia básica: Cuando escriba texto, el texto seleccionado se elimina y el texto introducido lo sustituye.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set selectmode+=mouse</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set selectmode+=mouse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now use the mouse to select some text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A continuación, use el ratón para seleccionar algún texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is highlighted like in Visual mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se resaltará como con el modo Visual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now press a letter.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse ahora un carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The selected text is deleted, and the single letter replaces it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El texto seleccionado se eliminará, y ese carácter lo reemplazará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are in Insert mode now, thus you can continue typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Entrará en modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_31.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_31.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2007 May 08</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 8/6/2007</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exploiting the GUI</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sacar partido a la interfaz gráfica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim works well in a terminal, but the GUI has a few extra items.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim funciona bien en una terminal, pero la interfaz gráfica de usuario tiene algunos elementos adicionales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A file browser can be used for commands that use a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un explorador de archivos para las órdenes que usan un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dialog to make a choice between alternatives.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una ventana de diálogo para hacer una elección entre alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use keyboard shortcuts to access menu items quickly.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar accesos directos de teclado para acceder rápidamente a los elementos en los menús.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|31.1|	The file browser
|31.2|	Confirmation
|31.3|	Menu shortcuts
|31.4|	Vim window position and size
|31.5|	Various</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|31.1|	El explorador de archivos
|31.2|	Confirmación
|31.3|	Atajos de teclado para menús
|31.4|	Posición y tamaño de la ventana de Vim
|31.5|	Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_32.txt|  The undo tree
 Previous chapter: |usr_30.txt|  Editing programs
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_32.esx|  El árbol de deshacer
     Capítulo anterior: |usr_30.esx|  Editar programas
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.1*	The file browser</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.1*	El explorador de archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the File/Open... menu you get a file browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al usar el menú «Archivo/Abrir»... obtiene un explorador de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This makes it easier
to find the file you want to edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto facilita ubicar el archivo que desea editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But what if you want to split a window to
edit another file?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¿Pero y si desea
dividir una ventana para editar otro archivo?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no menu entry for this.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No hay una entrada en el menú
para esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could first use
Window/Split and then File/Open..., but that's more work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar primero «Ventana/Dividir» y luego «Archivo/Abrir»...,
pero eso es más trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since you are typing most commands in Vim, opening the file browser with a
typed command is possible as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que está escribiendo la mayoría de las órdenes en Vim, abrir el
explorador de archivos con una orden escrita también es posible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the split command use the file
browser, prepend "browse": &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer
que la orden de división use el explorador de archivos, anteponga «browse»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:browse split</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:browse split</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:browse split /etc</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:browse split /etc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The ":browse" command can be prepended to just about any command that opens a
file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:browse» puede ser antepuesta prácticamente a cualquier orden que
abra un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no directory is specified, Vim will decide where to start the file
browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no se especifica un directorio, Vim será quien determine en qué
directorio iniciar el explorador de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default it uses the same directory as the last time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>De manera predeterminada se usa
el mismo directorio usado la vez anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus when
you used ":browse split" and selected a file in "/usr/local/share", the next
time you use a ":browse" it will start in "/usr/local/share" again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, si se usó «:browse split» y
se seleccionó un archivo en «/usr/local/share», la próxima vez que use
«:browse» se empezará desde «/usr/local/share» de nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be changed with the 'browsedir' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se puede ajustar mediante la opción 'browsedir'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can have one of three
values:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dicha opción acepta
uno de los tres siguientes valores:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>last		Use the last directory browsed (default)
	buffer		Use the same directory as the current buffer
	current		use the current directory</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>last		Usar el último directorio visitado (predeterminado)
	buffer		Usar el mismo directorio del búfer actual
	current		Usar el directorio actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set browsedir=buffer
	:browse edit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set browsedir=buffer
	:browse edit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will start the browser in "/usr/local/share".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ejecutará el explorador de archivos desde «/usr/local/share».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otro lado: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set browsedir=current
	:browse edit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set browsedir=current
	:browse edit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	To avoid using the mouse, most file browsers offer using key presses
	to navigate.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Para evitar el uso del ratón, muchos de los exploradores de archivos
	ofrecen navegación mediante teclas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since this is different for every system, it is not
	explained here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que esto difiere de sistema a
	sistema, no se explica aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim uses a standard browser when possible, your
	system documentation should contain an explanation on the keyboard
	shortcuts somewhere.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim usa un explorador estándar cuando es
	posible; la documentación del sistema que use debería contener
	una sección acerca de los accesos directos de teclado disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are not using the GUI version, you could use the file explorer window to select files like in a file browser.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no se está usando la versión gráfica de Vim, es posible usar el explorador de archivos para seleccionar archivos de la forma habitual con un explorador de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, this doesn't work for the ":browse" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, el explorador no funciona con la orden «:browse».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See |netrw-browse|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Véase |netrw-browse|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.2*	Confirmation</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.2*	Confirmación</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim protects you from accidentally overwriting a file and other ways to lose
changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le protege de sobreescribir accidentalmente un archivo, y de otras formas
de perder los cambios realizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do something that might be a bad thing to do, Vim produces an
error message and suggests appending ! if you really want to do it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si hace algo que puede ser peligroso,
Vim muestra un mensaje de error y sugiere añadir ! si el usuario está
seguro de querer hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid retyping the command with the !, you can make Vim give you a
dialog.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar teclear de nuevo la orden con el !, puede hacer que Vim le
ofrezca un diálogo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then press "OK" or "Cancel" to tell Vim what you want.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así, podrá pulsar «OK» o «Cancelar» para
indicarle a Vim qué desea hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you are editing a file and made changes to it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, está editando un archivo y ya hizo algunos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You start
editing another file with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede editar otro archivo con: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:confirm edit foo.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:confirm edit foo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now make your choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y ahora puede decidir qué hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do want to save the changes, select "YES".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea conservar los cambios, escoja «SÍ».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to lose the changes for ever: "NO".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si quiere descartar permanentemente los cambios hechos: «NO».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you forgot what you were doing and want to check what really changed use "CANCEL".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si olvidó lo que estaba haciendo y quiere revisar cuáles fueron los cambios hechos, use «CANCELAR».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will be back in the same file, with the changes still there.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estará de nuevo en el mismo archivo, y los cambios aún estarán allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like ":browse", the ":confirm" command can be prepended to most commands that edit another file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tal como «:browse», la orden «:confirm» se puede anteponer a la mayoría de las órdenes que editan un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They can also be combined: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas órdenes también se pueden combinar: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:confirm browse edit</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:confirm browse edit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will produce a dialog when the current buffer was changed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto mostrará un diálogo cuando el búfer actual contiene cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then it will pop up a file browser to select the file to edit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Luego se mostrará un explorador de archivos para seleccionar el archivo a editar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	In the dialog you can use the keyboard to select the choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Es posible usar el teclado para seleccionar la opción deseada en
	el diálogo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typically the &lt;Tab&gt; key and the cursor keys change the choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Generalmente, la tecla &lt;Tab&gt; y las teclas de cursor
	cambian la opción seleccionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pressing &lt;Enter&gt; selects the choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar &lt;Enter&gt; escoge la opción
	definida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This depends on the system
	though.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sin embargo, esto varía de sistema a sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you are not using the GUI, the ":confirm" command works as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando no se usa la GUI, la orden «:confirm» sigue funcionando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of popping up a dialog, Vim will print the message at the bottom of the Vim window and ask you to press a key to make a choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En vez de crear una ventana de diálogo, el mensaje se mostrará en la parte de abajo de la ventana de Vim, y se le solicitará pulsar una tecla para hacer una elección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:confirm edit main.c
&lt;	Save changes to "Untitled"?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:confirm edit main.c
&lt;	Guardar los cambios en "Sin título"?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>~
	[Y]es, (N)o, (C)ancel:  ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>~
	[Y]es, (N)o, (C)ancelar:  ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now press the single key for the choice.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede realizar su selección simplemente pulsando una tecla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to press &lt;Enter&gt;, unlike other typing on the command line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En particular, no tiene que pulsar &lt;Enter&gt;, a diferencia del tecleo normal en la línea de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.3*	Menu shortcuts</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.3*	Atajos de teclado para menús</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a conflict between using the &lt;Alt&gt; key to select menu items, and
using &lt;Alt&gt; key combinations for mappings.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay un conflicto con el uso de la tecla &lt;Alt&gt; para seleccionar elementos de
menús, y el uso de la tecla &lt;Alt&gt; en combinaciones de teclas para macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'winaltkeys' option tells Vim
what it should do with the &lt;Alt&gt; key.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La
opción 'winaltkeys' le indica a Vim qué hacer con la tecla &lt;Alt&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value "menu" is the smart choice: If the key combination is a
menu shortcut it can't be mapped.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor predeterminado «menu» es la selección inteligente: si la
combinación de teclas es un atajo de teclado para el menú, no se la puede
usar en una macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All other keys are available for mapping.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas las otras teclas están disponibles para crear macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value "no" doesn't use any &lt;Alt&gt; keys for the menus.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor «no» hace que no se use ninguna tecla &lt;Alt&gt; para los menús.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you must use
the mouse for the menus, and all &lt;Alt&gt; keys can be mapped.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
esto, es necesario usar el ratón para acceder a los menús, y todas las teclas
&lt;Alt&gt; se pueden incluir en macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The value "yes" means that Vim will use any &lt;Alt&gt; keys for the menus.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El valor «yes» implica que Vim usará cualquier tecla &lt;Alt&gt; para los menús.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some
&lt;Alt&gt; key combinations may also do other things than selecting a menu.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas combinaciones de teclas con &lt;Alt&gt; pueden hacer cosas distintas a
seleccionar un menú.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.4*	Vim window position and size</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.4*	Posición y tamaño de la ventana de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:winpos</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:winpos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will only work in the GUI.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto sólo funcionará en la interfaz gráfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output may look like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida será similar a lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Window position: X 272, Y 103 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Posición de la ventana: X 272, Y 103 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The position is given in screen pixels.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La posición está dada en píxeles de la pantalla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can use the numbers to move Vim somewhere else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar estos números para mover la ventana de Vim a algún otro sitio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to move it to the left a hundred pixels: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para moverla a la izquierda cien píxeles: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:winpos 172 103
&lt;
	Note:
	There may be a small offset between the reported position and where
	the window moves.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:winpos 172 103
&lt;
	Nota:
	Puede haber un pequeño desfase entre la posición señalada y el sitio
	al que se mueve la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is because of the border around the window.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es debido al borde de la ventana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is added by the window manager.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Éste es añadido por el administrador de ventanas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The size of the Vim window is computed in characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El tamaño de la ventana de Vim se calcula en caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus this depends on the size of the font being used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por este motivo el tamaño depende del tipo de letra usado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the current size with this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El tamaño actual puede consultarse con esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set lines columns</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set lines columns</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set lines=50
	:set columns=80</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set lines=50
	:set columns=80</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the size works in a terminal just like in the GUI.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consultar el tamaño funciona en una terminal de la misma manera que en la GUI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the size is not possible in most terminals.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En la mayoría de las terminales no es posible ajustar el tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim -geometry {width}x{height}+{x_offset}+{y_offset}</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim -geometry {ancho}x{alto}+{desplz_x}+{desplz_y}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{width} and {height} are in characters, {x_offset} and {y_offset} are in pixels.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{ancho} y {alto} están dados en caracteres, {desplz_x} y {desplz_y} están dados en píxeles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim -geometry 80x25+100+300</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim -geometry 80x25+100+300</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*31.5*	Various</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*31.5*	Varios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use gvim to edit an e-mail message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar gvim para editar mensajes de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your e-mail program you must
select gvim to be the editor for messages.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe seleccionar gvim como el
editor para sus mensajes en su programa de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you try that, you will
see that it doesn't work: The mail program thinks that editing is finished,
while gvim is still running!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al hacerlo, notará que
esto falla: el programa de correo cree que la edición del mensaje ha
terminado, ¡aún cuando gvim no se ha cerrado!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What happens is that gvim disconnects from the shell it was started in.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El motivo de este error es que gvim se desconecta de la consola en la que
se inició.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is fine when you start gvim in a terminal, so that you can do other work
in that terminal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto funciona bien cuando se inicia gvim desde una terminal,
para que se pueda hacer otras cosas en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But when you really want to wait for gvim to finish, you
must prevent it from disconnecting.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero cuando se necesita esperar
a que gvim termine, hay que evitar dicha desconexión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-f" argument does this: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-f» hace
precisamente eso: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim -f file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim -f file.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-f" stands for foreground.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«-f» significa foreground (primer plano).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Vim will block the shell it was started in until you finish editing and exit.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, Vim bloqueará la consola en la que se inició hasta que termine la edición y cierre el editor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix it's possible to first start Vim in a terminal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix es posible iniciar Vim en una terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's useful if you do various tasks in the same shell.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil si se están realizando varias tareas en una misma consola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are editing a file and decide you want to use the GUI after all, you can start it with: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está editando un archivo y decide que después de todo quiere usar la GUI, puede lanzarla con la orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:gui</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:gui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will open the GUI window and no longer use the terminal.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim abrirá la ventana de la GUI y no seguirá usando la terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can continue using the terminal for something else.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede continuar usando la terminal para lo que necesite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "-f" argument is used here to run the GUI in the foreground.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El argumento «-f» se usa aquí para ejecutar la GUI en primer plano.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use ":gui -f".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar «:gui -f».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When gvim starts, it reads the gvimrc file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando gvim inicia, lee el archivo gvimrc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's similar to the vimrc file used when starting Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es similar al archivo vimrc que se
usa al iniciar Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gvimrc file can be used for settings and commands that are only to be used when the GUI is going to be started.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo gvimrc puede usarse para fijar opciones de
configuración y órdenes que sólo deban usarse cuando se inicie la GUI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you can set the 'lines' option to set a different window size: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, puede definir la opción 'lines' para obtener un tamaño de ventana
diferente: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set lines=55</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set lines=55</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't want to do this in a terminal, since its size is fixed (except for
an xterm that supports resizing).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es conveniente hacer esto en una terminal, debido a que su tamaño es fijo
(excepto por un xterm que soporte redimensionado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gvimrc file is searched for in the same locations as the vimrc file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo gvimrc se busca en las mismas ubicaciones que el archivo vimrc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally its name is "~/.gvimrc" for Unix and "$VIM/_gvimrc" for MS-Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Habitualmente, su nombre es «~/.gvimrc» en sistemas Unix/Linux y
«$VIM/_gvimrc» en MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The $MYGVIMRC environment variable is set to it, thus you can use this command
to edit the file, if you have one: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La ruta de este archivo se almacena en la 
variable de entorno $MYGVIMRC, por lo que puede usar la siguiente orden para
editar ese archivo, si existe: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit $MYGVIMRC
&lt;
   If for some reason you don't want to use the normal gvimrc file, you can
specify another one with the "-U" argument: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit $MYGVIMRC
&lt;
Si por algún motivo no desea usar el archivo gvimrc normal, puede especificar
otro mediante el argumento «-U»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim -U thisrc ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim -U otrorc ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That allows starting gvim for different kinds of editing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto le permite iniciar gvim para distintas formas de edición.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could set
another font size, for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede,
por ejemplo, definir otro tamaño para el tipo de letra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To completely skip reading a gvimrc file: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar la ejecución del archivo gvimrc use: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gvim -U NONE ...</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>gvim -U NONE ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_23.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_23.esx*	Para Vim version 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Editing other files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Editar otros archivos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This chapter is about editing files that are not ordinary files.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este capítulo trata acerca de editar archivos que no son archivos ordinarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Vim you can edit files that are compressed or encrypted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con Vim, puede editar archivos comprimidos o cifrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some files need to be accessed over the internet.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita acceder a algunos archivos a través de Internet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With some restrictions, binary files can be edited as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con alguna restricción, también puede editar archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|23.1|	DOS, Mac and Unix files
|23.2|	Files on the internet
|23.3|	Encryption
|23.4|	Binary files
|23.5|	Compressed files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|23.1|	Archivos de DOS, Mac y Unix
|23.2|	Archivos en Internet
|23.3|	Cifrado
|23.4|	Archivos binarios
|23.5|	Archivos comprimidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_24.txt|  Inserting quickly
 Previous chapter: |usr_22.txt|  Finding the file to edit
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente : |usr_24.esx|  Insertar con rapidez
  Capítulo anterior: |usr_22.esx|  Encontrar el archivo a editar
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.1*	DOS, Mac and Unix files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.1*	Archivos de DOS, Mac y Unix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back in the early days, the old Teletype machines used two characters to
start a new line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Antiguamente, las viejas máquinas Teletype usaban dos caracteres para
iniciar una nueva línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One to move the carriage back to the first position
(carriage return, &lt;CR&gt;), another to move the paper up (line feed, &lt;LF&gt;).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uno desplazaba el transporte de vuelta a la
posición inicial («carriage return», &lt;CR&gt;), y el otro desplazaba la
la página hacia arriba («line feed», &lt;LF&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When computers came out, storage was expensive.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando aparecieron los ordenadores el almacenamiento era caro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some people decided that
they did not need two characters for end-of-line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunas
personas decidieron que no necesitaban dos caracteres para marcar el final
de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UNIX people decided
they could use &lt;Line Feed&gt; only for end-of-line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La gente de UNIX decidió usar sólo &lt;Line Feed&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Apple people
standardized on &lt;CR&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La gente de
Apple tomó &lt;CR&gt; como estándar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MS-DOS (and Microsoft Windows) folks decided to
keep the old &lt;CR&gt;&lt;LF&gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La gente de MS-DOS (y Microsoft Windows)
decidió seguir con el antiguo &lt;CR&gt;&lt;LF&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that if you try to move a file from one system to another, you
have line-break problems.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto supone que si intenta mover un archivo de un sistema a otro, tendrá
problemas con el retorno de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor automatically recognizes the
different file formats and handles things properly behind your back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El editor Vim detecta los diferentes
formatos de archivos automáticamente y gestiona las cosas adecuadamente
sin que usted lo note.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The option 'fileformats' contains the various formats that will be tried
when a new file is edited.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'fileformats' contiene los diversos formatos que se prueban
cuando edite un archivo nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following command, for example, tells Vim to
try UNIX format first and MS-DOS format second: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente orden, por ejemplo, le dice a
Vim que primero pruebe con el formato UNIX, y después con el formato MS-DOS: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set fileformats=unix,dos</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set fileformats=unix,dos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will notice the format in the message you get when editing a file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Reconocerá el formato por el mensaje que obtendrá al editar un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't see anything if you edit a native file format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No verá nada si edita un formato de archivo nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus editing a Unix file on Unix won't result in a remark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, editar un archivo UNIX en Unix no resultará en un aviso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But when you edit a dos file, Vim will notify you of this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero cuando edite un archivo DOS, Vim le notificará de ello:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"/tmp/test" [dos] 3L, 71C ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"/tmp/test" [dos] 3L, 71C ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a Mac file you would see "[mac]".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Verá «[mac]» si es un archivo MAC.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The detected file format is stored in the 'fileformat' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El formato de archivo detectado se guarda en la opción 'fileformat'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see
which format you have, execute the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para
ver qué formato tiene, ejecute la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set fileformat?</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set fileformat?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>unix		&lt;LF&gt;
	dos		&lt;CR&gt;&lt;LF&gt;
	mac		&lt;CR&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>unix		&lt;LF&gt;
	dos		&lt;CR&gt;&lt;LF&gt;
	mac		&lt;CR&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix, &lt;LF&gt; is used to break a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Unix, se emplea &lt;LF&gt; para marcar un retorno de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not unusual to have a &lt;CR&gt;
character halfway a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No es inusual
obtener un caracter &lt;CR&gt; en mitad de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Incidentally, this happens quite often in Vi (and
Vim) scripts.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Fortuitamente, esto ocurre
con regularidad en los scripts de Vi (y Vim).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the Macintosh, where &lt;CR&gt; is the line break character, it's possible to
have a &lt;LF&gt; character halfway a line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En un Macintosh, donde &lt;CR&gt; marca el retorno de línea, es posible obtener
un caracter &lt;LF&gt; en mitad de la línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result is that it's not possible to be 100% sure whether a file
containing both &lt;CR&gt; and &lt;LF&gt; characters is a Mac or a Unix file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado es que no es posible estar totalmente seguro de si es un
archivo MAC o UNIX al estar presentes ambos caracteres &lt;CR&gt; y &lt;LF&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore,
Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
for this type of file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ello, Vim asume que probablemente no editaría un archivo MAC bajo Unix, y no
revisará el tipo del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To check for this format anyway, add "mac" to
'fileformats': &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para revisar el formato de todas maneras,
añada «mac» a 'fileformats'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set fileformats+=mac</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set fileformats+=mac</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then Vim will take a guess at the file format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim intentará entonces dilucidar el formato del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Watch out for situations where Vim guesses wrong.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esté atento a las situaciones en las que Vim erra en su conclusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit ++ff=unix file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit ++ff=unix file.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "++" string is an item that tells Vim that an option name follows, which
overrules the default for this single command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La cadena «++» es un elemento que informa a Vim de que a continuación hay
un nombre de opción que invalida el valor predeterminado, sólo de esta
orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"++ff" is used for
'fileformat'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«++ff» se usa para 'fileformat'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could also use "++ff=mac" or "++ff=dos".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar «++ff=mac» o
«++ff=dos».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This doesn't work for any option, only "++ff" and "++enc" are currently
implemented.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no funciona con cualquier opción, y sólo está
implementado «++ff» y «++enc».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full names "++fileformat" and "++encoding" also work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los nombres completos, «++fileformat» y
«++encoding», también funcionan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the 'fileformat' option to convert from one file format to
another.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar la opción 'fileformat' para convertir el formato de un archivo a
otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose, for example, that you have an MS-DOS file named README.TXT
that you want to convert to UNIX format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga, por ejemplo, que tiene un archivo MS-DOS llamado README.TXT,
que desea convertir al formato UNIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start by editing the MS-DOS format
file: &gt;
	vim README.TXT</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Comience editando el archivo de formato
MS-DOS: &gt;
	vim README.TXT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will recognize this as a dos format file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim reconocerá esto como un archivo de formato MS-DOS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now change the file format to UNIX: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora cambie el formato a UNIX: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set fileformat=unix
	:write</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set fileformat=unix
	:write</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.2*	Files on the internet</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.2*	Archivos en Internet</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Someone sends you an e-mail message, which refers to a file by its URL.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que alguien le manda un correo electrónico que le remite a un archivo a través de su URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the information here: ~
		ftp://ftp.vim.org/pub/vim/README ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puedes encontrar la información aquí: ~
	ftp://ftp.vim.org/pub/vim/README ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could start a program to download the file, save it on your local disk and
then start Vim to edit it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede iniciar un programa para descargar el archivo, guardarlo en su disco
e iniciar Vim para editarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a much simpler way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe una manera mucho más simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the cursor to any character of the URL.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desplace el cursor hacia cualquier
carácter del URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después ejecute esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With a bit of luck, Vim will figure out which program to use for downloading
the file, download it and edit the copy.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con un poco de suerte, Vim escogerá qué programa usar para descargarse el
archivo, lo descargará y editará la copia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To open the file in a new window use
CTRL-W f.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para abrir el archivo en una
ventana nueva use «CTRL-W f».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If something goes wrong you will get an error message.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Se le informará de cualquier incidencia en el proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's possible that
the URL is wrong, you don't have permission to read it, the network connection
is down, etc.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible que
el URL sea erróneo, que no tiene los permisos necesarios para leerlo, que
la conexion a Internet se ha interrumpido, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unfortunately, it's hard to tell the cause of the error.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Desafortunadamente, es
difícil conocer la causa del error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You
might want to try the manual way of downloading the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que desee intentar una descarga
manual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing files over the internet works with the netrw plugin.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El acceso a archivos en Internet es posible gracias a la extensión netrw.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently URLs with these formats are recognized:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>A día de hoy se reconocen los siguientes formatos de URL:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ftp://		uses ftp
	rcp://		uses rcp
	scp://		uses scp
	http://		uses wget (reading only)</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>ftp://		usa ftp
	rcp://		usa rcp
	scp://		usa scp
	http://		usa wget (sólo lectura)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim doesn't do the communication itself, it relies on the mentioned programs to be available on your computer.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no realiza la conexión por si mismo, sino que depende de que los programas mencionados estén instalados en su ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On most Unix systems "ftp" and "rcp" will be present.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La mayoría de los sistemas Unix incluyen ftp y rcp.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"scp" and "wget" might need to be installed.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que tenga que instalar scp y wget.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim detects these URLs for each command that starts editing a new file, also with ":edit" and ":split", for example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim detecta estas URL para cada orden que inicia la edición de un archivo nuevo, también con «:edit» y «:split», por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write commands also work, except for http://.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las órdenes de escritura también funcionan, a excepción de «http://».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.3*	Encryption</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.3*	Cifrado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -x exam.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -x examen.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter encryption key: ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introduzca la clave de cifrado: ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carefully type the secret key now.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba ahora la clave con cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot see the characters you type, they will be replaced by stars.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No puede ver los caracteres que teclea, sino que serán reemplazados por estrellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid the situation that a typing mistake will cause trouble, Vim asks you to enter the key again:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar problemas debidos a un error mecanográfico, Vim le pedirá que introduzca la clave otra vez:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter same key again: ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Introduzca la misma clave de cifrado otra vez: ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now edit this file normally and put in all your secrets.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede editar este archivo con normalidad e introducir en él todos sus
secretos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you
finish editing the file and tell Vim to exit, the file is encrypted and
written.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando haya terminado de editar el archivo este se guarda y es
cifrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you edit the file with Vim, it will ask you to enter the same key
again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando edite el archivo con Vim, éste le pedirá que introduzca la
contraseña otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to use the "-x" argument.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No necesita emplear el argumento «-x».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use the normal
":edit" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede también
usar la orden «:edit».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim adds a magic string to the file by which it recognizes
that the file was encrypted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim añade una cadena mágica al archivo con el cual
reconoce que el archivo está cifrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you try to view this file using another program, all you get is garbage.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obtendrá sólo basura si intenta editar este archivo con otro programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, if you edit the file with Vim and enter the wrong key, you get garbage.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Así mismo, si lo abre con Vim pero introduce mal la contraseña también
obtendrá basura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim does not have a mechanism to check if the key is the right one (this makes
it much harder to break the key).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no posee un mecanismo para revisar si la clave es correcta (lo cual hace
más difícil descifrar la clave).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable the encryption of a file, set the 'key' option to an empty string:
&gt;
	:set key=</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desactivar el cifrado de un archivo, configure la opción 'key' con una
cadena vacía: &gt;
	:set key=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next time you write the file this will be done without encryption.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La siguiente vez que escriba el archivo, ésto se hará sin cifrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the 'key' option to enable encryption is not a good idea, because
the password appears in the clear.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Configurar la opción 'key' para activar el cifrado no es una buena idea
ya que la contraseña aparece sin ocultar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone shoulder-surfing can read your
password.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cualquier persona leyendo por
encima de su hombro puede leer su contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this problem, the ":X" command was created.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden «:X» se creó para evitar este problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It asks you for an
encryption key, just like the "-x" argument did: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Le pide una clave de
cifrado, al igual que hizo el argumento «-x»: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:X
	Enter encryption key: ******
	Enter same key again: ******</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:X
	Introduzca la clave de cifrado: ******
	Introduzca la misma clave de cifrado otra vez: ******</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption algorithm used by Vim is weak.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El algoritmo de cifrado de Vim es débil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is good enough to keep out
the casual prowler, but not good enough to keep out a cryptology expert with
lots of time on his hands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es suficiente para mantener alejado
al merodeador de turno, pero no lo es para mantener alejado a un experto
en cifrado con mucho tiempo libre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also you should be aware that the swap file is not
encrypted; so while you are editing, people with superuser privileges can read
the unencrypted text from this file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debe ser consciente de que el archivo de
de intercambio («swap») no está cifrado; por ello, al editar, personas con
privilegios de superusuario pueden leer el texto sin cifrar en este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to avoid letting people read your swap file is to avoid using one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una manera de evitar que le gente lea su archivo de intercambio es evitar
tener uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the -n argument is supplied on the command line, no swap file is used
(instead, Vim puts everything in memory).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si introduce el argumento «-n» en la linea de órdenes, no se usará ningún
archivo de intercambio (en lugar de ello, volcará todo en la memoria).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to edit the encrypted
file "file.txt" without a swap file use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, para editar el archivo cifrado «archivo.txt» si un archivo de
intercambio, use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -x -n file.txt</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -x -n archivo.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:setlocal noswapfile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:setlocal noswapfile</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since there is no swapfile, recovery will be impossible.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es imposible recuperar un archivo si no existe un archivo de intercambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save the file a bit more often to avoid the risk of losing your changes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Guarde los datos en el archivo más regularmente para evitar perder sus cambios .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the file is in memory, it is in plain text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un archivo está en texto simple mientras esté en memoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone with privilege can
look in the editor's memory and discover the contents of the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cualquiera con los
privilegios necesarios puede mirar en la memoria del editor y descubrir los
contenidos del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a viminfo file, be aware that the contents of text registers are
written out in the clear as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si está usando un archivo viminfo, sea consciente de que los contenidos del
registro del texto también se escriben de manera abierta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really want to secure the contents of a file, edit it only on a
portable computer not connected to a network, use good encryption tools, and
keep the computer locked up in a big safe when not in use.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si realmente desea proteger los contenidos de un archivo, edítelo sólo en
un ordenador portátil sin conexión a ninguna red, use buenas herramientas de
cifrado, y guarde el ordenador en una gran caja fuerte cuando no esté en uso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.4*	Binary files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.4*	Archivos binarios</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can edit binary files with Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede editar archivos binarios con Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim wasn't really made for this, thus
there are a few restrictions.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim no se creó para esta labor, y
por ello hay ciertas restricciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you can read a file, change a character and
write it back, with the result that only that one character was changed and
the file is identical otherwise.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero puede leer el archivo, cambiar un
carácter y escribir esto en el archivo, con el resultado de que sólo cambió
un carácter y que, en todo lo demás, el archivo es idéntico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make sure that Vim does not use its clever tricks in the wrong way, add
the "-b" argument when starting Vim: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para impedir que Vim use sus ingeniosos trucos de manera inapropiada,
añada el argumento «-b» al iniciar Vim: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>vim -b datafile</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>vim -b archivo_de_datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This sets the 'binary' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto activa la opción 'binary'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The effect of this is that unexpected side effects are turned off.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El efecto que tiene es que se desactivan ciertos efectos secundarios inesperados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, 'textwidth' is set to zero, to avoid automatic formatting of lines.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, 'textwidth' recibe un valor 0, para evitar el formateo automático de las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And files are always read in Unix file format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Y los archivos se leen siempre en el formato de archivo UNIX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Binary mode can be used to change a message in a program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo binario se puede usar para cambiar el mensaje de un programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be careful not to insert or delete any characters, it would stop the program from working.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tenga cuidado de no insertar o eliminar cualquier carácter, ya que impediría el funcionamiento del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use "R" to enter replace mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use «-R» para pasar al modo «replace» (reemplazar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many characters in the file will be unprintable.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Muchos caracteres en el archivo no se pueden imprimir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see them in Hex format: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para verlos en formato Hex: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set display=uhex</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set display=uhex</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, the "ga" command can be used to see the value of the character under the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otro lado, puede usar la orden «ga» para ver el valor del carácter bajo el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The output, when the cursor is on an &lt;Esc&gt;, looks like this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La salida, si el cursor está sobre un &lt;Esc&gt;, tiene este aspecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;^[&gt;  27,  Hex 1b,  Octal 033 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;^[&gt;  27,  Hex 1b,  Octal 033 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There might not be many line breaks in the file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que no haya demasiados retornos de línea en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get some overview switch the 'wrap' option off: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para obtener una visión de conjunto, desactive la opción 'wrap': &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Col 9-16 of 9-16; Line 277 of 330; Word 1806 of 2058; Byte 10580 of 12206 ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Col 9-16 of 9-16; Línea 277 of 330; Palabra 1806 de 2058; Byte 10580 de 12206 ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The last two numbers are the byte position in the file and the total number of
bytes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los dos últimos números son el byte posición en el archivo y el número total
de bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This takes into account how 'fileformat' changes the number of bytes
that a line break uses.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tiene en cuenta cómo 'fileformat' cambia el número de bytes que
emplea un retorno de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To move to a specific byte in the file, use the "go" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para desplazarse a un byte específico en el archivo, use la orden «go».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, to move to byte 2345: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para ir al byte 2345: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>2345go</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>2345go</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A real binary editor shows the text in two ways: as it is and in hex format.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un editor realmente binario muestra el texto de dos formas: tal cual y en
formato hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can do this in Vim by first converting the file with the "xxd" program.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim hace esto posible si primero convierte el archivo
con el programa «xxd».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This comes with Vim.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este programa está incluido en Vim.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First edit the file in binary mode: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Primero edite el archivo en modo binario: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:%!xxd</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:%!xxd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI ~
	0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0 ~
	0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.".....i.59.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI ~
	0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0 ~
	0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.".....i.59.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now view and edit the text as you like.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede ver y editar el texto como desee.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim treats the information as
ordinary text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim trata la información como
texto normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the hex does not cause the printable character to be
changed, or the other way around.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cambiar el valor hexadecimal no provoca un cambio en el
carácter imprimible, o vicecersa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally convert it back with:
&gt;
	:%!xxd -r</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por último, conviertalo otra vez con: &gt;
	:%!xxd -r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only changes in the hex part are used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se usan los cambios en la parte hexadecimal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changes in the printable text part on the right are ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los cambios en la parte imprimible de texto se ignoran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*23.5*	Compressed files</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*23.5*	Archivos comprimidos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>.Z	compress
	.gz	gzip
	.bz2	bzip2</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>.Z	compress
	.gz	gzip
	.bz2	bzip2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim uses the mentioned programs to do the actual compression and decompression.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim realiza la compresión y descompresión mediante los programas mencionados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to install the programs first.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que primero tenga instalar los programas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*usr_24.txt*	For Vim version 7.3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*usr_24.esx*	Para Vim versión 7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last change: 2006 Jul 23</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Último cambio: 23/6/2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inserting quickly</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Insertar con rapidez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When entering text, Vim offers various ways to reduce the number of keystrokes and avoid typing mistakes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al introducir texto, Vim ofrece varias maneras de reducir el número de teclas que pulsa, evitando teclear errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Insert mode completion to repeat previously typed words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use el modo de autocompletado del modo Insertar para repetir palabras anteriormente tecleadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Abbreviate long words to short ones.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Abrevie las palabras largas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type characters that aren't on your keyboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee caracteres que no están en su teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>|24.1|	Making corrections
|24.2|	Showing matches
|24.3|	Completion
|24.4|	Repeating an insert
|24.5|	Copying from another line
|24.6|	Inserting a register
|24.7|	Abbreviations
|24.8|	Entering special characters
|24.9|	Digraphs
|24.10|	Normal mode commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>|24.1|	Corregir
|24.2|	Mostrar coincidencias
|24.3|	Autocompletado
|24.4|	Repetir una inserción
|24.5|	Copiar desde otra línea
|24.6|	Insertar un registro
|24.7|	Abreviaturas
|24.8|	Introducir caracteres especiales
|24.9|	Dígrafos
|24.10|	Órdenes del modo Normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next chapter: |usr_25.txt|  Editing formatted text
 Previous chapter: |usr_23.txt|  Editing other files
Table of contents: |usr_toc.txt|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Capítulo siguiente: |usr_25.txt|  Editar texto con formato
  Capitulo anterior: |usr_23.esx|  Editar otros archivos
Tabla de contenidos: |usr_toc.esx|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.1*	Making corrections</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.1*	Corregir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;BS&gt; key was already mentioned.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;BS&gt; ya se ha mencionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It deletes the character just before the
cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Borra el carácter que precede al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The &lt;Del&gt; key does the same for the character under (after) the
cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla &lt;Del&gt; hace lo mismo con el carácter debajo (después) del cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you typed a whole word wrong, use CTRL-W:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-W en caso de haber tecleado una palabra completamente
errónea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El caballo cayó del cielo ~
					CTRL-W
	El caballo cayó del ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you really messed up a line and want to start over, use CTRL-U to delete it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de haber realizado errores en una línea, y desea empezar otra vez, use CTRL-U para eliminarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This keeps the text after the cursor and the indent.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto mantiene el texto después del cursor, así como la tabulación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only the text from the first non-blank to the cursor is deleted.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo se elimina el texto desde el primer espacio que no esté vacío hasta el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the cursor on the "f" of "fallen" in the next line pressing CTRL-U does this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar CTRL-U con el cursor sobre la «c» de «cayó» hace lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The horse had fallen to the ~
		      CTRL-U
	fallen to the ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El caballo cayó del cielo ~
					CTRL-W
	cayó del ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you spot a mistake a few words back, you need to move the cursor there to correct it.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando detecta un error en alguna palabra anterior, necesita desplazar el cursor hasta ese punto para corregirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you typed this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, escribió lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The horse had follen to the ground ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El caballo cayu al suelo ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to change "follen" to "fallen".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita cambiar «cayo» a «cayó».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the cursor at the end, you would type this to correct it: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con el cursor al final,  teclearía esto para corregirlo: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;Esc&gt;4blraA</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;Esc&gt;3blróA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	get out of Insert mode		&lt;Esc&gt;
	four words back			     4b
	move on top of the "o"		       l
	replace with "a"			ra
	restart Insert mode			  A</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Abandonar el modo insertar   &lt;Esc&gt;
	Cuatro palabras hacia atrás          3b
	Desplazarse a la «u»         		l
	Reemplazar con «ó»			ró
	Reiniciar modo insertar			  A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;Right&gt;&lt;Del&gt;a&lt;End&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;C-Izq&gt;&lt;C-Izq&gt;&lt;C-Izq&gt;&lt;Derecha&gt;&lt;Derecha&gt;&lt;Derecha&gt;&lt;Supr&gt;ó&lt;Fin&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;	four words back		     &lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;
	move on top of the "o"			&lt;Right&gt;
	delete the "o"				       &lt;Del&gt;
	insert an "a"					    a
	go to end of the line				     &lt;End&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;	Tres palabras hacia atrás	        &lt;C-Izq&gt;&lt;C-Izq&gt;&lt;C-Izq&gt;
	Desplazarse a la «u»		 &lt;Derecha&gt;&lt;Derecha&gt;&lt;Derecha&gt;
	Borrar la «u»						&lt;Supr&gt;
	Insertar una «ó»					ó
	Ir al final de la línea					&lt;Fin&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This uses special keys to move around, while remaining in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto emplea teclas especiales para el desplazamiento, a la vez que permanece
en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This
resembles what you would do in a modeless editor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se parece a lo que haría con un editor sin modos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's easier to remember,
but takes more time (you have to move your hand from the letters to the cursor
keys, and the &lt;End&gt; key is hard to press without looking at the keyboard).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es
más fácil de recordar, pero lleva más tiempo (tiene que mover sus manos de
las letras a las teclas del cursor, y es difícil pulsar la tecla &lt;Fin&gt; sin
mirar el teclado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These special keys are most useful when writing a mapping that doesn't
leave Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas teclas especiales son más útiles cuando escribe una macro que no
abandona el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extra typing doesn't matter then.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El tecleo adicional no importa en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An overview of the keys you can use in Insert mode:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Este es un resumen de las teclas que puede usar en el modo Insertar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;C-Home&gt;	to start of the file
	&lt;PageUp&gt;	a whole screenful up
	&lt;Home&gt;		to start of line
	&lt;S-Left&gt;	one word left
	&lt;C-Left&gt;	one word left
	&lt;S-Right&gt;	one word right
	&lt;C-Right&gt;	one word right
	&lt;End&gt;		to end of the line
	&lt;PageDown&gt;	a whole screenful down
	&lt;C-End&gt;		to end of the file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>&lt;C-Inicio&gt;	al principio del archivo
	&lt;Repág&gt;		subir una pantalla
	&lt;Inicio&gt;	al inicio de la línea
	&lt;S-Izq&gt;		una palabra a la izquierda
	&lt;C-Izq&gt;		una palabra a la izquierda
	&lt;S-Der&gt;		una palabra a la derecha
	&lt;C-Der&gt;		una palabra a la derecha
	&lt;Fin&gt;		al final de la línea
	&lt;Avpág&gt;		bajar una pantalla
	&lt;C-Fin&gt;		al final del archivo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.2*	Showing matches</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.2*	Mostrar coincidencias</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type a ) it would be nice to see with which ( it matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Al teclear una «)» estaría bien ver con qué «(» encaja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make Vim do that use this command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para hacer que Vim use esta orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set showmatch</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set showmatch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now type a text like "(example)", as soon as you type the ) Vim will
briefly move the cursor to the matching (, keep it there for half a second,
and move back to where you were typing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando teclee un texto como «(ejemplo), tan pronto como teclee el «)»
Vim moverá el cursor brevemente al «(» correspondiente, lo mantendrá ahí
medio segundo, y volverá a donde estaba tecleando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case there is no matching (, Vim will beep.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En caso de no existir un correspondiente «(», Vim pitará.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you know that you
might have forgotten the ( somewhere, or typed a ) too many.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sabrá entonces que
ha olvidado el «(» en algún lugar, o que escribió una «)» demasiadas veces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The match will also be shown for [] and {} pairs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También se mostrará el signo correspondiente en las parejas «[]» «{}».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to wait
with typing the next character, as soon as Vim sees it the cursor will move
back and inserting continues as before.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No
tiene que esperar a teclear el siguiente carácter, ya que tan pronto como Vim
lo detecte, devolverá el cursor a su posición original, continuando la
inserción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the time Vim waits with the 'matchtime' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede modificar el tiempo que Vim espera con la opción 'matchtime'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, to make Vim wait one and a half second: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para hacer que Vim espere un segundo y medio: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:set matchtime=15</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:set matchtime=15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.3*	Completion</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.3*	Autocompletado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim can automatically complete words on insertion.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim puede auto-completar palabras durante la inserción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You type the first part of
a word, press CTRL-P, and Vim guesses the rest.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba primero la
parte inicial de una palabra, pulse CTRL-P y Vim adivinará el resto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose, for example, that you are creating a C program and want to type in
the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga, por ejemplo, que está creando un programa en C y que desea
teclear lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>total = ch_array[0] + ch_array[1] + ch_array[2]; ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>total = ch_array[0] + ch_array[1] + ch_array[2]; ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>total = ch_array[0] + ch_ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>total = ch_array[0] + ch_ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you tell Vim to complete the word using the command CTRL-P.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este punto es cuando le dice a Vim que complete la palabra usando la orden CTRL-P.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim searches for a word that starts with what's in front of the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim buscará una palabra que empiece con lo que se aparece frente al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, it is "ch_", which matches with the word ch_array.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este caso, es «ch_», el cual encaja con la palabra «ch_array».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So typing CTRL-P gives you the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, teclear CTRL-P le daría lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>total = ch_array[0] + ch_array ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>total = ch_array[0] + ch_array ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>total = ch_array[0] + ch_array[1] +  ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>total = ch_array[0] + ch_array[1] +  ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now type CTRL-P Vim will search again for a word that completes the word before the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa ahora CTRL-P, Vim buscará otra vez una palabra que complete la que se haya frente al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since there is nothing in front of the cursor, it finds the first word backwards, which is "ch_array".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que no hay nada en frente del cursor, busca la palabra en sentido inverso, el cual es «ch_array».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing CTRL-P again gives you the next word that matches, in this case "total".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulsar CTRL-P otra vez le daría la siguiente palabra que encaja, en este caso «total».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A third CTRL-P searches further back.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si lo pulsa por tercera vez, Vim buscará aún más atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is nothing else, it causes the editor to run out of words, so it returns to the original text, which is nothing.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no hay nada más, al editor se le acabarían las palabras, volviendo al texto original, que es nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A fourth CTRL-P causes the editor to start over again with "ch_array".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Un cuarto CTRL-P causaría al editor empezar otra vez con «ch_array».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To search forward, use CTRL-N.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-N para una búsqueda hacia delante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the search wraps around the end of the file, CTRL-N and CTRL-P will find the same matches, but in a different sequence.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ya que la búsqueda vuelve al inicio cuando llega al final del archivo, CTRL-N y CTRL-P encontrarán las mismas coincidencias, pero en distinto orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hint: CTRL-N is Next-match and CTRL-P is Previous-match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pista: CTRL-N es siguiente coincidencia («Next-match») y CTRL-P es la coincidencia anterior («Previous-match»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vim editor goes through a lot of effort to find words to complete.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim realiza un gran esfuerzo por encontrar palabras que completar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, it searches the following places:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por omisión, busca en los siguientes lugares:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current file
	2.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Archivo actual
	2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Files in other windows
	3.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Archivos en otras ventanas
	3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other loaded files (hidden buffers)
	4.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otros archivos cargados (búfers ocultos)
	4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Files which are not loaded (inactive buffers)
	5.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Archivos que no están cargados (búfers inactivos)
	5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tag files
	6.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Archivos de etiquetas
	6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All files #included by the current file</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todos los archivos #incluidos en el archivo actual</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 'ignorecase' option is used.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La opción 'ignorecase' es empleada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it is set, case differences are ignored when searching for matches.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las diferencias entre mayúsculas y minúsculas se ignorarán al buscar coincidencias de activar esta opción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special option for completion is 'infercase'.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>'infercase' es una opción especial para el autocompletado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to find matches while ignoring case ('ignorecase' must be set) but still using the case of the word typed so far.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es útil para encontrar parejas cuando ignora la sensibilidad a mayúsculas y minúsculas (debe activar 'ignorecase') , y seguir usando con esta palabra la mencionada sensibilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus if you type "For" and Vim finds a match "fortunately", it will result in "Fortunately".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, si teclea «Para» y Vim encuentra «paramilitar», el resultado final será «Paramilitar».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-X CTRL-F		file names
	CTRL-X CTRL-L		whole lines
	CTRL-X CTRL-D		macro definitions (also in included files)
	CTRL-X CTRL-I		current and included files
	CTRL-X CTRL-K		words from a dictionary
	CTRL-X CTRL-T		words from a thesaurus
	CTRL-X CTRL-]		tags
	CTRL-X CTRL-V		Vim command line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-X CTRL-F		Nombres de archivo
	CTRL-X CTRL-L		Líneas completas
	CTRL-X CTRL-D		Definiciones de macros
				(también en archivos incluidos)
	CTRL-X CTRL-I		Archivo actual e incluidos
	CTRL-X CTRL-K		Palabras de un diccionario
	CTRL-X CTRL-T		Palabras de un tesauro
	CTRL-X CTRL-]		Etiquetas
	CTRL-X CTRL-V		Línea de órdenes de Vim</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After each of them CTRL-N can be used to find the next match, CTRL-P to find
the previous match.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede usar CTRL-N después de cada uno de estas órdenes para hallar la siguiente
coincidencia, y CTRL-P para hallar la anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information for each of these commands here: |ins-completion|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más información acerca de estas órdenes, consulte |ins-completion|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take CTRL-X CTRL-F as an example.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Tomemos CTRL-X CTRL-F como ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will find file names.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto busca nombres de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It scans
the current directory for files and displays each one that matches the word in
front of the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Examina el directorio actual en busca de archivos, y muestra cada uno que
encaja con la palabra frenet al cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose, for example, that you have the following files in the current
directory:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga, por ejemplo, que tiene las siguientes líneas en el directorio
actual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>main.c  sub_count.c  sub_done.c  sub_exit.c</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>main.c  sub_count.c  sub_done.c  sub_exit.c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The exit code is in the file sub ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código de salida está en el archivo sub ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you enter the command CTRL-X CTRL-F.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En este momento, introduzca la orden CTRL-X CTRL-F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim now completes the current word "sub" by looking at the files in the current directory.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim completará la palabra «sub» mirando en los ficheros en el directorio actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first match is sub_count.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La primera coincidencia es «sub_count.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not the one you want, so you match the next file by typing CTRL-N.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto no es lo que buscaba, así que busca la siguiente pareja pulsando CTRL-N.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This match is sub_done.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La coincidencia es «sub_done.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Typing CTRL-N again takes you to sub_exit.c.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclear CTRL-N otra vez le devolvería a «sub_exit.c».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The results:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The exit code is in the file sub_exit.c ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El código de salida está en el archivo sub_exit.c ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all files in the file system.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el nombre de archivo empieza con «/» (Unix) o «C:\» (MS-Windows), puede buscar todos los archivos en el sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, type "/u" and CTRL-X CTRL-F.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, teclee «/u» y CTRL-X CTRL-F.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will match "/usr" (this is on Unix):</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto buscará «/usr» (en Unix):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the file is found in /usr/ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo se encuentra en "/usr/" ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you now press CTRL-N you go back to "/u".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora pulsa CTRL-N volvería a «/u».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead, to accept the "/usr/" and go one directory level deeper, use CTRL-X CTRL-F again:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En lugar de ello, para aceptar «/usr/» y descender un nivel en el árbol de directorios, use otra vez CTRL-X CTRL-F:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the file is found in /usr/X11R6/ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo se encuentra en /usr/X11R6/~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The results depend on what is found in your file system, of course.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los resultados varían según lo que se encuentra en su sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The matches are sorted alphabetically.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Las coincidencias aparecen alfabéticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source code files are well structured.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Los archivos de código están bien estructurados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That makes it possible to do completion in an intelligent way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto posibilita un autocompletado inteligente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Vim this is called Omni completion.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En Vim, esto se llama autocompletado global («Omni completion»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some other editors it's called intellisense, but that is a trademark.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Algunos otros editores lo llaman intellisense, pero eso es una marca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The key to Omni completion is CTRL-X CTRL-O.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La tecla para el autocompletado global es CTRL-X CTRL-O.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously the O stands for Omni here, so that you can remember it easier.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Obviamente, la «O» significa «Omni», para recordarla mejor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's use an example for editing C source:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usemos un ejemplo para editar código C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{ ~
	    struct foo *p; ~
	    p-&gt; ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>{ ~
	    struct foo *p; ~
	    p-&gt; ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The cursor is after "p-&gt;".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El cursor está después de «p-&gt;».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now type CTRL-X CTRL-O.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pulse ahora CTRL-X CTRL-O.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will offer you a list of alternatives, which are the items that "struct foo" contains.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le ofrecerá una lista de alternativas, los cuales son los elementos que contiene «struct foo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is quite different from using CTRL-P, which would complete any word, while only members of "struct foo" are valid here.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es diferente al uso de CTRL-P, el cual completa cualquier palabra, mientras que aquí sólo son válidos los miembros de «struct foo».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Omni completion to work you may need to do some setup.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita realizar alguna configuración para que funcione el autocompletado
global.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At least make sure
filetype plugins are enabled.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asegúrese al menos de que las extensiones de tipo de archivo
(filetype) están activadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your vimrc file should contain a line like
this: &gt;
	filetype plugin on
Or: &gt;
	filetype plugin indent on</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El archivo vimrc debería tener esta línea: &gt;
	filetype plugin on
O: &gt;
	filetype plugin indent on</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For C code you need to create a tags file and set the 'tags' option.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Necesita crear un archivo de etiquetas y definir la opción 'tags' si desea editar código C.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That is explained |ft-c-omni|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Consulte |ft-c-omni|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For other filetypes you may need to do something similar, look below |compl-omni-filetypes|.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede que tenga que realizar algo
similar para otros tipos de archivo, consulte más adelante |compl-omni-filetypes|.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It only works for specific filetypes.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo funciona para ciertos tipos de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the value of the 'omnifunc' option to find out if it would work.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Revise el valor de la opción 'omnifunc' para ver si funcionaría.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.4*	Repeating an insert</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.4*	Repetir una inserción</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you press CTRL-A, the editor inserts the text you typed the last time you
were in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si pulsa CTRL-A, el editor insertará el texto que tecleó la última que estaba
en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Assume, for example, that you have a file that begins with the following:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga, por ejemplo, que tiene un archivo que empieza con lo siguiente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"file.h" ~
	/* Main program begins */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"file.h" ~
	/* El programa principal comienza */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "file.h" ~
	/* Main program begins */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#include "file.h" ~
	/* El programa principal comienza */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You go down to the beginning of the next line using the commands "j^".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede bajar hasta el inicio de la siguiente línea con las órdenes «j^».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now start to insert a new "#include" line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora puede empezar a insertar una nueva línea «include».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So you type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Asi que escribe: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i CTRL-A</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>i CTRL-A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "file.h" ~
	#include /* Main program begins */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#include "file.h" ~
	#include /* El programa principal comienza */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "#include " was inserted because CTRL-A inserts the text of the previous insert.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«#include» se insertó porque CTRL-A inserta el texto de la inserción anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you type "main.h"&lt;Enter&gt; to finish the line:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Teclee ahora «main.h» &lt;Enter&gt; para finalizar la línea:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>#include "file.h" ~
	#include "main.h" ~
	/* El programa principal comienza */ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-@ command does a CTRL-A and then exits Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-@ realiza un CTRL-A y abandona el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a quick way of doing exactly the same insertion again.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta es una manera rápida de hacer la misma inserción otra vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.5*	Copying from another line</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.5*	Copiar desde otra línea</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-Y command inserts the character above the cursor.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-Y inserta el carácter sobre el cursor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful when you are duplicating a previous line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil si está duplicando una línea anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you have this line of C code:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, tiene esta línea de código C:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to type the same line, but with "s_prev" instead of "s_next".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora necesita escribir la misma línea, pero con un «s_prev» en lugar de «s_next».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the new line, and press CTRL-Y 14 times, until you are at the "n" of "next":</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Inicie una nueva línea, y pulse CTRL-Y 14 veces, hasta encontrarse en la «n» de «next»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; ~
	b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.6*	Inserting a register</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.6*	Insertar un registro</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command CTRL-R {register} inserts the contents of the register.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-R {registro} inserta el contenido de un registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is useful to avoid having to type a long word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto es útil para evitar escribir una palabra larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, you need to type this:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, necesita teclear esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>r = FunciónMuyLarga(a) + FunciónMuyLarga(b) + FunciónMuyLarga(c) ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name is defined in a different file.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El nombre de la función se define en otro archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit that file and move the cursor on top of the function name there, and yank it into register v: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ese archivo y desplace el cursor sobre el nombre de función presente, y copie el mismo al registro v:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"vyiw</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>"vyiw</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"v is the register specification, "yiw" is yank-inner-word.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«"v» es el especificador del registro, «yiw» signifia copiar la palabra interior («yank inner word»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now edit the file where the new line is to be inserted, and type the first letters:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Edite ahora el archivo donde se insertará la línea, y escriba las primeras letras:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>r = ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>r = ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>r = VeryLongFunction ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>r = FunciónMuyLarga ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You continue to type the characters in between the function name, and use
CTRL-R v two times more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Continua insertando caracteres en medio del nombre de la función, y usa
«CTRL-R v» dos veces más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You could have done the same with completion.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Podría haber realizado lo mismo con el autocompletado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a register is useful
when there are many words that start with the same characters.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Usar un registro
es útil cuando hay varias palabras que empiezan con el mismo carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the register contains characters such as &lt;BS&gt; or other special characters, they are interpreted as if they had been typed from the keyboard.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si el registro contiene caracteres tales como &lt;BS&gt; o otros caracteres especiales, se interpretarán como introducidos a través del teclado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want this to happen (you really want the &lt;BS&gt; to be inserted in the text), use the command CTRL-R CTRL-R {register}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si no desea que esto ocurra (realmente quiere que &lt;BS&gt; acabe insertado en el texto), use la orden CTRL-R CTRL-R {registro}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.7*	Abbreviations</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.7*	Abreviaturas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An abbreviation is a short word that takes the place of a long one.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Una abreviatura es una palabra corta que sustituye a otra más larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For
example, "ad" stands for "advertisement".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por
ejemplo, «poli» simboliza «policía».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim enables you to type an
abbreviation and then will automatically expand it for you.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim le permite insertar una abreviatura
para después expandirla automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To tell Vim to expand "ad" into "advertisement" every time you insert it,
use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para decir a Vim que expanda «poli» a «policía» cada vez que lo inserte,
use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:iabbrev ad advertisement</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:iabbrev poli policía</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, when you type "ad", the whole word "advertisement" will be inserted into the text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Ahora, cuando escribe «po», aparecerá la palabra completa «policía» en el texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is triggered by typing a character that can't be part of a word, for example a space:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto se activa cuando teclea un carácter que no puede ser parte de una palabra, como por ejemplo un espacio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What Is Entered		What You See
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad&lt;Space&gt;	I saw the advertisement&lt;Space&gt; ~</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Texto introducido	Lo que ve
	Vi al p			Vi al p ~
	Vi al po		Vi al po ~
	Vi al po&lt;Espacio&gt;	Vi al policía&lt;Espacio&gt; ~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The expansion doesn't happen when typing just "ad".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La expansión no ocurre si solo escribe «po».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That allows you to type a word like "add", which will not get expanded.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto permite escribir una palabra como «polifacético», que no se expandirá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only whole words are checked for abbreviations.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Solo se revisan palabras completas con abreviaturas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to define an abbreviation that results in multiple words.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es posible definir una abreviatura cuyo resultado sean varias palabras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to define "JB" as "Jack Benny", use the following command: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para definir «JB» como «Juan Benítez», use la siguiente orden: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:iabbrev JB Jack Benny</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:iabbrev JB Juan Benítez</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:iabbrev #b /****************************************
	:iabbrev #e &lt;Space&gt;****************************************/</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:iabbrev #b /****************************************
	:iabbrev #e &lt;Space&gt;****************************************/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are used for creating boxed comments.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Uso esto para crear comentarios en cajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The comment starts with #b, which
draws the top line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El comentario empieza con «#b», el
cual escribe la línea superior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I then type the comment text and use #e to draw the
bottom line.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Después escribo el texto del comentario y uso
«#e» para dibujar la línea inferior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that the #e abbreviation begins with a space.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Observe que la abreviatura «#e» empieza con un espacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, the
first two characters are space-star.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras,
los primeros dos caracteres son espacio-asterisco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually Vim ignores spaces between the
abbreviation and the expansion.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por lo general, Vim
ignora los espacios entre la abreviatura y la expansión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid that problem, I spell space as seven
characters: &lt;, S, p, a, c, e, &gt;.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar tal
problema, deletreo espacio («space») como siete caracters: &lt;, S, p, a, c, e,&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	":iabbrev" is a long word to type.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	La palabra «:iabbrev» es algo larga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>":iab" works just as well.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>«:iab» también daría resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's abbreviating the abbreviate command!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>¡Esto es abreviar la orden de abreviar!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's very common to make the same typing mistake every time.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Es bastante normal escribir siempre el mismo error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, typing "teh" instead of "the".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, escribir «qeu» en lugar de «que».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can fix this with an abbreviation: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede arreglar esto con una abreviatura: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbreviate teh the</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbreviate qeu que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add a whole list of these.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede crear una lista completa de ejemplos como este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add one each time you discover a common mistake.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Añada uno cada vez que descubra un error común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Juan Benítez
	i  po		 policía
	!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>teh		 the</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>qeu		 que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "i" in the first column indicates Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La «i» en la primera columna indica modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These abbreviations are only active in Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Estas abreviaturas sólo están activas en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other possible characters are:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Otros caracteres posibles son:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since abbreviations are not often useful in Command-line mode, you will mostly use the ":iabbrev" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Debido a que las abreviaturas no son útiles en el modo Línea de órdenes, usará más regularmente la orden «:iabbrev».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That avoids, for example, that "ad" gets expanded when typing a command like: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto evita, por ejemplo, que se expanda «po» al escribir una orden como: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:edit ad</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:edit po</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get rid of an abbreviation, use the ":unabbreviate" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar una abreviatura, use la orden «:unabbreviate».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you have the following abbreviation: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Suponga que tiene la siguiente abreviatura: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbreviate @f fresh</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbreviate @f fresco</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:unabbreviate @f</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:unabbreviate @f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you type this, you will notice that @f is expanded to "fresh".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Notará al escribir esto que @f se expande a «fresco».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't
worry about this, Vim understands it anyway (except when you have an
abbreviation for "fresh", but that's very unlikely).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>No se preocupe, Vim lo
entiende de todas formas (a menos que tenga una abreviatura «fresco», pero
eso es improbable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To remove all the abbreviations: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para eliminar todas las abreviaturas: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abclear</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abclear</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one thing to watch out for when defining an abbreviation: The resulting string should not be mapped.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Existe un aspecto a tener en cuenta a la hora de definir una abreviatura: no debería asignar la cadena resultante a una macro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:abbreviate @a adder
	:imap dd disk-door</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:abbreviate @a adder
	:imap dd disk-door</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you now type @a, you will get "adisk-doorer".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si ahora teclea @a, obtendrá «adisk-doorer».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid this, use the ":noreabbrev" command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitarlo, use la orden «:noabbrev».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does the same as ":abbreviate", but avoids that the resulting string is used for mappings: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hace lo mismo que «:abbreviate», pero evita que la cadena resultante se use en macros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:noreabbrev @a adder</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:noreabbrev @a adder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.8*	Entering special characters</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.8*	Introducir caracteres especiales</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CTRL-V command is used to insert the next character literally.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>La orden CTRL-V se emplea para insertar el siguiente carácter de forma literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, any special meaning the character has, it will be ignored.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En otras palabras, se ignorará el significado especial de cualquier carácter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V &lt;Esc&gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V &lt;Esc&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inserts an escape character.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esta orden inserta un carácter de escapado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus you don't leave Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ello, no abandona el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Don't type the space after CTRL-V, it's only to make this easier to read).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>(No escriba un espacio después de CTRL-V, sólo lo hace más fácil de leer).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	On MS-Windows CTRL-V is used to paste text.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	En MS-Windows, CTRL-V se emplea para pegar texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use CTRL-Q instead of
	CTRL-V.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use CTRL-Q en
	lugar de CTRL-V.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Unix, on the other hand, CTRL-Q does not work on some
	terminals, because it has a special meaning.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por otra parte, Unix no reconoce CTRL-Q en algunas
	terminales, porque tiene un significado especial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use the command CTRL-V {digits} to insert a character with the decimal number {digits}.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar la orden CTRL-V {dígitos} para insertar un carácter con el número decimal {dígitos}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the character number 127 is the &lt;Del&gt; character (but not necessarily the &lt;Del&gt; key!).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, el carácter número 127 es el carácter &lt;Del&gt; (Supr) (¡pero no necesariamente la tecla &lt;Supr&gt;!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To insert &lt;Del&gt; type: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Escriba lo siguiente para insetar &lt;Del&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V 127</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V 127</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enter characters up to 255 this way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede introducir hasta el carácter 255 de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you type fewer than two
digits, a non-digit will terminate the command.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Cuando escribe menos
de dos dígitos, un no-dígito finalizará la orden.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para evitar la necesidad
de escribir un no-dígito, añada uno o dos ceros para sumar tres dígitos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the next commands insert a &lt;Tab&gt; and then a dot:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Todas las ordenes a continuación insertan primero un &lt;Tab&gt; y después un
punto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V 9.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V 09.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V 09.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V 009.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V 009.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V x7f</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V x7f</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also goes up to character 255 (CTRL-V xff).</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Esto también llega al carácter 255 (CTRL-V xff).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use "o" to type a character as an octal number and two more methods allow you to type up to a 16 bit and a 32 bit number (e.g., for a Unicode character): &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>También puede usar «o» para escribir un carácter como un número octal, y otros dos métodos le permiten escribir hasta un número en 16 y 32 bit (p, ej., un carácter Unicode): &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.9*	Digraphs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.9*	Dígrafos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-K Co</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-K Co</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:digraphs</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:digraphs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vim will display the digraph table.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Vim mostrará la tabla de dígrafos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are three lines of it:</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí puede ver tres líneas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note:
	The digraphs depend on the character set that Vim assumes you are
	using.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Nota:
	Los dígrafos dependen del juego de caracteres que Vim asume que está
	usando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On MS-DOS they are different from MS-Windows.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>En MS-DOS difieren con los de MS-Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Always use
	":digraphs" to find out which digraphs are currently available.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Use siempre
	«:digraphs» para ver de qué dígrafos dispone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your own digraphs.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede configurar sus propios dígrafos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>:digraph a" 228</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>:digraph a" 228</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information about digraphs here: |digraphs|
   Another way to insert special characters is with a keymap.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Para más información acerca de los dígrafos, consulte: |digraphs|
   Otra manera de insertar caracteres especiales es un «keymap».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More about that
here: |45.5|</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Puede leer
más acerca de esto aquí: |45.5|</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*24.10*	Normal mode commands</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>*24.10*	Órdenes del modo Normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Insert mode offers a limited number of commands.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>El modo Insertar ofrece un limitado número de órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Normal mode you have many
more.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Dispone de muchas más
en el modo normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you want to use one, you usually leave Insert mode with &lt;Esc&gt;,
execute the Normal mode command, and re-enter Insert mode with "i" or "a".</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Si desea usar uno, abandone el modo Insertar con &lt;Esc&gt;,
ejecuto la orden en modo Normal, y vuelva al modo Insertar con «i» o «a».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a quicker way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Hay una manera más rápida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With CTRL-O {command} you can execute any Normal
mode command from Insert mode.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Con CTRL-O {orden} puede ejecutar cualquier
orden de modo Normal en el modo Insertar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to delete from the cursor to the
end of the line: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Por ejemplo, para eliminar desde
el cursor hasta el final de la línea: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-O D</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-O D</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can execute only one Normal mode command this way.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Sólo puede ejecutar una orden de modo Normal de esta manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But you can specify a register or a count.</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Pero puede especificar un registro o cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more complicated example: &gt;</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>Aquí tiene una manera más complicada: &gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CTRL-O "g3dw</seg>
      </tuv>
      <tuv xml:lang="es-ES">
        <seg>CTRL-O "g3dw</seg>
      </tuv>
    </tu>
  </body>
</tmx>
