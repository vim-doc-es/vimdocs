*usr_30.txt*	For Vim version 7.3.  Last change: 2007 Nov 10

		MANUAL DE USUARIO DE VIM - por Bram Moolenaar

			    Editar programas


Vim tiene varias órdenes que asisten en la edición de programas de
ordenador. Puede compilar un programa y saltar directamente a los errores
que aparecen, y definir la tabulación automáticamente para varios lenguajes
así como el formato de los comentarios.

|30.1|	Compilar
|30.2|	Sangrado en archivos C
|30.3|	Sangrado automático
|30.4|	Otros sangrados
|30.5|	Tabulados y espacios
|30.6|	Formatear comentarios

     Next chapter: |usr_31.txt|  Exploiting the GUI
 Previous chapter: |usr_29.txt|  Moving through programs
Table of contents: |usr_toc.txt|

==============================================================================
*30.1*	Compilar

Vim tiene un conjunto de órdenes de «arreglos rápidos». Le permiten compilar
un programa desde Vim y después navegar a través de los errores generados y
(posiblemente) arreglarlos. Puede después recompilar y arreglar cualquier
error nuevo detectado hasta que finalmente su programa se compile sin
problemas.

La siguiente orden ejecuta el programa «make» (introduciendo cualquier
argumento) y captura los resultados: >

	:make {arguments}

Si se genera algún error, se captura y el editor le posicionará sobre el primer error.
   Este es un ejemplo de una sesión típica de «:make». (Las sesiones típicas de «:make»
generan muchos menos errores y menos errores estúpidos.) La pantalla presentará este
aspecto después de teclear «:make»:

	:!make | &tee /tmp/vim215953.err ~
	gcc -g -Wall -o prog main.c sub.c ~
	main.c: In function 'main': ~
	main.c:6: too many arguments to function 'do_sub' ~
	main.c: At top level: ~
	main.c:10: parse error before '}' ~
	make: *** [prog] Error 1 ~

	2 returned ~
	"main.c" 11L, 111C ~
	(3 of 6): too many arguments to function 'do_sub' ~
	Press ENTER or type command to continue ~

Aquí puede ver que tiene errores en el archivo «main.c». Cuando pulse
<Intro>, Vim mostrará el archivo «main.c», con el cursor posicionado en la
línea 6, la primera con un error. No necesitó definir el archivo o el número
de línea, ya que Vim sabe donde ir analizando los mensajes de error.

		+---------------------------------------------------+
		|int main()					    |
		|{						    |
		|	int i=3;				    |
      cursor -> |	do_sub("foo");				    |
		|	++i;					    |
		|	return (0);				    |
		|}						    |
		|}						    |
		| ~						    |
		|(3 of 12): too many arguments to function 'do_sub' |
		+---------------------------------------------------+

La siguiente orden va a la aparición del siguiente error: >

	:cnext

Vim salta a la línea 10, la última línea en el archivo, donde hay un «}» adicional.
   Cuando no hay suficiente espacio Vim acorta el mensaje de error. Para ver el mensaje
completo, use lo siguiente: >

	:cc

Puede obtener una visión general de todos los mensajes de error con la orden
« clist».  La salida tiene el siguiente aspecto: >

	:clist
<	3 main.c: 6:too many arguments to function 'do_sub' ~
	5 main.c: 10:parse error before '}' ~

Sólo se muestran las líneas donde Vim reconoció un nombre de fichero y un
número de línea. Asume que aquéllas son las líneas de interés, mientras que
toma el resto como mensajes aburridos. Aún así, a veces las líneas no
reconocidas contiene algo que desee ver. Por ejemplo, la salida del
enlazador acerca de una función no definida. Para ver todos los mensajes,
añada «!» a la orden: >

¡	:clist!
<	1 gcc -g -Wall -o prog main.c sub.c ~
	2 main.c: In function 'main': ~
	3 main.c:6: too many arguments to function 'do_sub' ~
	4 main.c: At top level: ~
	5 main.c:10: parse error before '}' ~
	6 make: *** [prog] Error 1 ~

Vim resaltará el error actual. Use lo siguiente para volver al error anterior: >
	:cprevious

Otras órdenes para desplazarse por la lista de errores:

	:cfirst		primer error
	:clast		último error
	:cc 3		error número 3


USAR OTRO COMPILADOR

El nombre del programa a ejecutar cuando usa la orden «:make» se define con
la opción 'makeprg'. Habitualmente, esto se define como «make», pero
usuarios de Visual C++ deberían definir esto como «nmake» ejecutando la
siguiente orden: >

	:set makeprg=nmake

También puede incluir argumentos en esta opción.  Los caracteres especiales
se deben escapar con una barra invertida.  Ejemplo: >

	:set makeprg=nmake\ -f\ project.mak

Puede incluir palabras clave especiales de Vim al especificar la orden. El carácter «%»
se expande con el nombre del archivo actual. Así que se ejecuta la siguiente orden: >
	:set makeprg=make\ %

Al editar «main.c», «:make» ejecutará la siguiente orden: >

	make main.c

Esto no es tan útil, así que refinaría la orden con el modificador «:r»
(root): >

	:set makeprg=make\ %:r.o

Ahora, la orden se ejecuta de la siguiente manera: >

	make main.o

Para más información acerca de los modificadores, consulte:
|filename-modifiers|.


LISTAS DE ERRORES ANTIGUOS

Suponga que compila un programa con «:make». Hay un mensaje de aviso en un
archivo y un mensaje de error en otro. Arregla el mensaje y usa «:make» otra
vez para comprobar que lo ha arreglado. Ahora desea ver el mensaje de
aviso. No aparece en la última lista de errores ya que aún no se ha
compilado el archivo con el aviso. Puede volver a la lista de errores previa
con: >

	:colder

Use ahora «:clist» y «:cc {nr}» para saltar al lugar con el aviso.
   Use lo siguiente para avanzar a la siguiente lista de errores: >

	:cnewer

Puede puede recordar diez listas de error.


CAMBIAR DE COMPILADOR

Tiene que decir el Vim el formato de los mensajes de error que produce su
compilador. Esto se puede hacer con la opción 'errorformat'. La sintaxis de
esta opción es algo complicada, y puede hacer que encaje con prácticamente
cualquier compilador. Puede encontrar la explicación aquí: |errorformat|.

Puede que esté usando varios compiladores diferentes. Definir la opción
'makeprg' y especialmente la opción 'errorformat' cada vez no es un tarea
sencilla. Vim ofrece una forma sencilla de hacer esto. Por ejemplo, para
cambiar al compilador Microsoft Visual C++: >

	:compiler msvc

Esto encontrará el script de Vim para el compilador «msvc» y definirá las opciones adecuadas.
   Puede escribir sus propios archivos de compilador. Consulte |write-compiler-plugin|.


REDIRECCIONAMIENTO DE LA SALIDA

La orden «:make» redirige la salida del programa ejecutado a un archivo
error. El modo en que esto funciona depende de varias cosas, tales como la
consola ('shell'). Si su orden «:make» no captura la salida, compruebe las
opciones 'makeef' y 'shellpipe'. Las opciones 'shellquote' y 'shellxquote'
también son de importancia.

En el caso de que no puede hacer que «:make» redirija la salida del archivo,
una alternativa es compilar el programa en otra ventana y redirigir la
salida al archivo. Después, haga que Vim lea este archivo con: >

	:cfile {filename}

Saltar a errores funcionará como la orden «:make».

==============================================================================
*30.2*	Sangrado en archivos C

Un programa es mucho más fácil de entender cuando las líneas tienen un
sangrado adecuado. Vim ofrece varias formas de disminuir el trabajo de
lograr esto. Para programas C o con estilo C como Java o C++, defina la
opción 'cindent'. Vim sabe mucho acerca de programas C e intentará definir
el sangrado automáticamente. Defina la opción 'shiftwidth'  con el número de
espacios que desea para cada nivel de profundidad. Cuatro espacios
funcionarán bien. Puede hacerlo con una orden 'set': >

	:set cindent shiftwidth=4

Con esta opción activada, cuando escriba algo como «if (x)», la siguiente
línea tendrá un nivel de sangrado adicional de forma automática.

				    if (flag)
	Automatic indent   --->		do_the_work();
	Automatic unindent <--	    if (other_flag) {
	Automatic indent   --->		do_file();
	keep indent			do_some_more();
	Automatic unindent <--	    }

Cuando teclee algo entre corchetes ({}), el texto tendrá un sangrado al
inicio, y pero no al final. La eliminación de sangrado («unindenting»)
aparecerá después de teclear '}', ya que Vim no puede adivinar qué va a
escribir.

Un efecto secundario del sangrado automático es que le permite encontrar los errores
en su código de manera temprana. Cuando teclea «}» para finalizar una función, sólo
para ver que el sangrado automático la da más sangrado del esperado, puede que falte
un «}». Use la orden «%» para encontrar qué «{» encaja con la «}» que tecleó.
  Un «)» y «;» omitido también causan un sangrado adicional. Por ello, si obtiene más espacios
en blanco del esperado, compruebe la líneas precedentes.

Cuando tiene código mal formateado, o si ha insertado o eliminado líneas,
tendrá que sangrar las líneas nuevamente. El operador «=» hace esto. La
forma más simple es: >

	==

Esto sangra la línea actual. Al igual que el resto de los operadores, hay
tres formas de usarlo. En el modo Visual, «=» sangra las líneas
seleccionadas. Un objeto de texto útil es «a{». Esto selecciona el bloque
«{}» actual. Por lo tanto, para sangrar otra vez el bloque de código en el
que se encuentra el cursor: >

	=a{

Si tiene código con un pésimo sangrado, puede sangrar nuevamente el archivo completo con: >
	gg=G

Sin embargo, no lo haga en los archivos que han sido cuidadosamente
sangrados manualmente.  El sangrado automático hace un buen trabajo, pero en
algunas situaciones puede que desee anularlo.


DEFINIR EL ESTILO DE SANGRADO

Diferentes personas tienen diferentes estilos de sangrado. Por omisión, Vim realiza
un buen trabajo de sangrado de la manera en que lo hacen el 90% de los programadores.
Aun así, hay diferentes estilos; así que si lo desea, puede personalizar el estilo de sangrado
con la opción 'cinoptions'.
   Por omisión, 'cinoptions' está vacío, usando Vim el estilo predefinido. Puede añadir
varios elementos cuando desee algo diferente. Por ejemplo, para ubicar corchetes de la
siguiente forma:

	if (flag) ~
	  { ~
	    i = 8; ~
	    j = 0; ~
	  } ~

Use esta orden: >

	:set cinoptions+={2

Hay muchos de estos elementos. Consulte |cinoptions-values|.

==============================================================================
*30.3*	Sangrado automático

No desea activar la opción 'cindent' manualmente cada vez que edite un
archivo C. Esta es la forma de hacer que funcione automáticamente: > 

	:filetype indent on

En realidad, esto hace  mucho más que activar 'cindent'  para archivos C. En primer
lugar, activa la detección de tipo de archivo. Es lo mismo que lo que usar para el
resaltado de sintaxis.
   Si el tipo de archivo es conocido, Vim buscará un archivo de sangrado para este tipo de
archivo. La distribución de Vim incluye un número para estos lenguajes de programación.
Este archivo de sangrado preparará automáticamente el sangrado específico para este
archivo.

Si no le gusta el sangrado automático, puede desactivarlo de nuevo: >

	:filetype indent off

Si no le gusta el sangrado para un tipo específico de archivo, esta es la
forma de evitarlo. Cree un archivo con sólo esta línea: >

	:let b:did_indent = 1

Ahora tiene que guardar este archivo con un nombre específico:

	{directorio}/indent/{tipo-de-archivo}.vim

El {tipo-de-archivo} es el nombre del tipo de archivo, por ejemplo, «cpp» o
«java». Puede ver el nombre exacto de archivo que Vim ha detectado con la
siguiente orden: >

	:set filetype

En este archivo, el resultado es:

	filetype=help ~

Entonces, usaría «help» para {tipo-de-archivo}.
   Para la parte de {directorio}, necesita usar su directorio de tiempo de ejecución.
Mire la salida de esta orden: >

	set runtimepath

Ahora use el primer elemento, el nombre que precede a la primera coma. Así,
la salida tiene el siguiente aspecto:

	runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~

Puede usar «~/.vim» para el {directorio}. Entonces, el nombre del archivo
resultante es:

	~/.vim/indent/help.vim ~

En lugar de desactivar el sangrado, podría escribir su propio archivo de
sangrado. La manera de hacerlo se explica aquí: |indent-expression|.

==============================================================================
*30.4*	Otros sangrados

La forma más simple de sangrado automático es con la opción 'autoindent',
ya que usa el sangrado de la línea anterior. La opción 'smartindent' es un poco más
inteligente. Es útil con aquellos lenguajes que no disponen de un archivo de sangrado.
'smartindent' no es tan inteligente como 'cindent', pero es más inteligente que
'autoindent'.
  Si 'smartindent' está definido, se añadirá un nivel adicional de sangrado para cada
«{», y se eliminará para cada «}». También se añadirá un nivel adicional de sangrado para
cada palabra en la opción 'cinwords'. Las líneas que empiezan con «#» se tratan de forma
especial: todo el sangrado se elimina. Esto se hace de forma que todas las directivas de
preproceso empiecen en la primera columna. El sangrado se restaura en la siguiente línea.


CORREGIR EL SANGRADO

Cuando use 'autoindent' o 'smartindent' para obtener el sangrado de línea anterior,
habrá ocasiones en que necesite añadir o eliminar un 'shiftwidth' de sangrado. La
forma rápida de hacerlo es usando las órdenes «CTRL-D» y «CTRL-T» en modo Insertar.
   Por ejemplo, está escribiendo un script de consola con el siguiente aspecto:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	fi ~

Empiece por definir estas opciones: >

	:set autoindent shiftwidth=3

Puede empezar a escribir la primer línea, <Intro>, y el principio de la
segunda:

	if test -n a; then ~
	echo ~

Ahora ve que necesita un sangrado adicional. Pulse«CTRL-T». El resultado:

	if test -n a; then ~
	   echo ~

La orden «CTRL-T», en modo Insertar, añade un 'shiftwidth' al sangrado, sin
importar en que línea está.
   Continua escribiendo en la segunda línea, <Intro>, y la tercera línea. Esta
vez el sangrado es correcto. Pulse <Intro> y salte a la última línea. Ahora
tiene lo siguiente:

	if test -n a; then ~
	   echo a ~
	   echo "-------" ~
	   fi ~

Para eliminar el sangrado innecesario en la última línea pulse «CTRL-D». Esto elimina
un 'shiftwidth' de sangrado, sin importar donde está dentro de la línea.
   Cuando está en modo Normal, puede usar las órdenes «>>» y «<<» para cambiar
las líneas. «>» y «<» son operadores, y por ello tiene las tres formas habituales de
definir las líneas que desea sangrar. Una combinación útil es la siguiente: >

	>i{

Esto añade un sangrado al bloque de líneas actual, dento de «{}». Las líneas
«{» y «}» se dejan sin modificar, mientras que «>a}» las incluye. En este
ejemplo, el cursor está sobre «printf»:

	texto original		después de «>i{»		después de «>a{»

	if (flag)		if (flag)		if (flag) ~
	{			{			    { ~
	printf("yes");		    printf("yes");	    printf("yes"); ~
	flag = 0;		    flag = 0;		    flag = 0;  ~
	}			}			    } ~

==============================================================================
*30.5*	Tabulados y espacios

Por omisión, 'tabstop' está definido con un valor de 8. Aunque puede cambiarlo,
puede que se encuentre con problemas en el futuro. Otros programas no sabrán
qué valor de «tabstop» (tabulación) usó. Probablemente, usan el valor predefinido
de 8, y por ello su texto presentaría un aspecto diferente. Además, la mayoría de
impresoras usan un valor de «tabstop» predefinido de 8. Por ello, es mejor
no modificar 'tabstop'. (Cuando edite un archivo que se escribió con otro valor de
tabulación, consulte |25.3| para ver como arreglarlo).
   Para insertar un sangrado en un programa, usar un múltiplo de ocho espacios
hace que vaya rápidamente al borde derecho de la ventana. Usar un sólo espacio
no ofrece la suficiente diferencia visual. La mayoría de personas prefieren usar
cuatro espacios, una buena solución.
  Ya que <Tab> equivale a 8 espacios y quiere usar un sangrado de cuatro espacios.
no puede usar <Tab> para insertar su sangrado. Hay dos formas de tratar esto:

1. Use una mezcla de <Tab> y caracteres de espacio. Ya que <Tab> toma el
    el lugar de 8 espacios, tendrá menos caracteres en su archivo. Insertar un <Tab>
    es más rápido que 8 espacios. La tecla de retroceso también es más rápido.

2. Utilice espacios solamente.  Esto evita los problemas con los programas que utilizan un
    valor de «tabstop» diferente.

Afortunadamente, Vim soporta ambos métodos bastante bien.


ESPACIOS Y TABULADOS

If you are using a combination of tabs and spaces, you just edit normally.
The Vim defaults do a fine job of handling things.
   You can make life a little easier by setting the 'softtabstop' option.
This option tells Vim to make the <Tab> key look and feel as if tabs were set
at the value of 'softtabstop', but actually use a combination of tabs and
spaces.
   After you execute the following command, every time you press the <Tab> key
the cursor moves to the next 4-column boundary: >

	:set softtabstop=4

When you start in the first column and press <Tab>, you get 4 spaces inserted
in your text.  The second time, Vim takes out the 4 spaces and puts in a <Tab>
(thus taking you to column 8).  Thus Vim uses as many <Tab>s as possible, and
then fills up with spaces.
   When backspacing it works the other way around.  A <BS> will always delete
the amount specified with 'softtabstop'.  Then <Tab>s are used as many as
possible and spaces to fill the gap.
   The following shows what happens pressing <Tab> a few times, and then using
<BS>.  A "." stands for a space and "------->" for a <Tab>.

	type			  result ~
	<Tab>			  ....
	<Tab><Tab>		  ------->
	<Tab><Tab><Tab>		  ------->....
	<Tab><Tab><Tab><BS>	  ------->
	<Tab><Tab><Tab><BS><BS>   ....

An alternative is to use the 'smarttab' option.  When it's set, Vim uses
'shiftwidth' for a <Tab> typed in the indent of a line, and a real <Tab>
when typed after the first non-blank character.  However, <BS> doesn't work
like with 'softtabstop'.


SÓLO ESPACIOS

Puede definir la opción 'expandtab' para evitar tabulaciones en su archivo:
>

	:set expandtab

Cuando se define esta opción, la tecla <Tab> inserte una serie de espacios.
Por ello, obtiene el mismo espacio en blanco que un carácter <Tab> inserta,
aunque en realidad no hay ningún carácter <Tab> en su archivo.
  La tecla de retroceso eliminará cada espacio por sí mismo. Por ello,
después de teclear un <Tab>, tendrá que pulsar la tecla <BS> (retroceso)
hasta ocho veces para deshacerlo. Si está dentro de la sangría, pulsar
«CTRL-D» es mucho más rápido.


CAMBIAR TABULADOS A ESPACIOS (Y VICEVERSA)

Definir 'expandtab' no afecta a las tabulaciones existentes. En otras
palabras, todas las tabulaciones del documento siguen siéndolo. Si desea
convertir esas tabulaciones en espacios, use la orden «:retab». Use las
siguientes órdenes: >

	:set expandtab
	:%retab

Ahora, Vim ha cambiado todas las sangrías para que usen espacios en lugar de
tabulados. Sin embargo, se respetan todos los tabulados a continuación de un
carácter no vacío. Añada «!» si desea convertir éstos también: >

	:%retab!

Esto es algo peligroso, ya que también puede cambiar los tabulados dentro de
una cadena. Puede usar lo siguiente para comprobar la existencia de éstos: >

	/"[^"\t]*\t[^"]*"

Se recomienda no usar tabulados rígidos dentro de una cadena. Reemplácelos
con «\t» para evitar problemas.

Esta otra forma ofrece el mismo resultado: >

	:set noexpandtab
	:%retab!

==============================================================================
*30.6*	Formatear comentarios

One of the great things about Vim is that it understands comments.  You can
ask Vim to format a comment and it will do the right thing.
   Suppose, for example, that you have the following comment:

	/* ~
	 * This is a test ~
	 * of the text formatting. ~
	 */ ~

You then ask Vim to format it by positioning the cursor at the start of the
comment and type: >

	gq]/

"gq" is the operator to format text.  "]/" is the motion that takes you to
the end of a comment.  The result is:

	/* ~
	 * This is a test of the text formatting. ~
	 */ ~

Notice that Vim properly handled the beginning of each line.
  An alternative is to select the text that is to be formatted in Visual mode
and type "gq".

To add a new line to the comment, position the cursor on the middle line and
press "o".  The result looks like this:

	/* ~
	 * This is a test of the text formatting. ~
	 * ~
	 */ ~

Vim has automatically inserted a star and a space for you.  Now you can type
the comment text.  When it gets longer than 'textwidth', Vim will break the
line.  Again, the star is inserted automatically:

	/* ~
	 * This is a test of the text formatting. ~
	 * Typing a lot of text here will make Vim ~
	 * break ~
	 */ ~

For this to work some flags must be present in 'formatoptions':

	r	insert the star when typing <Enter> in Insert mode
	o	insert the star when using "o" or "O" in Normal mode
	c	break comment text according to 'textwidth'

Para más detalles, consulte |fo-table|.


DEFINIR UN COMENTARIO

The 'comments' option defines what a comment looks like.  Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.
   Many single-line comments start with a specific character.  In C++ // is
used, in Makefiles #, in Vim scripts ".  For example, to make Vim understand
C++ comments: >

	:set comments=://

The colon separates the flags of an item from the text by which the comment
is recognized.  The general form of an item in 'comments' is:

	{flags}:{text}

The {flags} part can be empty, as in this case.
   Several of these items can be concatenated, separated by commas.  This
allows recognizing different types of comments at the same time.  For example,
let's edit an e-mail message.  When replying, the text that others wrote is
preceded with ">" and "!" characters.  This command would work: >

	:set comments=n:>,n:!

There are two items, one for comments starting with ">" and one for comments
that start with "!".  Both use the flag "n".  This means that these comments
nest.  Thus a line starting with ">" may have another comment after the
">".  This allows formatting a message like this:

	> ! Did you see that site? ~
	> ! It looks really great. ~
	> I don't like it.  The ~
	> colors are terrible. ~
	What is the URL of that ~
	site? ~

Try setting 'textwidth' to a different value, e.g., 80, and format the text
by Visually selecting it and typing "gq".  The result is:

	> ! Did you see that site?  It looks really great. ~
	> I don't like it.  The colors are terrible. ~
	What is the URL of that site? ~

You will notice that Vim did not move text from one type of comment to
another.  The "I" in the second line would have fit at the end of the first
line, but since that line starts with "> !" and the second line with ">",
Vim knows that this is a different kind of comment.


A THREE PART COMMENT

A C comment starts with "/*", has "*" in the middle and "*/" at the end.
The entry in 'comments' for this looks like this: >

	:set comments=s1:/*,mb:*,ex:*/

The start is defined with "s1:/*".  The "s" indicates the start of a
three-piece comment.  The colon separates the flags from the text by which the
comment is recognized: "/*".  There is one flag: "1".  This tells Vim that the
middle part has an offset of one space.
   The middle part "mb:*" starts with "m", which indicates it is a middle
part.  The "b" flag means that a blank must follow the text.  Otherwise Vim
would consider text like "*pointer" also to be the middle of a comment.
   The end part "ex:*/" has the "e" for identification.  The "x" flag has a
special meaning.  It means that after Vim automatically inserted a star,
typing / will remove the extra space.

Para más detalles, véase |format-comments|.

==============================================================================

Capítulo siguiente: |usr_31.esx| Sacar partido a la interfaz gráfica

Copyright: véase |manual-copyright| vim:tw=78:ts=8:ft=help:norl:

==============================================================================

Traducción del capítulo: Omar Campagne Polaino

Proyecto: |vim-doc-es|

