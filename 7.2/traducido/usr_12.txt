*usr_12.txt*	For Vim version 7.2.  Last change: 2007 May 11

                MANUAL DE USUARIO DE VIM - por Bram Moolenaar

				    Trucos


Combinando varios comandos puedes conseguir que Vim haga casi cualquier cosa.
En este capítulo, presentaremos una serie de combinaciones útiles.  Esto
emplea los comandos introducidos en capítulos anteriores y algunos más.

|12.1|  Reemplazar una palabra
|12.2|  Cambiar "Último, Primero" a "Primero Último"
|12.3|  Ordenar una lista
|12.4|  Invertir el orden de las líneas
|12.5|  Contar palabras
|12.6|  Encontrar una página del manual
|12.7|  Eliminar espacios en blanco sobrantes
|12.8|  Buscar dónde se emplea una palabra

 Capítulo siguiente: |usr_20.txt|  Ser eficaz con la línea de comandos
  Capítulo anterior: |usr_11.txt|  Recuperación de errores
         Contenidos: |usr_toc.txt|

==============================================================================
*12.1*  Reemplazar una palabra

El comando sustituir puede ser empleado para reemplazar todos los casos de una
palabra con otra: >

	:%s/cuatro/4/g

El rango "%" significa reemplazar en todas las líneas.  La bandera "g" al final
hace que todas las palabras de una línea sean sustituidas.
   Esto no hará lo que deseas si tu archivo también contiene "veinticuatro".
Será reemplazado por "veinti4".  Para evitar que esto ocurra usa el "\<" para
concordar el comienzo de una palabra. >

	:%s/\<cuatro/4/g

Obviamente, esto también funcionará mal con "cuatrocientos".  Usa "\>" para
concordar el final de una palabra: >

	:%s/\<cuatro\>/4/g

Si estás programando, quizá quieras reemplazar "cuatro" en los comentarios,
pero no en el código.  Ya que es difícil de especificar, añade la bandera "c"
para ser preguntado cada vez que se vaya a reemplazar la palabra: >


	:%s/\<cuatro\>/4/gc


REEMPLAZAR EN VARIOS ARCHIVOS

Supón que quieres reemplazar una palabra en más de un archivo.  Puedes editar
cada archivo y escribir el comando manualmente.  Es mucho más fácil usar la
grabación y reproducción.
   Vamos a asumir que tienes un directorio con archivos C++ en el que todos
terminan en ".cpp".  Quieres renombrar la función "GetResp" a "GetAnswer".

	vim *.cpp		Arranca Vim definiendo la lista de argumentos
				conteniendo todos los archivos C++.  Estarás
				ahora en el primer archivo.
	qq			Comienza a grabar en el registro q.
	:%s/\<GetResp\>/GetAnswer/g
				Reemplaza en el primer archivo.
	:wnext			Graba este archivo y ve al siguiente.
	q			Para la grabación.
	@q			Ejecuta el registro q.  Esto ejecutará la
				sustitución y el comando ":wnext".  Puedes
				comprobar que esto no produzca ningún error.
	999@q			Ejecuta el registro q en el resto de archivos.

En el último archivo obtendrás un mensaje de error, porque "wnext" no puede ir
a un archivo siguiente.  Esto parará la ejecución y todo terminará.

	Note:
	Cuando vuelvas a reproducir una secuencia grabada, un error parará la
	ejecución.  Cuida de no producir errores cuando grabes.

Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra
"GetResp", obtendrás un error y la ejecución se parará.  Para evitar esto,
añade la bandera "e" al comando sustituir: >

	:%s/\<GetResp\>/GetAnswer/ge

La bandera "e" le dice a ":substitute" que ninguna coincidencia no es un error.

==============================================================================
*12.2*  Cambiar "Último, Primero" a "Primero Último"

Tienes una lista de nombre de la siguiente forma:

	Pepe, Juan ~
	Amancio, Pedro ~

Quieres cambiarlo a:

	Juan Pepe ~
	Pedro Amancio ~

Esto se puede hacer con un solo comando: >

	:%s/\([^,]*\), \(.*\)/\2 \1/

Veámoslo por partes.  Obviamente comienza con el comando substitute .  El "%"
es el rango de líneas, que se refiere al archivo completo.  Por lo tanto la
sustitución se producirá en cada línea del archivo.
   Los argumentos para el comando sustituir son "/desde/a/".  Las barras
separan el patrón "desde" y la cadena "hacia".  Esto es lo que el patrón
"desde" contiene:
							\([^,]*\), \(.*\) ~

	La primera parte entre \( \) concuerda "Último" \(     \)
	    concordar cualquier cosa excepto una coma     [^,]
	    cualquier número de veces                         *
	concuerda literalmente ", "                              ,
	La segunda parte entre \(  \) concuerda "Primero"          \(  \)
	    cualquier carácter                                       .
	    cualquier número de veces                                 *

En la parte "a" tenemos "\2" y "\1".  A esto se le llaman referencias "vuelta
atrás".  Refieren al texto encontrado por los "\( \)" del patrón.  "\2" se
refiere al texto del segundo "\( \)", que es el nombre "Pimero".  "\1" se
refiere al primer "\( \)", que es el nombre "Último".
   Puedes usar hasta nueve referencias "vuelta atrás" en la parte "a" de un
comando sustitución.  "\0" se refiere a la cadena coincidente completa.  Hay
otros elementos especiales en un comando sustituir, ver |sub-replace-special|.

==============================================================================
*12.3*	Sort a list

En un archivo Makefile tienes a menudo una lista de archivos.  Por ejemplo:

	OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~

Para ordenar esta lista, filtra el texto a través del comando externo sort: >

	/^OBJS
	j
	:.,/^$/-1!sort

Esto va a la primera línea, donde "OBJS" es lo primero que se encuentra en una
línea.  Luego baja una línea y filtra las líneas hasta encontrar una línea
vacía.  También podrías seleccionar las líneas en modo Visual y escribir
"!sort".  Es más fácil pero conlleva más trabajo cuando hay muchas líneas.
   El resultado es el siguiente:

	OBJS = \ ~
		backup.o ~
		getopt.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		pch.o \ ~
		util.o \ ~
		version.o \ ~


Observa que una barra invertida al final de cada línea se usa para indicar que
la línea continúa.  Tras ordenar, está mal puesto.  La línea de "backup.o" que
estaba al final no tenía una barra invertida.  Ahora que se sitúa en otro
lugar debe tener una barra invertida.
   La solución más sencilla es añadirla con "A \<Esc>".  Puedes mantener la
barra en la última línea si te aseguras de que una línea en blanco viene justo
después.  De este modo no tendrás este problema de nuevo.

==============================================================================
*12.4*  Invertir el orden de las líneas

El comando |:global| debe ser combinado con el comando |:move| para mover
todas las líneas antes de la primera línea, invirtiendo el archivo.  Escribe:
>
	:global/^/m 0

Abreviado: >

	:g/^/m 0

La expresión regular "^" coincide con el comienzo de línea (incluso si la
línea está en blanco).  El comando |:move| mueve la línea justo después de la
mítica "línea cero", de forma que se convierte en la primera línea.  Como el
comando |:global| no se confunde al cambiar la numeración de las líneas,
|:global| procede a concordar el resto de líneas del archivo y pone cada una
como la primera.

Esto también funciona sobre un rango de líneas.  Primero ve a la línea de
encima de la primera y márcala con "mt".  Luego pon el cursor en la última
línea del rango y escribe: >

	:'t+1,.g/^/m 't

==============================================================================
*12.5*  Contar palabras

A veces puedes escribir un texto con un número máximo de palabras.  Vim puede
contar las palabras por ti.
   Cuando quieres usar el archivo completo para contar las palabras, usa el
siguiente comando: >

	g CTRL-G

No teclees un espacio tras la g, esto está aquí para hacer que el comando sea
fácil de leer.
   La salida tendrá este aspecto:

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~

Puedes ver en qué palabra estás (748), y el número total de palabras en el
archivo (774).

Cuando el texto sea sólo una parte del archivo, puedes ir al comienzo del
texto, escribir "g CTRL-G", ir al final del texto y volver a escribir "g
CTRL-G" y usar la cabeza para calcular la diferencia.  Es un buen ejercicio,
pero hay un modo más sencillo.  Con el modo Visual, selecciona el texto sobre
el que quieres contar las palabras.  Escribe "g CTRL-G".  El resultado será:

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~

Para otras formas de contar las palabras, líneas y otros, ver |count-items|.

==============================================================================
*12.6*  Encontrar una palabra del manual		*find-manpage*

Mientras editas un script de shell o un programa C, estás usando un comando o
función para el que quieres encontrar una página de manual (en Unix).  Vamos a
usar la forma sencilla.  Pon el cursor sobre la palabra y pulsa: >

	K

Vim ejecutará el programa externo "man" sobre la palabra.  Si la página man es
encontrada, se mostrará.  Esto usa el paginador normal para desplazarse por el
texto (con el programa "more").  Cuando llegues al final, presionando <Entrar>
te devolverá a Vim.

Una desventaja es que no puedes ver la página man y el texto en el que
trabajas al mismo tiempo.  Hay un truco para hacer que la página man aparezca
en una ventana de Vim.  Primero carga el plugin del tipo de archivo man: >

	:runtime! ftplugin/man.vim

Pon este comando en tu archivo vimrc si tienes intención de hacer esto a
menudo.  Ahora puedes usar ":Man" para ver una página man en una ventana: >

	:Man csh

Puedes desplazarte alrededor y el texto será coloreado.  Esto te permite
encontrar la ayuda que estabas buscando.  Usa CTRL-W w para saltar a la
ventana con el texto en el que trabajabas.
   Para encontrar la página man en una sección específica, pon el número de
sección primero.  Por ejemplo, para ver "echo" en la sección 3: >

	:Man 3 echo

Para saltar a otra página man, la cuál está en el texto con la forma típica
"word(1)", pulsa CTRL-] sobre ella.  Otros llamadas a ":Man" emplearán la
misma ventana.

Para mostrar una página man para la palabra bajo el cursor usa lo siguiente: >

	\K

(Si has redefinido <Leader>, úsalo en lugar de la barra invertida).  Por
ejemplo, puede que quieras saber el valor que te devuelve "strstr()" mientras
editas esta línea:

	if ( strstr (input, "aap") == ) ~

Pon el cursor en alguna parte de "strstr" y escribe "\K".  A continuación una
ventana se abrirá para mostrar la página man de strstr().

==============================================================================
*12.7*  Eliminar espacios en blanco sobrantes

Algunas personas encuentras los espacios y los tabuladores al final de línea
inútiles y feos.  Para eliminar el espacio en blando al final de cada línea,
ejecuta el siguiente comando: >

	:%s/\s\+$//

El rango de línea "%" es empleado, funcionando sobre todo el archivo.  El
patrón que el comando ":substitute" concuerda es el "\s\+$".  Esto encuentra
los caracteres en blanco (\s), 1 o más (\+), antes del final de línea ($).
Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.
   La parte "hacia" del comando sustituir está vacía: "//".  Por lo tanto
reemplaza con nada, lo que de hecho elimina el espacio en blanco.

Otro uso desafortunado de los espacios es colocarlos antes de un tabulador.  A
menudo pueden ser eliminados sin cambiar la cantidad de espacio en blanco.
¡Pero no siempre! Por lo tanto, lo mejor es que lo hagas a mano. Usa esto: >

	/	

No puedes verlo, pero hay un espacio antes de un tabulador en este comando.
De hecho, es "/<Espacio><Tabulador>".  Ahora usa "x" para eliminar el espacio
y comprobar que la cantidad de espacio en blanco no cambia.  Puede que tengas
que insertar un tabulador si cambia.  Teclea "n" para encontrar la próxima
coincidencia.  Repite esto hasta que no se encuentren más concordancias.

==============================================================================
*12.8*	Buscar dónde se emplea una palabra

Si eres un usuario UNIX, puedes usar una combinación de Vim y grep para editar
todos los archivos que contengan la palabra dada.  Esto es extremadamente útil
si estás trabajando en un programa y quieres ver o editar todos los archivos
que contienen una variable específica.
   Por ejemplo, supón que quieres editar todos los archivos C que contengan la
palabra "frame_counter".  Para hacer esto usa el comando: >

	vim `grep -l frame_counter *.c`

Veamos este comando en detalle.  El comando grep busca a través de un conjunto
de archivos una palabra dada.  Ya que especificamos el argumento -l, el
comando sólo listará archivos que contengan la palabra y no impriman las
líneas coincidentes.  La palabra que está buscando es "frame_counter".  De
hecho, esto puede ser cualquier expresión regular.  (Note: las expresiones
regulares en Vim y grep no siguen las mismas convenciones.)
   El comando está arropado por acentos invertidos (`).  Esto le dice al shell
de UNIX que ejecute el comando y haga como si el resultado hubiese sido
escrito en la línea de comandos.  Por lo tanto el comando grep será ejecutado
y producirá una lista de archivos, estos archivos serán puestos en la línea de
comandos de Vim.  Podrás usar los comandos ":next" y ":first" para navegar
entre los archivos.


ENCONTRAR CADA LÍNEA

El comando de arriba sólo dice los archivos en los cuáles se encuentra la
palabra.  Todavía tendrás que encontrar la palabra entre los archivos.
   Vim tiene un comando embebido que puedes usar para buscar una cadena en un
conjunto de archivos.  Si quieres encontrar todas las coincidencias de
"error_string" en todos los archivos C, por ejemplo, introduce lo siguiente: >

	:grep error_string *.c

Esto hace que Vim busque la cadena "error_string" en cada uno de los archivos
especificados (*.c).  El editor abrirá el primer archivo donde se produzca una
concordancia y posicionará el cursor en la primera línea coincidente.
Para ir a la siguiente línea (no importa en que archivo se encuentre), usa el
comando ":cnext".  Para ir a la anterior, usa ":cprev".  Usa ":clist" para ver
todas las coincidencias y dónde están.
  El comando ":grep" usa el comando externo grep en Unix y findstr en Windows.
Puedes cambiar esto modificando la opción 'grepprg'.

==============================================================================

Capítulo siguiente: |usr_20.txt|  Ser eficaz con la línea de comandos

Copyright: ver |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
