# Vim l10n es http://code.assembla.com/vim-doc-es/git/nodes/master 
#
# Copyright (C) 2009 
# This file is distributed under the same license as the Vim 7.2 package.
#
# Translators credits:
#   - Initial translation
#      Álvaro Castro Castilla <alvaro.castro.castilla@gmail.com>
#
#   - Updates
#       TRADUCTOR <CORREO>, AÑO 
#
# 
#
# Debido al formato (txt) y al máximo de 80 columnas que pueden tener 
# los textos de ayuda en Vim, así como el formato PO, por favor, leete los
# apuntes concernientes a la edición de los archivos PO relativos a la
# aplicación que desees usar.
# También encontrarás información acerca del uso de herramientas gettext en el 
# proyecto de localización (l10n) de Vim.
# 
# - http://www.assembla.com/wiki/show/vim-doc-es
#
# No somos parte del proyecto de traducción en Debian. Sin embargo, creemos que
# este enlace puede ser de interés. A pesar de no formar parte, nuestra 
# intención es homologarnos con su terminología y uso de la lengua 
# en la medida de lo útil y posible.
# 
#  - El proyecto de traducción de Debian al español
#     http://www.debian.org/intl/spanish/notas
# 
# La R.A.E. no es un inmenso referente en cuanto a términos tecnológicos,
# pero también puede servir de referencia para otros términos no técnicos.
# No pretendemos hacer es_ES, es_CO, es_AR, etc..., sino que la misma
# traducción sea comprensible independientemente de la nacionalidad del
# usuario. Si crees que alguna traducción puede llevar a confusión, consulta
# la R.A.E., o el diccionario de Maria Moliner, y escribe un correo.
# 
#  - www.rae.es 
#  - http://www.diclib.com/cgi-bin/d1.cgi?base=moliner&page=showpages   
# 
# Disponemos también de un archivo «terminology.po» en «/recursos_de..» que
# se puede consultar con un simple grep, pogrep o cargado en Virtaal.
# 
#. extracted from usr_10.txt

msgid ""
msgstr ""
"Project-Id-Version: Vim 7.2\n"
"Report-Msgid-Bugs-To: bugs@vim.org\n"
"POT-Creation-Date: 2009-08-01 19:54+0200\n"
"PO-Revision-Date: 2009-09-19 18:31+0200\n"
"Last-Translator: Álvaro Castro Castilla <alvaro.castro.castilla@gmail.com>\n"
"Language-Team: Documentación de Vim en español\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Virtaal 0.4.0\n"

#: usr_10.txt:1
msgid "*usr_10.txt*\tFor Vim version 7.2.  Last change: 2006 Nov 05"
msgstr "*usr_10.esx*\tPara Vim versión 7.2.  Último cambio: 2006 Nov 05"

#: usr_10.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr "\t\t MANUAL DE USUARIO DE VIM - por Bram Moolenaar"

#: usr_10.txt:5
msgid "\t\t\t     Making big changes"
msgstr "\t\t\t   Realizar grandes cambios"

#: usr_10.txt:8
msgid ""
"In chapter 4 several ways to make small changes were explained.  This "
"chapter\n"
"goes into making changes that are repeated or can affect a large amount of\n"
"text.  The Visual mode allows doing various things with blocks of text.  "
"Use\n"
"an external program to do really complicated things."
msgstr ""
"En el capítulo 4 se explicaron algunas formas de hacer cambios pequeños. "
"Este\n"
"capítulo tratará de cambios que se repiten o que afectan a grandes\n"
"porciones del texto. El modo Visual permite hacer varias cosas con bloques\n"
"de texto. Use un programa externo para hacer las cosas más complicadas."

#: usr_10.txt:13
msgid ""
"|10.1|\tRecord and playback commands\n"
"|10.2|\tSubstitution\n"
"|10.3|\tCommand ranges\n"
"|10.4|\tThe global command\n"
"|10.5|\tVisual block mode\n"
"|10.6|\tReading and writing part of a file\n"
"|10.7|\tFormatting text\n"
"|10.8|\tChanging case\n"
"|10.9|\tUsing an external program"
msgstr ""
"|10.1|\tÓrdenes de grabación y reproducción\n"
"|10.2|\tSustitución\n"
"|10.3|\tRangos de aplicación\n"
"|10.4|\tLas órdenes globales\n"
"|10.5|\tEl modo de bloque Visual\n"
"|10.6|\tLeer y escribir parte de un archivo\n"
"|10.7|\tFormatear texto\n"
"|10.8|\tCambiar mayúsculas y minúsculas\n"
"|10.9|\tUso de un programa externo"

#: usr_10.txt:23
msgid ""
"     Next chapter: |usr_11.txt|  Recovering from a crash\n"
" Previous chapter: |usr_09.txt|  Using the GUI\n"
"Table of contents: |usr_toc.txt|"
msgstr ""
" Capítulo siguiente: |usr_11.esx|  Recuperarse de un fallo\n"
"  Capítulo anterior: |usr_09.esx|  Uso de la interfaz gráfica\n"
"Tabla de contenidos: |usr_toc.esx|"

#: usr_10.txt:27
msgid ""
"==============================================================================\n"
"*10.1*\tRecord and playback commands"
msgstr ""
"==============================================================================\n"
"*10.1*\tÓrdenes de grabación y reproducción"

#: usr_10.txt:30
msgid ""
"The \".\" command repeats the preceding change.  But what if you want to do\n"
"something more complex than a single change?  That's where command "
"recording\n"
"comes in.  There are three steps:"
msgstr ""
"La orden «.» repite el cambio precedente. ¿Pero qué ocurre si quiere hacer\n"
"algo más complicado que un simple cambio? Para eso tenemos la orden\n"
"de grabación («:recording»). Hay que seguir tres pasos:"

#: usr_10.txt:34
msgid ""
"1. The \"q{register}\" command starts recording keystrokes into the "
"register\n"
"   named {register}.  The register name must be between a and z.\n"
"2. Type your commands.\n"
"3. To finish recording, press q (without any extra character)."
msgstr ""
"1. La orden «q{registro}» inicia la grabación de teclas pulsadas en un\n"
"   registro llamado {registro}. El nombre del registro es una letra (a-z).\n"
"2. Introduzca las órdenes.\n"
"3. Para finalizar la grabación, pulse «q» (sin ningún carácter extra)."

#: usr_10.txt:39
msgid "You can now execute the macro by typing the command \"@{register}\"."
msgstr "Puede ejecutar la macro tecleando la orden «@{registro}»"

#: usr_10.txt:41
msgid ""
"Take a look at how to use these commands in practice.  You have a list of\n"
"filenames that look like this:"
msgstr ""
"Vamos a echarle un vistazo a cómo se usan las órdenes en la práctica. Tiene\n"
"una lista de nombres de archivo como esta:"

#: usr_10.txt:44
msgid ""
"\tstdio.h ~\n"
"\tfcntl.h ~\n"
"\tunistd.h ~\n"
"\tstdlib.h ~"
msgstr ""
"\tstdio.h ~\n"
"\tfcntl.h ~\n"
"\tunistd.h ~\n"
"\tstdlib.h ~"

#: usr_10.txt:49
msgid "And what you want is the following:"
msgstr "Y lo que quiere es lo siguiente:"

#: usr_10.txt:51
msgid ""
"\t#include \"stdio.h\" ~\n"
"\t#include \"fcntl.h\" ~\n"
"\t#include \"unistd.h\" ~\n"
"\t#include \"stdlib.h\" ~"
msgstr ""
"\t#include \"stdio.h\" ~\n"
"\t#include \"fcntl.h\" ~\n"
"\t#include \"unistd.h\" ~\n"
"\t#include \"stdlib.h\" ~"

#: usr_10.txt:56
msgid ""
"You start by moving to the first character of the first line.  Next you\n"
"execute the following commands:"
msgstr ""
"Comienza desplazándose al primer carácter de la primera línea. A "
"continuación\n"
"ejecute la siguiente orden:"

#: usr_10.txt:59
msgid ""
"\tqa\t\t\tStart recording a macro in register a.\n"
"\t^\t\t\tMove to the beginning of the line.\n"
"\ti#include \"<Esc>\tInsert the string #include \" at the beginning\n"
"\t\t\t\tof the line.\n"
"\t$\t\t\tMove to the end of the line.\n"
"\ta\"<Esc>\t\t\tAppend the character double quotation mark (\")\n"
"\t\t\t\tto the end of the line.\n"
"\tj\t\t\tGo to the next line.\n"
"\tq\t\t\tStop recording the macro."
msgstr ""
"\tqa\t\t\tComenzar a grabar la macro en el registro «a».\n"
"\t^\t\t\tIr al comienzo de la línea.\n"
"\ti#include \"<Esc>\tInsertar el #include \" al comienzo de cada\n"
"\t\t\t\tlínea.\n"
"\t$\t\t\tIr al final de la línea.\n"
"\ta\"<Esc>\t\t\tAñadir el carácter de comillas dobles (\") al\n"
"\t\t\t\tfinal de la línea.\n"
"\tj\t\t\tIr a la próxima línea.\n"
"\tq\t\t\tDetener la grabación de la macro."

#: usr_10.txt:69
msgid ""
"Now that you have done the work once, you can repeat the change by typing "
"the\n"
"command \"@a\" three times.\n"
"   The \"@a\" command can be preceded by a count, which will cause the macro "
"to\n"
"be executed that number of times.  In this case you would type: >"
msgstr ""
"Ahora que ha realizado el trabajo una vez, puede repetir el cambio "
"tecleando\n"
"la orden «@a» tres veces.\n"
"   La orden «@a» puede venir precedido de un multiplicador, el cuál causará\n"
"que la macro se ejecute ese número determinado de veces. En este caso: >"

#: usr_10.txt:74
msgid "\t3@a"
msgstr "\t3@a"

#: usr_10.txt:77
msgid "MOVE AND EXECUTE"
msgstr "MOVER Y EJECUTAR"

#: usr_10.txt:79
msgid ""
"You might have the lines you want to change in various places.  Just move "
"the\n"
"cursor to each location and use the \"@a\" command.  If you have done that "
"once,\n"
"you can do it again with \"@@\".  That's a bit easier to type.  If you now\n"
"execute register b with \"@b\", the next \"@@\" will use register b.\n"
"   If you compare the playback method with using \".\", there are several\n"
"differences.  First of all, \".\" can only repeat one change.  As seen in "
"the\n"
"example above, \"@a\" can do several changes, and move around as well.\n"
"Secondly, \".\" can only remember the last change.  Executing a register "
"allows\n"
"you to make any changes and then still use \"@a\" to replay the recorded\n"
"commands.  Finally, you can use 26 different registers.  Thus you can "
"remember\n"
"26 different command sequences to execute."
msgstr ""
"Tal vez tenga las líneas que quiere cambiar en varios lugares. Simplemente\n"
"mueva el cursor a cada ubicación y use la orden «@a». Si ha hecho eso\n"
"una vez, puede repetirlo con «@@». Es un poco más sencillo de teclear. Si\n"
"ejecuta el registro b con «@b», el próximo «@@» usará el registro b.\n"
"   Si compara esto con el método «.», hay varias diferencias. Lo primero,\n"
"«.x sólo puede repetir un cambio. Como ha podido ver en el ejemplo de\n"
"arriba, «@a» puede llevar a cabo varios cambios, incluyendo movimientos.  "
"Por\n"
"otro lado, «.» sólo puede recordar el último cambio. Ejecutar un registro le\n"
"permite hacer algunos cambios en el texto y poder usar todavía las órdenes\n"
"grabadas. Por último, puede usar 26 registros distintos. De este modo\n"
"puede reusar 26 secuencias diferentes."

#: usr_10.txt:92
msgid "USING REGISTERS"
msgstr "USO DE REGISTROS"

#: usr_10.txt:94
msgid ""
"The registers used for recording are the same ones you used for yank and\n"
"delete commands.  This allows you to mix recording with other commands to\n"
"manipulate the registers.\n"
"   Suppose you have recorded a few commands in register n.  When you "
"execute\n"
"this with \"@n\" you notice you did something wrong.  You could try "
"recording\n"
"again, but perhaps you will make another mistake.  Instead, use this trick:"
msgstr ""
"Los registros que se usan para grabar son los mismos que se usan para las\n"
"órdenes de copiar y eliminar. Esto le permite mezclar la grabación con "
"otras\n"
"órdenes para manipular los registros.\n"
"   Suponga que ha grabado algunas órdenes en el registro n. Cuando lo\n"
"ejecuta con «@n», se da cuenta de que algo no va bien. Podría intentar\n"
"grabarlo de nuevo, pero quizá cometa otro error. Mejor usar este truco:"

#: usr_10.txt:101
msgid ""
"\tG\t\t\tGo to the end of the file.\n"
"\to<Esc>\t\t\tCreate an empty line.\n"
"\t\"np\t\t\tPut the text from the n register.  You now see\n"
"\t\t\t\tthe commands you typed as text in the file.\n"
"\t{edits}\t\t\tChange the commands that were wrong.  This is\n"
"\t\t\t\tjust like editing text.\n"
"\t0\t\t\tGo to the start of the line.\n"
"\t\"ny$\t\t\tYank the corrected commands into the n\n"
"\t\t\t\tregister.\n"
"\tdd\t\t\tDelete the scratch line."
msgstr ""
"\tG                       ir al final del archivo\n"
"\to<Esc>                  Crear una nueva línea\n"
"\t\"np                     Pegar el texto del registro n. Verá que las\n"
"\t\t\t\tórdenes que grabó se pegan como texto.\n"
"\t{edits}                 Cambiar las órdenes que están mal. Esto es\n"
"\t\t\t\tcomo editar texto.\n"
"\t0                       Ir al principio de la línea.\n"
"\t\"ny$                    Copiar (yank) las órdenes corregidas al\n"
"\t\t\t\tregistro n.\n"
"\tdd                      Eliminar la línea con las órdenes pegadas."

#: usr_10.txt:112
msgid ""
"Now you can execute the corrected commands with \"@n\".  (If your recorded\n"
"commands include line breaks, adjust the last two items in the example to\n"
"include all the lines.)"
msgstr ""
"Ahora puede ejecutar las órdenes corregidas con «@n». (Si las órdenes\n"
"grabadas incluyen saltos de línea, ajuste los dos últimos puntos explicados\n"
"anteriormente para incluir todas las líneas.)"

#: usr_10.txt:117
msgid "APPENDING TO A REGISTER"
msgstr "AÑADIR A UN REGISTRO"

#: usr_10.txt:119
msgid ""
"So far we have used a lowercase letter for the register name.  To append to "
"a\n"
"register, use an uppercase letter.\n"
"   Suppose you have recorded a command to change a word to register c.  It\n"
"works properly, but you would like to add a search for the next word to\n"
"change.  This can be done with: >"
msgstr ""
"Hasta el momento hemos usado letras en minúscula para el nombre del "
"registro.\n"
"Para añadir a un registro, use una letra en mayúscula.\n"
"   Suponga por un momento que ha grabado una orden para cambiar una\n"
"palabra en el registro c. Funciona correctamente, pero quisiera añadir una\n"
"búsqueda para la siguiente palabra a cambiar. Esto se puede hacer así: >"

#: usr_10.txt:125
msgid "\tqC/word<Enter>q"
msgstr "\tqC/palabra<Entrar>q"

#: usr_10.txt:127
msgid ""
"You start with \"qC\", which records to the c register and appends.  Thus\n"
"writing to an uppercase register name means to append to the register with\n"
"the same letter, but lowercase."
msgstr ""
"Comience con «qC», que añadirá al registro c. De este modo siempre podrá \n"
"escribir el registro al que quieras añadir nuevos pasos mediante la misma\n"
"de letra de identificación, pero en mayúscula."

#: usr_10.txt:131
msgid ""
"This works both with recording and with yank and delete commands.  For\n"
"example, you want to collect a sequence of lines into the a register.  Yank\n"
"the first line with: >"
msgstr ""
"Esto funciona tanto grabando como y con las órdenes de copiar y eliminar. "
"Por\n"
"ejemplo, quieres reunir una secuencia de líneas en un registro. Copie la\n"
"primera línea con: >"

#: usr_10.txt:135
msgid "\t\"aY"
msgstr "\t\"aY"

#: usr_10.txt:137
msgid "Now move to the second line, and type: >"
msgstr "Desplácese a la siguiente línea y escriba: >"

#: usr_10.txt:139
msgid "\t\"AY"
msgstr "\t\"AY"

#: usr_10.txt:141
msgid ""
"Repeat this command for all lines.  The a register now contains all those\n"
"lines, in the order you yanked them."
msgstr ""
"Repita la orden para todas las líneas. El registro «a» contiene ahora\n"
"todas estas líneas, en el orden en el que las ha copiado."

#: usr_10.txt:144
msgid ""
"==============================================================================\n"
"*10.2*\tSubstitution\t\t\t\t\t\t*find-replace*"
msgstr ""
"==============================================================================\n"
"*10.2*\tSustitución"

#: usr_10.txt:147
msgid ""
"The \":substitute\" command enables you to perform string replacements on a\n"
"whole range of lines.  The general form of this command is as follows: >"
msgstr ""
"La orden «:substitute» le permite ejecutar sustituciones de cadenas de\n"
"caracteres en un rango de líneas. La forma general es la siguiente: >"

#: usr_10.txt:150
msgid "\t:[range]substitute/from/to/[flags]"
msgstr "\t:[rango]substitute/de/a/[marcas]"

#: usr_10.txt:152
msgid ""
"This command changes the \"from\" string to the \"to\" string in the lines\n"
"specified with [range].  For example, you can change \"Professor\" to "
"\"Teacher\"\n"
"in all lines with the following command: >"
msgstr ""
"Esta orden cambia la cadena «de» por la cadena «a» en las líneas\n"
"especificadas con [rango]. Por ejemplo, puede cambiar «profesor» por\n"
"«maestro» en todas las líneas con la siguiente orden: >"

#: usr_10.txt:156
msgid ""
"\t:%substitute/Professor/Teacher/\n"
"<\n"
"\tNote:\n"
"\tThe \":substitute\" command is almost never spelled out completely.\n"
"\tMost of the time, people use the abbreviated version \":s\".  From here\n"
"\ton the abbreviation will be used."
msgstr ""
"\t:%substitute/profesor/maestro/\n"
"<\n"
"\tNota:\n"
"\tLa orden «:substitute» casi nunca se escribe completo. La mayoría\n"
"\tde las veces la gente escribe la versión abreviada \":s\". A partir de\n"
"\tahora, se empleará la abreviatura."

#: usr_10.txt:163
msgid ""
"The \"%\" before the command specifies the command works on all lines.  "
"Without\n"
"a range, \":s\" only works on the current line.  More about ranges in the "
"next\n"
"section |10.3|."
msgstr ""
"El «%» antes de la orden especifica que se ejecuta en todas las líneas. Sin\n"
"rango, «:s» sólo funciona en la línea actual. Más sobre los rangos en la\n"
"próxima sección |10.3|."

#: usr_10.txt:167
msgid ""
"By default, the \":substitute\" command changes only the first occurrence "
"on\n"
"each line.  For example, the preceding command changes the line:"
msgstr ""
"Por omisión, la orden «:substitute» cambia sólo la primera palabra\n"
"encontrada en cada línea. Por ejemplo, la orden anterior cambia esta línea:"

#: usr_10.txt:170
msgid "\tProfessor Smith criticized Professor Johnson today. ~"
msgstr "\tEl profesor Pinilla ha criticado hoy al profesor Burgos. ~"

#: usr_10.txt:172
msgid "to:"
msgstr "a esta:"

#: usr_10.txt:174
msgid "\tTeacher Smith criticized Professor Johnson today. ~"
msgstr "\tEl maestro Pinilla ha criticado hoy al profesor Burgos. ~"

#: usr_10.txt:176
msgid ""
"To change every occurrence on the line, you need to add the g (global) "
"flag.\n"
"The command: >"
msgstr ""
"Para cambiar todas palabras que aparezcan en la línea deberá usar la marca "
"g\n"
"(global). La orden: >"

#: usr_10.txt:179
msgid "\t:%s/Professor/Teacher/g"
msgstr "\t:%s/profesor/maestro/g"

#: usr_10.txt:181
msgid "results in (starting with the original line):"
msgstr "da como resultado (ejecutándolo sobre la línea original):"

#: usr_10.txt:183
msgid "\tTeacher Smith criticized Teacher Johnson today. ~"
msgstr "\tEl maestro Pinilla ha criticado hoy al maestro Burgos. ~"

#: usr_10.txt:185
msgid ""
"Other flags include p (print), which causes the \":substitute\" command to "
"print\n"
"out the last line it changes.  The c (confirm) flag tells \":substitute\" to "
"ask\n"
"you for confirmation before it performs each substitution.  Enter the\n"
"following: >"
msgstr ""
"Otras marcas incluyen p (print = imprimir), que hace la orden «:s» muestre\n"
"en pantalla la última línea que cambió. La «c» (confirm = confirmar) le dice "
"a\n"
"«:s» que pida confirmación antes que se ejecute cada sustitución. Introduzca\n"
"lo siguiente: >"

#: usr_10.txt:190
msgid "\t:%s/Professor/Teacher/c"
msgstr "\t:%s/profesor/maestro/c"

#: usr_10.txt:192
msgid ""
"Vim finds the first occurrence of \"Professor\" and displays the text it is\n"
"about to change.  You get the following prompt: >"
msgstr ""
"Vim encuentra la primera aparición de «profesor» y muestra el texto que está "
"a\n"
"punto de cambiar. Le aparecerá la siguiente pregunta: >"

#: usr_10.txt:195
msgid "\treplace with Teacher (y/n/a/q/l/^E/^Y)?"
msgstr "\treplace with maestro (y/n/a/q/l/^E/^Y)?"

#: usr_10.txt:197
msgid "At this point, you must enter one of the following answers:"
msgstr "Aquí puede darle cualquiera de las siguientes respuestas:"

#: usr_10.txt:199
msgid ""
"\ty\t\tYes; make this change.\n"
"\tn\t\tNo; skip this match.\n"
"\ta\t\tAll; make this change and all remaining ones without\n"
"\t\t\tfurther confirmation.\n"
"\tq\t\tQuit; don't make any more changes.\n"
"\tl\t\tLast; make this change and then quit.\n"
"\tCTRL-E\t\tScroll the text one line up.\n"
"\tCTRL-Y\t\tScroll the text one line down."
msgstr ""
"\ty               Si; hacer el cambio.\n"
"\tn               No; omitir esta coincidenci.\n"
"\ta               Todo; hacer este cambio y todos los restantes sin\n"
"\t\t\tpedir más confirmación.\n"
"\tq               Quit; no hacer más cambios.\n"
"\tl               Último; hacer este cambio y salir.\n"
"\tCTRL-E          Desplazar el texto hacia arriba.\n"
"\tCTRL-Y          Desplazar el texto hacia abajo."

#: usr_10.txt:209
msgid ""
"The \"from\" part of the substitute command is actually a pattern.  The "
"same\n"
"kind as used for the search command.  For example, this command only\n"
"substitutes \"the\" when it appears at the start of a line: >"
msgstr ""
"La parte «de» de la orden «:subsitute» es, de hecho, un patrón (del mismo\n"
"tipo de los que se usan para la búsqueda). Por ejemplo, esta orden sólo\n"
"sustituye «Eso» cuando aparece al comienzo de una línea: >"

#: usr_10.txt:213
msgid "\t:s/^the/these/"
msgstr "\t:s/^Eso/Aquello/"

#: usr_10.txt:215
msgid ""
"If you are substituting with a \"from\" or \"to\" part that includes a "
"slash, you\n"
"need to put a backslash before it.  A simpler way is to use another "
"character\n"
"instead of the slash.  A plus, for example: >"
msgstr ""
"Si sustituye con una parte «de» o «a» que incluyan una barra inclinada, "
"tendrá\n"
"que poner una barra invertida antes de él. Una forma más sencilla es usar\n"
"otro carácter como separador en lugar de la barra. Un «+», por ejemplo: >"

#: usr_10.txt:219
msgid "\t:s+one/two+one or two+"
msgstr "\t:s+uno/dos+uno o dos+"

#: usr_10.txt:221
msgid ""
"==============================================================================\n"
"*10.3*\tCommand ranges"
msgstr ""
"==============================================================================\n"
"*10.3*\tRangos de aplicación"

#: usr_10.txt:224
msgid ""
"The \":substitute\" command, and many other : commands, can be applied to a\n"
"selection of lines.  This is called a range.\n"
"   The simple form of a range is {number},{number}.  For example: >"
msgstr ""
"La orden «:substitute» y muchas otras órdenes «:» se pueden aplicar a\n"
"una selección de líneas. A esto se le llama rango.\n"
"   La forma más simple de un rango es {n},{n} (n es un número entero). Por "
"ej:\n"
">"

#: usr_10.txt:228
msgid "\t:1,5s/this/that/g"
msgstr "\t:1,5s/esto/aquello/g"

#: usr_10.txt:230
msgid ""
"Executes the substitute command on the lines 1 to 5.  Line 5 is included.\n"
"The range is always placed before the command."
msgstr ""
"Ejecuta la orden sustituir desde la línea 1 a la 5. La línea 5 queda\n"
"incluida. El rango se sitúa justo antes de la orden."

#: usr_10.txt:233
msgid "A single number can be used to address one specific line: >"
msgstr "Puede emplear un único número para acceder a una línea específica: >"

#: usr_10.txt:235
msgid "\t:54s/President/Fool/"
msgstr "\t:54s/Político/Demagogo/"

#: usr_10.txt:237
msgid ""
"Some commands work on the whole file when you do not specify a range.  To "
"make\n"
"them work on the current line the \".\" address is used.  The \":write\" "
"command\n"
"works like that.  Without a range, it writes the whole file.  To make it "
"write\n"
"only the current line into a file: >"
msgstr ""
"Algunas órdenes funcionan sobre un archivo completo cuando no le especifica\n"
"un rango. Para hacerlos funcionar en la línea actual, use «.». La orden «:"
"write»\n"
"funciona de ese modo. Sin un rango, escribe el archivo\n"
"completo. Para hacer que sólo escriba una línea a un archivo: >"

#: usr_10.txt:242
msgid "\t:.write otherfile"
msgstr "\t:.write otroarchivo"

#: usr_10.txt:244
msgid ""
"The first line always has number one.  How about the last line?  The \"$\"\n"
"character is used for this.  For example, to substitute in the lines from "
"the\n"
"cursor to the end: >"
msgstr ""
"La primera línea siempre tiene como numeración el 1. ¿Pero qué ocurre con "
"la\n"
"última línea? Puede usar el carácter «$» ppara esto.  Por ejemplo, para "
"sustituir\n"
"en las líneas desde la del cursor hasta el final: >"

#: usr_10.txt:248
msgid "\t:.,$s/yes/no/"
msgstr "\t:.,$s/si/no/"

#: usr_10.txt:250
msgid ""
"The \"%\" range that we used before, is actually a short way to say \"1,$\", "
"from\n"
"the first to the last line."
msgstr ""
"El rango «%» que usamos anteriormente es una forma de decir «1,$» (desde la\n"
"primera hasta la última)."

#: usr_10.txt:254
msgid "USING A PATTERN IN A RANGE"
msgstr "USO DE UN PATRÓN EN EL RANGO"

#: usr_10.txt:256
msgid ""
"Suppose you are editing a chapter in a book, and want to replace all\n"
"occurrences of \"grey\" with \"gray\".  But only in this chapter, not in the "
"next\n"
"one.  You know that only chapter boundaries have the word \"Chapter\" in "
"the\n"
"first column.  This command will work then: >"
msgstr ""
"Suponga que está editado un capítulo de un libro y que desea reemplazar "
"todas\n"
"las palabras «grisx con «blanco». Pero sólo en ese capítulo, no en el "
"siguiente.\n"
"Sabe que los límites entre capítulos tienen la palabra «Capítulo» en la\n"
"primera columna. Esta orden funcionaría aquí: >"

#: usr_10.txt:261
msgid "\t:?^Chapter?,/^Chapter/s=grey=gray=g"
msgstr "\t:?^Capítulo?,/^Capítulo/s=gris=azul=g"

#: usr_10.txt:263
msgid ""
"You can see a search pattern is used twice.  The first \"?^Chapter?\" finds "
"the\n"
"line above the current position that matches this pattern.  Thus the ?"
"pattern?\n"
"range is used to search backwards.  Similarly, \"/^Chapter/\" is used to "
"search\n"
"forward for the start of the next chapter.\n"
"   To avoid confusion with the slashes, the \"=\" character was used in the\n"
"substitute command here.  A slash or another character would have worked as\n"
"well."
msgstr ""
"Puede observar que un patrón se ha usado en dos ocasiones. La primera\n"
"«?^Chapter?» busca el patrón en sentido inverso. Por lo tanto «?patrón?»\n"
"buscará encima de la línea actual. De forma similar, «/^Capítulo/» se usa "
"para\n"
"buscar hacia delante el comienzo del nuevo capítulo.\n"
"   Para evitar confusión con las barras, el carácter «=» se ha empleado en\n"
"la orden sustituir. Una barra o cualquier otro carácter habría funcionado\n"
"igual de bien."

#: usr_10.txt:272
msgid "ADD AND SUBTRACT"
msgstr "AÑADIR Y ELIMINAR"

#: usr_10.txt:274
msgid ""
"There is a slight error in the above command: If the title of the next "
"chapter\n"
"had included \"grey\" it would be replaced as well.  Maybe that's what you\n"
"wanted, but what if you didn't?  Then you can specify an offset.\n"
"   To search for a pattern and then use the line above it: >"
msgstr ""
"Hay un pequeño error en la orden de arriba: Si el título del siguiente\n"
"capítulo hubiese incluido «grisx habría sido reemplazado igualmente. Quizá\n"
"quería eso, ¿pero qué ocurre si no? Puede especificar un «offset».\n"
"   Para buscar un patrón e indicar la línea anterior: >"

#: usr_10.txt:279
msgid "\t/Chapter/-1"
msgstr "\t/Capítulo/-1"

#: usr_10.txt:281
msgid ""
"You can use any number instead of the 1.  To address the second line below "
"the\n"
"match: >"
msgstr ""
"Puede usar cualquier número en lugar de 1. Para indicar la segunda línea "
"por\n"
"debajo de la cadena encontrada: >"

#: usr_10.txt:284
msgid "\t/Chapter/+2"
msgstr "\t/Capítulo/+2"

#: usr_10.txt:286
msgid ""
"The offsets can also be used with the other items in a range.  Look at this\n"
"one: >"
msgstr ""
"El desplazamiento se puede emplear también con otros elementos en un rango.\n"
"Observe esto: >"

#: usr_10.txt:289
msgid "\t:.+3,$-5"
msgstr "\t:.+3,$-5"

#: usr_10.txt:291
msgid ""
"This specifies the range that starts three lines below the cursor and ends\n"
"five lines before the last line in the file."
msgstr ""
"Esto especifica que el rango comienza tres líneas por debajo de la actual y\n"
"termina cinco líneas antes de la última línea del archivo."

#: usr_10.txt:295
msgid "USING MARKS"
msgstr "USO DE MARCAS "

#: usr_10.txt:297
msgid ""
"Instead of figuring out the line numbers of certain positions, remembering "
"them\n"
"and typing them in a range, you can use marks.\n"
"   Place the marks as mentioned in chapter 3.  For example, use \"mt\" to "
"mark\n"
"the top of an area and \"mb\" to mark the bottom.  Then you can use this "
"range\n"
"to specify the lines between the marks (including the lines with the marks): "
">"
msgstr ""
"En lugar de adivinar el número de algunas líneas en determinadas "
"posiciones,\n"
"e introducirlas en un rango, puede usar marcadores.\n"
"   Ponga marcas como se explica en el capítulo 3. Por ejemplo, usa «ms» para\n"
"marcar la parte superior de un área y «mi» para marcar la parte inferior\".\n"
"Puede usar el rango para especificar las líneas entre las marcas\n"
"(inclusive): >"

#: usr_10.txt:303
msgid "\t:'t,'b"
msgstr "\t:'t,'b"

#: usr_10.txt:306
msgid "VISUAL MODE AND RANGES"
msgstr "MODO VISUAL Y RANGOS"

#: usr_10.txt:308
msgid ""
"You can select text with Visual mode.  If you then press \":\" to start a "
"colon\n"
"command, you will see this: >"
msgstr ""
"Puede seleccionar texto con el modo Visual. Si pulsa «:» para iniciar una\n"
"orden, verá lo siguiente: >"

#: usr_10.txt:311
msgid "\t:'<,'>"
msgstr "\t:'<,'>"

#: usr_10.txt:313
msgid ""
"Now you can type the command and it will be applied to the range of lines "
"that\n"
"was visually selected."
msgstr ""
"Ahora puede introducir la orden y éste se aplicará al rango de líneas que "
"tiene\n"
"seleccionadas."

#: usr_10.txt:316
msgid ""
"\tNote:\n"
"\tWhen using Visual mode to select part of a line, or using CTRL-V to\n"
"\tselect a block of text, the colon commands will still apply to whole\n"
"\tlines.  This might change in a future version of Vim."
msgstr ""
"\tNota:\n"
"\tCuando use el modo Visual para seleccionar parte de una línea, o use\n"
"\tCTRL-V para seleccionar un bloque de texto, las órdenes se aplicarán\n"
"\ta líneas completas. Puede que esto cambie en una futura versión."

#: usr_10.txt:321
msgid ""
"The '< and '> are actually marks, placed at the start and end of the Visual\n"
"selection.  The marks remain at their position until another Visual "
"selection\n"
"is made.  Thus you can use the \"'<\" command to jump to position where the\n"
"Visual area started.  And you can mix the marks with other items: >"
msgstr ""
"Los «'<» y «'>» son marcadores que se sitúan al principio y al final de la\n"
"selección. Estos marcadores mantienen estas posiciones hasta que aparece "
"una\n"
"nueva selección Visual. Por lo tanto, puede usar la orden «\"'<\"» para "
"saltar\n"
"al lugar donde el área Visual comenzaba. También puede mezclarlas: >"

#: usr_10.txt:326
msgid "\t:'>,$"
msgstr "\t:'>,$"

#: usr_10.txt:328
msgid ""
"This addresses the lines from the end of the Visual area to the end of the\n"
"file."
msgstr ""
"Esto especifica las líneas desde el final del área visual hasta el final "
"del\n"
"archivo."

#: usr_10.txt:332
msgid "A NUMBER OF LINES"
msgstr "UN NÚMERO DE LÍNEAS"

#: usr_10.txt:334
msgid ""
"When you know how many lines you want to change, you can type the number "
"and\n"
"then \":\".  For example, when you type \"5:\", you will get: >"
msgstr ""
"Cuando sepa cuántas líneas quieres cambiar, puede teclear el número y luego\n"
"«:».  Si, por ejemplo, escribe «5:» obtendrá: >"

#: usr_10.txt:337
msgid "\t:.,.+4"
msgstr "\t:.,.+4"

#: usr_10.txt:339
msgid ""
"Now you can type the command you want to use.  It will use the range \".\"\n"
"(current line) until \".+4\" (four lines down).  Thus it spans five lines."
msgstr ""
"Ahora puedes ejecutar la orden que quiera usar. Usará el rango «.» (línea\n"
"actual) hasta «.+4» (cuatro líneas más). Esto hará un total de cinco líneas."

#: usr_10.txt:342
msgid ""
"==============================================================================\n"
"*10.4*\tThe global command"
msgstr ""
"==============================================================================\n"
"*10.4*\tLas órdenes globales"

#: usr_10.txt:345
msgid ""
"The \":global\" command is one of the more powerful features of Vim.  It "
"allows\n"
"you to find a match for a pattern and execute a command there.  The general\n"
"form is: >"
msgstr ""
"La orden «:global» es una de las características más potentes de Vim.\n"
"Permite que encuentre una cadena con un patrón y ejecute una orden en esa\n"
"ubicación. El formato habitual es: >"

#: usr_10.txt:349
msgid "\t:[range]global/{pattern}/{command}"
msgstr "\t:[rango]global/{patrón}/{orden}"

#: usr_10.txt:351
msgid ""
"This is similar to the \":substitute\" command.  But, instead of replacing "
"the\n"
"matched text with other text, the command {command} is executed."
msgstr ""
"Esto es similar a la orden «:substitute». Pero en lugar de reemplazar el\n"
"texto concordado con otro texto, la orden {orden} se ejecutará."

#: usr_10.txt:354
msgid ""
"\tNote:\n"
"\tThe command executed for \":global\" must be one that starts with a\n"
"\tcolon.  Normal mode commands can not be used directly.  The |:normal|\n"
"\tcommand can do this for you."
msgstr ""
"\tNota:\n"
"\tLa orden ejecutada con «:global» debe ser uno que comience con un\n"
"\tpunto y coma. Las órdenes para el modo Normal no se pueden emplear de\n"
"\tforma directa. De esto se encargará |:normal|."

#: usr_10.txt:359
msgid ""
"Suppose you want to change \"foobar\" to \"barfoo\", but only in C++ style\n"
"comments.  These comments start with \"//\".  Use this command: >"
msgstr ""
"Suponga que quiere cambiar «foobar» por «barfoo», pero solamente en los\n"
"comentarios de C++. Estos comentarios empiezan por «//». Use lo siguiente: >"

#: usr_10.txt:362
msgid "\t:g+//+s/foobar/barfoo/g"
msgstr "\t:g+//+s/foobar/barfoo/g"

#: usr_10.txt:364
msgid ""
"This starts with \":g\".  That is short for \":global\", just like \":s\" is "
"short\n"
"for \":substitute\".  Then the pattern, enclosed in plus characters.  Since "
"the\n"
"pattern we are looking for contains a slash, this uses the plus character "
"to\n"
"separate the pattern.  Next comes the substitute command that changes "
"\"foobar\"\n"
"into \"barfoo\".\n"
"   The default range for the global command is the whole file.  Thus no "
"range\n"
"was specified in this example.  This is different from \":substitute\", "
"which\n"
"works on one line without a range.\n"
"   The command isn't perfect, since it also matches lines where \"//\" "
"appears\n"
"halfway a line, and the substitution will also take place before the \"//\"."
msgstr ""
"Esto comienza con «:g», la abreviatura de «:global», igual que ocurría con «:s» "
"y\n"
"«substitutex. Luego viene el patrón, entre signos «+». Ya que el patrón\n"
"que estamos buscando contiene una barra inclinada, esto emplea el signo «+»\n"
"para separar el patrón. A continuación viene la orden que cambia «foobar» a\n"
"«barfoo».\n"
"   El rango predeterminado de la orden global es el archivo completo. Como "
"en\n"
"este caso, ya que ningún rango se ha especificado. Esto difiere de la orden\n"
"«:substitute», la cuál afecta a una línea por omisión.\n"
"   La orden no es perfecta, ya que también encontrará líneas donde «//»\n"
"aparece a mitad de línea y la sustitución también se hará antes de los «//»."

#: usr_10.txt:375
msgid ""
"Just like with \":substitute\", any pattern can be used.  When you learn "
"more\n"
"complicated patterns later, you can use them here."
msgstr ""
"Tal y como ocurre con «:substitute», puede emplear cualquier patrón.\n"
"Cuando aprenda patrones más complicados, podrá usarlos aquí."

#: usr_10.txt:378
msgid ""
"==============================================================================\n"
"*10.5*\tVisual block mode"
msgstr ""
"==============================================================================\n"
"*10.5*\tEl modo de bloque Visual"

#: usr_10.txt:381
msgid ""
"With CTRL-V you can start selection of a rectangular area of text.  There "
"are\n"
"a few commands that do something special with the text block."
msgstr ""
"Con CTRL-V puede seleccionar un área rectangular de texto. Hay algunas\n"
"órdenes que hacen algo especial con los bloques de texto."

#: usr_10.txt:384
msgid ""
"There is something special about using the \"$\" command in Visual block "
"mode.\n"
"When the last motion command used was \"$\", all lines in the Visual "
"selection\n"
"will extend until the end of the line, also when the line with the cursor "
"is\n"
"shorter.  This remains effective until you use a motion command that moves "
"the\n"
"cursor horizontally.  Thus using \"j\" keeps it, \"h\" stops it."
msgstr ""
"La orden «$» en el modo bloque Visual tiene algo de especial. Cuando el\n"
"último orden de movimiento fue «$», todas las líneas de la selección Visual\n"
"se extenderán hasta el final de la línea, incluso cuando la línea con el\n"
"cursor sea más corta. Esto se hará efectivo hasta que use otra orden de\n"
"movimiento que desplace el cursor horizontalmente."

#: usr_10.txt:391
msgid "INSERTING TEXT"
msgstr "INSERTAR TEXTO"

#: usr_10.txt:393
msgid ""
"The command  \"I{string}<Esc>\" inserts the text {string} in each line, "
"just\n"
"left of the visual block.  You start by pressing CTRL-V to enter visual "
"block\n"
"mode.  Now you move the cursor to define your block.  Next you type I to "
"enter\n"
"Insert mode, followed by the text to insert.  As you type, the text appears "
"on\n"
"the first line only.\n"
"   After you press <Esc> to end the insert, the text will magically be\n"
"inserted in the rest of the lines contained in the visual selection.  "
"Example:"
msgstr ""
"La orden «I{cadena}<Esc>» inserta el texto {cadena} en cada línea, justo a\n"
"la izquierda del bloque. Comience tecleando CTRL-V para entrar en el modo\n"
"bloque Visual. Mueva el cursor para definir su bloque. A continuación pulse\n"
"«I» para iniciar el modo Insertar. A medida que teclea, el texto aparece\n"
"únicamente en la primera línea.\n"
"   Tras pulsar <Esc> para finalizar la inserción, el texto aparecerá\n"
"mágicamente insertado en el resto de líneas contenidas en el bloque:"

#: usr_10.txt:401
msgid ""
"\tinclude one ~\n"
"\tinclude two ~\n"
"\tinclude three ~\n"
"\tinclude four ~"
msgstr ""
"\tinclude uno ~\n"
"\tinclude dos ~\n"
"\tinclude tres ~\n"
"\tinclude cuatro ~"

#: usr_10.txt:406
msgid ""
"Move the cursor to the \"o\" of \"one\" and press CTRL-V.  Move it down with "
"\"3j\"\n"
"to \"four\".  You now have a block selection that spans four lines.  Now "
"type: >"
msgstr ""
"Mueva el cursor a la «u» de «uno» y presione CTRL-V. Desplácese hacia abajo\n"
"con «3j» hasta«\"cuatro». Tiene una selección que abarca cuatro líneas. "
"Teclee:\n"
">"

#: usr_10.txt:409
msgid "\tImain.<Esc>"
msgstr "\tImain.<Esc>"

#: usr_10.txt:411
msgid "The result:"
msgstr "El resultado:"

#: usr_10.txt:413
msgid ""
"\tinclude main.one ~\n"
"\tinclude main.two ~\n"
"\tinclude main.three ~\n"
"\tinclude main.four ~"
msgstr ""
"\tinclude main.uno ~\n"
"\tinclude main.dos ~\n"
"\tinclude main.tres ~\n"
"\tinclude main.cuatro ~"

#: usr_10.txt:418
msgid ""
"If the block spans short lines that do not extend into the block, the text "
"is\n"
"not inserted in that line.  For example, make a Visual block selection that\n"
"includes the word \"long\" in the first and last line of this text, and thus "
"has\n"
"no text selected in the second line:"
msgstr ""
"Si el bloque abarca líneas que no caben dentro del área del bloque, el texto "
"no\n"
"se insertará en esa línea. Por ejemplo, haga un bloque Visual que no "
"incluya\n"
"la palabra «larga» en la primera y última línea de este texto, de manera que "
"no\n"
"se seleccione texto en la segunda línea:"

#: usr_10.txt:423
msgid ""
"\tThis is a long line ~\n"
"\tshort ~\n"
"\tAny other long line ~"
msgstr ""
"\tEsto es una línea larga ~\n"
"\tcorta ~\n"
"\tCualquier es una línea larga ~"

#: usr_10.txt:427
msgid "\t\t  ^^^^ selected block"
msgstr "\t\t    ^^^^^ bloque seleccionado"

#: usr_10.txt:429
msgid "Now use the command \"Ivery <Esc>\".  The result is:"
msgstr "Ahora usa la orden «Imuy <Esc>». El resultado es:"

#: usr_10.txt:431
msgid ""
"\tThis is a very long line ~\n"
"\tshort ~\n"
"\tAny other very long line ~"
msgstr ""
"\tEsto es una línea muy larga ~\n"
"\tcorta ~\n"
"\tEsto es una línea muy larga ~"

#: usr_10.txt:435
msgid "In the short line no text was inserted."
msgstr "En el texto corto no se introdujo nada."

#: usr_10.txt:437
msgid ""
"If the string you insert contains a newline, the \"I\" acts just like a "
"Normal\n"
"insert command and affects only the first line of the block."
msgstr ""
"Si la cadena que insertó contiene una nueva línea, el «I» actúa justo como\n"
"una inserción normal y únicamente afecta a la primera línea del bloque."

#: usr_10.txt:440
msgid ""
"The \"A\" command works the same way, except that it appends after the "
"right\n"
"side of the block.  And it does insert text in a short line.  Thus you can\n"
"make a choice whether you do or don't want to append text to a short line.\n"
"   There is one special case for \"A\": Select a Visual block and then use "
"\"$\"\n"
"to make the block extend to the end of each line.  Using \"A\" now will "
"append\n"
"the text to the end of each line.\n"
"   Using the same example from above, and then typing \"$A XXX<Esc>, you "
"get\n"
"this result:"
msgstr ""
"La orden «A» funciona de la misma manera, excepto que añade a la derecha\n"
"del bloque. En este caso sí se se añade al final de la línea corta. De este\n"
"modo puede elegir si quieres añadir o no un texto a la línea corta.\n"
"   Hay un caso especial para «Ax: seleccione un bloque Visual y pulsw «$» "
"para\n"
"hacer que el bloque se extienda al final de cada línea. Usar «A» añadirá el\n"
"texto al final de cada línea.\n"
"   De usar el mismo ejemplo que arriba y teclear «$A XXX<Esc>» obtendría el\n"
"siguiente resultado:"

#: usr_10.txt:449
msgid ""
"\tThis is a long line XXX ~\n"
"\tshort XXX ~\n"
"\tAny other long line XXX ~"
msgstr ""
"\tEsto es una línea larga XXX~\n"
"\tcorta XXX~\n"
"\tEsto es una línea larga XXX~"

#: usr_10.txt:453
msgid ""
"This really requires using the \"$\" command.  Vim remembers that it was "
"used.\n"
"Making the same selection by moving the cursor to the end of the longest "
"line\n"
"with other movement commands will not have the same result."
msgstr ""
"Esto requiere el uso de la orden «$». Vim recordará que los ha usado. Hacer\n"
"la misma selección con el cursor hasta el final de la línea más larga con\n"
"otras órdenes no te dará el mismo resultado."

#: usr_10.txt:458
msgid "CHANGING TEXT"
msgstr "CAMBIAR EL TEXTO"

#: usr_10.txt:460
msgid ""
"The Visual block \"c\" command deletes the block and then throws you into "
"Insert\n"
"mode to enable you to type in a string.  The string will be inserted in "
"each\n"
"line in the block.\n"
"   Starting with the same selection of the \"long\" words as above, then "
"typing\n"
"\"c_LONG_<Esc>\", you get this:"
msgstr ""
"La orden de bloque Visual «c» elimina el bloque y le devuelve al modo\n"
"Insertar para que escriba en una cadena de caracteres. La cadena se\n"
"insertará en cada línea del bloque.\n"
"   Comenzando con la misma selección que las palabras zlarga» de arriba,\n"
"y teclear después «c_LARGA_<Esc>», le daría esto:"

#: usr_10.txt:466
msgid ""
"\tThis is a _LONG_ line ~\n"
"\tshort ~\n"
"\tAny other _LONG_ line ~"
msgstr ""
"\tEsto es una línea _LARGA_ ~\n"
"\tcorta ~\n"
"\tEsto es una línea _LARGA_ ~"

#: usr_10.txt:470
msgid ""
"Just like with \"I\" the short line is not changed.  Also, you can't enter "
"a\n"
"newline in the new text."
msgstr ""
"Tal y como ocurre con «Ix, la línea corta no cambia. Del mismo modo, no "
"podrá\n"
"introducir una nueva línea en el texto."

#: usr_10.txt:473
msgid ""
"The \"C\" command deletes text from the left edge of the block to the end "
"of\n"
"line.  It then puts you in Insert mode so that you can type in a string,\n"
"which is added to the end of each line.\n"
"   Starting with the same text again, and typing \"Cnew text<Esc>\" you get:"
msgstr ""
"La orden «C» elimina texto desde el borde izquierdo del bloque hasta el\n"
"final de cada línea. Luego le deja en modo Insert para que pueda teclear "
"una\n"
"cadena, que se añadirá al final de cada línea.\n"
"   Comenzando con el mismo texto, teclee «Ctexto nuevo<Esc>». Obtendrá:"

#: usr_10.txt:478
msgid ""
"\tThis is a new text ~\n"
"\tshort ~\n"
"\tAny other new text ~"
msgstr ""
"\tEsto es un texto nuevo ~\n"
"\tcorta ~\n"
"\tEsto es un texto nuevo ~"

#: usr_10.txt:482
msgid ""
"Notice that, even though only the \"long\" word was selected, the text after "
"it\n"
"is deleted as well.  Thus only the location of the left edge of the visual\n"
"block really matters.\n"
"   Again, short lines that do not reach into the block are excluded."
msgstr ""
"Observe que aunque sólo se seleccionó la palabra «larga», el texto\n"
"tras ella fue eliminado igualmente. Por lo tanto sólo la posición del borde\n"
"izquierdo del eje izquierdo importa realmente.\n"
"   Una vez más, las palabras que no forman parte del bloque se excluyen."

#: usr_10.txt:487
msgid "Other commands that change the characters in the block:"
msgstr "Otras órdenes que cambian los caracteres  en el bloque son:"

#: usr_10.txt:489
msgid ""
"\t~\tswap case\t(a -> A and A -> a)\n"
"\tU\tmake uppercase  (a -> A and A -> A)\n"
"\tu\tmake lowercase  (a -> a and A -> a)"
msgstr ""
"\t~       cambiar may./min.   (a -> A and A -> a)\n"
"\tU       cambiar a may.      (a -> A and A -> A)\n"
"\tu       cambiar a min.      (a -> a and A -> a)"

#: usr_10.txt:494
msgid "FILLING WITH A CHARACTER"
msgstr "RELLENAR CON UN CARÁCTER"

#: usr_10.txt:496
msgid ""
"To fill the whole block with one character, use the \"r\" command.  Again,\n"
"starting with the same example text from above, and then typing \"rx\":"
msgstr ""
"Para rellenar un bloque completo con un sólo carácter, usw la orden «r».\n"
"Pruébelo de nuevo con el texto de antes, pulsando «rx»:"

#: usr_10.txt:499
msgid ""
"\tThis is a xxxx line ~\n"
"\tshort ~\n"
"\tAny other xxxx line ~"
msgstr ""
"\tEsto es una línea larga ~\n"
"\tcorta ~\n"
"\tCualquier es una línea larga ~"

#: usr_10.txt:504
msgid ""
"\tNote:\n"
"\tIf you want to include characters beyond the end of the line in the\n"
"\tblock, check out the 'virtualedit' feature in chapter 25."
msgstr ""
"\tNota:\n"
"\tSi desea incluir los caracteres más allá del final de línea en el\n"
"\tbloque, véase la opción 'virtualedit' en el capítulo 25."

#: usr_10.txt:509
msgid "SHIFTING"
msgstr "CAMBIAR"

#: usr_10.txt:511
msgid ""
"The command \">\" shifts the selected text to the right one shift amount,\n"
"inserting whitespace.  The starting point for this shift is the left edge "
"of\n"
"the visual block.\n"
"   With the same example again, \">\" gives this result:"
msgstr ""
"La orden «>» empuja el texto hacia la derecha un espacio determinado,\n"
"insertando espacios en blanco. El punto base empleado para esta operación "
"es\n"
"el borde izquierdo del bloque visual.\n"
"   Con el mismo ejemplo de nuevo, «>» le da el resultado:"

#: usr_10.txt:516
msgid ""
"\tThis is a\t  long line ~\n"
"\tshort ~\n"
"\tAny other\t  long line ~"
msgstr ""
"\tEsto es una\tlínea larga ~\n"
"\tcorta ~\n"
"\tEsto es una\tlínea larga ~"

#: usr_10.txt:520
msgid ""
"The shift amount is specified with the 'shiftwidth' option.  To change it "
"to\n"
"use 4 spaces: >"
msgstr ""
"El espacio del desplazamiento se especifica con la opción 'shiftwidth\".\n"
"Para cambiarlo a cuatro espacios: >"

#: usr_10.txt:523
msgid "\t:set shiftwidth=4"
msgstr "\t:set shiftwidth=4"

#: usr_10.txt:525
msgid ""
"The \"<\" command removes one shift amount of whitespace at the left\n"
"edge of the block.  This command is limited by the amount of text that is\n"
"there; so if there is less than a shift amount of whitespace available, it\n"
"removes what it can."
msgstr ""
"La orden «<» desplaza por cada empuje la misma cantidad de espacios en\n"
"blanco hacia la izquierda. Esta orden se limita al texto que se\n"
"encuentre, de manera que eliminará la cantidad de espacio en blanco\n"
"disponible sin sobreescribir texto."

#: usr_10.txt:531
msgid "JOINING LINES"
msgstr "UNIR LÍNEAS"

#: usr_10.txt:533
msgid ""
"The \"J\" command joins all selected lines together into one line.  Thus it\n"
"removes the line breaks.  Actually, the line break, leading white space and\n"
"trailing white space is replaced by one space.  Two spaces are used after a\n"
"line ending (that can be changed with the 'joinspaces' option).\n"
"   Let's use the example that we got so familiar with now.  The result of\n"
"using the \"J\" command:"
msgstr ""
"La orden «J» funde todas las líneas en una sola, eliminando los saltos de\n"
"línea. De hecho, el salto de línea, espacios en blanco al comienzo y al\n"
"final de línea se convierten en un solo espacio. Se usan dos espacios tras\n"
"un final de línea (pudiéndose cambiar esto con la opción 'joinspaces').\n"
"   Vamos a usar el ejemplo que nos resulta ya familiar. El resultado de "
"usar\n"
"la orden «J» será:"

#: usr_10.txt:540
msgid "\tThis is a long line short Any other long line ~"
msgstr "\tEsto es una línea larga corta Esto es una línea larga ~"

#: usr_10.txt:542
msgid ""
"The \"J\" command doesn't require a blockwise selection.  It works with \"v"
"\" and\n"
"\"V\" selection in exactly the same way."
msgstr ""
"La orden «J» no requiere selección de bloques. Funciona de igual modo\n"
"con la selección «v» y «V»."

#: usr_10.txt:545
msgid ""
"If you don't want the white space to be changed, use the \"gJ\" command."
msgstr "Si no quiere que los espacios en blanco cambien, use la orden «gJ»."

#: usr_10.txt:547
msgid ""
"==============================================================================\n"
"*10.6*\tReading and writing part of a file"
msgstr ""
"==============================================================================\n"
"*10.6*\tLeer y escribir parte de un archivo"

#: usr_10.txt:550
msgid ""
"When you are writing an e-mail message, you may want to include another "
"file.\n"
"This can be done with the \":read {filename}\" command.  The text of the "
"file is\n"
"put below the cursor line.\n"
"   Starting with this text:"
msgstr ""
"Cuando escriba un correo, puede que desee incluir otro archivo.\n"
"Esto se puede llevar a cabo con la orden «:read {nombredearchivo}». El\n"
"texto del archivo se pegará debajo de la línea actual:\n"
"   A partir de este texto:"

#: usr_10.txt:555
msgid ""
"\tHi John, ~\n"
"\tHere is the diff that fixes the bug: ~\n"
"\tBye, Pierre. ~"
msgstr ""
"\tHola Juan, ~\n"
"\tAquí tienes el parche que arregla el problema: ~\n"
"\tUn saludo, Pedro. ~"

#: usr_10.txt:559
msgid "Move the cursor to the second line and type: >"
msgstr "Mueva el cursor a la segunda línea y escriba: >"

#: usr_10.txt:561
msgid "\t:read patch"
msgstr "\t:read parche"

#: usr_10.txt:563
msgid "The file named \"patch\" will be inserted, with this result:"
msgstr "El archivo de nombre «parche» se insertará: con este resultado:"

#: usr_10.txt:565
msgid ""
"\tHi John, ~\n"
"\tHere is the diff that fixes the bug: ~\n"
"\t2c2 ~\n"
"\t<\tfor (i = 0; i <= length; ++i) ~\n"
"\t--- ~\n"
"\t>\tfor (i = 0; i < length; ++i) ~\n"
"\tBye, Pierre. ~"
msgstr ""
"\tHola Juan, ~\n"
"\tAquí tienes el parche que arregla el problema: ~\n"
"\t2c2 ~\n"
"\t<\tfor (i = 0; i <= length; ++i) ~\n"
"\t--- ~\n"
"\t>\tfor (i = 0; i < length; ++i) ~\n"
"\tUn saludo, Pedro. ~"

#: usr_10.txt:573
msgid ""
"The \":read\" command accepts a range.  The file will be put below the last "
"line\n"
"number of this range.  Thus \":$r patch\" appends the file \"patch\" at the "
"end of\n"
"the file.\n"
"   What if you want to read the file above the first line?  This can be "
"done\n"
"with the line number zero.  This line doesn't really exist, you will get an\n"
"error message when using it with most commands.  But this command is "
"allowed:\n"
">\n"
"\t:0read patch"
msgstr ""
"La orden «:read» acepta un rango. El archivo será colocado justo debajo de\n"
"la última línea de este rango. Por lo tanto, «:$r parche» añadirá el archivo "
"«parche» al final del actual.\n"
"   ¿Qué ocurre si quiere pegar el archivo encima de la primera línea? Esto\n"
"se puede realizar con el número de línea cero. Este número de línea en\n"
"realidad no existe, lo cuál hará que con muchas órdenes reciba un error. >\n"
":0read parche"

#: usr_10.txt:582
msgid "The file \"patch\" will be put above the first line of the file."
msgstr "El archivo «parche» se insertará sobre la primera línea del archivo."

#: usr_10.txt:585
msgid "WRITING A RANGE OF LINES"
msgstr "ESCRIBIR UN RANGO DE LÍNEAS"

#: usr_10.txt:587
msgid ""
"To write a range of lines to a file, the \":write\" command can be used.\n"
"Without a range it writes the whole file.  With a range only the specified\n"
"lines are written: >"
msgstr ""
"Para guardar un rango de líneas en un archivo puede usar la orden «:write».\n"
"Sin el rango esto guardará el archivo completo. Pero con un rango\n"
"especificado únicamente las líneas que se especifiquen se escribirán: >"

#: usr_10.txt:591
msgid "\t:.,$write tempo"
msgstr "\t:.,$write tempo"

#: usr_10.txt:593
msgid ""
"This writes the lines from the cursor until the end of the file into the "
"file\n"
"\"tempo\".  If this file already exists you will get an error message.  Vim\n"
"protects you from accidentally overwriting an existing file.  If you know "
"what\n"
"you are doing and want to overwrite the file, append !: >"
msgstr ""
"Esto guardará las líneas desde el cursor hasta el final del texto en el\n"
"archivo «tempo». Si este archivo existe actualmente obtendrá un mensaje de\n"
"error. Vim le protege de que sobreescriba un archivo preexistente. Si sabe\n"
"lo que hace y quiere sobreescribirlo, añada «!»: >"

#: usr_10.txt:598
msgid "\t:.,$write! tempo"
msgstr "\t:.,$write! tempo"

#: usr_10.txt:600
msgid ""
"CAREFUL: The ! must follow the \":write\" command immediately, without "
"white\n"
"space.  Otherwise it becomes a filter command, which is explained later in\n"
"this chapter."
msgstr ""
"CUIDADO: El «!» debe ponerse justo después de la orden «:write», sin el\n"
"espacio en blanco. En caso contrario se convierte en un ordena filtro, el\n"
"cuál se explica en el capítulo siguiente."

#: usr_10.txt:605
msgid "APPENDING TO A FILE"
msgstr "AÑADIR A UN ARCHIVO"

#: usr_10.txt:607
msgid ""
"In the first section of this chapter was explained how to collect a number "
"of\n"
"lines into a register.  The same can be done to collect lines in a file.\n"
"Write the first line with this command: >"
msgstr ""
"En la primera sección de este capítulo se explicó cómo reunir una serie de\n"
"líneas en un registro. Se puede hacer lo mismo para reunir líneas en\n"
"un archivo. Escriba una primera línea con esta orden: >"

#: usr_10.txt:611
msgid "\t:.write collection"
msgstr "\t:.write archivo"

#: usr_10.txt:613
msgid ""
"Now move the cursor to the second line you want to collect, and type this: >"
msgstr ""
"Ahora ponga el cursor en la siguiente línea que quiera añadir y escriba "
"esto:\n"
">"

#: usr_10.txt:615
msgid "\t:.write >>collection"
msgstr "\t:.write >>archivo"

#: usr_10.txt:617
msgid ""
"The \">>\" tells Vim the \"collection\" file is not to be written as a new "
"file,\n"
"but the line must be appended at the end.   You can repeat this as many "
"times\n"
"as you like."
msgstr ""
"El «>>» le dice a Vim que «archivo» no se debe escribir como un nuevo archivo\n"
"sino que la línea debe ser añadida al final. Puede repetir esto tantas "
"veces\n"
"como desee."

#: usr_10.txt:621
msgid ""
"==============================================================================\n"
"*10.7*\tFormatting text"
msgstr ""
"==============================================================================\n"
"*10.7*\tFormatear texto"

#: usr_10.txt:624
msgid ""
"When you are typing plain text, it's nice if the length of each line is\n"
"automatically trimmed to fit in the window.  To make this happen while\n"
"inserting text, set the 'textwidth' option: >"
msgstr ""
"Cuando introducza texto, tal vez le resulta útil que, si la longitud de "
"cada\n"
"línea supera un número, sea automáticamente partida. Para hacer esto "
"posible,\n"
"active la opción 'textwidth': >"

#: usr_10.txt:628
msgid "\t:set textwidth=72"
msgstr "\t:set textwidth=72"

#: usr_10.txt:630
msgid ""
"You might remember that in the example vimrc file this command was used for\n"
"every text file.  Thus if you are using that vimrc file, you were already\n"
"using it.  To check the current value of 'textwidth': >"
msgstr ""
"Quizá se acuerde de que en el ejemplo de archivo «vimrc» esta orden era\n"
"empleada para cualquier tipo de archivo. Por lo tanto, si está usando ese\n"
"archivo «vimrc», ya lo tiene activado. Para comprobar el valor actual: >"

#: usr_10.txt:634
msgid "\t:set textwidth"
msgstr "\t:set textwidth"

#: usr_10.txt:636
msgid ""
"Now lines will be broken to take only up to 72 characters.  But when you\n"
"insert text halfway a line, or when you delete a few words, the lines will "
"get\n"
"too long or too short.  Vim doesn't automatically reformat the text.\n"
"   To tell Vim to format the current paragraph: >"
msgstr ""
"A partir de ahora las líneas se partirán cuando lleguen a 72 caracteres. "
"Sin\n"
"embargo, cuando introduzca texto en mitad de una línea, o cuando elimine\n"
"unas palabras la línea no será reformateada por Vim.\n"
"   Para decirle a Vim que formatee el párrafo actual: >"

#: usr_10.txt:641
msgid "\tgqap"
msgstr "\tgqap"

#: usr_10.txt:643
msgid ""
"This starts with the \"gq\" command, which is an operator.  Following is \"ap"
"\",\n"
"the text object that stands for \"a paragraph\".  A paragraph is separated "
"from\n"
"the next paragraph by an empty line."
msgstr ""
"Esto consiste en un orden «gq», que es un operador, seguido de una «ap», el\n"
"objeto de texto para «un párrafo». Un párrafo es lo que está separado de "
"otro\n"
"párrafo por una línea en blanco."

#: usr_10.txt:647
msgid ""
"\tNote:\n"
"\tA blank line, which contains white space, does NOT separate\n"
"\tparagraphs.  This is hard to notice!"
msgstr ""
"\tNota:\n"
"\tUna línea que contiene espacios en blanco NO separa párrafos. Esto\n"
"\tsuele ser difícil de notar."

#: usr_10.txt:651
msgid ""
"Instead of \"ap\" you could use any motion or text object.  If your "
"paragraphs\n"
"are properly separated, you can use this command to format the whole file: >"
msgstr ""
"En lugar de «ap» puede usar cualquier movimiento u objeto de texto. Si "
"sus\n"
"párrafos están adecuadamente separados, puede usar esto para formatear "
"todo:\n"
">"

#: usr_10.txt:654
msgid "\tgggqG"
msgstr "\tgggqG"

#: usr_10.txt:656
msgid ""
"\"gg\" takes you to the first line, \"gq\" is the format operator and \"G\" "
"the\n"
"motion that jumps to the last line."
msgstr ""
"«gg» le lleva a la primera línea, «gq» es el operador de formateo y «G» la\n"
"orden de movimiento que le lleva a la última línea."

#: usr_10.txt:659
msgid ""
"In case your paragraphs aren't clearly defined, you can format just the "
"lines\n"
"you manually select.  Move the cursor to the first line you want to format.\n"
"Start with the command \"gqj\".  This formats the current line and the one "
"below\n"
"it.  If the first line was short, words from the next line will be "
"appended.\n"
"If it was too long, words will be moved to the next line.  The cursor moves "
"to\n"
"the second line.  Now you can use \".\" to repeat the command.  Keep doing "
"this\n"
"until you are at the end of the text you want to format."
msgstr ""
"En caso de que sus párrafos no estén claramente definidos, puede dar formato\n"
"sólo a las líneas que seleccione manualmente. Ponga el cursor sobre la\n"
"primera línea que quiera formatear.\n"
"  Teclee «gqj». Esto formatea la línea actual y la siguiente.\n"
"  Si la primera era demasiado corta, las palabras de la siguiente\n"
"línea serán añadidas. Si era demasiado larga, las palabras se moverán a la\n"
"siguiente línea. A continuación puede usar la orden «.» para repetir la\n"
"operación. Repítalo hasta que llegue al final del texto a formatear."

#: usr_10.txt:667
msgid ""
"==============================================================================\n"
"*10.8*\tChanging case"
msgstr ""
"==============================================================================\n"
"*10.8*\tCambiar mayúsculas y minúsculas"

#: usr_10.txt:670
msgid ""
"You have text with section headers in lowercase.  You want to make the word\n"
"\"section\" all uppercase.  Do this with the \"gU\" operator.  Start with "
"the\n"
"cursor in the first column: >"
msgstr ""
"Suponga que tiene texto con las cabeceras de sección en minúscula. Quiere\n"
"que la palabra «sección» esté en mayúsculas.\n"
"  Puede hacerlo con el operador «gU». Comience con el cursor en la primera\n"
"columna: >"

#: usr_10.txt:674
msgid ""
"\t\t\t     gUw\n"
"<\tsection header\t    ---->      SECTION header"
msgstr ""
"\t\t\t     gUw\n"
"<\tcabecera de sección ---->      cabecera de SECCIÓN"

#: usr_10.txt:677
msgid "The \"gu\" operator does exactly the opposite: >"
msgstr "El operador «gu» hace exactamente lo contrario:"

#: usr_10.txt:679
msgid ""
"\t\t\t     guw\n"
"<\tSECTION header\t    ---->      section header"
msgstr ""
"\t\t\t     guw\n"
"\tcabecera de SECCIÓN ---->      cabecera de sección"

#: usr_10.txt:682
msgid ""
"You can also use \"g~\" to swap case.  All these are operators, thus they "
"work\n"
"with any motion command, with text objects and in Visual mode.\n"
"   To make an operator work on lines you double it.  The delete operator is\n"
"\"d\", thus to delete a line you use \"dd\".  Similarly, \"gugu\" makes a "
"whole line\n"
"lowercase.  This can be shortened to \"guu\".  \"gUgU\" is shortened to \"gUU"
"\" and\n"
"\"g~g~\" to \"g~~\".  Example: >"
msgstr ""
"También puede usar «g~» para alternar may./min. Son operadores, así que\n"
"funcionan con órdenes de movimiento, objetos de texto y el modo Visual.\n"
"   Para hacer que un operador funcione en líneas, lo duplica. El operador\n"
"de eliminación es «d», de manera que para eliminar una línea empleas «dd»\n"
"De forma similar, «gugu» hace que la línea al completo sea en minúsculas. "
"Esto\n"
"puede abreviarse con «guu». «gUgU» se puede abreviar a «gUU» y «g~g~» a\n"
"«g~~»:"

#: usr_10.txt:689
msgid ""
"\t\t\t\tg~~ \n"
"<\tSome GIRLS have Fun    ---->   sOME girls HAVE fUN ~"
msgstr ""
"\t\t\t\t      g~~ \n"
"\tAlgunas CHICAS se divierten  ---->  aLGUNAS chicas SE DIVIERTEN ~"

#: usr_10.txt:692
msgid ""
"==============================================================================\n"
"*10.9*\tUsing an external program"
msgstr ""
"==============================================================================\n"
"*10.9*\tUso de un programa externo"

#: usr_10.txt:695
msgid ""
"Vim has a very powerful set of commands, it can do anything.  But there may\n"
"still be something that an external command can do better or faster.\n"
"   The command \"!{motion}{program}\" takes a block of text and filters it\n"
"through an external program.  In other words, it runs the system command\n"
"represented by {program}, giving it the block of text represented by "
"{motion}\n"
"as input.  The output of this command then replaces the selected block.\n"
"   Because this summarizes badly if you are unfamiliar with UNIX filters, "
"take\n"
"a look at an example.  The sort command sorts a file.  If you execute the\n"
"following command, the unsorted file input.txt will be sorted and written "
"to\n"
"output.txt.  (This works on both UNIX and Microsoft Windows.) >"
msgstr ""
"Vim tiene un conjunto de órdenes muy potente para hacer cualquier cosa.\n"
"Pero siempre hay un programa externo que es mejor para una tarea específica.\n"
"   La orden «!{movimiento}{programa}» recoge un bloque de un texto y lo\n"
"filtra a través de un programa externo. En otras palabras, ejecuta la\n"
"orden de sistema {programa}, dándole el bloque de texto representado por\n"
"{movimiento} como entrada. La salida de la orden sustituirá la selección.\n"
"   Ya que esto requiere más explicación si no usa los filtros UNIX\n"
"habitualmente, veamos un ejemplo. La orden «sort» ordena un archivo. Si\n"
"ejecuta lo siguiente, el archivo desordenado entrada.txt será ordenado y\n"
"guardado en output.txt. (Esto funciona en UNIX y en Windows.) >"

#: usr_10.txt:706
msgid "\tsort <input.txt >output.txt"
msgstr "\tsort <input.txt >output.txt"

#: usr_10.txt:708
msgid ""
"Now do the same thing in Vim.  You want to sort lines 1 through 5 of a "
"file.\n"
"You start by putting the cursor on line 1.  Next you execute the following\n"
"command: >"
msgstr ""
"Ahora haga lo mismo en Vim. Desea ordenar las líneas de la 1 a la 5. Para\n"
"comenzar, ponga el cursor en la línea 1. A continuación ejecute la siguiente\n"
"orden: >"

#: usr_10.txt:712
msgid "\t!5G"
msgstr "\t!5G"

#: usr_10.txt:714
msgid ""
"The \"!\" tells Vim that you are performing a filter operation.  The Vim "
"editor\n"
"expects a motion command to follow, indicating which part of the file to\n"
"filter.  The \"5G\" command tells Vim to go to line 5, so it now knows that "
"it\n"
"is to filter lines 1 (the current line) through 5.\n"
"   In anticipation of the filtering, the cursor drops to the bottom of the\n"
"screen and a ! prompt displays.  You can now type in the name of the filter\n"
"program, in this case \"sort\".  Therefore, your full command is as follows: "
">"
msgstr ""
"El «!» le dice a Vim que está realizando una operación filtro. El editor\n"
"Vim espera que introduzca a continuación un orden de movimiento para saber\n"
"qué filtrar. La orden «5G» le dice a Vim que vaya a la línea 5, de forma\n"
"que sepa que tiene que filtrar desde la línea 1 (la actual) hasta la 5.\n"
"   Antes de filtrar nada, la línea de órdenes se activa y muestra un «!».\n"
"Ahora es el momento de que escriba el filtro, en este caso «sort». Por lo\n"
"tanto, la orden completo sería: >"

#: usr_10.txt:722
msgid "\t!5Gsort<Enter>"
msgstr "\t!5Gsort<Entrar>"

#: usr_10.txt:724
msgid ""
"The result is that the sort program is run on the first 5 lines.  The "
"output\n"
"of the program replaces these lines."
msgstr ""
"El resultado es que se ejecuta el programa «sort» sobre las 5 primeras\n"
"líneas. La salida del programa reemplaza estas líneas."


#: usr_10.txt:727
msgid ""
"\tline 55\t\t\t      line 11\n"
"\tline 33\t\t\t      line 22\n"
"\tline 11\t\t-->\t      line 33\n"
"\tline 22\t\t\t      line 44\n"
"\tline 44\t\t\t      line 55\n"
"\tlast line\t\t      last line"
msgstr ""
"\tlínea 55\t\t      línea 11\n"
"\tlínea 33\t\t      línea 22\n"
"\tlínea 11\t-->\t      línea 33\n"
"\tlínea 22\t\t      línea 44\n"
"\tlínea 44\t\t      línea 55\n"
"\túltima línea\t\t      última línea"

#: usr_10.txt:734
msgid ""
"The \"!!\" command filters the current line through a filter.  In Unix the "
"\"date\"\n"
"command prints the current time and date.  \"!!date<Enter>\" replaces the "
"current\n"
"line with the output of \"date\".  This is useful to add a timestamp to a "
"file."
msgstr ""
"La orden «!!» filtra la línea actual. En Unix, la orden »date» imprime la\n"
"hora y fecha actuales. «!!date<Entrar>» reemplaza la línea actual con la\n"
"salida de «date». Esto es útil para añadir una marca de tiempo al archivo."

#: usr_10.txt:739
msgid "WHEN IT DOESN'T WORK"
msgstr "CUANDO NO FUNCIONA"

#: usr_10.txt:741
msgid ""
"Starting a shell, sending it text and capturing the output requires that "
"Vim\n"
"knows how the shell works exactly.  When you have problems with filtering,\n"
"check the values of these options:"
msgstr ""
"Iniciar la consola, enviarle texto y capturar la salida requiere que Vim \n" 
"sepa exactamente cómo funciona la consola de forma precisa. Cuando tenga\n"
"problemas con el filtrado, comprueba los valores de las siguientes opciones:"


#: usr_10.txt:745
msgid ""
"\t'shell'\t\tspecifies the program that Vim uses to execute\n"
"\t\t\texternal programs.\n"
"\t'shellcmdflag'\targument to pass a command to the shell\n"
"\t'shellquote'\tquote to be used around the command\n"
"\t'shellxquote'\tquote to be used around the command and redirection\n"
"\t'shelltype'\tkind of shell (only for the Amiga)\n"
"\t'shellslash'\tuse forward slashes in the command (only for\n"
"\t\t\tMS-Windows and alikes)\n"
"\t'shellredir'\tstring used to write the command output into a file"
msgstr ""
"\t'shell'\t\tespecifica el programa que Vim empleará para ejecutar\n"
"\t\t\tprogramas externos.\n"
"\t'shellcmdflag'\targumento para pasar un orden a la consola\n"
"\t'shellquote'\tcomillas a usar alrededor de la orden\n"
"\t'shellxquote'\tcomillas a usar alrededor de la orden y redirección\n"
"\t'shelltype'\ttipo de consola (sólo para Amiga)\n"
"\t'shellslash'\tusar barras inclinadas en la orden (sólo para\n"
"\t\t\tWindows y similares)\n"
"\t'shellredir'\tcadena para escribir la salida a un archivo"

#: usr_10.txt:755
msgid ""
"On Unix this is hardly ever a problem, because there are two kinds of "
"shells:\n"
"\"sh\" like and \"csh\" like.  Vim checks the 'shell' option and sets "
"related\n"
"options automatically, depending on whether it sees \"csh\" somewhere in\n"
"'shell'.\n"
"   On MS-Windows, however, there are many different shells and you might "
"have\n"
"to tune the options to make filtering work.  Check the help for the options\n"
"for more information."
msgstr ""
"En Unix esto es raramente un problema, porque hay dos tipos de consola: «sh» "
"y\n"
"«csh». Vim comprueba la opción 'shell' y configura todo automáticamente,\n"
"dependiendo de si ve «cshx en algún lugar de 'shell'.\n"
"   Sin embargo, en Windows, hay muchos tipos de consolas y quizá tenga que\n"
"ajustar las opciones para hacer que el filtrado funcione correctamente.\n"
"Busque en la ayuda más información sobre las opciones de configuración\n"
"de la consola para poder solucionarlo."


#: usr_10.txt:764
msgid "READING COMMAND OUTPUT"
msgstr "LEER LA SALIDA DE LA ORDEN"

#: usr_10.txt:766
msgid "To read the contents of the current directory into the file, use this:"
msgstr "Para escribir los contenidos del directorio actual en el archivo, use:"

#: usr_10.txt:768
msgid ""
"on Unix: >\n"
"\t:read !ls\n"
"on MS-Windows: >\n"
"\t:read !dir"
msgstr ""
"en Unix: >\n"
"\t:read !ls\n"
"en MS-Windows: >\n"
"\t:read !dir"

#: usr_10.txt:773
msgid ""
"The output of the \"ls\" or \"dir\" command is captured and inserted in the "
"text,\n"
"below the cursor.  This is similar to reading a file, except that the \"!\" "
"is\n"
"used to tell Vim that a command follows.\n"
"   The command may have arguments.  And a range can be used to tell where "
"Vim\n"
"should put the lines: >"
msgstr ""
"La salida de las órdenes «ls» o «dir» se puede capturar e insertar en el\n"
"texto, debajo del cursor. Esto es similar a leer un archivo, excepto que el\n"
"«!» se emplea para decirle a Vim que hay una orden a continuación.\n"
"   Puede que la orden tenga argumentos. Puede emplear un rango para\n"
"decirle a Vim dónde debería poner las líneas: >"

#: usr_10.txt:779
msgid "\t:0read !date -u"
msgstr "\t:0read !date -u"

#: usr_10.txt:781
msgid ""
"This inserts the current time and date in UTC format at the top of the "
"file.\n"
"(Well, if you have a date command that accepts the \"-u\" argument.)  Note "
"the\n"
"difference with using \"!!date\": that replaced a line, while \":read !date"
"\" will\n"
"insert a line."
msgstr ""
"Esto inserta la hora y fecha actuales en formato UTC en la primera línea del\n"
"archivo. (Bueno, si tienes una orden «date» que acepta el argumento «-u».)\n"
"Observe la diferencia de usar «!!date»: esto reemplazó una línea, mientras\n"
"que «:read !date» insertó una línea."


#: usr_10.txt:787
msgid "WRITING TEXT TO A COMMAND"
msgstr "PASAR TEXTO A UNA ORDEN"

#: usr_10.txt:789
msgid ""
"The Unix command \"wc\" counts words.  To count the words in the current "
"file: >"
msgstr ""
"La orden Unix «wc» cuenta palabras. Para contar las del archivo actual: >"

#: usr_10.txt:791
msgid "\t:write !wc"
msgstr "\t:write !wc"

#: usr_10.txt:793
msgid ""
"This is the same write command as before, but instead of a file name the \"!"
"\"\n"
"character is used and the name of an external command.  The written text "
"will\n"
"be passed to the specified command as its standard input.  The output could\n"
"look like this:"
msgstr ""
"Esta es la misma orden «write» vista  que anteriormente, pero en lugar de un\n"
"nombre de archivo, se emplean el carácter «!» y una orden externa. El texto\n"
"guardado será pasado al orden especificado como entrada estándar. La salida\n"
"será algo así:"

#: usr_10.txt:798
msgid "       4      47     249 ~"
msgstr "       4      47     249 ~"

#: usr_10.txt:800
msgid ""
"The \"wc\" command isn't verbose.  This means you have 4 lines, 47 words and "
"249\n"
"characters."
msgstr ""
"La orden «wc» no es muy informativa. Esto significa que tiene 4 líneas, 47\n"
"palabras y 249 caracteres."

#: usr_10.txt:803
msgid "Watch out for this mistake: >"
msgstr "Tenga cuidado de no cometer este error: >"

#: usr_10.txt:805
msgid "\t:write! wc"
msgstr "\t:write! wc"

#: usr_10.txt:807
msgid ""
"This will write the file \"wc\" in the current directory, with force.  "
"White\n"
"space is important here!"
msgstr ""
"Esto guardará el archivo «wc» en el directorio actual con la opción «force»\n"
"(forzar). ¡El espacio en blanco es muy importante en este caso!"

#: usr_10.txt:811
msgid "REDRAWING THE SCREEN"
msgstr "REDIBUJAR LA PANTALLA"

#: usr_10.txt:813
msgid ""
"If the external command produced an error message, the display may have "
"been\n"
"messed up.  Vim is very efficient and only redraws those parts of the "
"screen\n"
"that it knows need redrawing.  But it can't know about what another program\n"
"has written.  To tell Vim to redraw the screen: >"
msgstr ""
"Si la orden externa produjo un mensaje de error, la pantalla de Vim tal vez\n"
"esté sobreescrita con información confusa. Vim es muy eficiente y sólo\n"
"reescribe aquellas partes de la pantalla que lo necesiten. Pero no puede\n"
"saber sobre lo que otro programa ha tocado. Para decirle a Vim que redibuje\n"
"la pantalla: >"

#: usr_10.txt:818
msgid "\tCTRL-L"
msgstr "\tCTRL-L"

#: usr_10.txt:820
msgid "=============================================================================="
msgstr "=============================================================================="

#: usr_10.txt:822
msgid "Next chapter: |usr_11.txt|  Recovering from a crash"
msgstr "Capítulo siguiente: |usr_11.esx|  Recuperarse de un fallo"

#: usr_10.txt:824
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: véase |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
