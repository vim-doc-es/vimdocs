# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#. extracted from usr_12.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-01 19:54+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: ENCODING\n"

#: usr_12.txt:1
#, fuzzy
msgid "*usr_12.txt*\tFor Vim version 7.2.  Last change: 2007 May 11"
msgstr "*usr_12.txt*\tFor Vim version 7.2.  Last change: 2007 May 11"

#: usr_12.txt:3
#, fuzzy
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr "                MANUAL DE USUARIO DE VIM - por Bram Moolenaar"

#: usr_12.txt:5
#, fuzzy
msgid "\t\t\t\tClever tricks"
msgstr "\t\t\t\t    Trucos"

#: usr_12.txt:8
#, fuzzy
msgid ""
"By combining several commands you can make Vim do nearly everything.  In "
"this\n"
"chapter a number of useful combinations will be presented.  This uses the\n"
"commands introduced in the previous chapters and a few more."
msgstr ""
"Combinando varios comandos puedes conseguir que Vim haga casi cualquier "
"cosa.\n"
"En este capítulo, presentaremos una serie de combinaciones útiles.  Esto\n"
"emplea los comandos introducidos en capítulos anteriores y algunos más."

#: usr_12.txt:12
#, fuzzy
msgid ""
"|12.1|\tReplace a word\n"
"|12.2|\tChange \"Last, First\" to \"First Last\"\n"
"|12.3|\tSort a list\n"
"|12.4|\tReverse line order\n"
"|12.5|\tCount words\n"
"|12.6|\tFind a man page\n"
"|12.7|\tTrim blanks\n"
"|12.8|\tFind where a word is used"
msgstr ""
"|12.1|  Reemplazar una palabra\n"
"|12.2|  Cambiar \"Último, Primero\" a \"Primero Último\"\n"
"|12.3|  Ordenar una lista\n"
"|12.4|  Invertir el orden de las líneas\n"
"|12.5|  Contar palabras\n"
"|12.6|  Encontrar una página del manual\n"
"|12.7|  Eliminar espacios en blanco sobrantes\n"
"|12.8|  Buscar dónde se emplea una palabra"

#: usr_12.txt:21
#, fuzzy
msgid ""
"     Next chapter: |usr_20.txt|  Typing command-line commands quickly\n"
" Previous chapter: |usr_11.txt|  Recovering from a crash\n"
"Table of contents: |usr_toc.txt|"
msgstr ""
" Capítulo siguiente: |usr_20.txt|  Ser eficaz con la línea de comandos\n"
"  Capítulo anterior: |usr_11.txt|  Recuperación de errores\n"
"         Contenidos: |usr_toc.txt|"

#: usr_12.txt:25
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.1*\tReplace a word"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:28
#, fuzzy
msgid ""
"The substitute command can be used to replace all occurrences of a word "
"with\n"
"another word: >"
msgstr ""
"El comando sustituir puede ser empleado para reemplazar todos los casos de "
"una\n"
"palabra con otra: >"

#: usr_12.txt:31
#, fuzzy
msgid "\t:%s/four/4/g"
msgstr "\t:%s/cuatro/4/g"

#: usr_12.txt:33
#, fuzzy
msgid ""
"The \"%\" range means to replace in all lines.  The \"g\" flag at the end "
"causes\n"
"all words in a line to be replaced.\n"
"   This will not do the right thing if your file also contains \"thirtyfour"
"\".\n"
"It would be replaced with \"thirty4\".  To avoid this, use the \"\\<\" item "
"to\n"
"match the start of a word: >"
msgstr ""
"El rango \"%\" significa reemplazar en todas las líneas.  La bandera \"g\" "
"al final\n"
"hace que todas las palabras de una línea sean sustituidas.\n"
"   Esto no hará lo que deseas si tu archivo también contiene \"veinticuatro"
"\".\n"
"Será reemplazado por \"veinti4\".  Para evitar que esto ocurra usa el \"\\<"
"\" para\n"
"concordar el comienzo de una palabra. >"

#: usr_12.txt:39
#, fuzzy
msgid "\t:%s/\\<four/4/g"
msgstr "\t:%s/\\<cuatro/4/g"

#: usr_12.txt:41
#, fuzzy
msgid ""
"Obviously, this still goes wrong on \"fourteen\".  Use \"\\>\" to match the "
"end of\n"
"a word: >"
msgstr ""
"Obviamente, esto también funcionará mal con \"cuatrocientos\".  Usa \"\\>\" "
"para\n"
"concordar el final de una palabra: >"

#: usr_12.txt:44
#, fuzzy
msgid "\t:%s/\\<four\\>/4/g"
msgstr "\t:%s/\\<cuatro\\>/4/g"

#: usr_12.txt:46
#, fuzzy
msgid ""
"If you are programming, you might want to replace \"four\" in comments, but "
"not\n"
"in the code.  Since this is difficult to specify, add the \"c\" flag to have "
"the\n"
"substitute command prompt you for each replacement: >"
msgstr ""
"Si estás programando, quizá quieras reemplazar \"cuatro\" en los "
"comentarios,\n"
"pero no en el código.  Ya que es difícil de especificar, añade la bandera \"c"
"\"\n"
"para ser preguntado cada vez que se vaya a reemplazar la palabra: >"

#: usr_12.txt:51
#, fuzzy
msgid "\t:%s/\\<four\\>/4/gc"
msgstr "\t:%s/\\<cuatro\\>/4/gc"

#: usr_12.txt:54
#, fuzzy
msgid "REPLACING IN SEVERAL FILES"
msgstr "REEMPLAZAR EN VARIOS ARCHIVOS"

#: usr_12.txt:56
#, fuzzy
msgid ""
"Suppose you want to replace a word in more than one file.  You could edit "
"each\n"
"file and type the command manually.  It's a lot faster to use record and\n"
"playback.\n"
"   Let's assume you have a directory with C++ files, all ending in \".cpp"
"\".\n"
"There is a function called \"GetResp\" that you want to rename to \"GetAnswer"
"\"."
msgstr ""
"Supón que quieres reemplazar una palabra en más de un archivo.  Puedes "
"editar\n"
"cada archivo y escribir el comando manualmente.  Es mucho más fácil usar la\n"
"grabación y reproducción.\n"
"   Vamos a asumir que tienes un directorio con archivos C++ en el que todos\n"
"terminan en \".cpp\".  Quieres renombrar la función \"GetResp\" a \"GetAnswer"
"\"."

#: usr_12.txt:62
#, fuzzy
msgid ""
"\tvim *.cpp\t\tStart Vim, defining the argument list to\n"
"\t\t\t\tcontain all the C++ files.  You are now in the\n"
"\t\t\t\tfirst file.\n"
"\tqq\t\t\tStart recording into the q register\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tDo the replacements in the first file.\n"
"\t:wnext\t\t\tWrite this file and move to the next one.\n"
"\tq\t\t\tStop recording.\n"
"\t@q\t\t\tExecute the q register.  This will replay the\n"
"\t\t\t\tsubstitution and \":wnext\".  You can verify\n"
"\t\t\t\tthat this doesn't produce an error message.\n"
"\t999@q\t\t\tExecute the q register on the remaining files."
msgstr ""
"\tvim *.cpp\t\tArranca Vim definiendo la lista de argumentos\n"
"\t\t\t\tconteniendo todos los archivos C++.  Estarás\n"
"\t\t\t\tahora en el primer archivo.\n"
"\tqq\t\t\tComienza a grabar en el registro q.\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tReemplaza en el primer archivo.\n"
"\t:wnext\t\t\tGraba este archivo y ve al siguiente.\n"
"\tq\t\t\tPara la grabación.\n"
"\t@q\t\t\tEjecuta el registro q.  Esto ejecutará la\n"
"\t\t\t\tsustitución y el comando \":wnext\".  Puedes\n"
"\t\t\t\tcomprobar que esto no produzca ningún error.\n"
"\t999@q\t\t\tEjecuta el registro q en el resto de archivos."

#: usr_12.txt:75
#, fuzzy
msgid ""
"At the last file you will get an error message, because \":wnext\" cannot "
"move\n"
"to the next file.  This stops the execution, and everything is done."
msgstr ""
"En el último archivo obtendrás un mensaje de error, porque \"wnext\" no "
"puede ir\n"
"a un archivo siguiente.  Esto parará la ejecución y todo terminará."

#: usr_12.txt:78
#, fuzzy
msgid ""
"\tNote:\n"
"\tWhen playing back a recorded sequence, an error stops the execution.\n"
"\tTherefore, make sure you don't get an error message when recording."
msgstr ""
"\tNote:\n"
"\tCuando vuelvas a reproducir una secuencia grabada, un error parará la\n"
"\tejecución.  Cuida de no producir errores cuando grabes."

#: usr_12.txt:82
#, fuzzy
msgid ""
"There is one catch: If one of the .cpp files does not contain the word\n"
"\"GetResp\", you will get an error and replacing will stop.  To avoid this, "
"add\n"
"the \"e\" flag to the substitute command: >"
msgstr ""
"Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra\n"
"\"GetResp\", obtendrás un error y la ejecución se parará.  Para evitar "
"esto,\n"
"añade la bandera \"e\" al comando sustituir: >"

#: usr_12.txt:86
#, fuzzy
msgid "\t:%s/\\<GetResp\\>/GetAnswer/ge"
msgstr "\t:%s/\\<GetResp\\>/GetAnswer/ge"

#: usr_12.txt:88
#, fuzzy
msgid ""
"The \"e\" flag tells \":substitute\" that not finding a match is not an "
"error."
msgstr ""
"La bandera \"e\" le dice a \":substitute\" que ninguna coincidencia no es un "
"error."

#: usr_12.txt:90
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.2*\tChange \"Last, First\" to \"First Last\""
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:93
#, fuzzy
msgid "You have a list of names in this form:"
msgstr "Tienes una lista de nombre de la siguiente forma:"

#: usr_12.txt:95
#, fuzzy
msgid ""
"\tDoe, John ~\n"
"\tSmith, Peter ~"
msgstr ""
"\tPepe, Juan ~\n"
"\tAmancio, Pedro ~"

#: usr_12.txt:98
#, fuzzy
msgid "You want to change that to:"
msgstr "Quieres cambiarlo a:"

#: usr_12.txt:100
#, fuzzy
msgid ""
"\tJohn Doe ~\n"
"\tPeter Smith ~"
msgstr ""
"\tJuan Pepe ~\n"
"\tPedro Amancio ~"

#: usr_12.txt:103
#, fuzzy
msgid "This can be done with just one command: >"
msgstr "Esto se puede hacer con un solo comando: >"

#: usr_12.txt:105
#, fuzzy
msgid "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/"
msgstr "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/"

#: usr_12.txt:107
#, fuzzy
msgid ""
"Let's break this down in parts.  Obviously it starts with a substitute\n"
"command.  The \"%\" is the line range, which stands for the whole file.  "
"Thus\n"
"the substitution is done in every line in the file.\n"
"   The arguments for the substitute command are \"/from/to/\".  The slashes\n"
"separate the \"from\" pattern and the \"to\" string.  This is what the \"from"
"\"\n"
"pattern contains:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~"
msgstr ""
"Veámoslo por partes.  Obviamente comienza con el comando substitute .  El \"%"
"\"\n"
"es el rango de líneas, que se refiere al archivo completo.  Por lo tanto la\n"
"sustitución se producirá en cada línea del archivo.\n"
"   Los argumentos para el comando sustituir son \"/desde/a/\".  Las barras\n"
"separan el patrón \"desde\" y la cadena \"hacia\".  Esto es lo que el "
"patrón\n"
"\"desde\" contiene:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~"

#: usr_12.txt:115
#, fuzzy
msgid ""
"\tThe first part between \\( \\) matches \"Last\"\t\\(     \\)\n"
"\t    match anything but a comma\t\t\t  [^,]\n"
"\t    any number of times\t\t\t\t      *\n"
"\tmatches \", \" literally\t\t\t\t\t ,\n"
"\tThe second part between \\( \\) matches \"First\"\t\t   \\(  \\)\n"
"\t    any character\t\t\t\t\t     .\n"
"\t    any number of times\t\t\t\t\t      *"
msgstr ""
"\tLa primera parte entre \\( \\) concuerda \"Último\" \\(     \\)\n"
"\t    concordar cualquier cosa excepto una coma     [^,]\n"
"\t    cualquier número de veces                         *\n"
"\tconcuerda literalmente \", \"                              ,\n"
"\tLa segunda parte entre \\(  \\) concuerda \"Primero\"          \\(  \\)\n"
"\t    cualquier carácter                                       .\n"
"\t    cualquier número de veces                                 *"

#: usr_12.txt:123
#, fuzzy
msgid ""
"In the \"to\" part we have \"\\2\" and \"\\1\".  These are called "
"backreferences.\n"
"They refer to the text matched by the \"\\( \\)\" parts in the pattern.  "
"\"\\2\"\n"
"refers to the text matched by the second \"\\( \\)\", which is the \"First\" "
"name.\n"
"\"\\1\" refers to the first \"\\( \\)\", which is the \"Last\" name.\n"
"   You can use up to nine backreferences in the \"to\" part of a substitute\n"
"command.  \"\\0\" stands for the whole matched pattern.  There are a few "
"more\n"
"special items in a substitute command, see |sub-replace-special|."
msgstr ""
"En la parte \"a\" tenemos \"\\2\" y \"\\1\".  A esto se le llaman "
"referencias \"vuelta\n"
"atrás\".  Refieren al texto encontrado por los \"\\( \\)\" del patrón.  \"\\2"
"\" se\n"
"refiere al texto del segundo \"\\( \\)\", que es el nombre \"Pimero\".  \"\\1"
"\" se\n"
"refiere al primer \"\\( \\)\", que es el nombre \"Último\".\n"
"   Puedes usar hasta nueve referencias \"vuelta atrás\" en la parte \"a\" de "
"un\n"
"comando sustitución.  \"\\0\" se refiere a la cadena coincidente completa.  "
"Hay\n"
"otros elementos especiales en un comando sustituir, ver |sub-replace-"
"special|."

#: usr_12.txt:131
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.3*\tSort a list"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:134
#, fuzzy
msgid "In a Makefile you often have a list of files.  For example:"
msgstr ""
"En un archivo Makefile tienes a menudo una lista de archivos.  Por ejemplo:"

#: usr_12.txt:136
#, fuzzy
msgid ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~"

#: usr_12.txt:146
#, fuzzy
msgid "To sort this list, filter the text through the external sort command: >"
msgstr ""
"Para ordenar esta lista, filtra el texto a través del comando externo sort: >"

#: usr_12.txt:148
#, fuzzy
msgid ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort"
msgstr ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort"

#: usr_12.txt:152
#, fuzzy
msgid ""
"This goes to the first line, where \"OBJS\" is the first thing in the line.\n"
"Then it goes one line down and filters the lines until the next empty line.\n"
"You could also select the lines in Visual mode and then use \"!sort\".  "
"That's\n"
"easier to type, but more work when there are many lines.\n"
"   The result is this:"
msgstr ""
"Esto va a la primera línea, donde \"OBJS\" es lo primero que se encuentra en "
"una\n"
"línea.  Luego baja una línea y filtra las líneas hasta encontrar una línea\n"
"vacía.  También podrías seleccionar las líneas en modo Visual y escribir\n"
"\"!sort\".  Es más fácil pero conlleva más trabajo cuando hay muchas "
"líneas.\n"
"   El resultado es el siguiente:"

#: usr_12.txt:158
#, fuzzy
msgid ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~"

#: usr_12.txt:169
#, fuzzy
msgid ""
"Notice that a backslash at the end of each line is used to indicate the "
"line\n"
"continues.  After sorting, this is wrong!  The \"backup.o\" line that was "
"at\n"
"the end didn't have a backslash.  Now that it sorts to another place, it\n"
"must have a backslash.\n"
"   The simplest solution is to add the backslash with \"A \\<Esc>\".  You "
"can\n"
"keep the backslash in the last line, if you make sure an empty line comes\n"
"after it.  That way you don't have this problem again."
msgstr ""
"Observa que una barra invertida al final de cada línea se usa para indicar "
"que\n"
"la línea continúa.  Tras ordenar, está mal puesto.  La línea de \"backup.o\" "
"que\n"
"estaba al final no tenía una barra invertida.  Ahora que se sitúa en otro\n"
"lugar debe tener una barra invertida.\n"
"   La solución más sencilla es añadirla con \"A \\<Esc>\".  Puedes mantener "
"la\n"
"barra en la última línea si te aseguras de que una línea en blanco viene "
"justo\n"
"después.  De este modo no tendrás este problema de nuevo."

#: usr_12.txt:177
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.4*\tReverse line order"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:180
#, fuzzy
msgid ""
"The |:global| command can be combined with the |:move| command to move all "
"the\n"
"lines before the first line, resulting in a reversed file.  The command is: >"
msgstr ""
"El comando |:global| debe ser combinado con el comando |:move| para mover\n"
"todas las líneas antes de la primera línea, invirtiendo el archivo.  "
"Escribe:\n"
">"

#: usr_12.txt:183
#, fuzzy
msgid "\t:global/^/m 0"
msgstr "\t:global/^/m 0"

#: usr_12.txt:185
#, fuzzy
msgid "Abbreviated: >"
msgstr "Abreviado: >"

#: usr_12.txt:187
#, fuzzy
msgid "\t:g/^/m 0"
msgstr "\t:g/^/m 0"

#: usr_12.txt:189
#, fuzzy
msgid ""
"The \"^\" regular expression matches the beginning of the line (even if the "
"line\n"
"is blank).  The |:move| command moves the matching line to after the "
"mythical\n"
"zeroth line, so the current matching line becomes the first line of the "
"file.\n"
"As the |:global| command is not confused by the changing line numbering,\n"
"|:global| proceeds to match all remaining lines of the file and puts each "
"as\n"
"the first."
msgstr ""
"La expresión regular \"^\" coincide con el comienzo de línea (incluso si la\n"
"línea está en blanco).  El comando |:move| mueve la línea justo después de "
"la\n"
"mítica \"línea cero\", de forma que se convierte en la primera línea.  Como "
"el\n"
"comando |:global| no se confunde al cambiar la numeración de las líneas,\n"
"|:global| procede a concordar el resto de líneas del archivo y pone cada "
"una\n"
"como la primera."

#: usr_12.txt:196
#, fuzzy
msgid ""
"This also works on a range of lines.  First move to above the first line "
"and\n"
"mark it with \"mt\".  Then move the cursor to the last line in the range "
"and\n"
"type: >"
msgstr ""
"Esto también funciona sobre un rango de líneas.  Primero ve a la línea de\n"
"encima de la primera y márcala con \"mt\".  Luego pon el cursor en la "
"última\n"
"línea del rango y escribe: >"

#: usr_12.txt:200
#, fuzzy
msgid "\t:'t+1,.g/^/m 't"
msgstr "\t:'t+1,.g/^/m 't"

#: usr_12.txt:202
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.5*\tCount words"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:205
#, fuzzy
msgid ""
"Sometimes you have to write a text with a maximum number of words.  Vim can\n"
"count the words for you.\n"
"   When the whole file is what you want to count the words in, use this\n"
"command: >"
msgstr ""
"A veces puedes escribir un texto con un número máximo de palabras.  Vim "
"puede\n"
"contar las palabras por ti.\n"
"   Cuando quieres usar el archivo completo para contar las palabras, usa el\n"
"siguiente comando: >"

#: usr_12.txt:210
#, fuzzy
msgid "\tg CTRL-G"
msgstr "\tg CTRL-G"

#: usr_12.txt:212
#, fuzzy
msgid ""
"Do not type a space after the g, this is just used here to make the command\n"
"easy to read.\n"
"   The output looks like this:"
msgstr ""
"No teclees un espacio tras la g, esto está aquí para hacer que el comando "
"sea\n"
"fácil de leer.\n"
"   La salida tendrá este aspecto:"

#: usr_12.txt:216
#, fuzzy
msgid "\tCol 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~"
msgstr "\tCol 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~"

#: usr_12.txt:218
#, fuzzy
msgid ""
"You can see on which word you are (748), and the total number of words in "
"the\n"
"file (774)."
msgstr ""
"Puedes ver en qué palabra estás (748), y el número total de palabras en el\n"
"archivo (774)."

#: usr_12.txt:221
#, fuzzy
msgid ""
"When the text is only part of a file, you could move to the start of the "
"text,\n"
"type \"g CTRL-G\", move to the end of the text, type \"g CTRL-G\" again, and "
"then\n"
"use your brain to compute the difference in the word position.  That's a "
"good\n"
"exercise, but there is an easier way.  With Visual mode, select the text "
"you\n"
"want to count words in.  Then type g CTRL-G.  The result:"
msgstr ""
"Cuando el texto sea sólo una parte del archivo, puedes ir al comienzo del\n"
"texto, escribir \"g CTRL-G\", ir al final del texto y volver a escribir \"g\n"
"CTRL-G\" y usar la cabeza para calcular la diferencia.  Es un buen "
"ejercicio,\n"
"pero hay un modo más sencillo.  Con el modo Visual, selecciona el texto "
"sobre\n"
"el que quieres contar las palabras.  Escribe \"g CTRL-G\".  El resultado "
"será:"

#: usr_12.txt:227
#, fuzzy
msgid "\tSelected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~"
msgstr "\tSelected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~"

#: usr_12.txt:229
#, fuzzy
msgid ""
"For other ways to count words, lines and other items, see |count-items|."
msgstr ""
"Para otras formas de contar las palabras, líneas y otros, ver |count-items|."

#: usr_12.txt:231
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.6*\tFind a man page\t\t\t\t\t*find-manpage*"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:234
#, fuzzy
msgid ""
"While editing a shell script or C program, you are using a command or "
"function\n"
"that you want to find the man page for (this is on Unix).  Let's first use "
"a\n"
"simple way: Move the cursor to the word you want to find help on and press >"
msgstr ""
"Mientras editas un script de shell o un programa C, estás usando un comando "
"o\n"
"función para el que quieres encontrar una página de manual (en Unix).  Vamos "
"a\n"
"usar la forma sencilla.  Pon el cursor sobre la palabra y pulsa: >"

#: usr_12.txt:238
#, fuzzy
msgid "\tK"
msgstr "\tK"

#: usr_12.txt:240
#, fuzzy
msgid ""
"Vim will run the external \"man\" program on the word.  If the man page is\n"
"found, it is displayed.  This uses the normal pager to scroll through the "
"text\n"
"(mostly the \"more\" program).  When you get to the end pressing <Enter> "
"will\n"
"get you back into Vim."
msgstr ""
"Vim ejecutará el programa externo \"man\" sobre la palabra.  Si la página "
"man es\n"
"encontrada, se mostrará.  Esto usa el paginador normal para desplazarse por "
"el\n"
"texto (con el programa \"more\").  Cuando llegues al final, presionando "
"<Entrar>\n"
"te devolverá a Vim."

#: usr_12.txt:245
#, fuzzy
msgid ""
"A disadvantage is that you can't see the man page and the text you are "
"working\n"
"on at the same time.  There is a trick to make the man page appear in a Vim\n"
"window.  First, load the man filetype plugin: >"
msgstr ""
"Una desventaja es que no puedes ver la página man y el texto en el que\n"
"trabajas al mismo tiempo.  Hay un truco para hacer que la página man "
"aparezca\n"
"en una ventana de Vim.  Primero carga el plugin del tipo de archivo man: >"

#: usr_12.txt:249
#, fuzzy
msgid "\t:runtime! ftplugin/man.vim"
msgstr "\t:runtime! ftplugin/man.vim"

#: usr_12.txt:251
#, fuzzy
msgid ""
"Put this command in your vimrc file if you intend to do this often.  Now "
"you\n"
"can use the \":Man\" command to open a window on a man page: >"
msgstr ""
"Pon este comando en tu archivo vimrc si tienes intención de hacer esto a\n"
"menudo.  Ahora puedes usar \":Man\" para ver una página man en una ventana: >"

#: usr_12.txt:254
#, fuzzy
msgid "\t:Man csh"
msgstr "\t:Man csh"

#: usr_12.txt:256
#, fuzzy
msgid ""
"You can scroll around and the text is highlighted.  This allows you to find\n"
"the help you were looking for.  Use CTRL-W w to jump to the window with the\n"
"text you were working on.\n"
"   To find a man page in a specific section, put the section number first.\n"
"For example, to look in section 3 for \"echo\": >"
msgstr ""
"Puedes desplazarte alrededor y el texto será coloreado.  Esto te permite\n"
"encontrar la ayuda que estabas buscando.  Usa CTRL-W w para saltar a la\n"
"ventana con el texto en el que trabajabas.\n"
"   Para encontrar la página man en una sección específica, pon el número de\n"
"sección primero.  Por ejemplo, para ver \"echo\" en la sección 3: >"

#: usr_12.txt:262
#, fuzzy
msgid "\t:Man 3 echo"
msgstr "\t:Man 3 echo"

#: usr_12.txt:264
#, fuzzy
msgid ""
"To jump to another man page, which is in the text with the typical form\n"
"\"word(1)\", press CTRL-] on it.  Further \":Man\" commands will use the "
"same\n"
"window."
msgstr ""
"Para saltar a otra página man, la cuál está en el texto con la forma típica\n"
"\"word(1)\", pulsa CTRL-] sobre ella.  Otros llamadas a \":Man\" emplearán "
"la\n"
"misma ventana."

#: usr_12.txt:268
#, fuzzy
msgid "To display a man page for the word under the cursor, use this: >"
msgstr ""
"Para mostrar una página man para la palabra bajo el cursor usa lo siguiente: "
">"

#: usr_12.txt:270
#, fuzzy
msgid "\t\\K"
msgstr "\t\\K"

#: usr_12.txt:272
#, fuzzy
msgid ""
"(If you redefined the <Leader>, use it instead of the backslash).\n"
"For example, you want to know the return value of \"strstr()\" while "
"editing\n"
"this line:"
msgstr ""
"(Si has redefinido <Leader>, úsalo en lugar de la barra invertida).  Por\n"
"ejemplo, puede que quieras saber el valor que te devuelve \"strstr()\" "
"mientras\n"
"editas esta línea:"

#: usr_12.txt:276
#, fuzzy
msgid "\tif ( strstr (input, \"aap\") == ) ~"
msgstr "\tif ( strstr (input, \"aap\") == ) ~"

#: usr_12.txt:278
#, fuzzy
msgid ""
"Move the cursor to somewhere on \"strstr\" and type \"\\K\".  A window will "
"open\n"
"to display the man page for strstr()."
msgstr ""
"Pon el cursor en alguna parte de \"strstr\" y escribe \"\\K\".  A "
"continuación una\n"
"ventana se abrirá para mostrar la página man de strstr()."

#: usr_12.txt:281
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.7*\tTrim blanks"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:284
#, fuzzy
msgid ""
"Some people find spaces and tabs at the end of a line useless, wasteful, "
"and\n"
"ugly.  To remove whitespace at the end of every line, execute the following\n"
"command: >"
msgstr ""
"Algunas personas encuentras los espacios y los tabuladores al final de "
"línea\n"
"inútiles y feos.  Para eliminar el espacio en blando al final de cada "
"línea,\n"
"ejecuta el siguiente comando: >"

#: usr_12.txt:288
#, fuzzy
msgid "\t:%s/\\s\\+$//"
msgstr "\t:%s/\\s\\+$//"

#: usr_12.txt:290
#, fuzzy
msgid ""
"The line range \"%\" is used, thus this works on the whole file.  The "
"pattern\n"
"that the \":substitute\" command matches with is \"\\s\\+$\".  This finds "
"white\n"
"space characters (\\s), 1 or more of them (\\+), before the end-of-line "
"($).\n"
"Later will be explained how you write patterns like this |usr_27.txt|.\n"
"   The \"to\" part of the substitute command is empty: \"//\".  Thus it "
"replaces\n"
"with nothing, effectively deleting the matched white space."
msgstr ""
"El rango de línea \"%\" es empleado, funcionando sobre todo el archivo.  El\n"
"patrón que el comando \":substitute\" concuerda es el \"\\s\\+$\".  Esto "
"encuentra\n"
"los caracteres en blanco (\\s), 1 o más (\\+), antes del final de línea "
"($).\n"
"Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.\n"
"   La parte \"hacia\" del comando sustituir está vacía: \"//\".  Por lo "
"tanto\n"
"reemplaza con nada, lo que de hecho elimina el espacio en blanco."

#: usr_12.txt:297
#, fuzzy
msgid ""
"Another wasteful use of spaces is placing them before a tab.  Often these "
"can\n"
"be deleted without changing the amount of white space.  But not always!\n"
"Therefore, you can best do this manually.  Use this search command: >"
msgstr ""
"Otro uso desafortunado de los espacios es colocarlos antes de un tabulador.  "
"A\n"
"menudo pueden ser eliminados sin cambiar la cantidad de espacio en blanco.\n"
"¡Pero no siempre! Por lo tanto, lo mejor es que lo hagas a mano. Usa esto: >"

#: usr_12.txt:301
#, fuzzy
msgid "\t/ \t"
msgstr "\t/\t"

#: usr_12.txt:303
#, fuzzy
msgid ""
"You cannot see it, but there is a space before a tab in this command.  Thus\n"
"it's \"/<Space><Tab>\".   Now use \"x\" to delete the space and check that "
"the\n"
"amount of white space doesn't change.  You might have to insert a tab if it\n"
"does change.  Type \"n\" to find the next match.  Repeat this until no more\n"
"matches can be found."
msgstr ""
"No puedes verlo, pero hay un espacio antes de un tabulador en este comando.\n"
"De hecho, es \"/<Espacio><Tabulador>\".  Ahora usa \"x\" para eliminar el "
"espacio\n"
"y comprobar que la cantidad de espacio en blanco no cambia.  Puede que "
"tengas\n"
"que insertar un tabulador si cambia.  Teclea \"n\" para encontrar la "
"próxima\n"
"coincidencia.  Repite esto hasta que no se encuentren más concordancias."

#: usr_12.txt:309
#, fuzzy
msgid ""
"==============================================================================\n"
"*12.8*\tFind where a word is used"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:312
#, fuzzy
msgid ""
"If you are a UNIX user, you can use a combination of Vim and the grep "
"command\n"
"to edit all the files that contain a given word.  This is extremely useful "
"if\n"
"you are working on a program and want to view or edit all the files that\n"
"contain a specific variable.\n"
"   For example, suppose you want to edit all the C program files that "
"contain\n"
"the word \"frame_counter\".  To do this you use the command: >"
msgstr ""
"Si eres un usuario UNIX, puedes usar una combinación de Vim y grep para "
"editar\n"
"todos los archivos que contengan la palabra dada.  Esto es extremadamente "
"útil\n"
"si estás trabajando en un programa y quieres ver o editar todos los "
"archivos\n"
"que contienen una variable específica.\n"
"   Por ejemplo, supón que quieres editar todos los archivos C que contengan "
"la\n"
"palabra \"frame_counter\".  Para hacer esto usa el comando: >"

#: usr_12.txt:319
#, fuzzy
msgid "\tvim `grep -l frame_counter *.c`"
msgstr "\tvim `grep -l frame_counter *.c`"

#: usr_12.txt:321
#, fuzzy
msgid ""
"Let's look at this command in detail.  The grep command searches through a "
"set\n"
"of files for a given word.  Because the -l argument is specified, the "
"command\n"
"will only list the files containing the word and not print the matching "
"lines.\n"
"The word it is searching for is \"frame_counter\".  Actually, this can be "
"any\n"
"regular expression.  (Note: What grep uses for regular expressions is not\n"
"exactly the same as what Vim uses.)\n"
"   The entire command is enclosed in backticks (`).  This tells the UNIX "
"shell\n"
"to run this command and pretend that the results were typed on the command\n"
"line.  So what happens is that the grep command is run and produces a list "
"of\n"
"files, these files are put on the Vim command line.  This results in Vim\n"
"editing the file list that is the output of grep.  You can then use "
"commands\n"
"like \":next\" and \":first\" to browse through the files."
msgstr ""
"Veamos este comando en detalle.  El comando grep busca a través de un "
"conjunto\n"
"de archivos una palabra dada.  Ya que especificamos el argumento -l, el\n"
"comando sólo listará archivos que contengan la palabra y no impriman las\n"
"líneas coincidentes.  La palabra que está buscando es \"frame_counter\".  "
"De\n"
"hecho, esto puede ser cualquier expresión regular.  (Note: las expresiones\n"
"regulares en Vim y grep no siguen las mismas convenciones.)\n"
"   El comando está arropado por acentos invertidos (`).  Esto le dice al "
"shell\n"
"de UNIX que ejecute el comando y haga como si el resultado hubiese sido\n"
"escrito en la línea de comandos.  Por lo tanto el comando grep será "
"ejecutado\n"
"y producirá una lista de archivos, estos archivos serán puestos en la línea "
"de\n"
"comandos de Vim.  Podrás usar los comandos \":next\" y \":first\" para "
"navegar\n"
"entre los archivos."

#: usr_12.txt:335
#, fuzzy
msgid "FINDING EACH LINE"
msgstr "ENCONTRAR CADA LÍNEA"

#: usr_12.txt:337
#, fuzzy
msgid ""
"The above command only finds the files in which the word is found.  You "
"still\n"
"have to find the word within the files.\n"
"   Vim has a built-in command that you can use to search a set of files for "
"a\n"
"given string.  If you want to find all occurrences of \"error_string\" in "
"all C\n"
"program files, for example, enter the following command: >"
msgstr ""
"El comando de arriba sólo dice los archivos en los cuáles se encuentra la\n"
"palabra.  Todavía tendrás que encontrar la palabra entre los archivos.\n"
"   Vim tiene un comando embebido que puedes usar para buscar una cadena en "
"un\n"
"conjunto de archivos.  Si quieres encontrar todas las coincidencias de\n"
"\"error_string\" en todos los archivos C, por ejemplo, introduce lo "
"siguiente: >"

#: usr_12.txt:343
#, fuzzy
msgid "\t:grep error_string *.c"
msgstr "\t:grep error_string *.c"

#: usr_12.txt:345
#, fuzzy
msgid ""
"This causes Vim to search for the string \"error_string\" in all the "
"specified\n"
"files (*.c).  The editor will now open the first file where a match is "
"found\n"
"and position the cursor on the first matching line.  To go to the next\n"
"matching line (no matter in what file it is), use the \":cnext\" command.  "
"To go\n"
"to the previous match, use the \":cprev\" command.  Use \":clist\" to see "
"all the\n"
"matches and where they are.\n"
"   The \":grep\" command uses the external commands grep (on Unix) or "
"findstr\n"
"(on Windows).  You can change this by setting the option 'grepprg'."
msgstr ""
"Esto hace que Vim busque la cadena \"error_string\" en cada uno de los "
"archivos\n"
"especificados (*.c).  El editor abrirá el primer archivo donde se produzca "
"una\n"
"concordancia y posicionará el cursor en la primera línea coincidente.\n"
"Para ir a la siguiente línea (no importa en que archivo se encuentre), usa "
"el\n"
"comando \":cnext\".  Para ir a la anterior, usa \":cprev\".  Usa \":clist\" "
"para ver\n"
"todas las coincidencias y dónde están.\n"
"  El comando \":grep\" usa el comando externo grep en Unix y findstr en "
"Windows.\n"
"Puedes cambiar esto modificando la opción 'grepprg'."

#: usr_12.txt:354
#, fuzzy
msgid "=============================================================================="
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:356
#, fuzzy
msgid "Next chapter: |usr_20.txt|  Typing command-line commands quickly"
msgstr "Capítulo siguiente: |usr_20.txt|  Ser eficaz con la línea de comandos"

#: usr_12.txt:358
#, fuzzy
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: ver |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
