# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#. extracted from usr_10es.txt
#, fuzzy
msgid ""
msgstr "Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-08 01:17+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: ENCODING\n"

#: usr_10es.txt:1
#, fuzzy
msgid "*usr_10.txt*\tFor Vim version 7.2.  Last change: 2006 Nov 05"
msgstr "*usr_10.txt*\tFor Vim version 7.2.  Last change: 2006 Nov 05"

#: usr_10es.txt:3
#, fuzzy
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar"

#: usr_10es.txt:5
#, fuzzy
msgid "\t\t\t     Making big changes"
msgstr "\t\t\t   Realizar grandes cambios"

#: usr_10es.txt:8
#, fuzzy
msgid "In chapter 4 several ways to make small changes were explained.  This "
"chapter\n"
"goes into making changes that are repeated or can affect a large amount of\n"
"text.  The Visual mode allows doing various things with blocks of text.  "
"Use\n"
"an external program to do really complicated things."
msgstr "En el capítulo 4 se explicaron algunas formas de hacer cambios pequeños.  "
"Este\n"
"capítulo tratará de cambios que se repiten o que afectan a grandes "
"porciones\n"
"del texto.  El modo Visual permite hacer varias cosas con bloques de texto.\n"
"Usa un programa externo para hacer las cosas más complicadas."

#: usr_10es.txt:13
#, fuzzy
msgid "|10.1|\tRecord and playback commands\n"
"|10.2|\tSubstitution\n"
"|10.3|\tCommand ranges\n"
"|10.4|\tThe global command\n"
"|10.5|\tVisual block mode\n"
"|10.6|\tReading and writing part of a file\n"
"|10.7|\tFormatting text\n"
"|10.8|\tChanging case\n"
"|10.9|\tUsing an external program"
msgstr "|10.1|\tComandos de grabación y reproducción\n"
"|10.2|\tSubstitución\n"
"|10.3|\tRangos de aplicación\n"
"|10.4|\tLos comandos globales\n"
"|10.5|\tEl modo de bloque Visual\n"
"|10.6|\tLeyendo y escribiendo parte de un archivo\n"
"|10.7|\tFormatear texto\n"
"|10.8|\tCambiar mayúsculas y minúsculas\n"
"|10.9|\tUso de un programa externo"

#: usr_10es.txt:23
#, fuzzy
msgid "     Next chapter: |usr_11.txt|  Recovering from a crash\n"
" Previous chapter: |usr_09.txt|  Using the GUI\n"
"Table of contents: |usr_toc.txt|"
msgstr " Capítulo siguiente: |usr_11.txt|  Recuperación de errores\n"
"  Capítulo anterior: |usr_09.txt|  Uso de la GUI\n"
"         Contenidos: |usr_toc.txt|"

#: usr_10es.txt:27
#, fuzzy
#: usr_10es.txt:144
#, fuzzy
#: usr_10es.txt:221
#, fuzzy
#: usr_10es.txt:344
#, fuzzy
#: usr_10es.txt:380
#, fuzzy
#: usr_10es.txt:550
#, fuzzy
#: usr_10es.txt:624
#, fuzzy
#: usr_10es.txt:671
#, fuzzy
#: usr_10es.txt:696
#, fuzzy
#: usr_10es.txt:825
#, fuzzy
msgid "==============================================================================\n"
"*10.1*\tRecord and playback commands"
msgstr "==============================================================================\n"
"*10.1*\tComandos de grabación y reproducción"

#: usr_10es.txt:30
#, fuzzy
msgid "The \".\" command repeats the preceding change.  But what if you want to do\n"
"something more complex than a single change?  That's where command "
"recording\n"
"comes in.  There are three steps:"
msgstr "El comando \".\" repite el cambio precedente.  ¿Pero qué ocurre si quieres "
"hacer\n"
"algo más complicado que un simple cambio?  Para eso tenemos el comando\n"
"\"grabación\".  Hay que seguir tres pasos:"

#: usr_10es.txt:34
#, fuzzy
msgid "1. The \"q{register}\" command starts recording keystrokes into the "
"register\n"
"   named {register}.  The register name must be between a and z.\n"
"2. Type your commands.\n"
"3. To finish recording, press q (without any extra character)."
msgstr "1. El comando \"q{registro}\" inicia la grabación de teclas pulsadas en un\n"
"   registro llamado {registro}.  El nombre del registro es una letra (a-z).\n"
"2. Introduce los comandos.\n"
"3. Para finalizar la grabación, pulsa q (sin ningún carácter extra)."

#: usr_10es.txt:39
#, fuzzy
msgid "You can now execute the macro by typing the command \"@{register}\"."
msgstr "Puedes ejecutar la macro tecleando el comando \"@{registro}\""

#: usr_10es.txt:41
#, fuzzy
msgid "Take a look at how to use these commands in practice.  You have a list of\n"
"filenames that look like this:"
msgstr "Vamos a echarle un vistazo a cómo se usan los comandos en la práctica.  "
"Tienes\n"
"una lista de nombres de archivo como esta:"

#: usr_10es.txt:44
#, fuzzy
msgid "\tstdio.h ~\n"
"\tfcntl.h ~\n"
"\tunistd.h ~\n"
"\tstdlib.h ~"
msgstr "\tstdio.h ~\n"
"\tfcntl.h ~\n"
"\tunistd.h ~\n"
"\tstdlib.h ~"

#: usr_10es.txt:49
#, fuzzy
msgid "And what you want is the following:"
msgstr "Y lo que quieres es lo siguiente:"

#: usr_10es.txt:51
#, fuzzy
msgid "\t#include \"stdio.h\" ~\n"
"\t#include \"fcntl.h\" ~\n"
"\t#include \"unistd.h\" ~\n"
"\t#include \"stdlib.h\" ~"
msgstr "\t#include \"stdio.h\" ~\n"
"\t#include \"fcntl.h\" ~\n"
"\t#include \"unistd.h\" ~\n"
"\t#include \"stdlib.h\" ~"

#: usr_10es.txt:56
#, fuzzy
msgid "You start by moving to the first character of the first line.  Next you\n"
"execute the following commands:"
msgstr "Comienzas yendo al primer carácter de la primera línea.  A continuación\n"
"ejecuta el siguiente comando:"

#: usr_10es.txt:59
#, fuzzy
msgid "\tqa\t\t\tStart recording a macro in register a.\n"
"\t^\t\t\tMove to the beginning of the line.\n"
"\ti#include \"<Esc>\tInsert the string #include \" at the beginning\n"
"\t\t\t\tof the line.\n"
"\t$\t\t\tMove to the end of the line.\n"
"\ta\"<Esc>\t\t\tAppend the character double quotation mark (\")\n"
"\t\t\t\tto the end of the line.\n"
"\tj\t\t\tGo to the next line.\n"
"\tq\t\t\tStop recording the macro."
msgstr "\tqa\t\t\tComenzar a grabar la macro en el registro a.\n"
"\t^\t\t\tMoverte al comienzo de la línea.\n"
"\ti#include \"<Esc>\tInsertar el #include \" al comienzo de cada\n"
"\t\t\t\tlínea.\n"
"\t$\t\t\tMoverte al final de la línea.\n"
"\ta\"<Esc>\t\t\tAñadir el carácter de comillas dobles (\") al\n"
"\t\t\t\tfinal de la línea.\n"
"\tj\t\t\tIr a la próxima línea.\n"
"\tq\t\t\tDetener la grabación de la macro."

#: usr_10es.txt:69
#, fuzzy
msgid "Now that you have done the work once, you can repeat the change by typing "
"the\n"
"command \"@a\" three times.\n"
"   The \"@a\" command can be preceded by a count, which will cause the macro "
"to\n"
"be executed that number of times.  In this case you would type: >"
msgstr "Ahora que has realizado el trabajo una vez, puedes repetir el cambio "
"tecleando\n"
"el comando \"@a\" tres veces.\n"
"   El comando \"@a\" puede venir precedido de un multiplicador, el cuál "
"causará\n"
"que la macro se ejecute ese número determinado de veces.  En este caso: >"

#: usr_10es.txt:74
#, fuzzy
msgid "\t3@a"
msgstr "\t3@a"

#: usr_10es.txt:77
#, fuzzy
msgid "MOVE AND EXECUTE"
msgstr "MOVER Y EJECUTAR"

#: usr_10es.txt:79
#, fuzzy
msgid "You might have the lines you want to change in various places.  Just move "
"the\n"
"cursor to each location and use the \"@a\" command.  If you have done that "
"once,\n"
"you can do it again with \"@@\".  That's a bit easier to type.  If you now\n"
"execute register b with \"@b\", the next \"@@\" will use register b.\n"
"   If you compare the playback method with using \".\", there are several\n"
"differences.  First of all, \".\" can only repeat one change.  As seen in "
"the\n"
"example above, \"@a\" can do several changes, and move around as well.\n"
"Secondly, \".\" can only remember the last change.  Executing a register "
"allows\n"
"you to make any changes and then still use \"@a\" to replay the recorded\n"
"commands.  Finally, you can use 26 different registers.  Thus you can "
"remember\n"
"26 different command sequences to execute."
msgstr "Tal vez tengas la líneas que quieres cambiar en varios lugares.  "
"Simplemente\n"
"mueve el cursor a cada localización y usa el comando \"@a\".  Si has hecho "
"eso\n"
"una vez, puedes repetirlo con \"@@\".  Es un poco más sencillo de teclear.  "
"Si\n"
"ejecutas el registro b con \"@b\", el próximo \"@@\" usará el registro b.\n"
"   Si comparas esto con el método \".\", hay varias diferencias.  Lo "
"primero,\n"
"\".\" sólo puede repetir un cambio.  Como has podido ver en el ejemplo de\n"
"arriba, \"@a\" puede llevar a cabo varios cambios, incluyendo movimientos.  "
"Por\n"
"otro lado, \".\" sólo puede recordar el último cambio.  Ejecutar un registro "
"te\n"
"permite hacer algunos cambios en el texto y poder usar todavía lo comandos\n"
"grabados.  Por último, puedes usar 26 registros distintos.  De este modo\n"
"puedes reusar 26 secuencias diferentes."

#: usr_10es.txt:92
#, fuzzy
msgid "USING REGISTERS"
msgstr "USO DE REGISTROS"

#: usr_10es.txt:94
#, fuzzy
msgid "The registers used for recording are the same ones you used for yank and\n"
"delete commands.  This allows you to mix recording with other commands to\n"
"manipulate the registers.\n"
"   Suppose you have recorded a few commands in register n.  When you "
"execute\n"
"this with \"@n\" you notice you did something wrong.  You could try "
"recording\n"
"again, but perhaps you will make another mistake.  Instead, use this trick:"
msgstr "Los registros que se usan para grabar son los mismos que se usan para los\n"
"comandos copiar y eliminar.  Esto te permite mezclar la grabación con otros\n"
"comandos para manipular los registros.\n"
"   Supón que has grabado algunos comandos en el registro n.  Cuando lo\n"
"ejecutas con \"@n\" te das cuenta de que algo no va bien.  Podrías intentar\n"
"grabarlo de nuevo, pero quizá cometas otro error.  Mejor usar este truco:"

#: usr_10es.txt:101
#, fuzzy
msgid "\tG\t\t\tGo to the end of the file.\n"
"\to<Esc>\t\t\tCreate an empty line.\n"
"\t\"np\t\t\tPut the text from the n register.  You now see\n"
"\t\t\t\tthe commands you typed as text in the file.\n"
"\t{edits}\t\t\tChange the commands that were wrong.  This is\n"
"\t\t\t\tjust like editing text.\n"
"\t0\t\t\tGo to the start of the line.\n"
"\t\"ny$\t\t\tYank the corrected commands into the n\n"
"\t\t\t\tregister.\n"
"\tdd\t\t\tDelete the scratch line."
msgstr "\tG                       Ve al final del archivo\n"
"\to<Esc>                  Crea una nueva línea\n"
"\t\"np                     Pega el texto del registro n.  Verás que los\n"
"\t\t\t\tcomandos que grabaste se pegan como texto.\n"
"\t{edits}                 Cambia los comandos que están mal.  Esto es\n"
"\t\t\t\tcomo editar texto.\n"
"\t0                       Ve al principio de la línea.\n"
"\t\"ny$                    Copia (yank) los comandos corregidos al\n"
"\t\t\t\tregistro n.\n"
"\tdd                      Elimina la línea con los comandos pegados."

#: usr_10es.txt:112
#, fuzzy
msgid "Now you can execute the corrected commands with \"@n\".  (If your recorded\n"
"commands include line breaks, adjust the last two items in the example to\n"
"include all the lines.)"
msgstr "Ahora puedes ejecutar los comandos corregidos con \"@n\".  (Si los comandos\n"
"grabados incluyen saltos de línea, ajusta los dos últimos puntos de "
"explicados\n"
"anteriormente para incluir todas las líneas.)"

#: usr_10es.txt:117
#, fuzzy
msgid "APPENDING TO A REGISTER"
msgstr "AÑADIR A UN REGISTRO"

#: usr_10es.txt:119
#, fuzzy
msgid "So far we have used a lowercase letter for the register name.  To append to "
"a\n"
"register, use an uppercase letter.\n"
"   Suppose you have recorded a command to change a word to register c.  It\n"
"works properly, but you would like to add a search for the next word to\n"
"change.  This can be done with: >"
msgstr "Hasta el momento hemos usado letras en minúscula para el nombre del "
"registro.\n"
"Para añadir a un registro, usa una letra en mayúscula.\n"
"   Supón por un momento que has grabado un comando para cambiar una palabra "
"en\n"
"el registro c.  Funciona correctamente, pero quisieras añadir una búsqueda\n"
"para la siguiente palabra a cambiar.  Esto se puede hacer así: >"

#: usr_10es.txt:125
#, fuzzy
msgid "\tqC/word<Enter>q"
msgstr "\tqC/palabra<Entrar>q"

#: usr_10es.txt:127
#, fuzzy
msgid "You start with \"qC\", which records to the c register and appends.  Thus\n"
"writing to an uppercase register name means to append to the register with\n"
"the same letter, but lowercase."
msgstr "Comienzas con \"qC\", que añadirá al registro c.  De este modo podrás "
"siempre\n"
"escribir el registro al que quieras añadir nuevos pasos mediante la misma\n"
"de letra de identificación pero en mayúscula."

#: usr_10es.txt:131
#, fuzzy
msgid "This works both with recording and with yank and delete commands.  For\n"
"example, you want to collect a sequence of lines into the a register.  Yank\n"
"the first line with: >"
msgstr "Esto funciona tanto grabando como con los comandos de copiar y eliminar.  "
"Por\n"
"ejemplo, quieres recoger una secuencia de líneas en un registro.  Copia la\n"
"primera línea con: >"

#: usr_10es.txt:135
#, fuzzy
msgid "\t\"aY"
msgstr "\t\"aY"

#: usr_10es.txt:137
#, fuzzy
msgid "Now move to the second line, and type: >"
msgstr "Ahora ve a la siguiente línea y escribe: >"

#: usr_10es.txt:139
#, fuzzy
msgid "\t\"AY"
msgstr "\t\"AY"

#: usr_10es.txt:141
#, fuzzy
msgid "Repeat this command for all lines.  The a register now contains all those\n"
"lines, in the order you yanked them."
msgstr "Repite el comando para todas las líneas.  El registro a\" contiene en este\n"
"momento todas estas líneas, en el orden en el que las has copiado."

#: usr_10es.txt:147
#, fuzzy
msgid "The \":substitute\" command enables you to perform string replacements on a\n"
"whole range of lines.  The general form of this command is as follows: >"
msgstr "El comando \":substitute\" te permite ejecutar sustituciones de cadenas de\n"
"caracteres en un rango de líneas.  La forma general es la siguiente: >"

#: usr_10es.txt:150
#, fuzzy
msgid "\t:[range]substitute/from/to/[flags]"
msgstr "\t:[rango]substitute/de/a/[banderas]"

#: usr_10es.txt:152
#, fuzzy
msgid "This command changes the \"from\" string to the \"to\" string in the lines\n"
"specified with [range].  For example, you can change \"Professor\" to "
"\"Teacher\"\n"
"in all lines with the following command: >"
msgstr "Este comando cambia la cadena \"de\" por la cadena \"a\" en las líneas\n"
"especificadas con [rango].  Por ejemplo, puedes cambiar \"profesor\" por\n"
"\"maestro\" en todas las líneas con el siguiente comando: >"

#: usr_10es.txt:156
#, fuzzy
msgid "\t:%substitute/Professor/Teacher/\n"
"<\n"
"\tNote:\n"
"\tThe \":substitute\" command is almost never spelled out completely.\n"
"\tMost of the time, people use the abbreviated version \":s\".  From here\n"
"\ton the abbreviation will be used."
msgstr "\t:%substitute/profesor/maestro/\n"
"<\n"
"\tNote:\n"
"\tEl comando \":substitute\" casi nunca se escribe completo.  La mayoría\n"
"\tde las veces la gente escribe la versión abreviada \":s\".  A partir de\n"
"\tahora la abreviatura será empleada."

#: usr_10es.txt:163
#, fuzzy
msgid "The \"%\" before the command specifies the command works on all lines.  "
"Without\n"
"a range, \":s\" only works on the current line.  More about ranges in the "
"next\n"
"section |10.3|."
msgstr "El \"%\" antes del comando especifica que se ejecuta en todas las líneas.  "
"Sin\n"
"rango, \":s\" sólo funciona en la línea actual.  Más sobre los rangos en la\n"
"próxima sección |10.3|."

#: usr_10es.txt:167
#, fuzzy
msgid "By default, the \":substitute\" command changes only the first occurrence "
"on\n"
"each line.  For example, the preceding command changes the line:"
msgstr "Por defecto, el comando \":substitute\" cambia sólo la primera palabra\n"
"encontrada en cada línea.  Por ejemplo, el comando anterior cambia esta "
"línea:"

#: usr_10es.txt:170
#, fuzzy
msgid "\tProfessor Smith criticized Professor Johnson today. ~"
msgstr "\tEl profesor Pinilla ha criticado hoy al profesor Burgos. ~"

#: usr_10es.txt:172
#, fuzzy
msgid "to:"
msgstr "a esta:"

#: usr_10es.txt:174
#, fuzzy
msgid "\tTeacher Smith criticized Professor Johnson today. ~"
msgstr "\tEl maestro Pinilla ha criticado hoy al profesor Burgos. ~"

#: usr_10es.txt:176
#, fuzzy
msgid "To change every occurrence on the line, you need to add the g (global) "
"flag.\n"
"The command: >"
msgstr "Para cambiar todas palabras que aparezcan en la línea deberás usa la bandera "
"g\n"
"(global).  El comando: >"

#: usr_10es.txt:179
#, fuzzy
msgid "\t:%s/Professor/Teacher/g"
msgstr "\t:%s/profesor/maestro/g"

#: usr_10es.txt:181
#, fuzzy
msgid "results in (starting with the original line):"
msgstr "da como resultado (ejecutándolo sobre la línea original):"

#: usr_10es.txt:183
#, fuzzy
msgid "\tTeacher Smith criticized Teacher Johnson today. ~"
msgstr "\tEl maestro Pinilla ha criticado hoy al maestro Burgos. ~"

#: usr_10es.txt:185
#, fuzzy
msgid "Other flags include p (print), which causes the \":substitute\" command to "
"print\n"
"out the last line it changes.  The c (confirm) flag tells \":substitute\" to "
"ask\n"
"you for confirmation before it performs each substitution.  Enter the\n"
"following: >"
msgstr "Otras banderas incluyen p (print = imprimir), que hace el comando \":s\" "
"muestre\n"
"en pantalla la última línea que cambie.  La c (confirm = confirmar) le dice "
"a\n"
"\":s\" que pida confirmación antes que se ejecute cada sustitución.  "
"Introduce\n"
"lo siguiente: >"

#: usr_10es.txt:190
#, fuzzy
msgid "\t:%s/Professor/Teacher/c"
msgstr "\t:%s/profesor/maestro/c"

#: usr_10es.txt:192
#, fuzzy
msgid "Vim finds the first occurrence of \"Professor\" and displays the text it is\n"
"about to change.  You get the following prompt: >"
msgstr "Vim encuentra la primera aparición de \"profesor\" y muestra el texto que "
"está a\n"
"punto de cambiar.  Te aparecerá la siguiente pregunta: >"

#: usr_10es.txt:195
#, fuzzy
msgid "\treplace with Teacher (y/n/a/q/l/^E/^Y)?"
msgstr "\treplace with maestro (y/n/a/q/l/^E/^Y)?"

#: usr_10es.txt:197
#, fuzzy
msgid "At this point, you must enter one of the following answers:"
msgstr "Aquí puedes darle cualquiera de las siguientes respuestas:"

#: usr_10es.txt:199
#, fuzzy
msgid "\ty\t\tYes; make this change.\n"
"\tn\t\tNo; skip this match.\n"
"\ta\t\tAll; make this change and all remaining ones without\n"
"\t\t\tfurther confirmation.\n"
"\tq\t\tQuit; don't make any more changes.\n"
"\tl\t\tLast; make this change and then quit.\n"
"\tCTRL-E\t\tScroll the text one line up.\n"
"\tCTRL-Y\t\tScroll the text one line down."
msgstr "\ty               Si; hacer el cambio.\n"
"\tn               No; saltar esta palabra.\n"
"\ta               Todo; hacer este cambio y todos los restantes sin\n"
"\t\t\tpedir más confirmación.\n"
"\tq               Quit; no hacer más cambios.\n"
"\tl               Último; hacer este cambio y salir.\n"
"\tCTRL-E          Desplazar el texto hacia arriba.\n"
"\tCTRL-Y          Desplazar el texto hacia abajo."

#: usr_10es.txt:209
#, fuzzy
msgid "The \"from\" part of the substitute command is actually a pattern.  The "
"same\n"
"kind as used for the search command.  For example, this command only\n"
"substitutes \"the\" when it appears at the start of a line: >"
msgstr "La parte \"de\" del comando sustituir es, de hecho, un patrón (del mismo\n"
"tipo de los que se usan para la búsqueda).  Por ejemplo, este comando sólo\n"
"sustituye \"Eso\" cuando aparece al comienzo de una línea: >"

#: usr_10es.txt:213
#, fuzzy
msgid "\t:s/^the/these/"
msgstr "\t:s/^Eso/Aquello/"

#: usr_10es.txt:215
#, fuzzy
msgid "If you are substituting with a \"from\" or \"to\" part that includes a "
"slash, you\n"
"need to put a backslash before it.  A simpler way is to use another "
"character\n"
"instead of the slash.  A plus, for example: >"
msgstr "Si sustituyes con un \"de\" o un \"a\" que incluyan una barra inclinada, "
"tendrás\n"
"que poner una barra invertida antes de él.  Una forma más sencilla es usar\n"
"otro carácter como separador en lugar de la barra.  Un \"+\", por ejemplo: >"

#: usr_10es.txt:219
#, fuzzy
msgid "\t:s+one/two+one or two+"
msgstr "\t:s+uno/dos+uno o dos+"

#: usr_10es.txt:224
#, fuzzy
msgid "The \":substitute\" command, and many other : commands, can be applied to a\n"
"selection of lines.  This is called a range.\n"
"   The simple form of a range is {number},{number}.  For example: >"
msgstr "El comando \":substitute\" y muchos otros comandos \":\" pueden ser "
"aplicados a\n"
"una selección de líneas.  A esto se le llama rango.\n"
"   La forma más simple de un rango es {n},{n} (n es un número entero). Por "
"ej:\n"
">"

#: usr_10es.txt:229
#, fuzzy
msgid "\t:1,5s/this/that/g"
msgstr "\t:1,5s/esto/aquello/g"

#: usr_10es.txt:231
#, fuzzy
msgid "Executes the substitute command on the lines 1 to 5.  Line 5 is included.\n"
"The range is always placed before the command."
msgstr "ejecuta el comando sustituir desde la línea 1 a la 5.  La línea 5 queda\n"
"incluida.  El rango se sitúa justo antes del comando."

#: usr_10es.txt:234
#, fuzzy
msgid "A single number can be used to address one specific line: >"
msgstr "Un único número puede ser empleado para acceder a una línea específica: >"

#: usr_10es.txt:236
#, fuzzy
msgid "\t:54s/President/Fool/"
msgstr "\t:54s/Político/Demagogo/"

#: usr_10es.txt:238
#, fuzzy
msgid "Some commands work on the whole file when you do not specify a range.  To "
"make\n"
"them work on the current line the \".\" address is used.  The \":write\" "
"command\n"
"works like that.  Without a range, it writes the whole file.  To make it "
"write\n"
"only the current line into a file: >"
msgstr "Algunos comandos funcionan sobre un archivo completo cuando no le "
"especificas\n"
"un rango.  Para hacerlos funcionar en la línea actual, \".\" es empleado.  "
"El\n"
"comando \":write\" funciona de ese modo.  Sin un rango, escribe el archivo\n"
"completo.  Para hacer que sólo escriba una línea a un archivo: >"

#: usr_10es.txt:243
#, fuzzy
msgid "\t:.write otherfile"
msgstr "\t:.write otroarchivo"

#: usr_10es.txt:245
#, fuzzy
msgid "The first line always has number one.  How about the last line?  The \"$\"\n"
"character is used for this.  For example, to substitute in the lines from "
"the\n"
"cursor to the end: >"
msgstr "La primera línea siempre tiene como numeración el 1.  ¿Pero qué ocurre con "
"la\n"
"última línea?  El carácter \"$\" puede ser empleado para esto.  Por "
"ejemplo,\n"
"para sustituir en las líneas desde la del cursor hasta el final: >"

#: usr_10es.txt:249
#, fuzzy
msgid "\t:.,$s/yes/no/"
msgstr "\t:.,$s/si/no/"

#: usr_10es.txt:251
#, fuzzy
msgid "The \"%\" range that we used before, is actually a short way to say \"1,$\", "
"from\n"
"the first to the last line."
msgstr "El rango \"%\" que usamos anteriormente es una forma de decir \"1,$\" (desde "
"la\n"
"primera hasta la última)."

#: usr_10es.txt:255
#, fuzzy
msgid "USING A PATTERN IN A RANGE"
msgstr "USO DE UN PATRÓN EN EL RANGO"

#: usr_10es.txt:257
#, fuzzy
msgid "Suppose you are editing a chapter in a book, and want to replace all\n"
"occurrences of \"grey\" with \"gray\".  But only in this chapter, not in the "
"next\n"
"one.  You know that only chapter boundaries have the word \"Chapter\" in "
"the\n"
"first column.  This command will work then: >"
msgstr "Supón que estás editado un capítulo de un libro y quieres reemplazar todas "
"las\n"
"palabras \"gris\" con \"blanco\".  Pero sólo en ese capítulo, no en el "
"siguiente.\n"
"Sabes que los límites entre capítulos tienen la palabra \"Capítulo\" en la\n"
"primera columna.  Este comando funcionará así: >"

#: usr_10es.txt:262
#, fuzzy
msgid "\t:?^Chapter?,/^Chapter/s=grey=gray=g"
msgstr "\t:?^Capítulo?,/^Capítulo/s=gris=azul=g"

#: usr_10es.txt:264
#, fuzzy
msgid "You can see a search pattern is used twice.  The first \"?^Chapter?\" finds "
"the\n"
"line above the current position that matches this pattern.  Thus the ?"
"pattern?\n"
"range is used to search backwards.  Similarly, \"/^Chapter/\" is used to "
"search\n"
"forward for the start of the next chapter.\n"
"   To avoid confusion with the slashes, the \"=\" character was used in the\n"
"substitute command here.  A slash or another character would have worked as\n"
"well."
msgstr "Puedes observar que un patrón ha sido usado en dos ocasiones.  La primera\n"
"\"?^Chapter?\" busca hacia atrás el patrón.  Por lo tanto ?patrón? buscará\n"
"encima de la línea actual.  De forma similar, \"/^Capítulo/\" se usa para "
"buscar\n"
"hacia delante el comienzo del nuevo capítulo.\n"
"   Para evitar confusión con las barras, el carácter \"=\" ha sido empleado "
"en\n"
"el comando sustituir.  Una barra o cualquier otro carácter habría "
"funcionado\n"
"igual de bien."

#: usr_10es.txt:273
#, fuzzy
msgid "ADD AND SUBTRACT"
msgstr "AÑADIR Y ELIMINAR"

#: usr_10es.txt:275
#, fuzzy
msgid "There is a slight error in the above command: If the title of the next "
"chapter\n"
"had included \"grey\" it would be replaced as well.  Maybe that's what you\n"
"wanted, but what if you didn't?  Then you can specify an offset.\n"
"   To search for a pattern and then use the line above it: >"
msgstr "Hay un pequeño error en el comando de arriba: Si el título del siguiente\n"
"capítulo hubiese incluido \"gris\" habría sido reemplazado igualmente.  "
"Quizá\n"
"querías eso, ¿pero qué ocurre si no? Puedes especificar un offset.\n"
"   Para buscar un patrón e indicar la línea anterior: >"

#: usr_10es.txt:280
#, fuzzy
msgid "\t/Chapter/-1"
msgstr "\t/Capítulo/-1"

#: usr_10es.txt:282
#, fuzzy
msgid "You can use any number instead of the 1.  To address the second line below "
"the\n"
"match: >"
msgstr "Puedes usar cualquier número en lugar de 1.  Para indicar la segunda línea "
"por\n"
"debajo de la cadena encontrada: >"

#: usr_10es.txt:285
#, fuzzy
msgid "\t/Chapter/+2"
msgstr "\t/Capítulo/+2"

#: usr_10es.txt:287
#, fuzzy
msgid "The offsets can also be used with the other items in a range.  Look at this\n"
"one: >"
msgstr "El desplazamiento puede ser empleado también con otros elementos en un "
"rango.\n"
"Mira este: >"

#: usr_10es.txt:290
#, fuzzy
msgid "\t:.+3,$-5"
msgstr "\t:.+3,$-5"

#: usr_10es.txt:292
#, fuzzy
msgid "This specifies the range that starts three lines below the cursor and ends\n"
"five lines before the last line in the file."
msgstr "Esto especifica que el rango comienza tres líneas por debajo de la actual y\n"
"termina cinco líneas antes de la última línea del archivo."

#: usr_10es.txt:296
#, fuzzy
msgid "USING MARKS"
msgstr "USO DE MARCAS "

#: usr_10es.txt:298
#, fuzzy
msgid "Instead of figuring out the line numbers of certain positions, remembering "
"them\n"
"and typing them in a range, you can use marks.\n"
"   Place the marks as mentioned in chapter 3.  For example, use \"mt\" to "
"mark\n"
"the top of an area and \"mb\" to mark the bottom.  Then you can use this "
"range\n"
"to specify the lines between the marks (including the lines with the marks): "
">"
msgstr "En lugar de acordarte del número de algunas líneas en determinadas "
"posiciones,\n"
"e introducirlas en un rango, puedes usar marcadores.\n"
"   Pon marcas como se explica en el capítulo 3.  Por ejemplo, usa \"ms\" "
"para\n"
"marcar la parte superior de un área y \"mi\" para marcar la parte inferior"
"\".\n"
"Puedes usar el rango para especificar las líneas entre las marcas "
"(inclusive):\n"
">"

#: usr_10es.txt:305
#, fuzzy
msgid "\t:'t,'b"
msgstr "\t:'s,'i"

#: usr_10es.txt:308
#, fuzzy
msgid "VISUAL MODE AND RANGES"
msgstr "MODO VISUAL Y RANGOS"

#: usr_10es.txt:310
#, fuzzy
msgid "You can select text with Visual mode.  If you then press \":\" to start a "
"colon\n"
"command, you will see this: >"
msgstr "Puedes seleccionar texto con el modo Visual.  Si pulsas \":\" para iniciar "
"un\n"
"comando, verás lo siguiente: >"

#: usr_10es.txt:313
#, fuzzy
msgid "\t:'<,'>"
msgstr "\t:'<,'>"

#: usr_10es.txt:315
#, fuzzy
msgid "Now you can type the command and it will be applied to the range of lines "
"that\n"
"was visually selected."
msgstr "Ahora puedes teclear el comando y será aplicado al rango de líneas que "
"tienes\n"
"seleccionadas."

#: usr_10es.txt:318
#, fuzzy
msgid "\tNote:\n"
"\tWhen using Visual mode to select part of a line, or using CTRL-V to\n"
"\tselect a block of text, the colon commands will still apply to whole\n"
"\tlines.  This might change in a future version of Vim."
msgstr "\tNote:\n"
"\tCuando uses el modo Visual para seleccionar parte de una línea, o uses\n"
"\tCTRL-V para seleccionar un bloque de texto, los comandos se aplicarán\n"
"\ta líneas completas.  Esto puede que cambie en una futura versión."

#: usr_10es.txt:323
#, fuzzy
msgid "The '< and '> are actually marks, placed at the start and end of the Visual\n"
"selection.  The marks remain at their position until another Visual "
"selection\n"
"is made.  Thus you can use the \"'<\" command to jump to position where the\n"
"Visual area started.  And you can mix the marks with other items: >"
msgstr "'<' y '>' con marcadores que se sitúan al principio y al final de la\n"
"selección.  Estos marcadores mantienen estas posiciones hasta que aparece "
"una\n"
"nueva selección Visual.  Por lo tanto, puedes usar el comando \"'<\" para "
"saltar\n"
"al lugar donde el área Visual comenzaba.  También puedes mezclarlas: >"

#: usr_10es.txt:328
#, fuzzy
msgid "\t:'>,$"
msgstr "\t:'>,$"

#: usr_10es.txt:330
#, fuzzy
msgid "This addresses the lines from the end of the Visual area to the end of the\n"
"file."
msgstr "Esto especifica las líneas desde el final del área visual hasta el final "
"del\n"
"archivo."

#: usr_10es.txt:334
#, fuzzy
msgid "A NUMBER OF LINES"
msgstr "UN NÚMERO DE LÍNEAS"

#: usr_10es.txt:336
#, fuzzy
msgid "When you know how many lines you want to change, you can type the number "
"and\n"
"then \":\".  For example, when you type \"5:\", you will get: >"
msgstr "Cuando sepas cuántas líneas quieres cambiar, puedes teclear el número y "
"luego\n"
"\":\".  Si, por ejemplo, escribes \"5:\" obtendrás: >"

#: usr_10es.txt:339
#, fuzzy
msgid "\t:.,.+4"
msgstr "\t:.,.+4"

#: usr_10es.txt:341
#, fuzzy
msgid "Now you can type the command you want to use.  It will use the range \".\"\n"
"(current line) until \".+4\" (four lines down).  Thus it spans five lines."
msgstr "Ahora puedes teclear el comando que quieras usar.  Usará el rango \"."
"\" (línea\n"
"actual) hasta \".+4\" (cuatro líneas más).  Esto hará un total de cinco "
"líneas."

#: usr_10es.txt:347
#, fuzzy
msgid "The \":global\" command is one of the more powerful features of Vim.  It "
"allows\n"
"you to find a match for a pattern and execute a command there.  The general\n"
"form is: >"
msgstr "El comando \":global\" es una de las características más potentes de Vim.\n"
"Permite que encuentres una cadena con un patrón y ejecutes un comando en el\n"
"lugar.  El formato habitual es: >"

#: usr_10es.txt:351
#, fuzzy
msgid "\t:[range]global/{pattern}/{command}"
msgstr "\t:[rango]global/{patrón}/{comando}"

#: usr_10es.txt:353
#, fuzzy
msgid "This is similar to the \":substitute\" command.  But, instead of replacing "
"the\n"
"matched text with other text, the command {command} is executed."
msgstr "Esto es similar al comando \":substitute\".  Pero en lugar de reemplazar el\n"
"texto concordado con otro texto, el comando {comando} se ejecutará."

#: usr_10es.txt:356
#, fuzzy
msgid "\tNote:\n"
"\tThe command executed for \":global\" must be one that starts with a\n"
"\tcolon.  Normal mode commands can not be used directly.  The |:normal|\n"
"\tcommand can do this for you."
msgstr "\tNote:\n"
"\tEl comando ejecutado para \":global\" debe ser uno que comience con un\n"
"\tpunto y coma.  Comandos para el modo normal no pueden ser empleados de\n"
"\tforma directa.  De esto se encargará |:normal|."

#: usr_10es.txt:361
#, fuzzy
msgid "Suppose you want to change \"foobar\" to \"barfoo\", but only in C++ style\n"
"comments.  These comments start with \"//\".  Use this command: >"
msgstr "Supón que quieres cambiar \"foobar\" por \"barfoo\", pero solamente en los\n"
"comentarios de C++.  Estos comentarios empiezan por \"//\".  Usa lo "
"siguiente: >"

#: usr_10es.txt:364
#, fuzzy
msgid "\t:g+//+s/foobar/barfoo/g"
msgstr "\t:g+//+s/foobar/barfoo/g"

#: usr_10es.txt:366
#, fuzzy
msgid "This starts with \":g\".  That is short for \":global\", just like \":s\" is "
"short\n"
"for \":substitute\".  Then the pattern, enclosed in plus characters.  Since "
"the\n"
"pattern we are looking for contains a slash, this uses the plus character "
"to\n"
"separate the pattern.  Next comes the substitute command that changes "
"\"foobar\"\n"
"into \"barfoo\".\n"
"   The default range for the global command is the whole file.  Thus no "
"range\n"
"was specified in this example.  This is different from \":substitute\", "
"which\n"
"works on one line without a range.\n"
"   The command isn't perfect, since it also matches lines where \"//\" "
"appears\n"
"halfway a line, and the substitution will also take place before the \"//\"."
msgstr "Comienza con \":g\", la abreviatura de \":global\", igual que ocurría con \":"
"s\" y\n"
"\":substitute\".  Luego viene el patrón, entre signos \"+\".  Puesto que el "
"patrón\n"
"que estamos buscando contiene una barra inclinada, esto emplea el signo \"+"
"\"\n"
"para separar el patrón.  A continuación viene el comando que cambia \"foobar"
"\" a\n"
"\"barfoo\".\n"
"   El rango por defecto del comando global es el archivo completo.  Como en\n"
"este caso, ya que ningún rango ha sido especificado.  Esto difiere del "
"comando\n"
"\":substitute\", el cuál afecta a una línea por defecto.\n"
"   El comando no es perfecto, ya que también coincidirá líneas donde \"//\"\n"
"aparece a mitad de línea y la substitución también se hará antes de los \"//"
"\"."

#: usr_10es.txt:377
#, fuzzy
msgid "Just like with \":substitute\", any pattern can be used.  When you learn "
"more\n"
"complicated patterns later, you can use them here."
msgstr "Tal y como ocurre con \":substitute\", cualquier patrón puede ser empleado.\n"
"Cuando aprendas patrones más complicados, podrás usarlos aquí."

#: usr_10es.txt:383
#, fuzzy
msgid "With CTRL-V you can start selection of a rectangular area of text.  There "
"are\n"
"a few commands that do something special with the text block."
msgstr "Con CTRL-V puedes seleccionar un área rectangular de texto.  Hay algunos\n"
"comandos que hacen algo especial con los bloques de texto."

#: usr_10es.txt:386
#, fuzzy
msgid "There is something special about using the \"$\" command in Visual block "
"mode.\n"
"When the last motion command used was \"$\", all lines in the Visual "
"selection\n"
"will extend until the end of the line, also when the line with the cursor "
"is\n"
"shorter.  This remains effective until you use a motion command that moves "
"the\n"
"cursor horizontally.  Thus using \"j\" keeps it, \"h\" stops it."
msgstr "El comando \"$\" en el modo bloque Visual tiene algo de especial.  Cuando "
"el\n"
"último comando de movimiento fue \"$\", todas las líneas de la selección "
"Visual\n"
"se extenderán hasta el final de la línea, incluso cuando la línea con el\n"
"cursor sea más corta.  Esto se hará efectivo hasta que uses otro comando de\n"
"movimiento que desplace el cursor horizontalmente."

#: usr_10es.txt:393
#, fuzzy
msgid "INSERTING TEXT"
msgstr "INSERTAR TEXTO"

#: usr_10es.txt:395
#, fuzzy
msgid "The command  \"I{string}<Esc>\" inserts the text {string} in each line, "
"just\n"
"left of the visual block.  You start by pressing CTRL-V to enter visual "
"block\n"
"mode.  Now you move the cursor to define your block.  Next you type I to "
"enter\n"
"Insert mode, followed by the text to insert.  As you type, the text appears "
"on\n"
"the first line only.\n"
"   After you press <Esc> to end the insert, the text will magically be\n"
"inserted in the rest of the lines contained in the visual selection.  "
"Example:"
msgstr "El comando \"I{cadena}<Esc>\" inserta el texto {cadena} en cada línea, justo "
"a\n"
"la izquierda del bloque.  Comienza tecleando CTRL-V para entrar en el modo\n"
"bloque Visual.  Mueve el cursor para definir tu bloque.  A continuación "
"pulsa\n"
"\"I\" para iniciar el modo Insertar.  Según tecleas, el texto aparece "
"únicamente\n"
"en la primera línea.\n"
"   Tras pulsar <Esc> para finalizar la inserción, el texto aparecerá\n"
"mágicamente insertado en el resto de líneas contenidas en el bloque:"

#: usr_10es.txt:403
#, fuzzy
msgid "\tinclude one ~\n"
"\tinclude two ~\n"
"\tinclude three ~\n"
"\tinclude four ~"
msgstr "\tinclude uno ~\n"
"\tinclude dos ~\n"
"\tinclude tres ~\n"
"\tinclude cuatro ~"

#: usr_10es.txt:408
#, fuzzy
msgid "Move the cursor to the \"o\" of \"one\" and press CTRL-V.  Move it down with "
"\"3j\"\n"
"to \"four\".  You now have a block selection that spans four lines.  Now "
"type: >"
msgstr "Mueve el cursor a la \"u\" de \"uno\" y presiona CTRL-V.  Muévete hacia "
"abajo con\n"
"\"3j\" hasta \"cuatro\".  Tienes unas selección que abarca cuatro líneas.  "
"Teclea:\n"
">"

#: usr_10es.txt:412
#, fuzzy
msgid "\tImain.<Esc>"
msgstr "\tImain.<Esc>"

#: usr_10es.txt:414
#, fuzzy
msgid "The result:"
msgstr "El resultado:"

#: usr_10es.txt:416
#, fuzzy
msgid "\tinclude main.one ~\n"
"\tinclude main.two ~\n"
"\tinclude main.three ~\n"
"\tinclude main.four ~"
msgstr "\tinclude main.uno ~\n"
"\tinclude main.dos ~\n"
"\tinclude main.tres ~\n"
"\tinclude main.cuatro ~"

#: usr_10es.txt:421
#, fuzzy
msgid "If the block spans short lines that do not extend into the block, the text "
"is\n"
"not inserted in that line.  For example, make a Visual block selection that\n"
"includes the word \"long\" in the first and last line of this text, and thus "
"has\n"
"no text selected in the second line:"
msgstr "Si el bloque abarca líneas que no caen dentro del área del bloque, el texto "
"no\n"
"se insertará en esa línea.  Por ejemplo, haz un bloque Visual que no "
"incluya\n"
"la palabra \"larga\" en la primera y última línea de este texto, de manera "
"que no\n"
"se seleccione texto en la segunda línea:"

#: usr_10es.txt:426
#, fuzzy
#: usr_10es.txt:502
#, fuzzy
msgid "\tThis is a long line ~\n"
"\tshort ~\n"
"\tAny other long line ~"
msgstr "\tEsto es una línea larga ~\n"
"\tcorta ~\n"
"\tCualquier es una línea larga ~"

#: usr_10es.txt:430
#, fuzzy
msgid "\t\t  ^^^^ selected block"
msgstr "\t\t    ^^^^^ bloque seleccionado"

#: usr_10es.txt:432
#, fuzzy
msgid "Now use the command \"Ivery <Esc>\".  The result is:"
msgstr "Ahora usa el comando \"Imuy <Esc>\".  El resultado es:"

#: usr_10es.txt:434
#, fuzzy
msgid "\tThis is a very long line ~\n"
"\tshort ~\n"
"\tAny other very long line ~"
msgstr "\tEsto es una línea muy larga ~\n"
"\tcorta ~\n"
"\tEsto es una línea muy larga ~"

#: usr_10es.txt:438
#, fuzzy
msgid "In the short line no text was inserted."
msgstr "En el texto corto no se introdujo nada."

#: usr_10es.txt:440
#, fuzzy
msgid "If the string you insert contains a newline, the \"I\" acts just like a "
"Normal\n"
"insert command and affects only the first line of the block."
msgstr "Si la cadena que insertaste contiene una nueva línea, el \"I\" actúa justo "
"como\n"
"una inserción normal y únicamente afecta a la primera línea del bloque."

#: usr_10es.txt:443
#, fuzzy
msgid "The \"A\" command works the same way, except that it appends after the "
"right\n"
"side of the block.  And it does insert text in a short line.  Thus you can\n"
"make a choice whether you do or don't want to append text to a short line.\n"
"   There is one special case for \"A\": Select a Visual block and then use "
"\"$\"\n"
"to make the block extend to the end of each line.  Using \"A\" now will "
"append\n"
"the text to the end of each line.\n"
"   Using the same example from above, and then typing \"$A XXX<Esc>, you "
"get\n"
"this result:"
msgstr "El comando \"A\" funciona de la misma manera, excepto porque añade a la "
"derecha\n"
"del bloque.  En este caso sí se se añade al final de la línea corta.  De "
"este\n"
"modo puedes elegir si quieres añadir o no un texto a la línea corta.\n"
"   Hay un caso especial para \"A\": selecciona un bloque Visual y pulsa \"$"
"\" para\n"
"hacer que el bloque se extienda al final de cada línea.  Usar \"A\" añadirá "
"el\n"
"texto al final de cada línea.\n"
"   Usar el mismo ejemplo que arriba y tecleando \"$A XXX<Esc>\" obtendrás "
"el\n"
"siguiente resultado:"

#: usr_10es.txt:452
#, fuzzy
msgid "\tThis is a long line XXX ~\n"
"\tshort XXX ~\n"
"\tAny other long line XXX ~"
msgstr "\tEsto es una línea larga XXX~\n"
"\tcorta XXX~\n"
"\tEsto es una línea larga XXX~"

#: usr_10es.txt:456
#, fuzzy
msgid "This really requires using the \"$\" command.  Vim remembers that it was "
"used.\n"
"Making the same selection by moving the cursor to the end of the longest "
"line\n"
"with other movement commands will not have the same result."
msgstr "Esto requiere el uso del comando \"$\". Vim recordará que los has usado.  "
"Hacer\n"
"la misma selección con el cursor hasta el final de la línea más larga con\n"
"otros comandos no te dará el mismo resultado."

#: usr_10es.txt:461
#, fuzzy
msgid "CHANGING TEXT"
msgstr "CAMBIAR EL TEXTO"

#: usr_10es.txt:463
#, fuzzy
msgid "The Visual block \"c\" command deletes the block and then throws you into "
"Insert\n"
"mode to enable you to type in a string.  The string will be inserted in "
"each\n"
"line in the block.\n"
"   Starting with the same selection of the \"long\" words as above, then "
"typing\n"
"\"c_LONG_<Esc>\", you get this:"
msgstr "El comando de bloque Visual \"c\" elimina el bloque y te devuelve al modo\n"
"Insertar para que escribas en una cadena de caracteres.  La cadena será\n"
"insertada en cada línea del bloque.\n"
"   Comenzando con la misma selección que las palabras \"larga\" de arriba,\n"
"tecleando \"c_LARGA_<Esc>\", obtendrás esto:"

#: usr_10es.txt:469
#, fuzzy
msgid "\tThis is a _LONG_ line ~\n"
"\tshort ~\n"
"\tAny other _LONG_ line ~"
msgstr "\tEsto es una línea _LARGA_ ~\n"
"\tcorta ~\n"
"\tEsto es una línea _LARGA_ ~"

#: usr_10es.txt:473
#, fuzzy
msgid "Just like with \"I\" the short line is not changed.  Also, you can't enter "
"a\n"
"newline in the new text."
msgstr "Tal y como ocurre con \"I\", la línea corta no cambia.  Del mismo modo no "
"podrás\n"
"introducir una nueva línea en el texto."

#: usr_10es.txt:476
#, fuzzy
msgid "The \"C\" command deletes text from the left edge of the block to the end "
"of\n"
"line.  It then puts you in Insert mode so that you can type in a string,\n"
"which is added to the end of each line.\n"
"   Starting with the same text again, and typing \"Cnew text<Esc>\" you get:"
msgstr "El comando \"C\" elimina texto desde el borde izquierdo del bloque hasta el\n"
"final de cada línea.  Luego te deja en modo Insert para que puedas teclear "
"una\n"
"cadena, que se añadirá al final de cada línea.\n"
"   Comenzando con el mismo texto, teclea \"Ctexto nuevo<Esc>\" y obtendrás:"

#: usr_10es.txt:481
#, fuzzy
msgid "\tThis is a new text ~\n"
"\tshort ~\n"
"\tAny other new text ~"
msgstr "\tEsto es un texto nuevo ~\n"
"\tcorta ~\n"
"\tEsto es un texto nuevo ~"

#: usr_10es.txt:485
#, fuzzy
msgid "Notice that, even though only the \"long\" word was selected, the text after "
"it\n"
"is deleted as well.  Thus only the location of the left edge of the visual\n"
"block really matters.\n"
"   Again, short lines that do not reach into the block are excluded."
msgstr "Date cuenta de que aunque sólo la palabra \"larga\" fue seleccionada, el "
"texto\n"
"tras ella fue eliminado igualmente.  Por lo tanto sólo la posición del "
"borde\n"
"izquierdo del eje izquierdo importa realmente.\n"
"   Una vez más, las palabras que no forman parte del bloque son excluidas."

#: usr_10es.txt:490
#, fuzzy
msgid "Other commands that change the characters in the block:"
msgstr "Otros comandos que cambian caracteres son en el bloque son:"

#: usr_10es.txt:492
#, fuzzy
msgid "\t~\tswap case\t(a -> A and A -> a)\n"
"\tU\tmake uppercase  (a -> A and A -> A)\n"
"\tu\tmake lowercase  (a -> a and A -> a)"
msgstr "\t~       cambiar may./min.   (a -> A and A -> a)\n"
"\tU       cambiar a may.      (a -> A and A -> A)\n"
"\tu       cambiar a min.      (a -> a and A -> a)"

#: usr_10es.txt:497
#, fuzzy
msgid "FILLING WITH A CHARACTER"
msgstr "RELLENAR CON UN CARÁCTER"

#: usr_10es.txt:499
#, fuzzy
msgid "To fill the whole block with one character, use the \"r\" command.  Again,\n"
"starting with the same example text from above, and then typing \"rx\":"
msgstr "Para rellenar un bloque completo con un sólo carácter, usa el comando \"r"
"\".\n"
"Pruébalo de nuevo con el texto de antes, pulsando \"rx\":"

#: usr_10es.txt:507
#, fuzzy
msgid "\tNote:\n"
"\tIf you want to include characters beyond the end of the line in the\n"
"\tblock, check out the 'virtualedit' feature in chapter 25."
msgstr "\tNote:\n"
"\tSi quieres incluir los caracteres más allá del final de línea en el\n"
"\tbloque, mira la opción 'virtualedit' en el capítulo 25."

#: usr_10es.txt:512
#, fuzzy
msgid "SHIFTING"
msgstr "EMPUJAR"

#: usr_10es.txt:514
#, fuzzy
msgid "The command \">\" shifts the selected text to the right one shift amount,\n"
"inserting whitespace.  The starting point for this shift is the left edge "
"of\n"
"the visual block.\n"
"   With the same example again, \">\" gives this result:"
msgstr "El comando \">\" empuja el texto hacia la derecha un espacio determinado,\n"
"insertando espacios en blanco.  El punto base empleado para esta operación "
"es\n"
"el borde izquierdo del bloque visual.\n"
"   Con el mismo ejemplo de nuevo, \">\" te da el resultado:"

#: usr_10es.txt:519
#, fuzzy
msgid "\tThis is a\t  long line ~\n"
"\tshort ~\n"
"\tAny other\t  long line ~"
msgstr "\tEsto es una\tlínea larga ~\n"
"\tcorta ~\n"
"\tEsto es una\tlínea larga ~"

#: usr_10es.txt:523
#, fuzzy
msgid "The shift amount is specified with the 'shiftwidth' option.  To change it "
"to\n"
"use 4 spaces: >"
msgstr "El espacio del desplazamiento está especificado con la opción 'shiftwidth"
"\".\n"
"Para cambiarlo a cuatro espacios: >"

#: usr_10es.txt:526
#, fuzzy
msgid "\t:set shiftwidth=4"
msgstr "\t:set shiftwidth=4"

#: usr_10es.txt:528
#, fuzzy
msgid "The \"<\" command removes one shift amount of whitespace at the left\n"
"edge of the block.  This command is limited by the amount of text that is\n"
"there; so if there is less than a shift amount of whitespace available, it\n"
"removes what it can."
msgstr "El comando \"<\" desplaza por cada empuje la misma cantidad de espacios en\n"
"blanco hacia la izquierda.  Este comando está limitado al texto que se\n"
"encuentre, de manera que eliminará la cantidad de espacio en blanco\n"
"disponible sin sobreescribir texto."

#: usr_10es.txt:534
#, fuzzy
msgid "JOINING LINES"
msgstr "FUNDIR LÍNEAS"

#: usr_10es.txt:536
#, fuzzy
msgid "The \"J\" command joins all selected lines together into one line.  Thus it\n"
"removes the line breaks.  Actually, the line break, leading white space and\n"
"trailing white space is replaced by one space.  Two spaces are used after a\n"
"line ending (that can be changed with the 'joinspaces' option).\n"
"   Let's use the example that we got so familiar with now.  The result of\n"
"using the \"J\" command:"
msgstr "El comando \"J\" funde todas las líneas en una sola, eliminando los saltos "
"de\n"
"línea.  De hecho, el salto de línea, espacios en blanco al comienzo y al "
"final\n"
"de línea se convierten en un solo espacio.  Se usan dos espacios tras un "
"final\n"
"de línea (pudiéndose cambiar esto con la opción 'joinspaces'.\n"
"   Vamos a usar el ejemplo que nos resulta ya familiar.  El resultado de "
"usar\n"
"el comando \"J\" será:"

#: usr_10es.txt:543
#, fuzzy
msgid "\tThis is a long line short Any other long line ~"
msgstr "\tEsto es una línea larga corta Esto es una línea larga ~"

#: usr_10es.txt:545
#, fuzzy
msgid "The \"J\" command doesn't require a blockwise selection.  It works with \"v"
"\" and\n"
"\"V\" selection in exactly the same way."
msgstr "El comando \"J\" no requiere selección de bloques.  Funciona con la "
"selección\n"
"\"v\" y \"V\" de igual modo."

#: usr_10es.txt:548
#, fuzzy
msgid "If you don't want the white space to be changed, use the \"gJ\" command."
msgstr "Si no quieres que los espacios en blanco cambien, usa el comando \"gJ\"."

#: usr_10es.txt:553
#, fuzzy
msgid "When you are writing an e-mail message, you may want to include another "
"file.\n"
"This can be done with the \":read {filename}\" command.  The text of the "
"file is\n"
"put below the cursor line.\n"
"   Starting with this text:"
msgstr "Mientras escribes un correo te das cuenta de que quieres incluir otro "
"archivo.\n"
"Esto puede ser llevado a cabo con el comando \":read {nombredearchivo}\".  "
"El\n"
"texto del archivo se pegará debajo de la línea actual:\n"
"   A partir de este texto:"

#: usr_10es.txt:558
#, fuzzy
msgid "\tHi John, ~\n"
"\tHere is the diff that fixes the bug: ~\n"
"\tBye, Pierre. ~"
msgstr "\tHola Juan, ~\n"
"\tAquí tienes el parche que arregle el problema: ~\n"
"\tUn saludo, Pedro. ~"

#: usr_10es.txt:562
#, fuzzy
msgid "Move the cursor to the second line and type: >"
msgstr "Mueve el cursor a la segunda línea y escribe: >"

#: usr_10es.txt:564
#, fuzzy
msgid "\t:read patch"
msgstr "\t:read parche"

#: usr_10es.txt:566
#, fuzzy
msgid "The file named \"patch\" will be inserted, with this result:"
msgstr "El archivo de nombre \"parche\" será insertado: con este resultado:"

#: usr_10es.txt:568
#, fuzzy
msgid "\tHi John, ~\n"
"\tHere is the diff that fixes the bug: ~\n"
"\t2c2 ~\n"
"\t<\tfor (i = 0; i <= length; ++i) ~\n"
"\t--- ~\n"
"\t>\tfor (i = 0; i < length; ++i) ~\n"
"\tBye, Pierre. ~"
msgstr "\tHola Juan, ~\n"
"\tAquí tienes el parche que arregle el problema: ~\n"
"\t2c2 ~\n"
"\t<\tfor (i = 0; i <= length; ++i) ~\n"
"\t--- ~\n"
"\t>\tfor (i = 0; i < length; ++i) ~\n"
"\tUn saludo, Pedro. ~"

#: usr_10es.txt:576
#, fuzzy
msgid "The \":read\" command accepts a range.  The file will be put below the last "
"line\n"
"number of this range.  Thus \":$r patch\" appends the file \"patch\" at the "
"end of\n"
"the file.\n"
"   What if you want to read the file above the first line?  This can be "
"done\n"
"with the line number zero.  This line doesn't really exist, you will get an\n"
"error message when using it with most commands.  But this command is "
"allowed:\n"
">\n"
"\t:0read patch"
msgstr "El comando \":read\" acepta un rango.  El archivo será colocado justo debajo "
"de\n"
"la última línea de este rango.  Por lo tanto, \":$r parche\" añadirá el "
"archivo\n"
"\"parche\" al final del actual.\n"
"   ¿Qué ocurre si quieres pegar el archivo encima de la primera línea?  "
"Esto\n"
"puede ser realizado con el número de línea cero.  Este número de línea en\n"
"realidad no existe, lo cuál hará que con muchos comandos recibas un error. "
">\n"
":0read parche"

#: usr_10es.txt:584
#, fuzzy
msgid "The file \"patch\" will be put above the first line of the file."
msgstr "El archivo \"parche\" será puesto sobre la primera línea del archivo."

#: usr_10es.txt:587
#, fuzzy
msgid "WRITING A RANGE OF LINES"
msgstr "ESCRIBIR UN RANGO DE LÍNEAS"

#: usr_10es.txt:589
#, fuzzy
msgid "To write a range of lines to a file, the \":write\" command can be used.\n"
"Without a range it writes the whole file.  With a range only the specified\n"
"lines are written: >"
msgstr "Para guardar un rango de líneas en un archivo puedes usar el comando \":write"
"\".\n"
"Sin el rango esto guardará el archivo completo.  Pero con un rango\n"
"especificado únicamente las líneas que se especifiquen se escribirán: >"

#: usr_10es.txt:593
#, fuzzy
msgid "\t:.,$write tempo"
msgstr "\t:.,$write tempo"

#: usr_10es.txt:595
#, fuzzy
msgid "This writes the lines from the cursor until the end of the file into the "
"file\n"
"\"tempo\".  If this file already exists you will get an error message.  Vim\n"
"protects you from accidentally overwriting an existing file.  If you know "
"what\n"
"you are doing and want to overwrite the file, append !: >"
msgstr "Esto guardará las líneas desde el cursor hasta el final del texto en el\n"
"archivo \"tempo\".  Si este archivo existe actualmente obtendrás un mensaje "
"de\n"
"error.  Vim te protege de que sobreescribas un archivo preexistente.  Si "
"sabes\n"
"lo que haces y quieres sobreescribirlo, añade \"!\": >"

#: usr_10es.txt:600
#, fuzzy
msgid "\t:.,$write! tempo"
msgstr "\t:.,$write! tempo"

#: usr_10es.txt:602
#, fuzzy
msgid "CAREFUL: The ! must follow the \":write\" command immediately, without "
"white\n"
"space.  Otherwise it becomes a filter command, which is explained later in\n"
"this chapter."
msgstr "CUIDADO: El \"!\" debe ponerse justo después del comando \":write\", sin el\n"
"espacio en blanco.  En caso contrario se convierte en un comando filtro, el\n"
"cuál es explicado en el capítulo siguiente."

#: usr_10es.txt:607
#, fuzzy
msgid "APPENDING TO A FILE"
msgstr "AÑADIR A UN ARCHIVO"

#: usr_10es.txt:609
#, fuzzy
msgid "In the first section of this chapter was explained how to collect a number "
"of\n"
"lines into a register.  The same can be done to collect lines in a file.\n"
"Write the first line with this command: >"
msgstr "En la primera sección de este capítulo se explicó cómo recolectar una serie "
"de\n"
"líneas en un registro. Lo mismo puede ser realizado para recolectar líneas "
"en\n"
"un archivo.  Escribe una primera línea con este comando: >"

#: usr_10es.txt:613
#, fuzzy
msgid "\t:.write collection"
msgstr "\t:.write archivo"

#: usr_10es.txt:615
#, fuzzy
msgid "Now move the cursor to the second line you want to collect, and type this: >"
msgstr "Ahora pon el cursor en la siguiente línea que quieras añadir y escribe "
"esto:\n"
">"

#: usr_10es.txt:618
#, fuzzy
msgid "\t:.write >>collection"
msgstr "\t:.write >>archivo"

#: usr_10es.txt:620
#, fuzzy
msgid "The \">>\" tells Vim the \"collection\" file is not to be written as a new "
"file,\n"
"but the line must be appended at the end.   You can repeat this as many "
"times\n"
"as you like."
msgstr "El \">>\" le dice a Vim que \"archivo\" no debe ser escrito como un nuevo "
"archivo\n"
"sino que la línea debe ser añadida al final.  Puedes repetir esto tantas "
"veces\n"
"como quieras."

#: usr_10es.txt:627
#, fuzzy
msgid "When you are typing plain text, it's nice if the length of each line is\n"
"automatically trimmed to fit in the window.  To make this happen while\n"
"inserting text, set the 'textwidth' option: >"
msgstr "Cuando introduces texto tal vez te resulte útil que, si la longitud de cada\n"
"línea supera un número, sea automáticamente partida.  Para hacer esto "
"posible,\n"
"activa la opción 'textwidth': >"

#: usr_10es.txt:631
#, fuzzy
msgid "\t:set textwidth=72"
msgstr "\t:set textwidth=72"

#: usr_10es.txt:633
#, fuzzy
msgid "You might remember that in the example vimrc file this command was used for\n"
"every text file.  Thus if you are using that vimrc file, you were already\n"
"using it.  To check the current value of 'textwidth': >"
msgstr "Quizá te acuerdes de que en el ejemplo de archivo vimrc este comando era\n"
"empleado para cualquier tipo de archivo.  Por lo tanto, si estás usando ese\n"
"archivo vimrc, ya lo tienes activado.  Para comprobar el valor actual: >"

#: usr_10es.txt:637
#, fuzzy
msgid "\t:set textwidth"
msgstr "\t:set textwidth"

#: usr_10es.txt:639
#, fuzzy
msgid "Now lines will be broken to take only up to 72 characters.  But when you\n"
"insert text halfway a line, or when you delete a few words, the lines will "
"get\n"
"too long or too short.  Vim doesn't automatically reformat the text.\n"
"   To tell Vim to format the current paragraph: >"
msgstr "A partir de ahora las líneas se partirán cuando lleguen a 72 caracteres.  "
"Sin\n"
"embargo, cuando introduzcas texto en mitad de una líneas, o cuando elimines\n"
"unas palabras la línea no será reformateada por Vim.\n"
"   Para decirle a Vim que formatee el párrafo actual: >"

#: usr_10es.txt:644
#, fuzzy
msgid "\tgqap"
msgstr "\tgqap"

#: usr_10es.txt:646
#, fuzzy
msgid "This starts with the \"gq\" command, which is an operator.  Following is \"ap"
"\",\n"
"the text object that stands for \"a paragraph\".  A paragraph is separated "
"from\n"
"the next paragraph by an empty line."
msgstr "Esto consiste en un comando \"gq\", que es un operador, seguido de una \"ap"
"\", el\n"
"objeto de texto para \"un párrafo\".  Un párrafo es lo que está separado de "
"otro\n"
"párrafo por una línea en blanco."

#: usr_10es.txt:650
#, fuzzy
msgid "\tNote:\n"
"\tA blank line, which contains white space, does NOT separate\n"
"\tparagraphs.  This is hard to notice!"
msgstr "\tNote:\n"
"\tUna línea que contiene espacio en blanco NO separa párrafos.  Esto\n"
"\tsuele ser difícil de notar."

#: usr_10es.txt:654
#, fuzzy
msgid "Instead of \"ap\" you could use any motion or text object.  If your "
"paragraphs\n"
"are properly separated, you can use this command to format the whole file: >"
msgstr "En lugar de \"ap\" puedes usar cualquier movimiento u objeto de texto.  Si "
"tus\n"
"párrafos están adecuadamente separados, puedes usar esto para formatear "
"todo:\n"
">"

#: usr_10es.txt:658
#, fuzzy
msgid "\tgggqG"
msgstr "\tgggqG"

#: usr_10es.txt:660
#, fuzzy
msgid "\"gg\" takes you to the first line, \"gq\" is the format operator and \"G\" "
"the\n"
"motion that jumps to the last line."
msgstr "\"gg\" te lleva a la primera línea, \"gq\" es el operador de formateo y \"G"
"\" el\n"
"comando de movimiento que te lleva a la última línea."

#: usr_10es.txt:663
#, fuzzy
msgid "In case your paragraphs aren't clearly defined, you can format just the "
"lines\n"
"you manually select.  Move the cursor to the first line you want to format.\n"
"Start with the command \"gqj\".  This formats the current line and the one "
"below\n"
"it.  If the first line was short, words from the next line will be "
"appended.\n"
"If it was too long, words will be moved to the next line.  The cursor moves "
"to\n"
"the second line.  Now you can use \".\" to repeat the command.  Keep doing "
"this\n"
"until you are at the end of the text you want to format."
msgstr "En caso de que tus párrafos no estén claramente definidos, puedes dar "
"formato\n"
"sólo a las líneas que selecciones manualmente.  Pon el cursor sobre la "
"primera\n"
"línea que quieras formatear.  Teclea \"gqj\".  Esto formatea la línea actual "
"y\n"
"la siguiente.  Si la primera era demasiado corta, las palabras de la "
"siguiente\n"
"línea serán añadidas.  Si era demasiado larga, las palabras se moverán a la\n"
"siguiente línea.  A continuación puedes usar el comando \".\" para repetir "
"la\n"
"operación.  Repítelo hasta que llegues al final del texto a formatear."

#: usr_10es.txt:674
#, fuzzy
msgid "You have text with section headers in lowercase.  You want to make the word\n"
"\"section\" all uppercase.  Do this with the \"gU\" operator.  Start with "
"the\n"
"cursor in the first column: >"
msgstr "Tienes texto con cabeceras de sección en minúsculas.  Quieres que la "
"palabra\n"
"\"sección\" esté en mayúsculas.  Puedes hacerlo con el operador \"gU\".  "
"Comienza\n"
"con el cursor en la primera columna: >"

#: usr_10es.txt:678
#, fuzzy
msgid "\t\t\t     gUw\n"
"<\tsection header\t    ---->      SECTION header"
msgstr "\t\t\t     gUw\n"
"<\tcabecera de sección ---->      cabecera de SECCIÓN"

#: usr_10es.txt:681
#, fuzzy
msgid "The \"gu\" operator does exactly the opposite: >"
msgstr "El operador \"gu\" hace exactamente lo contrario:"

#: usr_10es.txt:683
#, fuzzy
msgid "\t\t\t     guw\n"
"<\tSECTION header\t    ---->      section header"
msgstr "\t\t\t     guw\n"
"\tcabecera de SECCIÓN ---->      cabecera de sección"

#: usr_10es.txt:686
#, fuzzy
msgid "You can also use \"g~\" to swap case.  All these are operators, thus they "
"work\n"
"with any motion command, with text objects and in Visual mode.\n"
"   To make an operator work on lines you double it.  The delete operator is\n"
"\"d\", thus to delete a line you use \"dd\".  Similarly, \"gugu\" makes a "
"whole line\n"
"lowercase.  This can be shortened to \"guu\".  \"gUgU\" is shortened to \"gUU"
"\" and\n"
"\"g~g~\" to \"g~~\".  Example: >"
msgstr "También puedes usar c\"g~\" para alternar may./min.  Son operadores, así "
"que\n"
"funcionan con comandos de movimiento, objetos de texto y el modo Visual.\n"
"   Para hacer que un operador funcione en líneas, lo duplicas.  El operador\n"
"de eliminación es \"d\", de manera que para eliminar una línea empleas \"dd"
"\".  De\n"
"forma similar, \"gugu\" hace que la línea al completo sea en minúsculas.  "
"Esto\n"
"puede abreviarse a \"guu\". \"gUgU\" puede abreviarse a \"gUU\" y \"g~g~\" a "
"\"g~~\":"

#: usr_10es.txt:693
#, fuzzy
msgid "\t\t\t\tg~~ \n"
"<\tSome GIRLS have Fun    ---->   sOME girls HAVE fUN ~"
msgstr "\t\t\t\t      g~~ \n"
"\tAlgunas CHICAS se divierten  ---->  aLGUNAS chicas SE DIVIERTEN ~"

#: usr_10es.txt:699
#, fuzzy
msgid "Vim has a very powerful set of commands, it can do anything.  But there may\n"
"still be something that an external command can do better or faster.\n"
"   The command \"!{motion}{program}\" takes a block of text and filters it\n"
"through an external program.  In other words, it runs the system command\n"
"represented by {program}, giving it the block of text represented by "
"{motion}\n"
"as input.  The output of this command then replaces the selected block.\n"
"   Because this summarizes badly if you are unfamiliar with UNIX filters, "
"take\n"
"a look at an example.  The sort command sorts a file.  If you execute the\n"
"following command, the unsorted file input.txt will be sorted and written "
"to\n"
"output.txt.  (This works on both UNIX and Microsoft Windows.) >"
msgstr "Vim tiene un conjunto de operaciones muy potente para hacer cualquier cosa.\n"
"Pero siempre hay un programa externo que es mejor para una tarea "
"específica.\n"
"   El comando \"!{movimiento}{programa}\" recoge un bloque de un texto y lo\n"
"filtra a través de un programa externo.  En otras palabras, hace correr el\n"
"comando de sistema {programa}, dándole el bloque te texto representado por\n"
"{movimiento} como entrada.  La la salida del comando sustituirá la "
"selección.\n"
"   Ya que esto requiere más explicación si no usas los filtros UNIX\n"
"habitualmente, veamos un ejemplo.  El comando \"sort\" ordena un archivo.  "
"Si\n"
"ejecutas lo siguiente, el archivo desordenado entrada.txt será ordenado y\n"
"guardado en output.txt.  (Esto funciona en UNIX y en Windows.) >"

#: usr_10es.txt:710
#, fuzzy
msgid "\tsort <input.txt >output.txt"
msgstr "\tsort <input.txt >output.txt"

#: usr_10es.txt:712
#, fuzzy
msgid "Now do the same thing in Vim.  You want to sort lines 1 through 5 of a "
"file.\n"
"You start by putting the cursor on line 1.  Next you execute the following\n"
"command: >"
msgstr "Ahora haz lo mismo en Vim.  Quieres ordenar las líneas de la 1 a la 5.  "
"Para\n"
"comenzar, pon el cursor en la línea 1.  A continuación ejecuta el siguiente\n"
"comando: >"

#: usr_10es.txt:716
#, fuzzy
msgid "\t!5G"
msgstr "\t!5G"

#: usr_10es.txt:718
#, fuzzy
msgid "The \"!\" tells Vim that you are performing a filter operation.  The Vim "
"editor\n"
"expects a motion command to follow, indicating which part of the file to\n"
"filter.  The \"5G\" command tells Vim to go to line 5, so it now knows that "
"it\n"
"is to filter lines 1 (the current line) through 5.\n"
"   In anticipation of the filtering, the cursor drops to the bottom of the\n"
"screen and a ! prompt displays.  You can now type in the name of the filter\n"
"program, in this case \"sort\".  Therefore, your full command is as follows: "
">"
msgstr "El \"!\" le dice a Vim que estás formateando una operación filtro.  El "
"editor\n"
"Vim espera que introduzcas a continuación un comando de movimiento para "
"saber\n"
"qué filtrar.  El comando \"5G\" le dice a Vim que vaya a la línea 5, de "
"forma\n"
"que sepa que tiene que filtrar desde la línea 1 (la actual) hasta la 5.\n"
"   Antes de filtrar nada, la línea de comandos se activa y muestra un \"!"
"\".\n"
"Ahora es el momento de que escribas el filtro, en este caso \"sort\".  Por "
"lo\n"
"tanto, el comando completo sería: >"

#: usr_10es.txt:726
#, fuzzy
msgid "\t!5Gsort<Enter>"
msgstr "\t!5Gsort<Entrar>"

#: usr_10es.txt:728
#, fuzzy
msgid "The result is that the sort program is run on the first 5 lines.  The "
"output\n"
"of the program replaces these lines."
msgstr "El resultado es que el programa sort es ejecutado sobre las 5 primeras "
"líneas.\n"
"La salida del programa reemplaza estas líneas."

#: usr_10es.txt:731
#, fuzzy
msgid "\tline 55\t\t\t      line 11\n"
"\tline 33\t\t\t      line 22\n"
"\tline 11\t\t-->\t      line 33\n"
"\tline 22\t\t\t      line 44\n"
"\tline 44\t\t\t      line 55\n"
"\tlast line\t\t      last line"
msgstr "\tlínea 55\t\t      línea 11\n"
"\tlínea 33\t\t      línea 22\n"
"\tlínea 11\t-->\t      línea 33\n"
"\tlínea 22\t\t      línea 44\n"
"\tlínea 44\t\t      línea 55\n"
"\túltima línea\t\t      última línea"

#: usr_10es.txt:738
#, fuzzy
msgid "The \"!!\" command filters the current line through a filter.  In Unix the "
"\"date\"\n"
"command prints the current time and date.  \"!!date<Enter>\" replaces the "
"current\n"
"line with the output of \"date\".  This is useful to add a timestamp to a "
"file."
msgstr "El comando \"!!\" filtra la línea actual.  En Unix, el comando \"date\" "
"imprime la\n"
"hora y fecha actuales.  \"!!date<Entrar>\" reemplaza la línea actual con la\n"
"salida de \"date\".  Esto es útil para añadir una marca de tiempo al archivo."

#: usr_10es.txt:743
#, fuzzy
msgid "WHEN IT DOESN'T WORK"
msgstr "CUANDO NO FUNCIONA"

#: usr_10es.txt:745
#, fuzzy
msgid "Starting a shell, sending it text and capturing the output requires that "
"Vim\n"
"knows how the shell works exactly.  When you have problems with filtering,\n"
"check the values of these options:"
msgstr "Iniciar la shell, enviarle texto y capturar la salida requiere que Vim sepa\n"
"exactamente cómo funciona la shell de forma precisa.  Cuando tengas "
"problemas\n"
"con el filtrado, comprueba los valores de las siguientes opciones:"

#: usr_10es.txt:749
#, fuzzy
msgid "\t'shell'\t\tspecifies the program that Vim uses to execute\n"
"\t\t\texternal programs.\n"
"\t'shellcmdflag'\targument to pass a command to the shell\n"
"\t'shellquote'\tquote to be used around the command\n"
"\t'shellxquote'\tquote to be used around the command and redirection\n"
"\t'shelltype'\tkind of shell (only for the Amiga)\n"
"\t'shellslash'\tuse forward slashes in the command (only for\n"
"\t\t\tMS-Windows and alikes)\n"
"\t'shellredir'\tstring used to write the command output into a file"
msgstr "\t'shell'\t\tespecifica el programa que Vim empleará para ejecutar\n"
"\t\t\tprogramas externos.\n"
"\t'shellcmdflag'\targumento para pasar un comando a la shell\n"
"\t'shellquote'\tcomillas a usar alrededor del comando\n"
"\t'shellxquote'\tcomillas a usar alrededor del comando y redirección\n"
"\t'shelltype'\ttipo de shell (sólo para Amiga)\n"
"\t'shellslash'\tusar barras inclinadas en el comando (sólo para\n"
"\t\t\tWindows y similares)\n"
"\t'shellredir'\tcadena para escribir la salida a un archivo"

#: usr_10es.txt:759
#, fuzzy
msgid "On Unix this is hardly ever a problem, because there are two kinds of "
"shells:\n"
"\"sh\" like and \"csh\" like.  Vim checks the 'shell' option and sets "
"related\n"
"options automatically, depending on whether it sees \"csh\" somewhere in\n"
"'shell'.\n"
"   On MS-Windows, however, there are many different shells and you might "
"have\n"
"to tune the options to make filtering work.  Check the help for the options\n"
"for more information."
msgstr "En Unix esto raramente es un problema, porque hay dos tipos de shell: \"sh\" "
"y\n"
"\"csh\".  Vim comprueba la opción 'shell' y configura todo automáticamente,\n"
"dependiendo de si ve \"csh\" en algún lugar de 'shell'.\n"
"   Sin embargo, en Windows, hay muchos tipos de shells y quizá tengas que\n"
"ajustar las opciones para hacer que el filtrado funcione correctamente.  "
"Busca\n"
"en la ayuda más información sobre las opciones de configuración de la shell\n"
"para poder solucionarlo."

#: usr_10es.txt:768
#, fuzzy
msgid "READING COMMAND OUTPUT"
msgstr "LEER LA SALIDA DEL COMANDO"

#: usr_10es.txt:770
#, fuzzy
msgid "To read the contents of the current directory into the file, use this:"
msgstr "Para escribir los contenidos del directorio actual en el archivo, usa:"

#: usr_10es.txt:772
#, fuzzy
msgid "on Unix: >\n"
"\t:read !ls\n"
"on MS-Windows: >\n"
"\t:read !dir"
msgstr "en Unix: >\n"
"\t:read !ls\n"
"en MS-Windows: >\n"
"\t:read !dir"

#: usr_10es.txt:777
#, fuzzy
msgid "The output of the \"ls\" or \"dir\" command is captured and inserted in the "
"text,\n"
"below the cursor.  This is similar to reading a file, except that the \"!\" "
"is\n"
"used to tell Vim that a command follows.\n"
"   The command may have arguments.  And a range can be used to tell where "
"Vim\n"
"should put the lines: >"
msgstr "La salida de los comandos \"ls\" o \"dir\" puede ser capturada e insertada "
"en el\n"
"texto, debajo del cursor.  Esto es similar a leer un archivo, excepto que "
"el\n"
"\"!\" se emplea para decirle a Vim que hay un comando a continuación.\n"
"   El comando puede que tenga argumentos.  Un rango puede ser empleado para\n"
"decirle a Vim dónde debería poner las líneas: >"

#: usr_10es.txt:783
#, fuzzy
msgid "\t:0read !date -u"
msgstr "\t:0read !date -u"

#: usr_10es.txt:785
#, fuzzy
msgid "This inserts the current time and date in UTC format at the top of the "
"file.\n"
"(Well, if you have a date command that accepts the \"-u\" argument.)  Note "
"the\n"
"difference with using \"!!date\": that replaced a line, while \":read !date"
"\" will\n"
"insert a line."
msgstr "Esto inserta la hora y fecha actuales en formato UTC en la primera línea "
"del\n"
"archivo.  (Bueno, si tienes un comando date que acepta el argumento \"-u"
"\".)\n"
"Observa la diferencia de usar \"!!date\": esto reemplazó una línea, mientras "
"que\n"
"\":read !date\" insertó una línea."

#: usr_10es.txt:791
#, fuzzy
msgid "WRITING TEXT TO A COMMAND"
msgstr "PASARLE TEXTO A UN COMANDO"

#: usr_10es.txt:793
#, fuzzy
msgid "The Unix command \"wc\" counts words.  To count the words in the current "
"file: >"
msgstr "El comando Unix \"wc\" cuenta palabras.  Para contar las del archivo actual: "
">"

#: usr_10es.txt:795
#, fuzzy
msgid "\t:write !wc"
msgstr "\t:write !wc"

#: usr_10es.txt:797
#, fuzzy
msgid "This is the same write command as before, but instead of a file name the \"!"
"\"\n"
"character is used and the name of an external command.  The written text "
"will\n"
"be passed to the specified command as its standard input.  The output could\n"
"look like this:"
msgstr "Este es el mismo comando write que anteriormente, pero en lugar de un "
"nombre\n"
"de archivo, el carácter \"!\" y un comando externo son empleados.  El texto\n"
"guardado será pasado al comando especificado como entrada estándar.  La "
"salida\n"
"será algo así:"

#: usr_10es.txt:802
#, fuzzy
msgid "       4      47     249 ~"
msgstr "       4      47     249 ~"

#: usr_10es.txt:804
#, fuzzy
msgid "The \"wc\" command isn't verbose.  This means you have 4 lines, 47 words and "
"249\n"
"characters."
msgstr "El comando \"wc\" no es muy prolijo.  Esto significa que tienes 4 líneas, "
"47\n"
"palabras y 249 caracteres."

#: usr_10es.txt:807
#, fuzzy
msgid "Watch out for this mistake: >"
msgstr "Ten cuidado de no cometer este error: >"

#: usr_10es.txt:809
#, fuzzy
msgid "\t:write! wc"
msgstr "\t:write! wc"

#: usr_10es.txt:811
#, fuzzy
msgid "This will write the file \"wc\" in the current directory, with force.  "
"White\n"
"space is important here!"
msgstr "Esto guardará el archivo \"wc\" en el directorio actual (con la opción force "
"=\n"
"forzar).  ¡El espacio en blanco es muy importante en este caso!"

#: usr_10es.txt:815
#, fuzzy
msgid "REDRAWING THE SCREEN"
msgstr "REDIBUJAR LA PANTALLA"

#: usr_10es.txt:817
#, fuzzy
msgid "If the external command produced an error message, the display may have "
"been\n"
"messed up.  Vim is very efficient and only redraws those parts of the "
"screen\n"
"that it knows need redrawing.  But it can't know about what another program\n"
"has written.  To tell Vim to redraw the screen: >"
msgstr "Si el comando externo produjo un mensaje de error, la pantalla de Vim tal "
"vez\n"
"esté sobreescrita con información confusa.  Vim es muy eficiente y sólo\n"
"reescribe aquellas partes de la pantalla que lo necesiten.  Pero no puede\n"
"saber sobre lo que otro programa ha tocado.  Para decirle a Vim que "
"redibuje:\n"
">"

#: usr_10es.txt:823
#, fuzzy
msgid "\tCTRL-L"
msgstr "\tCTRL-L"

#: usr_10es.txt:827
#, fuzzy
msgid "Next chapter: |usr_11.txt|  Recovering from a crash"
msgstr "Capítulo siguiente: |usr_11.txt|  Recuperación de errores"

#: usr_10es.txt:829
#, fuzzy
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"

