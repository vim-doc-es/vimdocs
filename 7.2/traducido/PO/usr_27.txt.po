# vim-doc-es https://www.assembla.com/wiki/show/vim-doc-es
# Copyright (C) 2009
# This file is distributed under the same license as the Vim 7.2 package.
# Translators credits:
# - Initial translation
# Omar Campagne <ocampagne@gmail.com>, 2009, 2010.
# - Updates
# TRADUCTOR <CORREO>, AÑO
# Debido al formato (txt) y al máximo de 80 columnas que pueden tener
# los textos de ayuda en Vim, así como el formato PO, por favor, leete los
# apuntes concernientes a la edición de los archivos PO relativos a la
# aplicación que desees usar.
# También encontrarás información acerca del uso de herramientas gettext en el
# proyecto de localización (l10n) de Vim.
# - http://www.assembla.com/wiki/show/vim-doc-es
# No somos parte del proyecto de traducción en Debian. Sin embargo, creemos que
# este enlace puede ser de interés. A pesar de no formar parte, nuestra
# intención es homologarnos con su terminología y uso de la lengua
# en la medida de lo útil y posible.
# - El proyecto de traducción de Debian al español
# http://www.debian.org/intl/spanish/notas
# La R.A.E. no es un inmenso referente en cuanto a términos tecnológicos,
# pero también puede servir de referencia para otros términos no técnicos.
# No pretendemos hacer es_ES, es_CO, es_AR, etc..., sino que la misma
# traducción sea comprensible independientemente de la nacionalidad del
# usuario. Si crees que alguna traducción puede llevar a confusión, consulta
# la R.A.E., o el diccionario de Maria Moliner, y escribe un correo.
# - www.rae.es
# - http://www.diclib.com/cgi-bin/d1.cgi?base=moliner&page=showpages
# Disponemos también de un archivo «terminology.po» en «/recursos_de..» que
# se puede consultar con un simple grep, pogrep o cargado en Virtaal.
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.2\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2009-12-03 19:17+0100\n"
"PO-Revision-Date: 2010-02-01 22:53+0200\n"
"Last-Translator: Omar Campagne <ocampagne@gmail.com>\n"
"Language-Team: vim-doc-es <vim-doc-es@freelists.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Virtaal 0.5.2\n"

#. type: Plain text
#: original/TXT/intro.txt:18 original/TXT/intro.txt:75
#: original/TXT/intro.txt:176 original/TXT/intro.txt:285
#: original/TXT/intro.txt:513 original/TXT/intro.txt:591
#: original/TXT/intro.txt:684 original/TXT/intro.txt:812
#: original/TXT/intro.txt:875 original/TXT/usr_toc.txt:7
#: original/TXT/usr_toc.txt:58 original/TXT/usr_toc.txt:172
#: original/TXT/usr_toc.txt:280 original/TXT/usr_toc.txt:339
#: original/TXT/usr_toc.txt:351 original/TXT/usr_01.txt:19
#: original/TXT/usr_01.txt:50 original/TXT/usr_01.txt:100
#: original/TXT/usr_01.txt:181 original/TXT/usr_02.txt:25
#: original/TXT/usr_02.txt:69 original/TXT/usr_02.txt:130
#: original/TXT/usr_02.txt:179 original/TXT/usr_02.txt:239
#: original/TXT/usr_02.txt:307 original/TXT/usr_02.txt:369
#: original/TXT/usr_02.txt:406 original/TXT/usr_02.txt:560
#: original/TXT/usr_03.txt:28 original/TXT/usr_03.txt:74
#: original/TXT/usr_03.txt:101 original/TXT/usr_03.txt:147
#: original/TXT/usr_03.txt:172 original/TXT/usr_03.txt:223
#: original/TXT/usr_03.txt:265 original/TXT/usr_03.txt:320
#: original/TXT/usr_03.txt:491 original/TXT/usr_03.txt:552
#: original/TXT/usr_03.txt:650 original/TXT/usr_04.txt:27
#: original/TXT/usr_04.txt:74 original/TXT/usr_04.txt:160
#: original/TXT/usr_04.txt:194 original/TXT/usr_04.txt:269
#: original/TXT/usr_04.txt:324 original/TXT/usr_04.txt:360
#: original/TXT/usr_04.txt:390 original/TXT/usr_04.txt:446
#: original/TXT/usr_04.txt:469 original/TXT/usr_04.txt:510
#: original/TXT/usr_05.txt:24 original/TXT/usr_05.txt:63
#: original/TXT/usr_05.txt:219 original/TXT/usr_05.txt:266
#: original/TXT/usr_05.txt:418 original/TXT/usr_05.txt:467
#: original/TXT/usr_05.txt:506 original/TXT/usr_05.txt:621
#: original/TXT/usr_06.txt:24 original/TXT/usr_06.txt:50
#: original/TXT/usr_06.txt:135 original/TXT/usr_06.txt:189
#: original/TXT/usr_06.txt:266 original/TXT/usr_06.txt:272
#: original/TXT/usr_07.txt:24 original/TXT/usr_07.txt:63
#: original/TXT/usr_07.txt:179 original/TXT/usr_07.txt:266
#: original/TXT/usr_07.txt:316 original/TXT/usr_07.txt:404
#: original/TXT/usr_07.txt:444 original/TXT/usr_07.txt:475
#: original/TXT/usr_08.txt:26 original/TXT/usr_08.txt:82
#: original/TXT/usr_08.txt:109 original/TXT/usr_08.txt:161
#: original/TXT/usr_08.txt:215 original/TXT/usr_08.txt:278
#: original/TXT/usr_08.txt:337 original/TXT/usr_08.txt:477
#: original/TXT/usr_08.txt:509 original/TXT/usr_08.txt:597
#: original/TXT/usr_09.txt:21 original/TXT/usr_09.txt:124
#: original/TXT/usr_09.txt:175 original/TXT/usr_09.txt:259
#: original/TXT/usr_09.txt:285 original/TXT/usr_10.txt:27
#: original/TXT/usr_10.txt:144 original/TXT/usr_10.txt:221
#: original/TXT/usr_10.txt:342 original/TXT/usr_10.txt:378
#: original/TXT/usr_10.txt:547 original/TXT/usr_10.txt:621
#: original/TXT/usr_10.txt:667 original/TXT/usr_10.txt:692
#: original/TXT/usr_10.txt:820 original/TXT/usr_11.txt:22
#: original/TXT/usr_11.txt:66 original/TXT/usr_11.txt:126
#: original/TXT/usr_11.txt:268 original/TXT/usr_11.txt:283
#: original/TXT/usr_12.txt:25 original/TXT/usr_12.txt:90
#: original/TXT/usr_12.txt:131 original/TXT/usr_12.txt:177
#: original/TXT/usr_12.txt:202 original/TXT/usr_12.txt:231
#: original/TXT/usr_12.txt:281 original/TXT/usr_12.txt:309
#: original/TXT/usr_12.txt:354 original/TXT/usr_20.txt:22
#: original/TXT/usr_20.txt:113 original/TXT/usr_20.txt:158
#: original/TXT/usr_20.txt:285 original/TXT/usr_20.txt:327
#: original/TXT/usr_20.txt:380 original/TXT/usr_21.txt:24
#: original/TXT/usr_21.txt:47 original/TXT/usr_21.txt:87
#: original/TXT/usr_21.txt:236 original/TXT/usr_21.txt:385
#: original/TXT/usr_21.txt:438 original/TXT/usr_21.txt:495
#: original/TXT/usr_22.txt:22 original/TXT/usr_22.txt:148
#: original/TXT/usr_22.txt:213 original/TXT/usr_22.txt:272
#: original/TXT/usr_22.txt:396 original/TXT/usr_23.txt:23
#: original/TXT/usr_23.txt:114 original/TXT/usr_23.txt:156
#: original/TXT/usr_23.txt:238 original/TXT/usr_23.txt:324
#: original/TXT/usr_23.txt:339 original/TXT/usr_24.txt:28
#: original/TXT/usr_24.txt:96 original/TXT/usr_24.txt:119
#: original/TXT/usr_24.txt:268 original/TXT/usr_24.txt:305
#: original/TXT/usr_24.txt:336 original/TXT/usr_24.txt:369
#: original/TXT/usr_24.txt:493 original/TXT/usr_24.txt:537
#: original/TXT/usr_24.txt:583 original/TXT/usr_24.txt:602
#: original/TXT/usr_25.txt:22 original/TXT/usr_25.txt:132
#: original/TXT/usr_25.txt:210 original/TXT/usr_25.txt:287
#: original/TXT/usr_25.txt:453 original/TXT/usr_25.txt:574
#: original/TXT/usr_26.txt:21 original/TXT/usr_26.txt:46
#: original/TXT/usr_26.txt:103 original/TXT/usr_26.txt:136
#: original/TXT/usr_26.txt:217 original/TXT/usr_27.txt:26
#: original/TXT/usr_27.txt:88 original/TXT/usr_27.txt:136
#: original/TXT/usr_27.txt:239 original/TXT/usr_27.txt:320
#: original/TXT/usr_27.txt:350 original/TXT/usr_27.txt:427
#: original/TXT/usr_27.txt:469 original/TXT/usr_27.txt:510
#: original/TXT/usr_27.txt:559
#, no-wrap
msgid "============================================================================"
"==\n"
msgstr "============================================================================"
"==\n"

#. type: Plain text
#: original/TXT/usr_toc.txt:4 original/TXT/usr_01.txt:4
#: original/TXT/usr_02.txt:4 original/TXT/usr_03.txt:4
#: original/TXT/usr_04.txt:4 original/TXT/usr_05.txt:4
#: original/TXT/usr_06.txt:4 original/TXT/usr_07.txt:4
#: original/TXT/usr_08.txt:4 original/TXT/usr_09.txt:4
#: original/TXT/usr_10.txt:4 original/TXT/usr_11.txt:4
#: original/TXT/usr_12.txt:4 original/TXT/usr_20.txt:4
#: original/TXT/usr_21.txt:4 original/TXT/usr_22.txt:4
#: original/TXT/usr_23.txt:4 original/TXT/usr_24.txt:4
#: original/TXT/usr_25.txt:4 original/TXT/usr_26.txt:4
#: original/TXT/usr_27.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar\n"

#. type: Plain text
#: original/TXT/usr_toc.txt:353 original/TXT/usr_01.txt:185
#: original/TXT/usr_02.txt:564 original/TXT/usr_03.txt:654
#: original/TXT/usr_04.txt:514 original/TXT/usr_05.txt:625
#: original/TXT/usr_06.txt:276 original/TXT/usr_07.txt:479
#: original/TXT/usr_08.txt:601 original/TXT/usr_09.txt:289
#: original/TXT/usr_10.txt:824 original/TXT/usr_11.txt:287
#: original/TXT/usr_12.txt:358 original/TXT/usr_20.txt:384
#: original/TXT/usr_21.txt:499 original/TXT/usr_22.txt:400
#: original/TXT/usr_23.txt:343 original/TXT/usr_24.txt:606
#: original/TXT/usr_25.txt:578 original/TXT/usr_26.txt:221
#: original/TXT/usr_27.txt:563
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: véase |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"

#. type: Plain text
#: original/TXT/usr_03.txt:261 original/TXT/usr_27.txt:110
#, no-wrap
msgid "\t:set ruler\n"
msgstr "\t:set ruler\n"

#. type: Plain text
#: original/TXT/usr_03.txt:362 original/TXT/usr_27.txt:35
#, no-wrap
msgid "\t:set ignorecase\n"
msgstr "\t:set ignorecase\n"

#. type: Plain text
#: original/TXT/usr_03.txt:367 original/TXT/usr_27.txt:42
#, no-wrap
msgid "\t:set noignorecase\n"
msgstr "\t:set noignorecase\n"

#. type: Plain text
#: original/TXT/usr_27.txt:2
#, no-wrap
msgid "*usr_27.txt*\tFor Vim version 7.2.  Last change: 2007 Nov 10\n"
msgstr "*usr_27.esx*\tPara Vim versión 7.2.  Último cambio: 10/11/2007\n"

#. type: Plain text
#: original/TXT/usr_27.txt:6
#, no-wrap
msgid "\t\t\t Search commands and patterns\n"
msgstr "\t\t\t Órdenes y patrones de búsqueda\n"

#. type: Plain text
#: original/TXT/usr_27.txt:11
msgid ""
"In chapter 3 a few simple search patterns were mentioned |03.9|.  Vim can do "
"much more complex searches.  This chapter explains the most often used "
"ones.  A detailed specification can be found here: |pattern|"
msgstr ""
"El capítulo 3 trató superficialmente los patrones de búsqueda |03.9|, pero "
"Vim puede realizar búsquedas más complejas. Este capítulo explica los más "
"comunes. Dispone de una explicación más detallada: |pattern|"

#. type: Plain text
#: original/TXT/usr_27.txt:21
#, fuzzy, no-wrap
msgid ""
"|27.1|\tIgnoring case\n"
"|27.2|\tWrapping around the file end\n"
"|27.3|\tOffsets\n"
"|27.4|\tMatching multiple times\n"
"|27.5|\tAlternatives\n"
"|27.6|\tCharacter ranges\n"
"|27.7|\tCharacter classes\n"
"|27.8|\tMatching a line break\n"
"|27.9|\tExamples\n"
msgstr ""
"|27.1|\tIgnoring case\n"
"|27.2|\tWrapping around the file end\n"
"|27.3|\tOffsets\n"
"|27.4|\tMatching multiple times\n"
"|27.5|\tAlternatives\n"
"|27.6|\tCharacter ranges\n"
"|27.7|\tCharacter classes\n"
"|27.8|\tMatching a line break\n"
"|27.9|\tExamples\n"

#. type: Plain text
#: original/TXT/usr_27.txt:25
#, no-wrap
msgid ""
"     Next chapter: |usr_28.txt|  Folding\n"
" Previous chapter: |usr_26.txt|  Repeating\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""
" Siguiente capítulo: |usr_28.txt|  Plegar\n"
"  Capítulo anterior: |usr_25.esx|  Repetición\n"
"Tabla de contenidos: |usr_toc.esx|\n"

#. type: Plain text
#: original/TXT/usr_27.txt:28
#, no-wrap
msgid "*27.1*\tIgnoring case\n"
msgstr "*27.1*\tIgnorar la distinción entre mayúsculas y minúsculas\n"

#. type: Plain text
#: original/TXT/usr_27.txt:33
#, no-wrap
msgid ""
"By default, Vim's searches are case sensitive.  Therefore, \"include\",\n"
"\"INCLUDE\", and \"Include\" are three different words and a search will match\n"
"only one of them.\n"
"   Now switch on the 'ignorecase' option: >\n"
msgstr ""
"Vim distingue entre mayúsculas y minúsculas al realizar un búsqueda de forma\n"
"predefinida. «INCLUDE», «Include» e «include»  son por ello tres palabras\n"
"distintas, y una búsqueda encontraría sólo una de ellas.\n"
"   Active ahora la opción 'ignorecase': >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:40
#, no-wrap
msgid ""
"Search for \"include\" again, and now it will match \"Include\", \"INCLUDE\" and\n"
"\"InClUDe\".  (Set the 'hlsearch' option to quickly see where a pattern\n"
"matches.)\n"
"   You can switch this off again with: >\n"
msgstr ""
"Si realiza otra búsqueda de «include», ésta devolvería «Include», «INCLUDE» "
"e «InClUDe». Puede activar la opción 'hlsearch' (resaltar búsquedas) para\n"
"ver fácilmente los patrones coincidentes.\n"
"   Puede desactivar esta opción con: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:45
msgid ""
"But lets keep it set, and search for \"INCLUDE\".  It will match exactly the "
"same text as \"include\" did.  Now set the 'smartcase' option: >"
msgstr ""
"Vamos a dejar esta opción activada, y realizar una búsqueda de «INCLUDE». "
"Encontrará el mismo texto que «include». Active ahora la opción 'smartcase': >"

#. type: Plain text
#: original/TXT/usr_27.txt:47
#, no-wrap
msgid "\t:set ignorecase smartcase\n"
msgstr "\t:set ignorecase smartcase\n"

#. type: Plain text
#: original/TXT/usr_27.txt:53
#, no-wrap
msgid ""
"If you have a pattern with at least one uppercase character, the search\n"
"becomes case sensitive.  The idea is that you didn't have to type that\n"
"uppercase character, so you must have done it because you wanted case to\n"
"match.  That's smart!\n"
"    With these two options set you find the following matches:\n"
msgstr ""
"Si tiene un patrón con al menos un carácter en mayúscula, la búsqueda no\n"
"distinguirá entre mayúsculas y minúsculas. La idea es que no necesitaba\n"
"escribir ese carácter en mayúscula, y que por ello lo que deseaba era\n"
"encontrar coincidencias con distinción entre mayúsculas y minúsculas. ¡Qué\n"
"inteligente!\n"
"   Obtendría las siguientes coincidencias de activar ambas opciones:\n"

#. type: Plain text
#: original/TXT/usr_27.txt:59
#, no-wrap
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\tword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\tWord\t\t\tWord\n"
"\tWORD\t\t\tWORD\n"
"\tWoRd\t\t\tWoRd\n"
msgstr ""
"\tpatrón\t\t\tcoincidencias\t~\n"
"\tpalabra\t\t\tpalabra, Palabra, PALABRA, PaLaBRa etc.\n"
"\tPalabra\t\t\tPalabra\n"
"\tPALABRA\t\t\tPALABRA\n"
"\tPaLaBRa\t\t\tPaLaBRa\n"

#. type: Plain text
#: original/TXT/usr_27.txt:62
msgid "CASE IN ONE PATTERN"
msgstr "DISTINCIÓN ENTRE MAYÚSCULAS Y MINÚSCULAS EN UN PATRÓN"

#. type: Plain text
#: original/TXT/usr_27.txt:67
msgid ""
"If you want to ignore case for one specific pattern, you can do this by "
"prepending the \"\\c\" string.  Using \"\\C\" will make the pattern to match "
"case.  This overrules the 'ignorecase' and 'smartcase' options, when \"\\c\" "
"or \"\\C\" is used their value doesn't matter."
msgstr ""
"Puede anexar la cadena «\\c» si desea ignorar esta distinción para un patrón "
"en particular. Usar «\\C» activará la distinción. Esto invalida las opciones "
"'ignorecase' y 'smartcase', ya que usar «\\c» o «\\C» obvia el valor de estas "
"opciones."

#. type: Plain text
#: original/TXT/usr_27.txt:73
#, no-wrap
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\t\\Cword\t\t\tword\n"
"\t\\CWord\t\t\tWord\n"
"\t\\cword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\t\\cWord\t\t\tword, Word, WORD, WoRd, etc.\n"
msgstr ""
"\tpatrón\t\t\tcoincidencias\t~\n"
"\t\\Cpalabra\t\tpalabra\n"
"\t\\CPalabra\t\tPalabra\n"
"\t\\cpalabra\t\tpalabra, Palabra, PALABRA, PaLaBrA, etc.\n"
"\t\\cPalabra\t\tpalabra, Palabra, PALABRA, PaLaBrA, etc.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:77
msgid ""
"A big advantage of using \"\\c\" and \"\\C\" is that it sticks with the "
"pattern.  Thus if you repeat a pattern from the search history, the same "
"will happen, no matter if 'ignorecase' or 'smartcase' was changed."
msgstr ""
"Una enorme ventaja de usar «\\c» y «\\C» es que se mantienen ligadas al "
"patrón. Por ello, si repite un patrón desde el registro de búsquedas "
"obtendrá el mismo resultado sin importar si cualquier cambio de 'ignorecase' "
"y 'smartcase'. "

#. type: Plain text
#: original/TXT/usr_27.txt:83
#, no-wrap
msgid ""
"\tNote:\n"
"\tThe use of \"\\\" items in search patterns depends on the 'magic' option.\n"
"\tIn this chapters we will assume 'magic' is on, because that is the\n"
"\tstandard and recommended setting.  If you would change 'magic', many\n"
"\tsearch patterns would suddenly become invalid.\n"
msgstr ""
"\tNota:\n"
"\tEl uso del elemento «\\» en patrones de búsqueda depende de la opción\n"
"\t'magic'.\n"
"\tEn estos capítulos daremos por sentado que 'magic' está activada, ya\n"
"\tque es la configuración estándar y recomendad. De cambiar 'magic'\n"
"\tmuchos patrones de búsqueda no serían válidos.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:87
#, no-wrap
msgid ""
"\tNote:\n"
"\tIf your search takes much longer than you expected, you can interrupt\n"
"\tit with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows.\n"
msgstr ""
"\tNota:\n"
"\tSi la búsqueda lleva más tiempo del esperado, puede interrumpir esta\n"
"\tcon CTRL-C en Unix y CTRL-Break en MS-DOS y MS-Windows.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:90
#, no-wrap
msgid "*27.2*\tWrapping around the file end\n"
msgstr "*27.2*\tJustificar el fin del archivo\n"

#. type: Plain text
#: original/TXT/usr_27.txt:98
#, no-wrap
msgid ""
"By default, a forward search starts searching for the given string at the\n"
"current cursor location.  It then proceeds to the end of the file.  If it "
"has\n"
"not found the string by that time, it starts from the beginning and searches\n"
"from the start of the file to the cursor location.\n"
"   Keep in mind that when repeating the \"n\" command to search for the next\n"
"match, you eventually get back to the first match.  If you don't notice this\n"
"you keep searching forever!  To give you a hint, Vim displays this message:\n"
msgstr ""
"Por omisión, una búsqueda hacia adelante se inicia buscando la cadena dada\n"
"en la ubicación presente del cursor. Después continua hasta el final del\n"
"archivo. Si no ha encontrado ninguna cadena, vuelve al inicio y busca desde\n"
"el principio del archivo.\n"
"   Tenga en cuenta que, de repetir la orden «n» para buscar la siguiente\n"
"coincidencia, al final volverá a la primera. ¡Buscará para siempre si no "
"nota\n"
"esto! Vim le da una pista con la forma del siguiente mensaje:\n"

#. type: Plain text
#: original/TXT/usr_27.txt:100
#, no-wrap
msgid "\tsearch hit BOTTOM, continuing at TOP ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:103
msgid ""
"If you use the \"?\" command, to search in the other direction, you get this "
"message:"
msgstr ""
"Si usa la orden «?» para buscar en dirección inversa obtendrá el siguiente "
"mensaje:"

#. type: Plain text
#: original/TXT/usr_27.txt:105
#, no-wrap
msgid "\tsearch hit TOP, continuing at BOTTOM ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:108
msgid ""
"Still, you don't know when you are back at the first match.  One way to see "
"this is by switching on the 'ruler' option: >"
msgstr ""
"Aún así,no sabe cuando vuelve a la primera coincidencia. Una forma de ver "
"esto es activando la opción 'ruler'."

#. type: Plain text
#: original/TXT/usr_27.txt:113
msgid ""
"Vim will display the cursor position in the lower righthand corner of the "
"window (in the status line if there is one).  It looks like this:"
msgstr ""
"Muestra siempre la posición actual en la esquina inferior derecha de la "
"ventana (en la línea de estado, de existir). Presenta este aspecto:"

#. type: Plain text
#: original/TXT/usr_27.txt:115
#, no-wrap
msgid "\t101,29       84% ~\n"
msgstr "\t101,29       84% ~\n"

#. type: Plain text
#: original/TXT/usr_27.txt:118
msgid ""
"The first number is the line number of the cursor.  Remember the line number "
"where you started, so that you can check if you passed this position again."
msgstr ""
"El primer número es el número de la línea del cursor. Recuerde el número de "
"la línea inicial, de manera pueda comprobar si ya pasó por esta posición."

#. type: Plain text
#: original/TXT/usr_27.txt:121
#, fuzzy
msgid "NOT WRAPPING"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:123
#, fuzzy
msgid "To turn off search wrapping, use the following command: >"
msgstr "Use la siguiente orden para centrar un rango de líneas: >"

#. type: Plain text
#: original/TXT/usr_27.txt:125
#, no-wrap
msgid "\t:set nowrapscan\n"
msgstr "\t:set nowrapscan\n"

#. type: Plain text
#: original/TXT/usr_27.txt:127
msgid ""
"Now when the search hits the end of the file, an error message displays:"
msgstr ""
"Ahora verá un mensaje de error cuando la búsqueda llega al final del archivo:"

#. type: Plain text
#: original/TXT/usr_27.txt:129
#, no-wrap
msgid "\tE385: search hit BOTTOM without match for: forever ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:133
#, no-wrap
msgid ""
"Thus you can find all matches by going to the start of the file with \"gg\" "
"and\n"
"keep searching until you see this message.\n"
"   If you search in the other direction, using \"?\", you get:\n"
msgstr ""
"Así, puede encontrar todas las coincidencias desplazándose al inicio del\n"
"archivo con «gg», y buscar hasta ver este mensaje.\n"
"   Si busca en otra dirección, usando, «?», obtendrá:\n"

#. type: Plain text
#: original/TXT/usr_27.txt:135
#, no-wrap
msgid "\tE384: search hit TOP without match for: forever ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:138
#, no-wrap
msgid "*27.3*\tOffsets\n"
msgstr "*27.3*\tDirección relativa («Offsets»)\n"

#. type: Plain text
#: original/TXT/usr_27.txt:143
msgid ""
"By default, the search command leaves the cursor positioned on the beginning "
"of the pattern.  You can tell Vim to leave it some other place by "
"specifying an offset.  For the forward search command \"/\", the offset is "
"specified by appending a slash (/) and the offset: >"
msgstr ""
"Por omisión, la orden de búsqueda posiciona el cursor al inicio del patrón. "
"Puede hacer que Vim lo posicione en algún lugar especificando una dirección "
"relativa. Para la orden de búsqueda hacia delante «/», la dirección relativa "
"se especifica añadiendo una barra inversa («/») y la dirección relativa: >"

#. type: Plain text
#: original/TXT/usr_27.txt:145
#, no-wrap
msgid "\t/default/2\n"
msgstr "\t/omisión/2\n"

#. type: Plain text
#: original/TXT/usr_27.txt:150
msgid ""
"This command searches for the pattern \"default\" and then moves to the "
"beginning of the second line past the pattern.  Using this command on the "
"paragraph above, Vim finds the word \"default\" in the first line.  Then the "
"cursor is moved two lines down and lands on \"an offset\"."
msgstr ""
"Esta orden busca el patrón «omisión», y después se desplaza al inicio de la "
"segunda línea, más allá del patrón. De usar esta orden en el párrafo "
"anterior, Vim encontraría la palabra «omisión» en la primera línea. Acto "
"seguido, el cursor se posicionaría dos líneas más abajo, para acabar en la "
"dirección relativa."

#. type: Plain text
#: original/TXT/usr_27.txt:155
msgid ""
"If the offset is a simple number, the cursor will be placed at the beginning "
"of the line that many lines from the match.  The offset number can be "
"positive or negative.  If it is positive, the cursor moves down that many "
"lines; if negative, it moves up."
msgstr ""
"El cursor se posicionara al inicio de la línea presente un número n de "
"líneas a partir de la coincidencia, si la dirección relativa es un simple "
"número. El número de dirección relativa puede ser positivo o negativo. De "
"ser positivo, el cursor se desplaza hacia abajo un número n de líneas; si es "
"negativo, se desplaza hacia arriba.  "

#. type: Plain text
#: original/TXT/usr_27.txt:158
msgid "CHARACTER OFFSETS"
msgstr "DIRECCIÓN RELATIVA DE CARÁCTER"

#. type: Plain text
#: original/TXT/usr_27.txt:161
msgid ""
"The \"e\" offset indicates an offset from the end of the match.  It moves the "
"cursor onto the last character of the match.  The command: >"
msgstr ""
"La dirección relativa «e» indica una dirección a partir del final de la "
"coincidencia. Desplaza el cursor al último carácter de la coincidencia. La "
"orden :>"

#. type: Plain text
#: original/TXT/usr_27.txt:163
#, no-wrap
msgid "\t/const/e\n"
msgstr "\t/const/e\n"

#. type: Plain text
#: original/TXT/usr_27.txt:167
#, no-wrap
msgid ""
"puts the cursor on the \"t\" of \"const\".\n"
"   From that position, adding a number moves forward that many characters.\n"
"This command moves to the character just after the match: >\n"
msgstr ""
"pone el cursor sobre la «t» de «const».\n"
"   Añadir un número le desplazará hacia delante tantos caracteres desde la\n"
"posición inicial. Esta orden desplaza el carácter a la posición anterior\n"
"a la coincidencia: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:169
#, no-wrap
msgid "\t/const/e+1\n"
msgstr "\t/const/e+1\n"

#. type: Plain text
#: original/TXT/usr_27.txt:172
msgid ""
"A positive number moves the cursor to the right, a negative number moves it "
"to the left.  For example: >"
msgstr ""
"Un número positivo desplaza el cursor a la derecha, un número negativo lo "
"desplaza a la izquierda. Ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:174
#, no-wrap
msgid "\t/const/e-1\n"
msgstr "\t/const/e-1\n"

#. type: Plain text
#: original/TXT/usr_27.txt:176
msgid "moves the cursor to the \"s\" of \"const\"."
msgstr "desplaza el cursor a la «s» de «const»."

#. type: Plain text
#: original/TXT/usr_27.txt:181
msgid ""
"If the offset begins with \"b\", the cursor moves to the beginning of the "
"pattern.  That's not very useful, since leaving out the \"b\" does the same "
"thing.  It does get useful when a number is added or subtracted.  The cursor "
"then goes forward or backward that many characters.  For example: >"
msgstr ""
"Si la dirección empieza con una «b», el cursor se desplazará al inicio del "
"patrón. No es muy útil, ya que se logra lo mismo dejando la «b». Es de "
"utilidad al añadir o sustraer un número. Entonces, el cursor se desplaza "
"hacia delante o atrás tantos caracteres. Por ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:183
#, no-wrap
msgid "\t/const/b+2\n"
msgstr "\t/const/b+2\n"

#. type: Plain text
#: original/TXT/usr_27.txt:186
msgid ""
"Moves the cursor to the beginning of the match and then two characters to "
"the right.  Thus it lands on the \"n\"."
msgstr ""
"Desplaza el cursor al principio de la coincidencia, dos caracteres a la "
"derecha. Por ello, finaliza en «n»."

#. type: Plain text
#: original/TXT/usr_27.txt:189
msgid "REPEATING"
msgstr "REPETICIÓN"

#. type: Plain text
#: original/TXT/usr_27.txt:192
msgid ""
"To repeat searching for the previously used search pattern, but with a "
"different offset, leave out the pattern: >"
msgstr ""
"Para repetir una búsqueda del último patrón dado, pero con una dirección "
"relativa distinta, omita el patrón: >"

#. type: Plain text
#: original/TXT/usr_27.txt:195
#, no-wrap
msgid ""
"\t/that\n"
"\t//e\n"
msgstr ""
"\t/that\n"
"\t//e\n"

#. type: Plain text
#: original/TXT/usr_27.txt:197
msgid "Is equal to: >"
msgstr "Equivale a: >"

#. type: Plain text
#: original/TXT/usr_27.txt:199
#, no-wrap
msgid "\t/that/e\n"
msgstr "\t/that/e\n"

#. type: Plain text
#: original/TXT/usr_27.txt:201
msgid "To repeat with the same offset: >"
msgstr "Para repetir con el mismo desplazamiento:>"

#. type: Plain text
#: original/TXT/usr_27.txt:203
#, no-wrap
msgid "\t/\n"
msgstr "\t/\n"

#. type: Plain text
#: original/TXT/usr_27.txt:205
msgid ""
"\"n\" does the same thing.  To repeat while removing a previously used offset: "
">"
msgstr ""
"«n» hace lo mismo. Para repetir mientras elimina una dirección usada "
"anteriormente: >"

#. type: Plain text
#: original/TXT/usr_27.txt:207
#, no-wrap
msgid "\t//\n"
msgstr "\t//\n"

#. type: Plain text
#: original/TXT/usr_27.txt:210
msgid "SEARCHING BACKWARDS"
msgstr "BUSCAR EN SENTIDO INVERSO"

#. type: Plain text
#: original/TXT/usr_27.txt:213
msgid ""
"The \"?\" command uses offsets in the same way, but you must use \"?\" to "
"separate the offset from the pattern, instead of \"/\": >"
msgstr ""
"La orden «?» usa las direcciones relativas de la misma forma, pero debe usar "
"«?» para separar la dirección del patrón, en lugar de «/»: >"

#. type: Plain text
#: original/TXT/usr_27.txt:215
#, no-wrap
msgid "\t?const?e-2\n"
msgstr "\t?const?e-2\n"

#. type: Plain text
#: original/TXT/usr_27.txt:218
msgid ""
"The \"b\" and \"e\" keep their meaning, they don't change direction with the "
"use of \"?\"."
msgstr ""
"La «b» y la «e» mantienen su significado, no cambien de dirección con el uso "
"de «?»."

#. type: Plain text
#: original/TXT/usr_27.txt:221
msgid "START POSITION"
msgstr "POSICIÓN INICIAL"

#. type: Plain text
#: original/TXT/usr_27.txt:224
msgid ""
"When starting a search, it normally starts at the cursor position.  When you "
"specify a line offset, this can cause trouble.  For example: >"
msgstr ""
"Al iniciar una búsqueda, generalmente comienza por la posición del cursor. "
"Esto puede causar problemas cuando especifica un desplazamiento relativo de "
"línea. Por ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:226
#, no-wrap
msgid "\t/const/-2\n"
msgstr "\t/const/-2\n"

#. type: Plain text
#: original/TXT/usr_27.txt:234
#, no-wrap
msgid ""
"This finds the next word \"const\" and then moves two lines up.  If you\n"
"use \"n\" to search again, Vim could start at the current position and find "
"the same\n"
"\"const\" match.  Then using the offset again, you would be back where you "
"started.\n"
"You would be stuck!\n"
"   It could be worse: Suppose there is another match with \"const\" in the "
"next\n"
"line.  Then repeating the forward search would find this match and move two\n"
"lines up.  Thus you would actually move the cursor back!\n"
msgstr ""
"Esto encuentra la siguiente aparición de «const», y después se desplaza dos\n"
"líneas haci arriba. Si usa «n» para repetir la búsqueda, puede que Vim la\n"
"inicie en la posición actual, encontrando la misma coincidencia de «const».\n"
"Al usar el mismo desplazamiento relativo, ha vuelto al punto inicio.\n"
"¡Se quedaría atascado!\n"
"   Aún pero: supongo que existe otra aparición de «const» en la siguiente\n"
"línea. Repetir la búsqueda hacia adelante encontraría esta coincidencia,\n"
"y desplazaría el cursor dos líneas atrás. ¡Estaría desplazando el cursor\n"
"hacia atrás todo el rato!\n"

#. type: Plain text
#: original/TXT/usr_27.txt:238
msgid ""
"When you specify a character offset, Vim will compensate for this.  Thus the "
"search starts a few characters forward or backward, so that the same match "
"isn't found again."
msgstr ""
"Al especificar un carácter de desplazamiento relativo, Vim dará una "
"compensación. Por ello, la búsqueda se inicia unos cuantos caracteres "
"delante o detrás, para no encontrar otra vez la misma coincidencia."

#. type: Plain text
#: original/TXT/usr_27.txt:241
#, no-wrap
msgid "*27.4*\tMatching multiple times\n"
msgstr "*27.4*\tEmparejar varios elementos\n"

#. type: Plain text
#: original/TXT/usr_27.txt:244
msgid ""
"The \"*\" item specifies that the item before it can match any number of "
"times.  Thus: >"
msgstr ""
"El elemento «*» especifica que el elemento precedente puede emparejarse un "
"número ilimitado de veces. Por ello: >"

#. type: Plain text
#: original/TXT/usr_27.txt:246
#, no-wrap
msgid "\t/a*\n"
msgstr "\t/a*\n"

#. type: Plain text
#: original/TXT/usr_27.txt:253
#, no-wrap
msgid ""
"matches \"a\", \"aa\", \"aaa\", etc.  But also \"\" (the empty string), because zero\n"
"times is included.\n"
"   The \"*\" only applies to the item directly before it.  Thus \"ab*\" matches\n"
"\"a\", \"ab\", \"abb\", \"abbb\", etc.  To match a whole string multiple times, it\n"
"must be grouped into one item.  This is done by putting \"\\(\" before it and\n"
"\"\\)\" after it.  Thus this command: >\n"
msgstr ""
"coincide con «a», «aa», «aaa», etc. Pero también « » (una cadena vacía), ya\n"
"que se incluye por omisión cero veces.\n"
"   «*» sólo afecta al su elemento precedente. Por ello, «ab*» encuentra «a»,\n"
"«ab», «abb», «abbb», etc. Para encontrar varias apariciones de una cadena\n"
"completa, ésta ha de estar agrupada bajo un mismo elemento. Esto se hace\n"
"colocando «\\(» antes de la cadena, y «\\)» después. Por ello, la siguiente\n"
"orden: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:255
#, no-wrap
msgid "\t/\\(ab\\)*\n"
msgstr "\t/\\(ab\\)*\n"

#. type: Plain text
#: original/TXT/usr_27.txt:257
msgid "Matches: \"ab\", \"abab\", \"ababab\", etc.  And also \"\"."
msgstr "encuentra «ab», «abab», «ababab», etc. También « »."

#. type: Plain text
#: original/TXT/usr_27.txt:260
msgid ""
"To avoid matching the empty string, use \"\\+\".  This makes the previous "
"item match one or more times. >"
msgstr ""
"Para evitar que coincida con una cadena vacía, use «\\+». Esto encuentra una "
"o\n"
"más apariciones del elemento precedente. >"

#. type: Plain text
#: original/TXT/usr_27.txt:262
#, no-wrap
msgid "\t/ab\\+\n"
msgstr "\t/ab\\+\n"

#. type: Plain text
#: original/TXT/usr_27.txt:264
msgid ""
"Matches \"ab\", \"abb\", \"abbb\", etc.  It does not match \"a\" when no \"b"
"\" follows."
msgstr ""
"Encuentra «ab», «abb», «abbb», etc. No coincide con «a» si no va seguido de «b»."

#. type: Plain text
#: original/TXT/usr_27.txt:266
msgid "To match an optional item, use \"\\=\".  Example: >"
msgstr "Para hacer coincidir un elemento opcional, utilice «\\=». Ejemplo:>"

#. type: Plain text
#: original/TXT/usr_27.txt:268
#, no-wrap
msgid "\t/folders\\=\n"
msgstr "\t/directorio\\=\n"

#. type: Plain text
#: original/TXT/usr_27.txt:270
msgid "Matches \"folder\" and \"folders\"."
msgstr "Encuentra «directorio» y «directorios»."

#. type: Plain text
#: original/TXT/usr_27.txt:273
msgid "SPECIFIC COUNTS"
msgstr "RECUENTOS ESPECÍFICOS"

#. type: Plain text
#: original/TXT/usr_27.txt:277
msgid ""
"To match a specific number of items use the form \"\\{n,m}\".  \"n\" and \"m\" are "
"numbers.  The item before it will be matched \"n\" to \"m\" times |inclusive|.  "
"Example: >"
msgstr ""
"Use la forma «\\{n,m}» para emparejar un número específico de elementos. «n» "
"y «m» son números. El elemento anterior a éstos se emparejará con «n» un "
"número «m» de veces |inclusive|. Ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:279
#, no-wrap
msgid "\t/ab\\{3,5}\n"
msgstr "\t/ab\\{3,5}\n"

#. type: Plain text
#: original/TXT/usr_27.txt:284
#, no-wrap
msgid ""
"matches \"abbb\", \"abbbb\" and \"abbbbb\".\n"
"  When \"n\" is omitted, it defaults to zero.  When \"m\" is omitted it defaults\n"
"to infinity.  When \",m\" is omitted, it matches exactly \"n\" times.\n"
"Examples:\n"
msgstr ""
"empareja «abbb», «abbbb» y «abbbbb».\n"
"  El valor predefinido cero en ausencia de «n». El valor predefinido es\n"
"infinito en ausencia de «m». En ausencia de «m», se empareja exactamente\n"
"«n» veces.\n"
"Ejemplos:\n"

#. type: Plain text
#: original/TXT/usr_27.txt:292
#, no-wrap
msgid ""
"\tpattern\t\tmatch count ~\n"
"\t\\{,4}\t\t0, 1, 2, 3 or 4\n"
"\t\\{3,}\t\t3, 4, 5, etc.\n"
"\t\\{0,1}\t\t0 or 1, same as \\=\n"
"\t\\{0,}\t\t0 or more, same as *\n"
"\t\\{1,}\t\t1 or more, same as \\+\n"
"\t\\{3}\t\t3\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:295
msgid "MATCHING AS LITTLE AS POSSIBLE"
msgstr "REDUCIR EL NÚMERO DE COINCIDENCIAS"

#. type: Plain text
#: original/TXT/usr_27.txt:300
#, no-wrap
msgid ""
"The items so far match as many characters as they can find.  To match as few\n"
"as possible, use \"\\{-n,m}\".  It works the same as \"\\{n,m}\", except that the\n"
"minimal amount possible is used.\n"
"   For example, use: >\n"
msgstr ""
"Los elementos encajan con cuantos caracteres pueden encontrar. Para "
"encontrar\n"
"el menor número posible de coincidencias, use «\\{-n,m}». Funciona igual que "
"«\\{n,m}», pero se mostrará la menor cantidad posible.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:302
#, no-wrap
msgid "\t/ab\\{-1,3}\n"
msgstr "\t/ab\\{-1,3}\n"

#. type: Plain text
#: original/TXT/usr_27.txt:310
#, no-wrap
msgid ""
"Will match \"ab\" in \"abbb\".  Actually, it will never match more than one b,\n"
"because there is no reason to match more.  It requires something else to "
"force\n"
"it to match more than the lower limit.\n"
"   The same rules apply to removing \"n\" and \"m\".  It's even possible to "
"remove\n"
"both of the numbers, resulting in \"\\{-}\".  This matches the item before it\n"
"zero or more times, as few as possible.  The item by itself always matches\n"
"zero times.  It is useful when combined with something else.  Example: >\n"
msgstr ""
"Encontraría «ab» en «abbb». En realidad, nunca coincidirá con mas de una "
"«b»,\n"
"ya que no hay razón para coincidir con más. Se precisa algo más para forzar\n"
"un número de coincidencias mayor que el límite más bajo.\n"
"   Las mismas reglas están presentes al eliminar «n» y «m». También es "
"posible\n"
"eliminar ambos números, dejando «\\{-}». Esto encuentra el elemento anterior\n"
"a él cero o más veces, pero cuantas menos posibles. El elemento en sí "
"siempre\n"
"se empareja cero veces. Es de utilidad en combinación con algo más.\n"
"Ejemplo: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:312
#, no-wrap
msgid "\t/a.\\{-}b\n"
msgstr "\t/a.\\{-}b\n"

#. type: Plain text
#: original/TXT/usr_27.txt:314
msgid "This matches \"axb\" in \"axbxb\".  If this pattern would be used: >"
msgstr "Esto coincide con «axb» en «axbxb». De usar este patrón >"

#. type: Plain text
#: original/TXT/usr_27.txt:316
#, no-wrap
msgid "\t/a.*b\n"
msgstr "\t/a.*b\n"

#. type: Plain text
#: original/TXT/usr_27.txt:319
msgid ""
"It would try to match as many characters as possible with \".*\", thus it "
"matches \"axbxb\" as a whole."
msgstr ""
"...intentaría coincidir con tantos caracteres como es posible con «.*», y "
"por ello se empareja por completo con «axbxb»."

#. type: Plain text
#: original/TXT/usr_27.txt:322
#, no-wrap
msgid "*27.5*\tAlternatives\n"
msgstr "*27.5*\tAlternativas\n"

#. type: Plain text
#: original/TXT/usr_27.txt:324
msgid "The \"or\" operator in a pattern is \"\\|\".  Example: >"
msgstr "El operador «or» dentro de un patrón es «\\|». Ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:326
#, no-wrap
msgid "\t/foo\\|bar\n"
msgstr "\t/foo\\|bar\n"

#. type: Plain text
#: original/TXT/usr_27.txt:328
msgid ""
"This matches \"foo\" or \"bar\".  More alternatives can be concatenated: >"
msgstr "Esto encuentra «foo» o «bar». Puede concatenar más alternativas: >"

#. type: Plain text
#: original/TXT/usr_27.txt:330
#, no-wrap
msgid "\t/one\\|two\\|three\n"
msgstr "\t/uno\\|dos\\|tres\n"

#. type: Plain text
#: original/TXT/usr_27.txt:333
#, no-wrap
msgid ""
"Matches \"one\", \"two\" and \"three\".\n"
"   To match multiple times, the whole thing must be placed in \"\\(\" and \"\\)\": >\n"
msgstr ""
"Coincide con «uno», «dos» y «tres».\n"
"   Para encontrar varias coincidencias debe insertar la cadena completa entre\n"
"«\\(» y «\\)»: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:335
#, no-wrap
msgid "\t/\\(foo\\|bar\\)\\+\n"
msgstr "\t/\\(foo\\|bar\\)\\+\n"

#. type: Plain text
#: original/TXT/usr_27.txt:338
#, no-wrap
msgid ""
"This matches \"foo\", \"foobar\", \"foofoo\", \"barfoobar\", etc.\n"
"   Another example: >\n"
msgstr ""
"Esto encuentra «foo», «foobar», «foofoo», «barfoobar», etc.\n"
"   Otro ejemplo: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:340
#, no-wrap
msgid "\t/end\\(if\\|while\\|for\\)\n"
msgstr "\t/end\\(if\\|while\\|for\\)\n"

#. type: Plain text
#: original/TXT/usr_27.txt:342
msgid "This matches \"endif\", \"endwhile\" and \"endfor\"."
msgstr "Esto coincide con «endif», «endwhile» y «endfor»."

#. type: Plain text
#: original/TXT/usr_27.txt:345
msgid ""
"A related item is \"\\&\".  This requires that both alternatives match in "
"the same place.  The resulting match uses the last alternative.  Example: >"
msgstr ""
"Un elemento relacionado es «\\&». Esto requiere que ambas alternativas "
"coincidan en el mismo lugar. La coincidencia resultante usa la última "
"alternativa. Ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:347
#, no-wrap
msgid "\t/forever\\&...\n"
msgstr "\t/forever\\&...\n"

#. type: Plain text
#: original/TXT/usr_27.txt:349
msgid ""
"This matches \"for\" in \"forever\".  It will not match \"fortuin\", for "
"example."
msgstr ""
"Esto coincide on «for» en «forever». No coincide con «fortuin», por ejemplo."

#. type: Plain text
#: original/TXT/usr_27.txt:352
#, no-wrap
msgid "*27.6*\tCharacter ranges\n"
msgstr "*27.6*\tRangos de caracteres\n"

#. type: Plain text
#: original/TXT/usr_27.txt:355
msgid ""
"To match \"a\", \"b\" or \"c\" you could use \"/a\\|b\\|c\".  When you want to match "
"all letters from \"a\" to \"z\" this gets very long.  There is a shorter method: "
">"
msgstr ""
"Puede usar «/a|b\\|c» para encontrar «a», «b» o «c». Esto se extiende si "
"desea encontrar todas las letras de la «a» a la «z». Existe una manera más "
"corta: >"

#. type: Plain text
#: original/TXT/usr_27.txt:357
#, no-wrap
msgid "\t/[a-z]\n"
msgstr "\t/[a-z]\n"

#. type: Plain text
#: original/TXT/usr_27.txt:360
msgid ""
"The [] construct matches a single character.  Inside you specify which "
"characters to match.  You can include a list of characters, like this: >"
msgstr ""
"La construcción [] encuentra un sólo carácter. Especifique dentro de este "
"los caracteres a encontrar. Puede incluir una lista larga de caracteres, "
"como esto: >"

#. type: Plain text
#: original/TXT/usr_27.txt:362
#, no-wrap
msgid "\t/[0123456789abcdef]\n"
msgstr "\t/[0123456789abcdef]\n"

#. type: Plain text
#: original/TXT/usr_27.txt:366
msgid ""
"This will match any of the characters included.  For consecutive characters "
"you can specify the range.  \"0-3\" stands for \"0123\".  \"w-z\" stands for "
"\"wxyz\".  Thus the same command as above can be shortened to: >"
msgstr ""
"Esto encuentra cualquier carácter incluido. Puede especificar un rango para "
"encontrar caracteres consecutivos. «0-3» significa «01234». «w-z» significa "
"«wxyz». Por ello, puede acortar la orden anterior: >"

#. type: Plain text
#: original/TXT/usr_27.txt:368
#, no-wrap
msgid "\t/[0-9a-f]\n"
msgstr "\t/[0-9a-f]\n"

#. type: Plain text
#: original/TXT/usr_27.txt:372
msgid ""
"To match the \"-\" character itself make it the first or last one in the "
"range.  These special characters are accepted to make it easier to use them "
"inside a [] range (they can actually be used anywhere in the search "
"pattern):"
msgstr ""
"Para encontrar el carácter «-», tiene que aparecer al principio o final del "
"rango. Estos caracteres especiales se aceptan para facilitar su uso dentro "
"de un rango [] (en realidad, puede usarlos en cualquier lugar dentro del "
"patrón de búsqueda):"

#. type: Plain text
#: original/TXT/usr_27.txt:377
#, no-wrap
msgid ""
"\t\\e\t<Esc>\n"
"\t\\t\t<Tab>\n"
"\t\\r\t<CR>\n"
"\t\\b\t<BS>\n"
msgstr ""
"\t\\e\t<Esc>\n"
"\t\\t\t<Tab>\n"
"\t\\r\t<CR>\n"
"\t\\b\t<BS>\n"

#. type: Plain text
#: original/TXT/usr_27.txt:380
msgid ""
"There are a few more special cases for [] ranges, see |/[]| for the whole "
"story."
msgstr ""
"Existen unas cuantos casos especiales para los rangos [], consulte |/[]| "
"para una completa información."

#. type: Plain text
#: original/TXT/usr_27.txt:383
msgid "COMPLEMENTED RANGE"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:386
msgid ""
"To avoid matching a specific character, use \"^\" at the start of the range.  "
"The [] item then matches everything but the characters included.  Example: >"
msgstr ""
"Use «^» al principio del rango para evitar emparejar un carácter en "
"particular. El elemento [] emparejará todo menos los caracteres incluidos. "
"Ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:393
#, no-wrap
msgid ""
"\t/\"[^\"]*\"\n"
"<\n"
"\t \"\t  a double quote\n"
"\t  [^\"]\t  any character that is not a double quote\n"
"\t      *\t  as many as possible\n"
"\t       \"  a double quote again\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:395
msgid "This matches \"foo\" and \"3!x\", including the double quotes."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:398
msgid "PREDEFINED RANGES"
msgstr "RANGOS PREDEFINIDOS"

#. type: Plain text
#: original/TXT/usr_27.txt:401
msgid ""
"A number of ranges are used very often.  Vim provides a shortcut for these. "
" For example: >"
msgstr ""
"Existe un número de rangos usados a menudo. Vim ofrece accesos directos para "
"esto. Por ejemplo: >"

#. type: Plain text
#: original/TXT/usr_27.txt:403
#, no-wrap
msgid "\t/\\a\n"
msgstr "\t/\\a\n"

#. type: Plain text
#: original/TXT/usr_27.txt:406
msgid ""
"Finds alphabetic characters.  This is equal to using \"/[a-zA-Z]\".  Here are "
"a few more of these:"
msgstr ""
"Encuentra caracteres alfabéticos. Esto equivale a usar «/[a-zA-Z]». Aquí hay "
"más ejemplos:"

#. type: Plain text
#: original/TXT/usr_27.txt:418
#, no-wrap
msgid ""
"\titem\tmatches\t\t\tequivalent ~\n"
"\t\\d\tdigit\t\t\t[0-9]\n"
"\t\\D\tnon-digit\t\t[^0-9]\n"
"\t\\x\thex digit\t\t[0-9a-fA-F]\n"
"\t\\X\tnon-hex digit\t\t[^0-9a-fA-F]\n"
"\t\\s\twhite space\t\t[ \t]     (<Tab> and <Space>)\n"
"\t\\S\tnon-white characters\t[^ \t]     (not <Tab> and <Space>)\n"
"\t\\l\tlowercase alpha\t\t[a-z]\n"
"\t\\L\tnon-lowercase alpha\t[^a-z]\n"
"\t\\u\tuppercase alpha\t\t[A-Z]\n"
"\t\\U\tnon-uppercase alpha\t[^A-Z]\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:424
#, no-wrap
msgid ""
"\tNote:\n"
"\tUsing these predefined ranges works a lot faster than the character\n"
"\trange it stands for.\n"
"\tThese items can not be used inside [].  Thus \"[\\d\\l]\" does NOT work to\n"
"\tmatch a digit or lowercase alpha.  Use \"\\(\\d\\|\\l\\)\" instead.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:426
msgid "See |/\\s| for the whole list of these ranges."
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:429
#, no-wrap
msgid "*27.7*\tCharacter classes\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:434
#, no-wrap
msgid ""
"The character range matches a fixed set of characters.  A character class is\n"
"similar, but with an essential difference: The set of characters can be\n"
"redefined without changing the search pattern.\n"
"   For example, search for this pattern: >\n"
msgstr ""
"El rango de carácter empareja un conjunto específico de caracteres. Se\n"
"parece una clase de carácter, pero con una importante diferencia: puede\n"
"redefinir el conjunto de caracteres sin cambiar el patrón de búsqueda.\n"
"   Por ejemplo, busque este patrón: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:436
#, no-wrap
msgid "\t/\\f\\+\n"
msgstr "\t/\\f\\+\n"

#. type: Plain text
#: original/TXT/usr_27.txt:442
#, no-wrap
msgid ""
"The \"\\f\" items stands for file name characters.  Thus this matches a "
"sequence\n"
"of characters that can be a file name.\n"
"   Which characters can be part of a file name depends on the system you are\n"
"using.  On MS-Windows, the backslash is included, on Unix it is not.  This "
"is\n"
"specified with the 'isfname' option.  The default value for Unix is: >\n"
msgstr ""
"Los elementos «\\f» simbolizan caracteres de nombre de archivo. Así, esto "
"empareja una secuencia de caracteres que pueden ser un nombre de archivo.\n"
"   Qué caracteres pueden formar parte de un nombre de archivo dependen del "
"sistema que esté usando. En MS-Windows, la barra inversa está incluida, pero "
"no en Unix. Puede especificar esto con la opción 'isfname'. El valor por "
"omisión en Unix es: >"

#. type: Plain text
#: original/TXT/usr_27.txt:445
#, no-wrap
msgid ""
"\t:set isfname\n"
"\tisfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=\n"
msgstr ""
"\t:set isfname\n"
"\tisfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=\n"

#. type: Plain text
#: original/TXT/usr_27.txt:449
msgid ""
"For other systems the default value is different.  Thus you can make a "
"search pattern with \"\\f\" to match a file name, and it will automatically "
"adjust to the system you are using it on."
msgstr ""
"El valor predefinido depende del sistema. Así, puede crear un patrón de "
"búsqueda con «\\f» para emparejar un nombre de archivo, y ajustarse "
"automáticamente al sistema en el que lo está usando."

#. type: Plain text
#: original/TXT/usr_27.txt:456
#, no-wrap
msgid ""
"\tNote:\n"
"\tActually, Unix allows using just about any character in a file name,\n"
"\tincluding white space.  Including these characters in 'isfname' would\n"
"\tbe theoretically correct.  But it would make it impossible to find the\n"
"\tend of a file name in text.  Thus the default value of 'isfname' is a\n"
"\tcompromise.\n"
msgstr ""
"\tNota:\n"
"\tEn realidad, Unix permita usar casi cualquier carácter, incluyendo\n"
"\tespacios. Incluir estos caracteres en 'isfname' sería teóricamente\n"
"\tcorrecto, pero imposibilitaría encontrar el fin del nombre de archivo\n"
"\ten el texto. Así, el valor predefinido de 'isfname' es importante.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:458
msgid "The character classes are:"
msgstr "Las clases de caracteres son:"

#. type: Plain text
#: original/TXT/usr_27.txt:468
#, no-wrap
msgid ""
"\titem\tmatches\t\t\t\toption ~\n"
"\t\\i\tidentifier characters\t\t'isident'\n"
"\t\\I\tlike \\i, excluding digits\n"
"\t\\k\tkeyword characters\t\t'iskeyword'\n"
"\t\\K\tlike \\k, excluding digits\n"
"\t\\p\tprintable characters\t\t'isprint'\n"
"\t\\P\tlike \\p, excluding digits\n"
"\t\\f\tfile name characters\t\t'isfname'\n"
"\t\\F\tlike \\f, excluding digits\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_27.txt:471
#, no-wrap
msgid "*27.8*\tMatching a line break\n"
msgstr "*27.8*\tCoincidir con un salto de línea\n"

#. type: Plain text
#: original/TXT/usr_27.txt:476
#, no-wrap
msgid ""
"Vim can find a pattern that includes a line break.  You need to specify "
"where\n"
"the line break happens, because all items mentioned so far don't match a "
"line\n"
"break.\n"
"   To check for a line break in a specific place, use the \"\\n\" item: >\n"
msgstr ""
"Vim puede encontrar un patrón que incluye un salto de línea. Debe "
"especificar\n"
"la aparición del salto de línea, ya que todos los elementos mencionados "
"hasta\n"
"ahora no se emparejan con un salto de línea.\n"
"   Para comprobar si hay un salto de línea en un lugar específico, use el\n"
"elemento «\\n»: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:478
#, no-wrap
msgid "\t/the\\nword\n"
msgstr "\t/la\\npalabra\n"

#. type: Plain text
#: original/TXT/usr_27.txt:482
msgid ""
"This will match at a line that ends in \"the\" and the next line starts with "
"\"word\".  To match \"the word\" as well, you need to match a space or a line "
"break.  The item to use for it is \"\\_s\": >"
msgstr ""
"Esto coincidiría en una línea que termina con «la», seguida de una que "
"comienza con «palabra». Para encontrar también «la palabra», tendrá que "
"emparejar el espacio o el salto de línea. Para ello, use el elemento «\\_s»: "
">"

#. type: Plain text
#: original/TXT/usr_27.txt:484
#, no-wrap
msgid "\t/the\\_sword\n"
msgstr "\t/la\\_spalabra\n"

#. type: Plain text
#: original/TXT/usr_27.txt:486
msgid "To allow any amount of white space: >"
msgstr "Para permitir cualquier cantidad de espacio en blanco:>"

#. type: Plain text
#: original/TXT/usr_27.txt:488
#, no-wrap
msgid "\t/the\\_s\\+word\n"
msgstr "\t/la\\_s\\+palabra\n"

#. type: Plain text
#: original/TXT/usr_27.txt:491
#, no-wrap
msgid ""
"This also matches when \"the  \" is at the end of a line and \"   word\" at the\n"
"start of the next one.\n"
msgstr "Esto también coincide cuando «la » está al final de la línea, y «palabra» al "
"inicio de la siguiente.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:496
msgid ""
"\"\\s\" matches white space, \"\\_s\" matches white space or a line break.  "
"Similarly, \"\\a\" matches an alphabetic character, and \"\\_a\" matches an "
"alphabetic character or a line break.  The other character classes and "
"ranges can be modified in the same way by inserting a \"_\"."
msgstr ""
"«\\s» coincide con espacio en blanco, «\\_s» coincide con espacio en blanco o "
"un salto de línea. De forma parecida, «\\a» coincide con un carácter "
"alfabético o un salto de línea. Las otras clases de caracteres y rangos se "
"pueden modificar de la misma forma insertando un «_»."

#. type: Plain text
#: original/TXT/usr_27.txt:499
msgid ""
"Many other items can be made to match a line break by prepending \"\\_\".  For "
"example: \"\\_.\" matches any character or a line break."
msgstr ""
"Puede hacer coincidir muchos otros elementos con un salto de línea "
"prefijando «\\_». Por ejemplo, «\\_.» coincide con cualquier carácter o salto "
"de línea."

#. type: Plain text
#: original/TXT/usr_27.txt:503
#, no-wrap
msgid ""
"\tNote:\n"
"\t\"\\_.*\" matches everything until the end of the file.  Be careful with\n"
"\tthis, it can make a search command very slow.\n"
msgstr ""
"\tNota:\n"
"\t«\\_.*» empareja todo hasta el final del archivo. Use esto con\n"
"\tcuidado, ya que puede reducir la velocidad de una orden de búsqueda.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:505
msgid ""
"Another example is \"\\_[]\", a character range that includes a line break: >"
msgstr ""
"Otro ejemplo es «\\_[]», un rango de carácter que incluye un salto de línea: "
">"

#. type: Plain text
#: original/TXT/usr_27.txt:507
#, no-wrap
msgid "\t/\"\\_[^\"]*\"\n"
msgstr "\t/\"\\_[^\"]*\"\n"

#. type: Plain text
#: original/TXT/usr_27.txt:509
msgid ""
"This finds a text in double quotes that may be split up in several lines."
msgstr ""
"Esto encuentra un texto entre comillas dobles que se puede dividir en varias "
"líneas."

#. type: Plain text
#: original/TXT/usr_27.txt:512
#, no-wrap
msgid "*27.9*\tExamples\n"
msgstr "*27.9*\tEjemplos\n"

#. type: Plain text
#: original/TXT/usr_27.txt:515
msgid ""
"Here are a few search patterns you might find useful.  This shows how the "
"items mentioned above can be combined."
msgstr ""
"Aquí dispone de unos cuantos patrones de búsqueda que puede encontrar "
"útiles. Esto muestra cómo combinar los elementos anteriormente mencionados."

#. type: Plain text
#: original/TXT/usr_27.txt:518
msgid "FINDING A CALIFORNIA LICENSE PLATE"
msgstr "ENCONTRAR UNA MATRÍCULA DE COCHE DE CALIFORNIA"

#. type: Plain text
#: original/TXT/usr_27.txt:521
msgid ""
"A sample license plate number is \"1MGU103\".  It has one digit, three "
"uppercase letters and three digits.  Directly putting this into a search "
"pattern: >"
msgstr ""
"Un ejemplo de un número de matrícula es «1MGU103». Tiene un dígito, tres "
"letras mayúsculas y tres dígitos. Puede insertar esto en un patrón búsqueda "
"de la siguiente manera: >"

#. type: Plain text
#: original/TXT/usr_27.txt:523
#, no-wrap
msgid "\t/\\d\\u\\u\\u\\d\\d\\d\n"
msgstr "\t/\\d\\u\\u\\u\\d\\d\\d\n"

#. type: Plain text
#: original/TXT/usr_27.txt:526
msgid ""
"Another way is to specify that there are three digits and letters with a "
"count: >"
msgstr ""
"Otra forma es especificar que hay tres dígitos y letras, con un recuento: >"

#. type: Plain text
#: original/TXT/usr_27.txt:528
#, no-wrap
msgid "\t/\\d\\u\\{3}\\d\\{3}\n"
msgstr "\t/\\d\\u\\{3}\\d\\{3}\n"

#. type: Plain text
#: original/TXT/usr_27.txt:530
msgid "Using [] ranges instead: >"
msgstr "O usando rangos [] en su lugar: >"

#. type: Plain text
#: original/TXT/usr_27.txt:532
#, no-wrap
msgid "\t/[0-9][A-Z]\\{3}[0-9]\\{3}\n"
msgstr "\t/[0-9][A-Z]\\{3}[0-9]\\{3}\n"

#. type: Plain text
#: original/TXT/usr_27.txt:537
msgid ""
"Which one of these you should use? Whichever one you can remember.  The "
"simple way you can remember is much faster than the fancy way that you "
"can't.  If you can remember them all, then avoid the last one, because it's "
"both more typing and slower to execute."
msgstr ""
"¿Cual debería usar? Él que recuerde. La manera sencilla que puede recordar "
"es más rápida que la compleja que no puede. Si los puede recordar todos, "
"evite el último, ya que es más lento de teclear y de ejecutar."

#. type: Plain text
#: original/TXT/usr_27.txt:540
msgid "FINDING AN IDENTIFIER"
msgstr "ENCONTRAR UN IDENTIFICADOR"

#. type: Plain text
#: original/TXT/usr_27.txt:544
msgid ""
"In C programs (and many other computer languages) an identifier starts with "
"a letter and further consists of letters and digits.  Underscores can be "
"used too.  This can be found with: >"
msgstr ""
"En programas C (y muchos otros lenguajes de programación), un identificador "
"empieza con una letra seguida de letras y dígitos. Puede usar subrayados. "
"Puede encontrar esto con: >"

#. type: Plain text
#: original/TXT/usr_27.txt:546
#, no-wrap
msgid "\t/\\<\\h\\w*\\>\n"
msgstr "\t/\\<\\h\\w*\\>\n"

#. type: Plain text
#: original/TXT/usr_27.txt:549
msgid ""
"\"\\<\" and \"\\>\" are used to find only whole words.  \"\\h\" stands for "
"\"[A-Za-z_]\" and \"\\w\" for \"[0-9A-Za-z_]\"."
msgstr ""
"«\\<» y «\\>» se usan para encontrar palabras completas.«\\h» simboliza "
"«[A-Za-z_]», y «\\w» simboliza «[0-9A-Za-z_]»."

#. type: Plain text
#: original/TXT/usr_27.txt:553
#, no-wrap
msgid ""
"\tNote:\n"
"\t\"\\<\" and \"\\>\" depend on the 'iskeyword' option.  If it includes \"-\",\n"
"\tfor example, then \"ident-\" is not matched.  In this situation use: >\n"
msgstr ""
"\tNota:\n"
"\t«\\<» y «\\>» dependen de la opción 'iskeyword'. De incluir un «-»,\n"
"\tpor ejemplo, «ident-» no se encontrará. Use lo siguiente en esta\n"
"\tsituación: >\n"

#. type: Plain text
#: original/TXT/usr_27.txt:558
#, no-wrap
msgid ""
"\t\t/\\w\\@<!\\h\\w*\\w\\@!\n"
"<\n"
"\tThis checks if \"\\w\" does not match before or after the identifier.\n"
"\tSee |/\\@<!| and |/\\@!|.\n"
msgstr ""
"\t\t/\\w\\@<!\\h\\w*\\w\\@!\n"
"<\n"
"\tEsto revisa se «\\w» no se empareja antes o después de un\n"
"\tidentificador. Consulte |/\\@<!| and |/\\@!|.\n"

#. type: Plain text
#: original/TXT/usr_27.txt:562
msgid "Next chapter: |usr_28.txt| Folding"
msgstr "Siguiente capítulo: |usr_28.txt| Plegar"
