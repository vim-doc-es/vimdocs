# vim-doc-es https://www.assembla.com/wiki/show/vim-doc-es
#
# Copyright (C) AÑOS 
# This file is distributed under the same license as the Vim 7.2 package.
#
# Translators credits:
#   - Initial translation
#       Álvaro Castro Castillo <alvaro.castro.castilla@gmail.com>
#
#   - Updates
#       TRADUCTOR <CORREO>, AÑO 
#
# 
#
# Debido al formato (txt) y al máximo de 80 columnas que pueden tener 
# los textos de ayuda en Vim, así como el formato PO, por favor, leete los
# apuntes concernientes a la edición de los archivos PO relativos a la
# aplicación que desees usar.
# También encontrarás información acerca del uso de herramientas gettext en el 
# proyecto de localización (l10n) de Vim.
# 
# - http://www.assembla.com/wiki/show/vim-doc-es
#
# No somos parte del proyecto de traducción en Debian. Sin embargo, creemos que
# este enlace puede ser de interés. A pesar de no formar parte, nuestra 
# intención es homologarnos con su terminología y uso de la lengua 
# en la medida de lo útil y posible.
# 
#  - El proyecto de traducción de Debian al español
#     http://www.debian.org/intl/spanish/notas
# 
# La R.A.E. no es un inmenso referente en cuanto a términos tecnológicos,
# pero también puede servir de referencia para otros términos no técnicos.
# No pretendemos hacer es_ES, es_CO, es_AR, etc..., sino que la misma
# traducción sea comprensible independientemente de la nacionalidad del
# usuario. Si crees que alguna traducción puede llevar a confusión, consulta
# la R.A.E., o el diccionario de Maria Moliner, y escribe un correo.
# 
#  - www.rae.es 
#  - http://www.diclib.com/cgi-bin/d1.cgi?base=moliner&page=showpages   
# 
# Disponemos también de un archivo «terminology.po» en «/recursos_de..» que
# se puede consultar con un simple grep, pogrep o cargado en Virtaal.
# 
#. extracted from usr_12.txt
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.2\n"
"Report-Msgid-Bugs-To: bugs@vim.org\n"
"POT-Creation-Date: 2009-08-01 19:54+0200\n"
"PO-Revision-Date: 2009-10-18 18:19+0200\n"
"Last-Translator: Álvaro Castro Castillo <alvaro.castro.castilla@gmail.com>\n"
"Language-Team: Documentación de Vim en español\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: usr_12.txt:1
msgid "*usr_12.txt*\tFor Vim version 7.2.  Last change: 2007 May 11"
msgstr "*usr_12.esx*\tPara Vim versión 7.2.  Último cambio: 11/6/2007"

#: usr_12.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr "\t\tMANUAL DE USUARIO DE VIM - por Bram Moolenaar"

#: usr_12.txt:5
msgid "\t\t\t\tClever tricks"
msgstr "\t\t\t\tTrucos"

#: usr_12.txt:8
msgid ""
"By combining several commands you can make Vim do nearly everything.  In "
"this\n"
"chapter a number of useful combinations will be presented.  This uses the\n"
"commands introduced in the previous chapters and a few more."
msgstr ""
"Puedes conseguir que Vim haga casi cualquier cosa,.mediante la combinación\n"
"varias órdenes. En este capítulo, presentaremos una serie de combinaciones\n"
"útiles. Esto emplea las órdenes introducidos en capítulos anteriores y\n"
"algunos más."

#: usr_12.txt:12
msgid ""
"|12.1|\tReplace a word\n"
"|12.2|\tChange \"Last, First\" to \"First Last\"\n"
"|12.3|\tSort a list\n"
"|12.4|\tReverse line order\n"
"|12.5|\tCount words\n"
"|12.6|\tFind a man page\n"
"|12.7|\tTrim blanks\n"
"|12.8|\tFind where a word is used"
msgstr ""
"|12.1|\tReemplazar una palabra\n"
"|12.2|\tCambiar «Último, Primero» a «Primero Último»\n"
"|12.3|\tOrdenar una lista\n"
"|12.4|\tInvertir el orden de las líneas\n"
"|12.5|\tContar palabras\n"
"|12.6|\tEncontrar una página de manual\n"
"|12.7|\tEliminar espacios en blanco sobrantes\n"
"|12.8|\tBuscar dónde se emplea una palabra"

#: usr_12.txt:21
msgid ""
"     Next chapter: |usr_20.txt|  Typing command-line commands quickly\n"
" Previous chapter: |usr_11.txt|  Recovering from a crash\n"
"Table of contents: |usr_toc.txt|"
msgstr ""
" Capítulo siguiente: |usr_20.esx|  Ser eficaz con la línea de órdenes\n"
"  Capítulo anterior: |usr_11.esx|  Recuperarse de un fallo\n"
"Tabla de contenidos: |usr_toc.esx|"

#: usr_12.txt:25
msgid ""
"==============================================================================\n"
"*12.1*\tReplace a word"
msgstr ""
"==============================================================================\n"
"*12.1*  Reemplazar una palabra"

#: usr_12.txt:28
msgid ""
"The substitute command can be used to replace all occurrences of a word "
"with\n"
"another word: >"
msgstr ""
"La orden sustituir se puede emplear para reemplazar todas las apariciones\n"
"de una palabra con otra: >"

#: usr_12.txt:31
msgid "\t:%s/four/4/g"
msgstr "\t:%s/cuatro/4/g"

#: usr_12.txt:33
msgid ""
"The \"%\" range means to replace in all lines.  The \"g\" flag at the end "
"causes\n"
"all words in a line to be replaced.\n"
"   This will not do the right thing if your file also contains \"thirtyfour"
"\".\n"
"It would be replaced with \"thirty4\".  To avoid this, use the \"\\<\" item "
"to\n"
"match the start of a word: >"
msgstr ""
"El rango «%» significa reemplazar en todas las líneas. La marca «g» al final\n"
"hace que todas las palabras de una línea sean sustituidas.\n"
"   Esto no hará lo que desea si su archivo también contiene «veinticuatro».\n"
"Será reemplazado por «veinti4». Para evitar que esto ocurra, use el «\\<»\n"
"para concordar con el comienzo de una palabra. >"

#: usr_12.txt:39
msgid "\t:%s/\\<four/4/g"
msgstr "\t:%s/\\<cuatro/4/g"

#: usr_12.txt:41
msgid ""
"Obviously, this still goes wrong on \"fourteen\".  Use \"\\>\" to match the "
"end of\n"
"a word: >"
msgstr ""
"Obviamente, esto también funcionará mal con «cuatrocientos». Use «\\>»\n"
"para concordar el final de una palabra: >"

#: usr_12.txt:44
msgid "\t:%s/\\<four\\>/4/g"
msgstr "\t:%s/\\<cuatro\\>/4/g"

#: usr_12.txt:46
msgid ""
"If you are programming, you might want to replace \"four\" in comments, but "
"not\n"
"in the code.  Since this is difficult to specify, add the \"c\" flag to have "
"the\n"
"substitute command prompt you for each replacement: >"
msgstr ""
"Si está programando, quizá desee reemplazar «cuatro» en los comentarios,\n"
"pero no en el código. Ya que es difícil de especificar, añada la marca «c»\n"
"para que se le pida una confirmación cada vez que se vaya a reemplazar\n"
"la palabra: >"

#: usr_12.txt:51
msgid "\t:%s/\\<four\\>/4/gc"
msgstr "\t:%s/\\<cuatro\\>/4/gc"

#: usr_12.txt:54
msgid "REPLACING IN SEVERAL FILES"
msgstr "REEMPLAZAR EN VARIOS ARCHIVOS"

#: usr_12.txt:56
msgid ""
"Suppose you want to replace a word in more than one file.  You could edit "
"each\n"
"file and type the command manually.  It's a lot faster to use record and\n"
"playback.\n"
"   Let's assume you have a directory with C++ files, all ending in \".cpp"
"\".\n"
"There is a function called \"GetResp\" that you want to rename to \"GetAnswer"
"\"."
msgstr ""
"Suponga que quiere reemplazar una palabra en más de un archivo. Puede\n"
"editar cada archivo y escribir la orden manualmente. Es mucho más fácil\n"
"usar la grabación y reproducción.\n"
"   Vamos a suponer que tiene un directorio con archivos C++ en el que todos\n"
"terminan en «.cpp». Quiere renombrar la función «GetResp» a «GetAnswer»."

#: usr_12.txt:62
msgid ""
"\tvim *.cpp\t\tStart Vim, defining the argument list to\n"
"\t\t\t\tcontain all the C++ files.  You are now in the\n"
"\t\t\t\tfirst file.\n"
"\tqq\t\t\tStart recording into the q register\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tDo the replacements in the first file.\n"
"\t:wnext\t\t\tWrite this file and move to the next one.\n"
"\tq\t\t\tStop recording.\n"
"\t@q\t\t\tExecute the q register.  This will replay the\n"
"\t\t\t\tsubstitution and \":wnext\".  You can verify\n"
"\t\t\t\tthat this doesn't produce an error message.\n"
"\t999@q\t\t\tExecute the q register on the remaining files."
msgstr ""
"\tvim *.cpp\t\tInicie Vim definiendo la lista de argumentos\n"
"\t\t\t\tconteniendo todos los archivos C++. Estará\n"
"\t\t\t\tahora en el primer archivo.\n"
"\tqq\t\t\tComience a grabar en el registro «q».\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tReemplace en el primer archivo.\n"
"\t:wnext\t\t\tGrabe este archivo y vaya al siguiente.\n"
"\tq\t\t\tDetiene la grabación.\n"
"\t@q\t\t\tEjecute el registro «q». Esto ejecutará la\n"
"\t\t\t\tsustitución y el comando «:wnext». Puede\n"
"\t\t\t\tcomprobar que esto no produzca ningún error.\n"
"\t999@q\t\t\tEjecute el registro «q» en el resto de archivos."

#: usr_12.txt:75
msgid ""
"At the last file you will get an error message, because \":wnext\" cannot "
"move\n"
"to the next file.  This stops the execution, and everything is done."
msgstr ""
"En el último archivo obtendrá un mensaje de error, porque «wnext» no puede "
"ir\n"
"a un archivo siguiente. Esto parará la ejecución y todo terminará."

#: usr_12.txt:78
msgid ""
"\tNote:\n"
"\tWhen playing back a recorded sequence, an error stops the execution.\n"
"\tTherefore, make sure you don't get an error message when recording."
msgstr ""
"\tNota:\n"
"\tCuando vuelva a reproducir una secuencia grabada, un error detendrá la\n"
"\tejecución. Cuide de no producir errores cuando grabes."

#: usr_12.txt:82
msgid ""
"There is one catch: If one of the .cpp files does not contain the word\n"
"\"GetResp\", you will get an error and replacing will stop.  To avoid this, "
"add\n"
"the \"e\" flag to the substitute command: >"
msgstr ""
"Hay un pequeño problema: Si uno de los archivos .cpp no contiene la palabra\n"
"«GetResp», obtendrá un error y la ejecución se detendrá. Para evitar esto,\n"
"añada la marca «e» a la orden de sustituir: >"

#: usr_12.txt:86
msgid "\t:%s/\\<GetResp\\>/GetAnswer/ge"
msgstr "\t:%s/\\<GetResp\\>/GetAnswer/ge"

#: usr_12.txt:88
msgid ""
"The \"e\" flag tells \":substitute\" that not finding a match is not an "
"error."
msgstr ""
"La marca «e» le dice a «:substitute» que ninguna coincidencia no es un error."

#: usr_12.txt:90
msgid ""
"==============================================================================\n"
"*12.2*\tChange \"Last, First\" to \"First Last\""
msgstr ""
"==============================================================================\n"
"*12.2*\tCambiar «Último, Primero» a «Primero Último»"

#: usr_12.txt:93
msgid "You have a list of names in this form:"
msgstr "Tiene una lista de nombre de la siguiente forma:"

#: usr_12.txt:95
msgid ""
"\tDoe, John ~\n"
"\tSmith, Peter ~"
msgstr ""
"\tPepe, Juan ~\n"
"\tAmancio, Pedro ~"

#: usr_12.txt:98
msgid "You want to change that to:"
msgstr "Quiere cambiarlo a:"

#: usr_12.txt:100
msgid ""
"\tJohn Doe ~\n"
"\tPeter Smith ~"
msgstr ""
"\tJuan Pepe ~\n"
"\tPedro Amancio ~"

#: usr_12.txt:103
msgid "This can be done with just one command: >"
msgstr "Esto se puede hacer con una  sola orden: >"

#: usr_12.txt:105
msgid "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/"
msgstr "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/"

#: usr_12.txt:107
msgid ""
"Let's break this down in parts.  Obviously it starts with a substitute\n"
"command.  The \"%\" is the line range, which stands for the whole file.  "
"Thus\n"
"the substitution is done in every line in the file.\n"
"   The arguments for the substitute command are \"/from/to/\".  The slashes\n"
"separate the \"from\" pattern and the \"to\" string.  This is what the \"from"
"\"\n"
"pattern contains:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~"
msgstr ""
"Veámoslo por partes. Obviamente comienza con la orden «substitute».\n"
"El «%» es el rango de líneas, que se refiere al archivo completo. Por lo\n"
"tanto la sustitución se producirá en cada línea del archivo.\n"
"   Los argumentos para la orden sustituir son «/desde/a/». Las barras\n"
"separan el patrón «desde» y la cadena \"hacia\". Esto es lo que el patrón\n"
"«desde» contiene:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~"

#: usr_12.txt:115
msgid ""
"\tThe first part between \\( \\) matches \"Last\"\t\\(     \\)\n"
"\t    match anything but a comma\t\t\t  [^,]\n"
"\t    any number of times\t\t\t\t      *\n"
"\tmatches \", \" literally\t\t\t\t\t ,\n"
"\tThe second part between \\( \\) matches \"First\"\t\t   \\(  \\)\n"
"\t    any character\t\t\t\t\t     .\n"
"\t    any number of times\t\t\t\t\t      *"
msgstr ""
"\tLa primera parte entre \\( \\) concuerda «Último» \\(     \\)\n"
"\t    concordar cualquier cosa excepto una coma     [^,]\n"
"\t    cualquier número de veces                         *\n"
"\tconcuerda literalmente \", \"                              ,\n"
"\tLa segunda parte entre \\(  \\) concuerda «Primero»\t\t   \\(  \\)\n"
"\t    cualquier carácter                                       .\n"
"\t    cualquier número de veces \t\t\t\t\t     *"

#: usr_12.txt:123
msgid ""
"In the \"to\" part we have \"\\2\" and \"\\1\".  These are called "
"backreferences.\n"
"They refer to the text matched by the \"\\( \\)\" parts in the pattern.  "
"\"\\2\"\n"
"refers to the text matched by the second \"\\( \\)\", which is the \"First\" "
"name.\n"
"\"\\1\" refers to the first \"\\( \\)\", which is the \"Last\" name.\n"
"   You can use up to nine backreferences in the \"to\" part of a substitute\n"
"command.  \"\\0\" stands for the whole matched pattern.  There are a few "
"more\n"
"special items in a substitute command, see |sub-replace-special|."
msgstr ""
"En la parte «a» tenemos «\\2» y «\\1». A esto se le llaman referencias\n"
"«inversas». Se refieren al texto encontrado por los «\\( \\)» del patrón. «\\2» "
"se\n"
"refiere al texto del segundo «\\( \\)», que es el nombre «Primero». «\\1» se\n"
"refiere al primer «\\( \\)», que es el nombre «Último».\n"
"   Puede usar hasta nueve referencias «inversas» en la parte «a» de una\n"
"orden de sustitución. «\\0x se refiere a la cadena coincidente completa. Hay\n"
"otros elementos especiales en una orden sustituir,\n"
"véase |sub-replace-special|."

#: usr_12.txt:131
msgid ""
"==============================================================================\n"
"*12.3*\tSort a list"
msgstr ""
"==============================================================================\n"
"*12.3*\tOrdenar una lista"

#: usr_12.txt:134
msgid "In a Makefile you often have a list of files.  For example:"
msgstr ""
"A menudo, en un archivo Makefile tiene una lista de archivos. Por ejemplo:"

#: usr_12.txt:136
msgid ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~"

#: usr_12.txt:146
msgid "To sort this list, filter the text through the external sort command: >"
msgstr ""
"Para ordenar esta lista, filtre el texto a través de la orden externa «sort»: "
">"

#: usr_12.txt:148
msgid ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort"
msgstr ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort"

#: usr_12.txt:152
msgid ""
"This goes to the first line, where \"OBJS\" is the first thing in the line.\n"
"Then it goes one line down and filters the lines until the next empty line.\n"
"You could also select the lines in Visual mode and then use \"!sort\".  "
"That's\n"
"easier to type, but more work when there are many lines.\n"
"   The result is this:"
msgstr ""
"Esto va a la primera línea, donde «OBJS» es lo primero que se encuentra en "
"una\n"
"línea. Luego baja una línea y filtra las líneas hasta encontrar una línea\n"
"vacía. También podría seleccionar las líneas en modo Visual y escribir\n"
"«!sort». Es más fácil pero conlleva más trabajo cuando hay muchas líneas.\n"
"   El resultado es el siguiente:"

#: usr_12.txt:158
msgid ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~"
msgstr ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~"

#: usr_12.txt:169
msgid ""
"Notice that a backslash at the end of each line is used to indicate the "
"line\n"
"continues.  After sorting, this is wrong!  The \"backup.o\" line that was "
"at\n"
"the end didn't have a backslash.  Now that it sorts to another place, it\n"
"must have a backslash.\n"
"   The simplest solution is to add the backslash with \"A \\<Esc>\".  You "
"can\n"
"keep the backslash in the last line, if you make sure an empty line comes\n"
"after it.  That way you don't have this problem again."
msgstr ""
"Observe que una barra invertida al final de cada línea se usa para indicar\n"
"que la línea continúa. Tras ordenar, está mal puesto. La línea de «backup.o»\n"
"que estaba al final no tenía una barra invertida. Ahora que se sitúa en "
"otro\n"
"lugar debe tener una barra invertida.\n"
"   La solución más sencilla es añadirla con «A \\<Esc>». Puede mantener la\n"
"barra en la última línea si se asegura de que una línea en blanco viene "
"justo\n"
"después. De este modo no tendrá este problema de nuevo."

#: usr_12.txt:177
msgid ""
"==============================================================================\n"
"*12.4*\tReverse line order"
msgstr ""
"==============================================================================\n"
"*12.4*\tInvertir el orden de las líneas"

#: usr_12.txt:180
msgid ""
"The |:global| command can be combined with the |:move| command to move all "
"the\n"
"lines before the first line, resulting in a reversed file.  The command is: >"
msgstr ""
"La orden «|:global|» se debe combinar con la orden «|:move|» para mover\n"
"todas las líneas antes de la primera línea, invirtiendo el archivo.\n"
"La orden es: >"

#: usr_12.txt:183
msgid "\t:global/^/m 0"
msgstr "\t:global/^/m 0"

#: usr_12.txt:185
msgid "Abbreviated: >"
msgstr "Abreviado: >"

#: usr_12.txt:187
msgid "\t:g/^/m 0"
msgstr "\t:g/^/m 0"

#: usr_12.txt:189
msgid ""
"The \"^\" regular expression matches the beginning of the line (even if the "
"line\n"
"is blank).  The |:move| command moves the matching line to after the "
"mythical\n"
"zeroth line, so the current matching line becomes the first line of the "
"file.\n"
"As the |:global| command is not confused by the changing line numbering,\n"
"|:global| proceeds to match all remaining lines of the file and puts each "
"as\n"
"the first."
msgstr ""
"La expresión regular «^» coincide con el comienzo de línea (incluso si la\n"
"línea está en blanco). La orden «|:move|» mueve la línea justo después de la\n"
"mítica «línea cero», de forma que se convierte en la primera línea. Como la\n"
"orden «|:global|» no se confunde al cambiar la numeración de las líneas,\n"
"«|:global|» procede a concordar el resto de líneas del archivo y pone cada "
"una\n"
"como la primera."

#: usr_12.txt:196
msgid ""
"This also works on a range of lines.  First move to above the first line "
"and\n"
"mark it with \"mt\".  Then move the cursor to the last line in the range "
"and\n"
"type: >"
msgstr ""
"Esto también funciona sobre un rango de líneas. Vaya primero a la línea de\n"
"encima de la primera y márcala con \"mt\".  Luego pon el cursor en la "
"última\n"
"línea del rango y escribe: >"

#: usr_12.txt:200
msgid "\t:'t+1,.g/^/m 't"
msgstr "\t:'t+1,.g/^/m 't"

#: usr_12.txt:202
msgid ""
"==============================================================================\n"
"*12.5*\tCount words"
msgstr ""
"==============================================================================\n"
"*12.5*\tContar palabras"

#: usr_12.txt:205
msgid ""
"Sometimes you have to write a text with a maximum number of words.  Vim can\n"
"count the words for you.\n"
"   When the whole file is what you want to count the words in, use this\n"
"command: >"
msgstr ""
"A veces puede escribir un texto con un número máximo de palabras. Vim\n"
"puede contar las palabras por Ud.\n"
"   Cuando quiera usar el archivo completo para contar las palabras, use la\n"
"siguiente orden: >"

#: usr_12.txt:210
msgid "\tg CTRL-G"
msgstr "\tg CTRL-G"

#: usr_12.txt:212
msgid ""
"Do not type a space after the g, this is just used here to make the command\n"
"easy to read.\n"
"   The output looks like this:"
msgstr ""
"No teclee un espacio tras la «g», esto está aquí para hacer que la orden sea\n"
"fácil de leer.\n"
"   La salida tendrá este aspecto:"

#: usr_12.txt:216
msgid "\tCol 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~"
msgstr ""
"\tCol 1 of 0; Línea 141 of 157; Palabra 748 of 774; Carácter 4489 of 4976 ~"

#: usr_12.txt:218
msgid ""
"You can see on which word you are (748), and the total number of words in "
"the\n"
"file (774)."
msgstr ""
"Puede ver en qué palabra está (748), y el número total de palabras en el\n"
"archivo (774)."

#: usr_12.txt:221
msgid ""
"When the text is only part of a file, you could move to the start of the "
"text,\n"
"type \"g CTRL-G\", move to the end of the text, type \"g CTRL-G\" again, and "
"then\n"
"use your brain to compute the difference in the word position.  That's a "
"good\n"
"exercise, but there is an easier way.  With Visual mode, select the text "
"you\n"
"want to count words in.  Then type g CTRL-G.  The result:"
msgstr ""
"Cuando el texto sea sólo una parte del archivo, puede ir al comienzo del\n"
"texto, pulsar «g CTRL-G», ir al final del texto y volver a escribir\n"
"«g CTRL-G» y usar la cabeza para calcular la diferencia. Es un buen "
"ejercicio,\n"
"pero hay un modo más sencillo. En el modo Visual, seleccione el texto sobre\n"
"el que quiera contar las palabras. Escriba «g CTRL-G». El resultado será:"

#: usr_12.txt:227
msgid "\tSelected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~"
msgstr "\tSelección 5 of 293 Líneas; 70 of 1884 Palabras; 359 of 10928 Bytes ~"

#: usr_12.txt:229
msgid ""
"For other ways to count words, lines and other items, see |count-items|."
msgstr ""
"Para otras formas de contar las palabras, líneas y otros, véase |count-"
"items|."

#: usr_12.txt:231
msgid ""
"==============================================================================\n"
"*12.6*\tFind a man page\t\t\t\t\t*find-manpage*"
msgstr ""
"==============================================================================\n"
"*12.6*\tEncontrar una página de manual\t\t*find-manpage*"

#: usr_12.txt:234
msgid ""
"While editing a shell script or C program, you are using a command or "
"function\n"
"that you want to find the man page for (this is on Unix).  Let's first use "
"a\n"
"simple way: Move the cursor to the word you want to find help on and press >"
msgstr ""
"Mientras edita un script de consola o un programa C, está usando una orden\n"
"o función para el que quiera encontrar una página de manual (en Unix). "
"Vamos\n"
"a usar la forma sencilla. Ponga el cursor sobre la palabra y pulse: >"

#: usr_12.txt:238
msgid "\tK"
msgstr "\tK"

#: usr_12.txt:240
msgid ""
"Vim will run the external \"man\" program on the word.  If the man page is\n"
"found, it is displayed.  This uses the normal pager to scroll through the "
"text\n"
"(mostly the \"more\" program).  When you get to the end pressing <Enter> "
"will\n"
"get you back into Vim."
msgstr ""
"Vim ejecutará el programa externo «man» sobre la palabra. Si se encuentra\n"
"la página de manual, se mostrará. Esto usa el paginador normal para\n"
"desplazarse por el texto (con el programa «more»). Cuando llegue al final,\n"
"presionando <Intro> le devolverá a Vim."

#: usr_12.txt:245
msgid ""
"A disadvantage is that you can't see the man page and the text you are "
"working\n"
"on at the same time.  There is a trick to make the man page appear in a Vim\n"
"window.  First, load the man filetype plugin: >"
msgstr ""
"Una desventaja es que no puede ver la página de manual y el texto en el que\n"
"trabaja al mismo tiempo. Hay un truco para hacer que la página de manual\n"
"aparezca en una ventana de Vim. Primero cargue la extensión del tipo de\n"
"archivo man: >"

#: usr_12.txt:249
msgid "\t:runtime! ftplugin/man.vim"
msgstr "\t:runtime! ftplugin/man.vim"

#: usr_12.txt:251
msgid ""
"Put this command in your vimrc file if you intend to do this often.  Now "
"you\n"
"can use the \":Man\" command to open a window on a man page: >"
msgstr ""
"Ponga esta orden en su archivo «vimrc» si tiene la intención de hacer esto a\n"
"menudo. Ahora puede usar «:Man» para ver una página man en una ventana: >"

#: usr_12.txt:254
msgid "\t:Man csh"
msgstr "\t:Man csh"

#: usr_12.txt:256
msgid ""
"You can scroll around and the text is highlighted.  This allows you to find\n"
"the help you were looking for.  Use CTRL-W w to jump to the window with the\n"
"text you were working on.\n"
"   To find a man page in a specific section, put the section number first.\n"
"For example, to look in section 3 for \"echo\": >"
msgstr ""
"Puede desplazarse alrededor y el texto se resaltará. Esto le permite\n"
"encontrar la ayuda que estaba buscando. Use «CTRL-W w» para saltar a la\n"
"ventana con el texto en el que trabajaba.\n"
"   Para encontrar la página de manua en una sección específica, ponga el\n"
"número de sección primero. Por ejemplo, para ver «echo» en la sección 3: >"

#: usr_12.txt:262
msgid "\t:Man 3 echo"
msgstr "\t:Man 3 echo"

#: usr_12.txt:264
msgid ""
"To jump to another man page, which is in the text with the typical form\n"
"\"word(1)\", press CTRL-] on it.  Further \":Man\" commands will use the "
"same\n"
"window."
msgstr ""
"Para saltar a otra página de manual, la cuál está en el texto con la forma "
"típica\n"
"«word(1)», pulse «CTRL-]» sobre ella. Otras llamadas a «:Man» emplearán la\n"
"misma ventana."

#: usr_12.txt:268
msgid "To display a man page for the word under the cursor, use this: >"
msgstr ""
"Para mostrar una página de manual para la palabra bajo el cursor use\n"
"lo siguiente: >"

#: usr_12.txt:270
msgid "\t\\K"
msgstr "\t\\K"

#: usr_12.txt:272
msgid ""
"(If you redefined the <Leader>, use it instead of the backslash).\n"
"For example, you want to know the return value of \"strstr()\" while "
"editing\n"
"this line:"
msgstr ""
"(Si ha redefinido <Leader>, úselo en lugar de la barra invertida). Por\n"
"ejemplo, puede que quiera saber el valor que le devuelve «strstr()» mientras\n"
"edita esta línea:"

#: usr_12.txt:276
msgid "\tif ( strstr (input, \"aap\") == ) ~"
msgstr "\tif ( strstr (input, \"aap\") == ) ~"

#: usr_12.txt:278
msgid ""
"Move the cursor to somewhere on \"strstr\" and type \"\\K\".  A window will "
"open\n"
"to display the man page for strstr()."
msgstr ""
"Ponga el cursor en alguna parte de «strstr» y escriba «\\K». Una ventana\n"
"se abrirá a continuación para mostrar la página de manual de «strstr()»."

#: usr_12.txt:281
msgid ""
"==============================================================================\n"
"*12.7*\tTrim blanks"
msgstr ""
"==============================================================================\n"
"*12.7*\tEliminar espacios en blanco sobrantes"

#: usr_12.txt:284
msgid ""
"Some people find spaces and tabs at the end of a line useless, wasteful, "
"and\n"
"ugly.  To remove whitespace at the end of every line, execute the following\n"
"command: >"
msgstr ""
"Algunas personas encuentran los espacios y los tabuladores al final de "
"línea\n"
"inútiles y feos. Para eliminar el espacio en blanco al final de cada línea,\n"
"ejecute la siguiente orden: >"

#: usr_12.txt:288
msgid "\t:%s/\\s\\+$//"
msgstr "\t:%s/\\s\\+$//"

#: usr_12.txt:290
msgid ""
"The line range \"%\" is used, thus this works on the whole file.  The "
"pattern\n"
"that the \":substitute\" command matches with is \"\\s\\+$\".  This finds "
"white\n"
"space characters (\\s), 1 or more of them (\\+), before the end-of-line "
"($).\n"
"Later will be explained how you write patterns like this |usr_27.txt|.\n"
"   The \"to\" part of the substitute command is empty: \"//\".  Thus it "
"replaces\n"
"with nothing, effectively deleting the matched white space."
msgstr ""
"El rango de línea «%» es empleado, funcionando sobre todo en el archivo\n"
"completo. El patrón que la orden «:substitute» concuerda es el «\\s\\+$».\n"
"Esto encuentra los caracteres en blanco (\\s), 1 o más (\\+), antes del "
"final\n"
"de línea ($).\n"
"Más tarde explicaremos cómo se escriben patrones como este |usr_27.txt|.\n"
"   La parte «hacia» de la orden de sustituxión está vacía: «//». Por lo tanto\n"
"reemplaza con nada, lo que de hecho elimina el espacio en blanco."

#: usr_12.txt:297
msgid ""
"Another wasteful use of spaces is placing them before a tab.  Often these "
"can\n"
"be deleted without changing the amount of white space.  But not always!\n"
"Therefore, you can best do this manually.  Use this search command: >"
msgstr ""
"Otro uso desafortunado de los espacios es colocarlos antes de un tabulador. "
"A\n"
"menudo, se pueden eliminar sin cambiar la cantidad de espacio en blanco.\n"
"¡Pero no siempre! Por lo tanto, lo mejor es que lo haga a mano. Use esta\n"
"orden de búsqueda: >"

#: usr_12.txt:301
msgid "\t/ \t"
msgstr "\t/\t"

#: usr_12.txt:303
msgid ""
"You cannot see it, but there is a space before a tab in this command.  Thus\n"
"it's \"/<Space><Tab>\".   Now use \"x\" to delete the space and check that "
"the\n"
"amount of white space doesn't change.  You might have to insert a tab if it\n"
"does change.  Type \"n\" to find the next match.  Repeat this until no more\n"
"matches can be found."
msgstr ""
"No puede verlo, pero hay un espacio antes de un tabulador en esta orden.\n"
"De hecho, es «/<Espacio><Tabulador>». Use ahora «x» para eliminar el\n"
"espacio y comprobar que la cantidad de espacio en blanco no cambia. Puede\n"
"que tenga que insertar un tabulador si cambia. Teclee «n» para encontrar la\n"
"próxima coincidencia. Repita esto hasta que no se encuentren más\n"
"concordancias."

#: usr_12.txt:309
msgid ""
"==============================================================================\n"
"*12.8*\tFind where a word is used"
msgstr ""
"==============================================================================\n"
"*12.8*\tBuscar donde se emplea una palabra"

#: usr_12.txt:312
msgid ""
"If you are a UNIX user, you can use a combination of Vim and the grep "
"command\n"
"to edit all the files that contain a given word.  This is extremely useful "
"if\n"
"you are working on a program and want to view or edit all the files that\n"
"contain a specific variable.\n"
"   For example, suppose you want to edit all the C program files that "
"contain\n"
"the word \"frame_counter\".  To do this you use the command: >"
msgstr ""
"Si eres un usuario de sistemas UNIX, puede usar una combinación de Vim\n"
"y «grep» para editar todos los archivos que contengan la palabra dada.\n"
"Esto es extremadamente útil si está trabajando en un programa y quiere\n"
"ver o editar todos los archivos que contienen una variable específica.\n"
"   Por ejemplo, suponga que desea editar todos los archivos C que contengan\n"
"la palabra «frame_counter». Para hacer esto, use la orden: >"

#: usr_12.txt:319
msgid "\tvim `grep -l frame_counter *.c`"
msgstr "\tvim `grep -l frame_counter *.c`"

#: usr_12.txt:321
msgid ""
"Let's look at this command in detail.  The grep command searches through a "
"set\n"
"of files for a given word.  Because the -l argument is specified, the "
"command\n"
"will only list the files containing the word and not print the matching "
"lines.\n"
"The word it is searching for is \"frame_counter\".  Actually, this can be "
"any\n"
"regular expression.  (Note: What grep uses for regular expressions is not\n"
"exactly the same as what Vim uses.)\n"
"   The entire command is enclosed in backticks (`).  This tells the UNIX "
"shell\n"
"to run this command and pretend that the results were typed on the command\n"
"line.  So what happens is that the grep command is run and produces a list "
"of\n"
"files, these files are put on the Vim command line.  This results in Vim\n"
"editing the file list that is the output of grep.  You can then use "
"commands\n"
"like \":next\" and \":first\" to browse through the files."
msgstr ""
"Veamos esta orden en detalle. La orden «grep» busca a través de un\n"
"conjunto de archivos una palabra dada. Ya que especificamos el argumento\n"
"«-l», la orden sólo listará archivos que contengan la palabra y no impriman\n"
"las líneas coincidentes. La palabra que está buscando es «frame_counter».\n"
"De hecho, esto puede ser cualquier expresión regular. (Nota: las "
"expresiones\n"
"regulares en Vim y «grep» no siguen las mismas convenciones.)\n"
"   La orden está arropada por acentos invertidos (`). Esto le dice a la "
"consola\n"
"de UNIX que ejecute la orden y haga como si el resultado se hubiese\n"
"escrito en la línea de órdenes. Por lo tanto la orden «grep» se ejecutará\n"
"y producirá una lista de archivos, estos archivos serán puestos en la línea\n"
"de órdenes de Vim. Podrá usar las órdenes «:next» y «:first» para navegar\n"
"entre los archivos."

#: usr_12.txt:335
msgid "FINDING EACH LINE"
msgstr "ENCONTRAR CADA LÍNEA"

#: usr_12.txt:337
msgid ""
"The above command only finds the files in which the word is found.  You "
"still\n"
"have to find the word within the files.\n"
"   Vim has a built-in command that you can use to search a set of files for "
"a\n"
"given string.  If you want to find all occurrences of \"error_string\" in "
"all C\n"
"program files, for example, enter the following command: >"
msgstr ""
"La orden anterior sólo dice los archivos en los cuáles se encuentra la\n"
"palabra. Todavía tendrás que encontrar la palabra entre los archivos.\n"
"   Vim tiene una orden integrada que puede usar para buscar una cadena\n"
"en un conjunto de archivos. Si desea encontrar todas las coincidencias de\n"
"«error_string» en todos los archivos C, por ejemplo, introduzca lo siguiente: "
">"

#: usr_12.txt:343
msgid "\t:grep error_string *.c"
msgstr "\t:grep error_string *.c"

#: usr_12.txt:345
msgid ""
"This causes Vim to search for the string \"error_string\" in all the "
"specified\n"
"files (*.c).  The editor will now open the first file where a match is "
"found\n"
"and position the cursor on the first matching line.  To go to the next\n"
"matching line (no matter in what file it is), use the \":cnext\" command.  "
"To go\n"
"to the previous match, use the \":cprev\" command.  Use \":clist\" to see "
"all the\n"
"matches and where they are.\n"
"   The \":grep\" command uses the external commands grep (on Unix) or "
"findstr\n"
"(on Windows).  You can change this by setting the option 'grepprg'."
msgstr ""
"Esto hace que Vim busque la cadena «error_string» en cada uno de los\n"
"archivos especificados (*.c). El editor abrirá el primer archivo donde se\n"
"produzca una concordancia y posicionará el cursor en la primera línea\n"
"coincidente.\n"
"Para ir a la siguiente línea (no importa en que archivo se encuentre), use "
"la\n"
"orden «:cnext». Para ir a la anterior, use «:cprev». Use «:clist» para ver\n"
"todas las coincidencias y dónde están.\n"
"  La orden «:grep\"» usa la orden externa «grep» en Unix y «findstr» en\n"
"Windows.\n"
"Puedes cambiar esto modificando la opción 'grepprg'."

#: usr_12.txt:354
msgid "=============================================================================="
msgstr "=============================================================================="

#: usr_12.txt:356
msgid "Next chapter: |usr_20.txt|  Typing command-line commands quickly"
msgstr "Capítulo siguiente: |usr_20.esx|  Ser eficaz con la línea de órdenes"

#: usr_12.txt:358
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr "Copyright: véase |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
