#. extracted from usr_40.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-04 13:42+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_40.txt:1
msgid "*usr_40.txt*\tFor Vim version 7.2.  Last change: 2006 Jun 21"
msgstr ""

#: usr_40.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_40.txt:5
msgid "\t\t\t      Make new commands"
msgstr ""

#: usr_40.txt:8
msgid ""
"Vim is an extensible editor.  You can take a sequence of commands you use\n"
"often and turn it into a new command.  Or redefine an existing command.\n"
"Autocommands make it possible to execute commands automatically."
msgstr ""

#: usr_40.txt:12
msgid ""
"|40.1|\tKey mapping\n"
"|40.2|\tDefining command-line commands\n"
"|40.3|\tAutocommands"
msgstr ""

#: usr_40.txt:16
msgid ""
"     Next chapter: |usr_41.txt|  Write a Vim script\n"
" Previous chapter: |usr_32.txt|  The undo tree\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_40.txt:20
msgid ""
"============================================================================"
"==\n"
"*40.1*\tKey mapping"
msgstr ""

#: usr_40.txt:23
msgid ""
"A simple mapping was explained in section |05.3|.  The principle is that one\n"
"sequence of key strokes is translated into another sequence of key strokes.\n"
"This is a simple, yet powerful mechanism.\n"
"   The simplest form is that one key is mapped to a sequence of keys.  Since\n"
"the function keys, except <F1>, have no predefined meaning in Vim, these are "
"a\n"
"good choice to map.  Example: >"
msgstr ""

#: usr_40.txt:30
msgid "\t:map <F2> GoDate: <Esc>:read !date<CR>kJ"
msgstr ""

#: usr_40.txt:32
msgid ""
"This shows how three modes are used.  After going to the last line with \"G\",\n"
"the \"o\" command opens a new line and starts Insert mode.  The text \"Date: \" "
"is\n"
"inserted and <Esc> takes you out of insert mode.\n"
"   Notice the use of special keys inside <>.  This is called angle bracket\n"
"notation.  You type these as separate characters, not by pressing the key\n"
"itself.  This makes the mappings better readable and you can copy and paste\n"
"the text without problems.\n"
"   The \":\" character takes Vim to the command line.  The \":read !date\" "
"command\n"
"reads the output from the \"date\" command and appends it below the current\n"
"line.  The <CR> is required to execute the \":read\" command.\n"
"   At this point of execution the text looks like this:"
msgstr ""

#: usr_40.txt:44
msgid ""
"\tDate:  ~\n"
"\tFri Jun 15 12:54:34 CEST 2001 ~"
msgstr ""

#: usr_40.txt:47
msgid ""
"Now \"kJ\" moves the cursor up and joins the lines together.\n"
"   To decide which key or keys you use for mapping, see |map-which-keys|."
msgstr ""

#: usr_40.txt:51
msgid "MAPPING AND MODES"
msgstr ""

#: usr_40.txt:53
msgid ""
"The \":map\" command defines remapping for keys in Normal mode.  You can also\n"
"define mappings for other modes.  For example, \":imap\" applies to Insert "
"mode.\n"
"You can use it to insert a date below the cursor: >"
msgstr ""

#: usr_40.txt:57
msgid "\t:imap <F2> <CR>Date: <Esc>:read !date<CR>kJ"
msgstr ""

#: usr_40.txt:59
msgid ""
"It looks a lot like the mapping for <F2> in Normal mode, only the start is\n"
"different.  The <F2> mapping for Normal mode is still there.  Thus you can "
"map\n"
"the same key differently for each mode.\n"
"   Notice that, although this mapping starts in Insert mode, it ends in "
"Normal\n"
"mode.  If you want it to continue in Insert mode, append an \"a\" to the\n"
"mapping."
msgstr ""

#: usr_40.txt:66
msgid "Here is an overview of map commands and in which mode they work:"
msgstr ""

#: usr_40.txt:68
msgid ""
"\t:map\t\tNormal, Visual and Operator-pending\n"
"\t:vmap\t\tVisual\n"
"\t:nmap\t\tNormal\n"
"\t:omap\t\tOperator-pending\n"
"\t:map!\t\tInsert and Command-line\n"
"\t:imap\t\tInsert\n"
"\t:cmap\t\tCommand-line"
msgstr ""

#: usr_40.txt:76
msgid ""
"Operator-pending mode is when you typed an operator character, such as \"d\" "
"or\n"
"\"y\", and you are expected to type the motion command or a text object.  Thus\n"
"when you type \"dw\", the \"w\" is entered in operator-pending mode."
msgstr ""

#: usr_40.txt:80
msgid ""
"Suppose that you want to define <F7> so that the command d<F7> deletes a C\n"
"program block (text enclosed in curly braces, {}).  Similarly y<F7> would "
"yank\n"
"the program block into the unnamed register.  Therefore, what you need to do\n"
"is to define <F7> to select the current program block.  You can do this with\n"
"the following command: >"
msgstr ""

#: usr_40.txt:86
msgid "\t:omap <F7> a{"
msgstr ""

#: usr_40.txt:88
msgid ""
"This causes <F7> to perform a select block \"a{\" in operator-pending mode, "
"just\n"
"like you typed it.  This mapping is useful if typing a { on your keyboard is "
"a\n"
"bit difficult."
msgstr ""

#: usr_40.txt:93
msgid "LISTING MAPPINGS"
msgstr ""

#: usr_40.txt:95
msgid ""
"To see the currently defined mappings, use \":map\" without arguments.  Or one\n"
"of the variants that include the mode in which they work.  The output could\n"
"look like this:"
msgstr ""

#: usr_40.txt:99
msgid ""
"\t   _g\t\t :call MyGrep(1)<CR> ~\n"
"\tv  <F2>\t\t :s/^/> /<CR>:noh<CR>`` ~\n"
"\tn  <F2>\t\t :.,$s/^/> /<CR>:noh<CR>`` ~\n"
"\t   <xHome>\t <Home>\n"
"\t   <xEnd>\t <End>"
msgstr ""

#: usr_40.txt:106
msgid ""
"The first column of the list shows in which mode the mapping is effective.\n"
"This is \"n\" for Normal mode, \"i\" for Insert mode, etc.  A blank is used for "
"a\n"
"mapping defined with \":map\", thus effective in both Normal and Visual mode.\n"
"   One useful purpose of listing the mapping is to check if special keys in "
"<>\n"
"form have been recognized (this only works when color is supported).  For\n"
"example, when <Esc> is displayed in color, it stands for the escape "
"character.\n"
"When it has the same color as the other text, it is five characters."
msgstr ""

#: usr_40.txt:115
msgid "REMAPPING"
msgstr ""

#: usr_40.txt:117
msgid ""
"The result of a mapping is inspected for other mappings in it.  For example,\n"
"the mappings for <F2> above could be shortened to: >"
msgstr ""

#: usr_40.txt:120
msgid ""
"\t:map <F2> G<F3>\n"
"\t:imap <F2> <Esc><F3>\n"
"\t:map <F3>  oDate: <Esc>:read !date<CR>kJ"
msgstr ""

#: usr_40.txt:124
msgid ""
"For Normal mode <F2> is mapped to go to the last line, and then behave like\n"
"<F3> was pressed.  In Insert mode <F2> stops Insert mode with <Esc> and then\n"
"also uses <F3>.  Then <F3> is mapped to do the actual work."
msgstr ""

#: usr_40.txt:128
msgid ""
"Suppose you hardly ever use Ex mode, and want to use the \"Q\" command to "
"format\n"
"text (this was so in old versions of Vim).  This mapping will do it: >"
msgstr ""

#: usr_40.txt:131
msgid "\t:map Q gq"
msgstr ""

#: usr_40.txt:133
msgid ""
"But, in rare cases you need to use Ex mode anyway.  Let's map \"gQ\" to Q, so\n"
"that you can still go to Ex mode: >"
msgstr ""

#: usr_40.txt:136
msgid "\t:map gQ Q"
msgstr ""

#: usr_40.txt:138
msgid ""
"What happens now is that when you type \"gQ\" it is mapped to \"Q\".  So far so\n"
"good.  But then \"Q\" is mapped to \"gq\", thus typing \"gQ\" results in \"gq\", and\n"
"you don't get to Ex mode at all.\n"
"   To avoid keys to be mapped again, use the \":noremap\" command: >"
msgstr ""

#: usr_40.txt:143
msgid "\t:noremap gQ Q"
msgstr ""

#: usr_40.txt:145
msgid ""
"Now Vim knows that the \"Q\" is not to be inspected for mappings that apply to\n"
"it.  There is a similar command for every mode:"
msgstr ""

#: usr_40.txt:148
msgid ""
"\t:noremap\tNormal, Visual and Operator-pending\n"
"\t:vnoremap\tVisual\n"
"\t:nnoremap\tNormal\n"
"\t:onoremap\tOperator-pending\n"
"\t:noremap!\tInsert and Command-line\n"
"\t:inoremap\tInsert\n"
"\t:cnoremap\tCommand-line"
msgstr ""

#: usr_40.txt:157
msgid "RECURSIVE MAPPING"
msgstr ""

#: usr_40.txt:159
msgid ""
"When a mapping triggers itself, it will run forever.  This can be used to\n"
"repeat an action an unlimited number of times.\n"
"   For example, you have a list of files that contain a version number in "
"the\n"
"first line.  You edit these files with \"vim *.txt\".  You are now editing the\n"
"first file.  Define this mapping: >"
msgstr ""

#: usr_40.txt:165
msgid "\t:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,"
msgstr ""

#: usr_40.txt:167
msgid ""
"Now you type \",,\".  This triggers the mapping.  It replaces \"5.1\" with \"5.2\"\n"
"in the first line.  Then it does a \":wnext\" to write the file and edit the\n"
"next one.  The mapping ends in \",,\".  This triggers the same mapping again,\n"
"thus doing the substitution, etc.\n"
"   This continues until there is an error.  In this case it could be a file\n"
"where the substitute command doesn't find a match for \"5.1\".  You can then\n"
"make a change to insert \"5.1\" and continue by typing \",,\" again.  Or the\n"
"\":wnext\" fails, because you are in the last file in the list.\n"
"   When a mapping runs into an error halfway, the rest of the mapping is\n"
"discarded.  CTRL-C interrupts the mapping (CTRL-Break on MS-Windows)."
msgstr ""

#: usr_40.txt:179
msgid "DELETE A MAPPING"
msgstr ""

#: usr_40.txt:181
msgid ""
"To remove a mapping use the \":unmap\" command.  Again, the mode the unmapping\n"
"applies to depends on the command used:"
msgstr ""

#: usr_40.txt:184
msgid ""
"\t:unmap\t\tNormal, Visual and Operator-pending\n"
"\t:vunmap\t\tVisual\n"
"\t:nunmap\t\tNormal\n"
"\t:ounmap\t\tOperator-pending\n"
"\t:unmap!\t\tInsert and Command-line\n"
"\t:iunmap\t\tInsert\n"
"\t:cunmap\t\tCommand-line"
msgstr ""

#: usr_40.txt:192
msgid ""
"There is a trick to define a mapping that works in Normal and Operator-"
"pending\n"
"mode, but not in Visual mode.  First define it for all three modes, then\n"
"delete it for Visual mode: >"
msgstr ""

#: usr_40.txt:196
msgid ""
"\t:map <C-A> /---><CR>\n"
"\t:vunmap <C-A>"
msgstr ""

#: usr_40.txt:199
msgid ""
"Notice that the five characters \"<C-A>\" stand for the single key CTRL-A."
msgstr ""

#: usr_40.txt:201
msgid ""
"To remove all mappings use the |:mapclear| command.  You can guess the\n"
"variations for different modes by now.  Be careful with this command, it "
"can't\n"
"be undone."
msgstr ""

#: usr_40.txt:206
msgid "SPECIAL CHARACTERS"
msgstr ""

#: usr_40.txt:208
msgid ""
"The \":map\" command can be followed by another command.  A | character\n"
"separates the two commands.  This also means that a | character can't be "
"used\n"
"inside a map command.  To include one, use <Bar> (five characters).  "
"Example:\n"
">\n"
"\t:map <F8> :write <Bar> !checkin %<CR>"
msgstr ""

#: usr_40.txt:214
msgid ""
"The same problem applies to the \":unmap\" command, with the addition that you\n"
"have to watch out for trailing white space.  These two commands are "
"different:\n"
">\n"
"\t:unmap a | unmap b\n"
"\t:unmap a| unmap b"
msgstr ""

#: usr_40.txt:220
msgid "The first command tries to unmap \"a \", with a trailing space."
msgstr ""

#: usr_40.txt:222
msgid "When using a space inside a mapping, use <Space> (seven characters): >"
msgstr ""

#: usr_40.txt:224
msgid "\t:map <Space> W"
msgstr ""

#: usr_40.txt:226
msgid "This makes the spacebar move a blank-separated word forward."
msgstr ""

#: usr_40.txt:228
msgid ""
"It is not possible to put a comment directly after a mapping, because the \"\n"
"character is considered to be part of the mapping.  You can use |\", this\n"
"starts a new, empty command with a comment.  Example: >"
msgstr ""

#: usr_40.txt:232
msgid "\t:map <Space> W|     \" Use spacebar to move forward a word"
msgstr ""

#: usr_40.txt:235
msgid "MAPPINGS AND ABBREVIATIONS"
msgstr ""

#: usr_40.txt:237
msgid ""
"Abbreviations are a lot like Insert mode mappings.  The arguments are "
"handled\n"
"in the same way.  The main difference is the way they are triggered.  An\n"
"abbreviation is triggered by typing a non-word character after the word.  A\n"
"mapping is triggered when typing the last character.\n"
"   Another difference is that the characters you type for an abbreviation "
"are\n"
"inserted in the text while you type them.  When the abbreviation is "
"triggered\n"
"these characters are deleted and replaced by what the abbreviation produces.\n"
"When typing the characters for a mapping, nothing is inserted until you type\n"
"the last character that triggers it.  If the 'showcmd' option is set, the\n"
"typed characters are displayed in the last line of the Vim window.\n"
"   An exception is when a mapping is ambiguous.  Suppose you have done two\n"
"mappings: >"
msgstr ""

#: usr_40.txt:250
msgid ""
"\t:imap aa foo\n"
"\t:imap aaa bar"
msgstr ""

#: usr_40.txt:253
msgid ""
"Now, when you type \"aa\", Vim doesn't know if it should apply the first or "
"the\n"
"second mapping.  It waits for another character to be typed.  If it is an "
"\"a\",\n"
"the second mapping is applied and results in \"bar\".  If it is a space, for\n"
"example, the first mapping is applied, resulting in \"foo\", and then the "
"space\n"
"is inserted."
msgstr ""

#: usr_40.txt:260
msgid "ADDITIONALLY..."
msgstr ""

#: usr_40.txt:262
msgid ""
"The <script> keyword can be used to make a mapping local to a script.  See\n"
"|:map-<script>|."
msgstr ""

#: usr_40.txt:265
msgid ""
"The <buffer> keyword can be used to make a mapping local to a specific "
"buffer.\n"
"See |:map-<buffer>|"
msgstr ""

#: usr_40.txt:268
msgid ""
"The <unique> keyword can be used to make defining a new mapping fail when it\n"
"already exists.  Otherwise a new mapping simply overwrites the old one.  See\n"
"|:map-<unique>|."
msgstr ""

#: usr_40.txt:272
msgid ""
"To make a key do nothing, map it to <Nop> (five characters).  This will make\n"
"the <F7> key do nothing at all: >"
msgstr ""

#: usr_40.txt:275
msgid "\t:map <F7> <Nop>| map! <F7> <Nop>"
msgstr ""

#: usr_40.txt:277
msgid "There must be no space after <Nop>."
msgstr ""

#: usr_40.txt:279
msgid ""
"============================================================================"
"==\n"
"*40.2*\tDefining command-line commands"
msgstr ""

#: usr_40.txt:282
msgid ""
"The Vim editor enables you to define your own commands.  You execute these\n"
"commands just like any other Command-line mode command.\n"
"   To define a command, use the \":command\" command, as follows: >"
msgstr ""

#: usr_40.txt:286
msgid "\t:command DeleteFirst 1delete"
msgstr ""

#: usr_40.txt:288
msgid ""
"Now when you execute the command \":DeleteFirst\" Vim executes \":1delete\", "
"which\n"
"deletes the first line."
msgstr ""

#: usr_40.txt:291
msgid ""
"\tNote:\n"
"\tUser-defined commands must start with a capital letter.  You cannot\n"
"\tuse \":X\", \":Next\" and \":Print\".  The underscore cannot be used!  You\n"
"\tcan use digits, but this is discouraged."
msgstr ""

#: usr_40.txt:296
msgid "To list the user-defined commands, execute the following command: >"
msgstr ""

#: usr_40.txt:298
msgid "\t:command"
msgstr ""

#: usr_40.txt:300
msgid ""
"Just like with the builtin commands, the user defined commands can be\n"
"abbreviated.  You need to type just enough to distinguish the command from\n"
"another.  Command line completion can be used to get the full name."
msgstr ""

#: usr_40.txt:305
msgid "NUMBER OF ARGUMENTS"
msgstr ""

#: usr_40.txt:307
msgid ""
"User-defined commands can take a series of arguments.  The number of "
"arguments\n"
"must be specified by the -nargs option.  For instance, the example\n"
":DeleteFirst command takes no arguments, so you could have defined it as\n"
"follows: >"
msgstr ""

#: usr_40.txt:312
msgid "\t:command -nargs=0 DeleteFirst 1delete"
msgstr ""

#: usr_40.txt:314
msgid ""
"However, because zero arguments is the default, you do not need to add\n"
"\"-nargs=0\".  The other values of -nargs are as follows:"
msgstr ""

#: usr_40.txt:317
msgid ""
"\t-nargs=0\tNo arguments\n"
"\t-nargs=1\tOne argument\n"
"\t-nargs=*\tAny number of arguments\n"
"\t-nargs=?\tZero or one argument\n"
"\t-nargs=+\tOne or more arguments"
msgstr ""

#: usr_40.txt:324
msgid "USING THE ARGUMENTS"
msgstr ""

#: usr_40.txt:326
msgid ""
"Inside the command definition, the arguments are represented by the\n"
"<args> keyword.  For example: >"
msgstr ""

#: usr_40.txt:329
msgid "\t:command -nargs=+ Say :echo \"<args>\""
msgstr ""

#: usr_40.txt:331
msgid "Now when you type >"
msgstr ""

#: usr_40.txt:333
msgid "\t:Say Hello World"
msgstr ""

#: usr_40.txt:335
msgid ""
"Vim echoes \"Hello World\".  However, if you add a double quote, it won't "
"work.\n"
"For example: >"
msgstr ""

#: usr_40.txt:338
msgid "\t:Say he said \"hello\""
msgstr ""

#: usr_40.txt:340
msgid ""
"To get special characters turned into a string, properly escaped to use as "
"an\n"
"expression, use \"<q-args>\": >"
msgstr ""

#: usr_40.txt:343
msgid "\t:command -nargs=+ Say :echo <q-args>"
msgstr ""

#: usr_40.txt:345
msgid "Now the above \":Say\" command will result in this to be executed: >"
msgstr ""

#: usr_40.txt:347
msgid "\t:echo \"he said \\\"hello\\\"\""
msgstr ""

#: usr_40.txt:349
msgid ""
"The <f-args> keyword contains the same information as the <args> keyword,\n"
"except in a format suitable for use as function call arguments.  For "
"example:\n"
">\n"
"\t:command -nargs=* DoIt :call AFunction(<f-args>)\n"
"\t:DoIt a b c"
msgstr ""

#: usr_40.txt:355
msgid "Executes the following command: >"
msgstr ""

#: usr_40.txt:357
msgid "\t:call AFunction(\"a\", \"b\", \"c\")"
msgstr ""

#: usr_40.txt:360
msgid "LINE RANGE"
msgstr ""

#: usr_40.txt:362
msgid ""
"Some commands take a range as their argument.  To tell Vim that you are\n"
"defining such a command, you need to specify a -range option.  The values "
"for\n"
"this option are as follows:"
msgstr ""

#: usr_40.txt:366
msgid ""
"\t-range\t\tRange is allowed; default is the current line.\n"
"\t-range=%\tRange is allowed; default is the whole file.\n"
"\t-range={count}\tRange is allowed; the last number in it is used as a\n"
"\t\t\tsingle number whose default is {count}."
msgstr ""

#: usr_40.txt:371
msgid ""
"When a range is specified, the keywords <line1> and <line2> get the values "
"of\n"
"the first and last line in the range.  For example, the following command\n"
"defines the SaveIt command, which writes out the specified range to the file\n"
"\"save_file\": >"
msgstr ""

#: usr_40.txt:376
msgid "\t:command -range=% SaveIt :<line1>,<line2>write! save_file"
msgstr ""

#: usr_40.txt:379
msgid "OTHER OPTIONS"
msgstr ""

#: usr_40.txt:381
msgid "Some of the other options and keywords are as follows:"
msgstr ""

#: usr_40.txt:383
msgid ""
"\t-count={number}\t\tThe command can take a count whose default is\n"
"\t\t\t\t{number}.  The resulting count can be used\n"
"\t\t\t\tthrough the <count> keyword.\n"
"\t-bang\t\t\tYou can use a !.  If present, using <bang> will\n"
"\t\t\t\tresult in a !.\n"
"\t-register\t\tYou can specify a register.  (The default is\n"
"\t\t\t\tthe unnamed register.)\n"
"\t\t\t\tThe register specification is available as\n"
"\t\t\t\t<reg> (a.k.a. <register>).\n"
"\t-complete={type}\tType of command-line completion used.  See\n"
"\t\t\t\t|:command-completion| for the list of possible\n"
"\t\t\t\tvalues.\n"
"\t-bar\t\t\tThe command can be followed by | and another\n"
"\t\t\t\tcommand, or \" and a comment.\n"
"\t-buffer\t\t\tThe command is only available for the current\n"
"\t\t\t\tbuffer."
msgstr ""

#: usr_40.txt:400
msgid ""
"Finally, you have the <lt> keyword.  It stands for the character <.  Use "
"this\n"
"to escape the special meaning of the <> items mentioned."
msgstr ""

#: usr_40.txt:404
msgid "REDEFINING AND DELETING"
msgstr ""

#: usr_40.txt:406
msgid "To redefine the same command use the ! argument: >"
msgstr ""

#: usr_40.txt:408
msgid ""
"\t:command -nargs=+ Say :echo \"<args>\"\n"
"\t:command! -nargs=+ Say :echo <q-args>"
msgstr ""

#: usr_40.txt:411
msgid ""
"To delete a user command use \":delcommand\".  It takes a single argument, "
"which\n"
"is the name of the command.  Example: >"
msgstr ""

#: usr_40.txt:414
msgid "\t:delcommand SaveIt"
msgstr ""

#: usr_40.txt:416
msgid "To delete all the user commands: >"
msgstr ""

#: usr_40.txt:418
msgid "\t:comclear"
msgstr ""

#: usr_40.txt:420
msgid "Careful, this can't be undone!"
msgstr ""

#: usr_40.txt:422
msgid "More details about all this in the reference manual: |user-commands|."
msgstr ""

#: usr_40.txt:424
msgid ""
"============================================================================"
"==\n"
"*40.3*\tAutocommands"
msgstr ""

#: usr_40.txt:427
msgid ""
"An autocommand is a command that is executed automatically in response to "
"some\n"
"event, such as a file being read or written or a buffer change.  Through the\n"
"use of autocommands you can train Vim to edit compressed files, for example.\n"
"That is used in the |gzip| plugin.\n"
"   Autocommands are very powerful.  Use them with care and they will help "
"you\n"
"avoid typing many commands.  Use them carelessly and they will cause a lot "
"of\n"
"trouble."
msgstr ""

#: usr_40.txt:435
msgid ""
"Suppose you want to replace a datestamp on the end of a file every time it "
"is\n"
"written.  First you define a function: >"
msgstr ""

#: usr_40.txt:438
msgid ""
"\t:function DateInsert()\n"
"\t:  $delete\n"
"\t:  read !date\n"
"\t:endfunction"
msgstr ""

#: usr_40.txt:443
msgid ""
"You want this function to be called each time, just before a file is "
"written.\n"
"This will make that happen: >"
msgstr ""

#: usr_40.txt:446
msgid "\t:autocmd FileWritePre *  call DateInsert()"
msgstr ""

#: usr_40.txt:448
msgid ""
"\"FileWritePre\" is the event for which this autocommand is triggered: Just\n"
"before (pre) writing a file.  The \"*\" is a pattern to match with the file\n"
"name.  In this case it matches all files.\n"
"   With this command enabled, when you do a \":write\", Vim checks for any\n"
"matching FileWritePre autocommands and executes them, and then it\n"
"performs the \":write\".\n"
"   The general form of the :autocmd command is as follows: >"
msgstr ""

#: usr_40.txt:456
msgid "\t:autocmd [group] {events} {file_pattern} [nested] {command}"
msgstr ""

#: usr_40.txt:458
msgid ""
"The [group] name is optional.  It is used in managing and calling the "
"commands\n"
"(more on this later).  The {events} parameter is a list of events (comma\n"
"separated) that trigger the command.\n"
"   {file_pattern} is a filename, usually with wildcards.  For example, using\n"
"\"*.txt\" makes the autocommand be used for all files whose name end in "
"\".txt\".\n"
"The optional [nested] flag allows for nesting of autocommands (see below), "
"and\n"
"finally, {command} is the command to be executed."
msgstr ""

#: usr_40.txt:467
msgid "EVENTS"
msgstr ""

#: usr_40.txt:469
msgid ""
"One of the most useful events is BufReadPost.  It is triggered after a new\n"
"file is being edited.  It is commonly used to set option values.  For "
"example,\n"
"you know that \"*.gsm\" files are GNU assembly language.  To get the syntax "
"file\n"
"right, define this autocommand: >"
msgstr ""

#: usr_40.txt:474
msgid "\t:autocmd BufReadPost *.gsm  set filetype=asm"
msgstr ""

#: usr_40.txt:476
msgid ""
"If Vim is able to detect the type of file, it will set the 'filetype' option\n"
"for you.  This triggers the Filetype event.  Use this to do something when a\n"
"certain type of file is edited.  For example, to load a list of "
"abbreviations\n"
"for text files: >"
msgstr ""

#: usr_40.txt:481
msgid "\t:autocmd Filetype text  source ~/.vim/abbrevs.vim"
msgstr ""

#: usr_40.txt:483
msgid ""
"When starting to edit a new file, you could make Vim insert a skeleton: >"
msgstr ""

#: usr_40.txt:485
msgid "\t:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c"
msgstr ""

#: usr_40.txt:487
msgid "See |autocmd-events| for a complete list of events."
msgstr ""

#: usr_40.txt:490
msgid "PATTERNS"
msgstr ""

#: usr_40.txt:492
msgid ""
"The {file_pattern} argument can actually be a comma-separated list of file\n"
"patterns.  For example: \"*.c,*.h\" matches files ending in \".c\" and \".h\".\n"
"   The usual file wildcards can be used.  Here is a summary of the most "
"often\n"
"used ones:"
msgstr ""

#: usr_40.txt:497
msgid ""
"\t*\t\tMatch any character any number of times\n"
"\t?\t\tMatch any character once\n"
"\t[abc]\t\tMatch the character a, b or c\n"
"\t.\t\tMatches a dot\n"
"\ta{b,c}\t\tMatches \"ab\" and \"ac\""
msgstr ""

#: usr_40.txt:503
msgid ""
"When the pattern includes a slash (/) Vim will compare directory names.\n"
"Without the slash only the last part of a file name is used.  For example,\n"
"\"*.txt\" matches \"/home/biep/readme.txt\".  The pattern \"/home/biep/*\" would\n"
"also match it.  But \"home/foo/*.txt\" wouldn't.\n"
"   When including a slash, Vim matches the pattern against both the full "
"path\n"
"of the file (\"/home/biep/readme.txt\") and the relative path (e.g.,\n"
"\"biep/readme.txt\")."
msgstr ""

#: usr_40.txt:511
msgid ""
"\tNote:\n"
"\tWhen working on a system that uses a backslash as file separator, such\n"
"\tas MS-Windows, you still use forward slashes in autocommands.  This\n"
"\tmakes it easier to write the pattern, since a backslash has a special\n"
"\tmeaning.  It also makes the autocommands portable."
msgstr ""

#: usr_40.txt:518
msgid "DELETING"
msgstr ""

#: usr_40.txt:520
msgid ""
"To delete an autocommand, use the same command as what it was defined with,\n"
"but leave out the {command} at the end and use a !.  Example: >"
msgstr ""

#: usr_40.txt:523
msgid "\t:autocmd! FileWritePre *"
msgstr ""

#: usr_40.txt:525
msgid ""
"This will delete all autocommands for the \"FileWritePre\" event that use the\n"
"\"*\" pattern."
msgstr ""

#: usr_40.txt:529
msgid "LISTING"
msgstr ""

#: usr_40.txt:531
msgid "To list all the currently defined autocommands, use this: >"
msgstr ""

#: usr_40.txt:533
msgid "\t:autocmd"
msgstr ""

#: usr_40.txt:535
msgid ""
"The list can be very long, especially when filetype detection is used.  To\n"
"list only part of the commands, specify the group, event and/or pattern.  "
"For\n"
"example, to list all BufNewFile autocommands: >"
msgstr ""

#: usr_40.txt:539
msgid "\t:autocmd BufNewFile"
msgstr ""

#: usr_40.txt:541
msgid "To list all autocommands for the pattern \"*.c\": >"
msgstr ""

#: usr_40.txt:543
msgid "\t:autocmd * *.c"
msgstr ""

#: usr_40.txt:545
msgid ""
"Using \"*\" for the event will list all the events.  To list all autocommands\n"
"for the cprograms group: >"
msgstr ""

#: usr_40.txt:548
msgid "\t:autocmd cprograms"
msgstr ""

#: usr_40.txt:551
msgid "GROUPS"
msgstr ""

#: usr_40.txt:553
msgid ""
"The {group} item, used when defining an autocommand, groups related "
"autocommands\n"
"together.  This can be used to delete all the autocommands in a certain "
"group,\n"
"for example.\n"
"   When defining several autocommands for a certain group, use the "
"\":augroup\"\n"
"command.  For example, let's define autocommands for C programs: >"
msgstr ""

#: usr_40.txt:559
msgid ""
"\t:augroup cprograms\n"
"\t:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4\n"
"\t:  autocmd BufReadPost *.cpp   :set sw=3 sts=3\n"
"\t:augroup END"
msgstr ""

#: usr_40.txt:564
msgid "This will do the same as: >"
msgstr ""

#: usr_40.txt:566
msgid ""
"\t:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4\n"
"\t:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3"
msgstr ""

#: usr_40.txt:569
msgid "To delete all autocommands in the \"cprograms\" group: >"
msgstr ""

#: usr_40.txt:571
msgid "\t:autocmd! cprograms"
msgstr ""

#: usr_40.txt:574
msgid "NESTING"
msgstr ""

#: usr_40.txt:576
msgid ""
"Generally, commands executed as the result of an autocommand event will not\n"
"trigger any new events.  If you read a file in response to a "
"FileChangedShell\n"
"event, it will not trigger the autocommands that would set the syntax, for\n"
"example.  To make the events triggered, add the \"nested\" argument: >"
msgstr ""

#: usr_40.txt:581
msgid "\t:autocmd FileChangedShell * nested  edit"
msgstr ""

#: usr_40.txt:584
msgid "EXECUTING AUTOCOMMANDS"
msgstr ""

#: usr_40.txt:586
msgid ""
"It is possible to trigger an autocommand by pretending an event has "
"occurred.\n"
"This is useful to have one autocommand trigger another one.  Example: >"
msgstr ""

#: usr_40.txt:589
msgid ""
"\t:autocmd BufReadPost *.new  execute \"doautocmd BufReadPost \" . "
"expand(\"<afile>:r\")"
msgstr ""

#: usr_40.txt:591
msgid ""
"This defines an autocommand that is triggered when a new file has been "
"edited.\n"
"The file name must end in \".new\".  The \":execute\" command uses expression\n"
"evaluation to form a new command and execute it.  When editing the file\n"
"\"tryout.c.new\" the executed command will be: >"
msgstr ""

#: usr_40.txt:596
msgid "\t:doautocmd BufReadPost tryout.c"
msgstr ""

#: usr_40.txt:598
msgid ""
"The expand() function takes the \"<afile>\" argument, which stands for the "
"file\n"
"name the autocommand was executed for, and takes the root of the file name\n"
"with \":r\"."
msgstr ""

#: usr_40.txt:602
msgid ""
"\":doautocmd\" executes on the current buffer.  The \":doautoall\" command works\n"
"like \"doautocmd\" except it executes on all the buffers."
msgstr ""

#: usr_40.txt:606
msgid "USING NORMAL MODE COMMANDS"
msgstr ""

#: usr_40.txt:608
msgid ""
"The commands executed by an autocommand are Command-line commands.  If you\n"
"want to use a Normal mode command, the \":normal\" command can be used.\n"
"Example: >"
msgstr ""

#: usr_40.txt:612
msgid "\t:autocmd BufReadPost *.log normal G"
msgstr ""

#: usr_40.txt:614
msgid ""
"This will make the cursor jump to the last line of *.log files when you "
"start\n"
"to edit it.\n"
"   Using the \":normal\" command is a bit tricky.  First of all, make sure its\n"
"argument is a complete command, including all the arguments.  When you use "
"\"i\"\n"
"to go to Insert mode, there must also be a <Esc> to leave Insert mode again.\n"
"If you use a \"/\" to start a search pattern, there must be a <CR> to execute\n"
"it.\n"
"   The \":normal\" command uses all the text after it as commands.  Thus there\n"
"can be no | and another command following.  To work around this, put the\n"
"\":normal\" command inside an \":execute\" command.  This also makes it possible\n"
"to pass unprintable characters in a convenient way.  Example: >"
msgstr ""

#: usr_40.txt:626
msgid ""
"\t:autocmd BufReadPost *.chg execute \"normal ONew entry:\\<Esc>\" |\n"
"\t\t\\ 1read !date"
msgstr ""

#: usr_40.txt:629
msgid ""
"This also shows the use of a backslash to break a long command into more\n"
"lines.  This can be used in Vim scripts (not at the command line)."
msgstr ""

#: usr_40.txt:632
msgid ""
"When you want the autocommand do something complicated, which involves "
"jumping\n"
"around in the file and then returning to the original position, you may want\n"
"to restore the view on the file.  See |restore-position| for an example."
msgstr ""

#: usr_40.txt:637
msgid "IGNORING EVENTS"
msgstr ""

#: usr_40.txt:639
msgid ""
"At times, you will not want to trigger an autocommand.  The 'eventignore'\n"
"option contains a list of events that will be totally ignored.  For example,\n"
"the following causes events for entering and leaving a window to be ignored: "
">"
msgstr ""

#: usr_40.txt:643
msgid "\t:set eventignore=WinEnter,WinLeave"
msgstr ""

#: usr_40.txt:645
msgid "To ignore all events, use the following command: >"
msgstr ""

#: usr_40.txt:647
msgid "\t:set eventignore=all"
msgstr ""

#: usr_40.txt:649
msgid "To set it back to the normal behavior, make 'eventignore' empty: >"
msgstr ""

#: usr_40.txt:651
msgid "\t:set eventignore="
msgstr ""

#: usr_40.txt:653
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_40.txt:655
msgid "Next chapter: |usr_41.txt|  Write a Vim script"
msgstr ""

#: usr_40.txt:657
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
