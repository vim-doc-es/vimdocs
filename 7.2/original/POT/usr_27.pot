#. extracted from usr_27.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-04 13:40+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_27.txt:1
msgid "*usr_27.txt*\tFor Vim version 7.2.  Last change: 2007 Nov 10"
msgstr ""

#: usr_27.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_27.txt:5
msgid "\t\t\t Search commands and patterns"
msgstr ""

#: usr_27.txt:8
msgid ""
"In chapter 3 a few simple search patterns were mentioned |03.9|.  Vim can do\n"
"much more complex searches.  This chapter explains the most often used ones.\n"
"A detailed specification can be found here: |pattern|"
msgstr ""

#: usr_27.txt:12
msgid ""
"|27.1|\tIgnoring case\n"
"|27.2|\tWrapping around the file end\n"
"|27.3|\tOffsets\n"
"|27.4|\tMatching multiple times\n"
"|27.5|\tAlternatives\n"
"|27.6|\tCharacter ranges\n"
"|27.7|\tCharacter classes\n"
"|27.8|\tMatching a line break\n"
"|27.9|\tExamples"
msgstr ""

#: usr_27.txt:22
msgid ""
"     Next chapter: |usr_28.txt|  Folding\n"
" Previous chapter: |usr_26.txt|  Repeating\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_27.txt:26
msgid ""
"============================================================================"
"==\n"
"*27.1*\tIgnoring case"
msgstr ""

#: usr_27.txt:29
msgid ""
"By default, Vim's searches are case sensitive.  Therefore, \"include\",\n"
"\"INCLUDE\", and \"Include\" are three different words and a search will match\n"
"only one of them.\n"
"   Now switch on the 'ignorecase' option: >"
msgstr ""

#: usr_27.txt:34
msgid "\t:set ignorecase"
msgstr ""

#: usr_27.txt:36
msgid ""
"Search for \"include\" again, and now it will match \"Include\", \"INCLUDE\" and\n"
"\"InClUDe\".  (Set the 'hlsearch' option to quickly see where a pattern\n"
"matches.)\n"
"   You can switch this off again with: >"
msgstr ""

#: usr_27.txt:41
msgid "\t:set noignorecase"
msgstr ""

#: usr_27.txt:43
msgid ""
"But lets keep it set, and search for \"INCLUDE\".  It will match exactly the\n"
"same text as \"include\" did.  Now set the 'smartcase' option: >"
msgstr ""

#: usr_27.txt:46
msgid "\t:set ignorecase smartcase"
msgstr ""

#: usr_27.txt:48
msgid ""
"If you have a pattern with at least one uppercase character, the search\n"
"becomes case sensitive.  The idea is that you didn't have to type that\n"
"uppercase character, so you must have done it because you wanted case to\n"
"match.  That's smart!\n"
"    With these two options set you find the following matches:"
msgstr ""

#: usr_27.txt:54
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\tword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\tWord\t\t\tWord\n"
"\tWORD\t\t\tWORD\n"
"\tWoRd\t\t\tWoRd"
msgstr ""

#: usr_27.txt:61
msgid "CASE IN ONE PATTERN"
msgstr ""

#: usr_27.txt:63
msgid ""
"If you want to ignore case for one specific pattern, you can do this by\n"
"prepending the \"\\c\" string.  Using \"\\C\" will make the pattern to match case.\n"
"This overrules the 'ignorecase' and 'smartcase' options, when \"\\c\" or \"\\C\" "
"is\n"
"used their value doesn't matter."
msgstr ""

#: usr_27.txt:68
msgid ""
"\tpattern\t\t\tmatches\t~\n"
"\t\\Cword\t\t\tword\n"
"\t\\CWord\t\t\tWord\n"
"\t\\cword\t\t\tword, Word, WORD, WoRd, etc.\n"
"\t\\cWord\t\t\tword, Word, WORD, WoRd, etc."
msgstr ""

#: usr_27.txt:74
msgid ""
"A big advantage of using \"\\c\" and \"\\C\" is that it sticks with the pattern.\n"
"Thus if you repeat a pattern from the search history, the same will happen, "
"no\n"
"matter if 'ignorecase' or 'smartcase' was changed."
msgstr ""

#: usr_27.txt:78
msgid ""
"\tNote:\n"
"\tThe use of \"\\\" items in search patterns depends on the 'magic' option.\n"
"\tIn this chapters we will assume 'magic' is on, because that is the\n"
"\tstandard and recommended setting.  If you would change 'magic', many\n"
"\tsearch patterns would suddenly become invalid."
msgstr ""

#: usr_27.txt:84
msgid ""
"\tNote:\n"
"\tIf your search takes much longer than you expected, you can interrupt\n"
"\tit with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows."
msgstr ""

#: usr_27.txt:88
msgid ""
"============================================================================"
"==\n"
"*27.2*\tWrapping around the file end"
msgstr ""

#: usr_27.txt:91
msgid ""
"By default, a forward search starts searching for the given string at the\n"
"current cursor location.  It then proceeds to the end of the file.  If it "
"has\n"
"not found the string by that time, it starts from the beginning and searches\n"
"from the start of the file to the cursor location.\n"
"   Keep in mind that when repeating the \"n\" command to search for the next\n"
"match, you eventually get back to the first match.  If you don't notice this\n"
"you keep searching forever!  To give you a hint, Vim displays this message:"
msgstr ""

#: usr_27.txt:99
msgid "\tsearch hit BOTTOM, continuing at TOP ~"
msgstr ""

#: usr_27.txt:101
msgid ""
"If you use the \"?\" command, to search in the other direction, you get this\n"
"message:"
msgstr ""

#: usr_27.txt:104
msgid "\tsearch hit TOP, continuing at BOTTOM ~"
msgstr ""

#: usr_27.txt:106
msgid ""
"Still, you don't know when you are back at the first match.  One way to see\n"
"this is by switching on the 'ruler' option: >"
msgstr ""

#: usr_27.txt:109
msgid "\t:set ruler"
msgstr ""

#: usr_27.txt:111
msgid ""
"Vim will display the cursor position in the lower righthand corner of the\n"
"window (in the status line if there is one).  It looks like this:"
msgstr ""

#: usr_27.txt:114
msgid "\t101,29       84% ~"
msgstr ""

#: usr_27.txt:116
msgid ""
"The first number is the line number of the cursor.  Remember the line number\n"
"where you started, so that you can check if you passed this position again."
msgstr ""

#: usr_27.txt:120
msgid "NOT WRAPPING"
msgstr ""

#: usr_27.txt:122
msgid "To turn off search wrapping, use the following command: >"
msgstr ""

#: usr_27.txt:124
msgid "\t:set nowrapscan"
msgstr ""

#: usr_27.txt:126
msgid ""
"Now when the search hits the end of the file, an error message displays:"
msgstr ""

#: usr_27.txt:128
msgid "\tE385: search hit BOTTOM without match for: forever ~"
msgstr ""

#: usr_27.txt:130
msgid ""
"Thus you can find all matches by going to the start of the file with \"gg\" "
"and\n"
"keep searching until you see this message.\n"
"   If you search in the other direction, using \"?\", you get:"
msgstr ""

#: usr_27.txt:134
msgid "\tE384: search hit TOP without match for: forever ~"
msgstr ""

#: usr_27.txt:136
msgid ""
"============================================================================"
"==\n"
"*27.3*\tOffsets"
msgstr ""

#: usr_27.txt:139
msgid ""
"By default, the search command leaves the cursor positioned on the beginning\n"
"of the pattern.  You can tell Vim to leave it some other place by specifying\n"
"an offset.  For the forward search command \"/\", the offset is specified by\n"
"appending a slash (/) and the offset: >"
msgstr ""

#: usr_27.txt:144
msgid "\t/default/2"
msgstr ""

#: usr_27.txt:146
msgid ""
"This command searches for the pattern \"default\" and then moves to the\n"
"beginning of the second line past the pattern.  Using this command on the\n"
"paragraph above, Vim finds the word \"default\" in the first line.  Then the\n"
"cursor is moved two lines down and lands on \"an offset\"."
msgstr ""

#: usr_27.txt:151
msgid ""
"If the offset is a simple number, the cursor will be placed at the beginning\n"
"of the line that many lines from the match.  The offset number can be "
"positive\n"
"or negative.  If it is positive, the cursor moves down that many lines; if\n"
"negative, it moves up."
msgstr ""

#: usr_27.txt:157
msgid "CHARACTER OFFSETS"
msgstr ""

#: usr_27.txt:159
msgid ""
"The \"e\" offset indicates an offset from the end of the match.  It moves the\n"
"cursor onto the last character of the match.  The command: >"
msgstr ""

#: usr_27.txt:162
msgid "\t/const/e"
msgstr ""

#: usr_27.txt:164
msgid ""
"puts the cursor on the \"t\" of \"const\".\n"
"   From that position, adding a number moves forward that many characters.\n"
"This command moves to the character just after the match: >"
msgstr ""

#: usr_27.txt:168
msgid "\t/const/e+1"
msgstr ""

#: usr_27.txt:170
msgid ""
"A positive number moves the cursor to the right, a negative number moves it "
"to\n"
"the left.  For example: >"
msgstr ""

#: usr_27.txt:173
msgid "\t/const/e-1"
msgstr ""

#: usr_27.txt:175
msgid "moves the cursor to the \"s\" of \"const\"."
msgstr ""

#: usr_27.txt:177
msgid ""
"If the offset begins with \"b\", the cursor moves to the beginning of the\n"
"pattern.  That's not very useful, since leaving out the \"b\" does the same\n"
"thing.  It does get useful when a number is added or subtracted.  The cursor\n"
"then goes forward or backward that many characters.  For example: >"
msgstr ""

#: usr_27.txt:182
msgid "\t/const/b+2"
msgstr ""

#: usr_27.txt:184
msgid ""
"Moves the cursor to the beginning of the match and then two characters to "
"the\n"
"right.  Thus it lands on the \"n\"."
msgstr ""

#: usr_27.txt:188
msgid "REPEATING"
msgstr ""

#: usr_27.txt:190
msgid ""
"To repeat searching for the previously used search pattern, but with a\n"
"different offset, leave out the pattern: >"
msgstr ""

#: usr_27.txt:193
msgid ""
"\t/that\n"
"\t//e"
msgstr ""

#: usr_27.txt:196
msgid "Is equal to: >"
msgstr ""

#: usr_27.txt:198
msgid "\t/that/e"
msgstr ""

#: usr_27.txt:200
msgid "To repeat with the same offset: >"
msgstr ""

#: usr_27.txt:202
msgid "\t/"
msgstr ""

#: usr_27.txt:204
msgid ""
"\"n\" does the same thing.  To repeat while removing a previously used offset: "
">"
msgstr ""

#: usr_27.txt:206
msgid "\t//"
msgstr ""

#: usr_27.txt:209
msgid "SEARCHING BACKWARDS"
msgstr ""

#: usr_27.txt:211
msgid ""
"The \"?\" command uses offsets in the same way, but you must use \"?\" to "
"separate\n"
"the offset from the pattern, instead of \"/\": >"
msgstr ""

#: usr_27.txt:214
msgid "\t?const?e-2"
msgstr ""

#: usr_27.txt:216
msgid ""
"The \"b\" and \"e\" keep their meaning, they don't change direction with the use\n"
"of \"?\"."
msgstr ""

#: usr_27.txt:220
msgid "START POSITION"
msgstr ""

#: usr_27.txt:222
msgid ""
"When starting a search, it normally starts at the cursor position.  When you\n"
"specify a line offset, this can cause trouble.  For example: >"
msgstr ""

#: usr_27.txt:225
msgid "\t/const/-2"
msgstr ""

#: usr_27.txt:227
msgid ""
"This finds the next word \"const\" and then moves two lines up.  If you\n"
"use \"n\" to search again, Vim could start at the current position and find "
"the same\n"
"\"const\" match.  Then using the offset again, you would be back where you "
"started.\n"
"You would be stuck!\n"
"   It could be worse: Suppose there is another match with \"const\" in the "
"next\n"
"line.  Then repeating the forward search would find this match and move two\n"
"lines up.  Thus you would actually move the cursor back!"
msgstr ""

#: usr_27.txt:235
msgid ""
"When you specify a character offset, Vim will compensate for this.  Thus the\n"
"search starts a few characters forward or backward, so that the same match\n"
"isn't found again."
msgstr ""

#: usr_27.txt:239
msgid ""
"============================================================================"
"==\n"
"*27.4*\tMatching multiple times"
msgstr ""

#: usr_27.txt:242
msgid ""
"The \"*\" item specifies that the item before it can match any number of "
"times.\n"
"Thus: >"
msgstr ""

#: usr_27.txt:245
msgid "\t/a*"
msgstr ""

#: usr_27.txt:247
msgid ""
"matches \"a\", \"aa\", \"aaa\", etc.  But also \"\" (the empty string), because zero\n"
"times is included.\n"
"   The \"*\" only applies to the item directly before it.  Thus \"ab*\" matches\n"
"\"a\", \"ab\", \"abb\", \"abbb\", etc.  To match a whole string multiple times, it\n"
"must be grouped into one item.  This is done by putting \"\\(\" before it and\n"
"\"\\)\" after it.  Thus this command: >"
msgstr ""

#: usr_27.txt:254
msgid "\t/\\(ab\\)*"
msgstr ""

#: usr_27.txt:256
msgid "Matches: \"ab\", \"abab\", \"ababab\", etc.  And also \"\"."
msgstr ""

#: usr_27.txt:258
msgid ""
"To avoid matching the empty string, use \"\\+\".  This makes the previous item\n"
"match one or more times. >"
msgstr ""

#: usr_27.txt:261
msgid "\t/ab\\+"
msgstr ""

#: usr_27.txt:263
msgid ""
"Matches \"ab\", \"abb\", \"abbb\", etc.  It does not match \"a\" when no \"b\" "
"follows."
msgstr ""

#: usr_27.txt:265
msgid "To match an optional item, use \"\\=\".  Example: >"
msgstr ""

#: usr_27.txt:267
msgid "\t/folders\\="
msgstr ""

#: usr_27.txt:269
msgid "Matches \"folder\" and \"folders\"."
msgstr ""

#: usr_27.txt:272
msgid "SPECIFIC COUNTS"
msgstr ""

#: usr_27.txt:274
msgid ""
"To match a specific number of items use the form \"\\{n,m}\".  \"n\" and \"m\" are\n"
"numbers.  The item before it will be matched \"n\" to \"m\" times |inclusive|.\n"
"Example: >"
msgstr ""

#: usr_27.txt:278
msgid "\t/ab\\{3,5}"
msgstr ""

#: usr_27.txt:280
msgid ""
"matches \"abbb\", \"abbbb\" and \"abbbbb\".\n"
"  When \"n\" is omitted, it defaults to zero.  When \"m\" is omitted it defaults\n"
"to infinity.  When \",m\" is omitted, it matches exactly \"n\" times.\n"
"Examples:"
msgstr ""

#: usr_27.txt:285
msgid ""
"\tpattern\t\tmatch count ~\n"
"\t\\{,4}\t\t0, 1, 2, 3 or 4\n"
"\t\\{3,}\t\t3, 4, 5, etc.\n"
"\t\\{0,1}\t\t0 or 1, same as \\=\n"
"\t\\{0,}\t\t0 or more, same as *\n"
"\t\\{1,}\t\t1 or more, same as \\+\n"
"\t\\{3}\t\t3"
msgstr ""

#: usr_27.txt:294
msgid "MATCHING AS LITTLE AS POSSIBLE"
msgstr ""

#: usr_27.txt:296
msgid ""
"The items so far match as many characters as they can find.  To match as few\n"
"as possible, use \"\\{-n,m}\".  It works the same as \"\\{n,m}\", except that the\n"
"minimal amount possible is used.\n"
"   For example, use: >"
msgstr ""

#: usr_27.txt:301
msgid "\t/ab\\{-1,3}"
msgstr ""

#: usr_27.txt:303
msgid ""
"Will match \"ab\" in \"abbb\".  Actually, it will never match more than one b,\n"
"because there is no reason to match more.  It requires something else to "
"force\n"
"it to match more than the lower limit.\n"
"   The same rules apply to removing \"n\" and \"m\".  It's even possible to "
"remove\n"
"both of the numbers, resulting in \"\\{-}\".  This matches the item before it\n"
"zero or more times, as few as possible.  The item by itself always matches\n"
"zero times.  It is useful when combined with something else.  Example: >"
msgstr ""

#: usr_27.txt:311
msgid "\t/a.\\{-}b"
msgstr ""

#: usr_27.txt:313
msgid "This matches \"axb\" in \"axbxb\".  If this pattern would be used: >"
msgstr ""

#: usr_27.txt:315
msgid "\t/a.*b"
msgstr ""

#: usr_27.txt:317
msgid ""
"It would try to match as many characters as possible with \".*\", thus it\n"
"matches \"axbxb\" as a whole."
msgstr ""

#: usr_27.txt:320
msgid ""
"============================================================================"
"==\n"
"*27.5*\tAlternatives"
msgstr ""

#: usr_27.txt:323
msgid "The \"or\" operator in a pattern is \"\\|\".  Example: >"
msgstr ""

#: usr_27.txt:325
msgid "\t/foo\\|bar"
msgstr ""

#: usr_27.txt:327
msgid "This matches \"foo\" or \"bar\".  More alternatives can be concatenated: >"
msgstr ""

#: usr_27.txt:329
msgid "\t/one\\|two\\|three"
msgstr ""

#: usr_27.txt:331
msgid ""
"Matches \"one\", \"two\" and \"three\".\n"
"   To match multiple times, the whole thing must be placed in \"\\(\" and \"\\)\": "
">"
msgstr ""

#: usr_27.txt:334
msgid "\t/\\(foo\\|bar\\)\\+"
msgstr ""

#: usr_27.txt:336
msgid ""
"This matches \"foo\", \"foobar\", \"foofoo\", \"barfoobar\", etc.\n"
"   Another example: >"
msgstr ""

#: usr_27.txt:339
msgid "\t/end\\(if\\|while\\|for\\)"
msgstr ""

#: usr_27.txt:341
msgid "This matches \"endif\", \"endwhile\" and \"endfor\"."
msgstr ""

#: usr_27.txt:343
msgid ""
"A related item is \"\\&\".  This requires that both alternatives match in the\n"
"same place.  The resulting match uses the last alternative.  Example: >"
msgstr ""

#: usr_27.txt:346
msgid "\t/forever\\&..."
msgstr ""

#: usr_27.txt:348
msgid ""
"This matches \"for\" in \"forever\".  It will not match \"fortuin\", for example."
msgstr ""

#: usr_27.txt:350
msgid ""
"============================================================================"
"==\n"
"*27.6*\tCharacter ranges"
msgstr ""

#: usr_27.txt:353
msgid ""
"To match \"a\", \"b\" or \"c\" you could use \"/a\\|b\\|c\".  When you want to match "
"all\n"
"letters from \"a\" to \"z\" this gets very long.  There is a shorter method: >"
msgstr ""

#: usr_27.txt:356
msgid "\t/[a-z]"
msgstr ""

#: usr_27.txt:358
msgid ""
"The [] construct matches a single character.  Inside you specify which\n"
"characters to match.  You can include a list of characters, like this: >"
msgstr ""

#: usr_27.txt:361
msgid "\t/[0123456789abcdef]"
msgstr ""

#: usr_27.txt:363
msgid ""
"This will match any of the characters included.  For consecutive characters\n"
"you can specify the range.  \"0-3\" stands for \"0123\".  \"w-z\" stands for "
"\"wxyz\".\n"
"Thus the same command as above can be shortened to: >"
msgstr ""

#: usr_27.txt:367
msgid "\t/[0-9a-f]"
msgstr ""

#: usr_27.txt:369
msgid ""
"To match the \"-\" character itself make it the first or last one in the "
"range.\n"
"These special characters are accepted to make it easier to use them inside a\n"
"[] range (they can actually be used anywhere in the search pattern):"
msgstr ""

#: usr_27.txt:373
msgid ""
"\t\\e\t<Esc>\n"
"\t\\t\t<Tab>\n"
"\t\\r\t<CR>\n"
"\t\\b\t<BS>"
msgstr ""

#: usr_27.txt:378
msgid ""
"There are a few more special cases for [] ranges, see |/[]| for the whole\n"
"story."
msgstr ""

#: usr_27.txt:382
msgid "COMPLEMENTED RANGE"
msgstr ""

#: usr_27.txt:384
msgid ""
"To avoid matching a specific character, use \"^\" at the start of the range.\n"
"The [] item then matches everything but the characters included.  Example: >"
msgstr ""

#: usr_27.txt:387
msgid ""
"\t/\"[^\"]*\"\n"
"<\n"
"\t \"\t  a double quote\n"
"\t  [^\"]\t  any character that is not a double quote\n"
"\t      *\t  as many as possible\n"
"\t       \"  a double quote again"
msgstr ""

#: usr_27.txt:394
msgid "This matches \"foo\" and \"3!x\", including the double quotes."
msgstr ""

#: usr_27.txt:397
msgid "PREDEFINED RANGES"
msgstr ""

#: usr_27.txt:399
msgid ""
"A number of ranges are used very often.  Vim provides a shortcut for these.\n"
"For example: >"
msgstr ""

#: usr_27.txt:402
msgid "\t/\\a"
msgstr ""

#: usr_27.txt:404
msgid ""
"Finds alphabetic characters.  This is equal to using \"/[a-zA-Z]\".  Here are "
"a\n"
"few more of these:"
msgstr ""

#: usr_27.txt:407
msgid ""
"\titem\tmatches\t\t\tequivalent ~\n"
"\t\\d\tdigit\t\t\t[0-9]\n"
"\t\\D\tnon-digit\t\t[^0-9]\n"
"\t\\x\thex digit\t\t[0-9a-fA-F]\n"
"\t\\X\tnon-hex digit\t\t[^0-9a-fA-F]\n"
"\t\\s\twhite space\t\t[ \t]     (<Tab> and <Space>)\n"
"\t\\S\tnon-white characters\t[^ \t]     (not <Tab> and <Space>)\n"
"\t\\l\tlowercase alpha\t\t[a-z]\n"
"\t\\L\tnon-lowercase alpha\t[^a-z]\n"
"\t\\u\tuppercase alpha\t\t[A-Z]\n"
"\t\\U\tnon-uppercase alpha\t[^A-Z]"
msgstr ""

#: usr_27.txt:419
msgid ""
"\tNote:\n"
"\tUsing these predefined ranges works a lot faster than the character\n"
"\trange it stands for.\n"
"\tThese items can not be used inside [].  Thus \"[\\d\\l]\" does NOT work to\n"
"\tmatch a digit or lowercase alpha.  Use \"\\(\\d\\|\\l\\)\" instead."
msgstr ""

#: usr_27.txt:425
msgid "See |/\\s| for the whole list of these ranges."
msgstr ""

#: usr_27.txt:427
msgid ""
"============================================================================"
"==\n"
"*27.7*\tCharacter classes"
msgstr ""

#: usr_27.txt:430
msgid ""
"The character range matches a fixed set of characters.  A character class is\n"
"similar, but with an essential difference: The set of characters can be\n"
"redefined without changing the search pattern.\n"
"   For example, search for this pattern: >"
msgstr ""

#: usr_27.txt:435
msgid "\t/\\f\\+"
msgstr ""

#: usr_27.txt:437
msgid ""
"The \"\\f\" items stands for file name characters.  Thus this matches a "
"sequence\n"
"of characters that can be a file name.\n"
"   Which characters can be part of a file name depends on the system you are\n"
"using.  On MS-Windows, the backslash is included, on Unix it is not.  This "
"is\n"
"specified with the 'isfname' option.  The default value for Unix is: >"
msgstr ""

#: usr_27.txt:443
msgid ""
"\t:set isfname\n"
"\tisfname=@,48-57,/,.,-,_,+,,,#,$,%,~,="
msgstr ""

#: usr_27.txt:446
msgid ""
"For other systems the default value is different.  Thus you can make a "
"search\n"
"pattern with \"\\f\" to match a file name, and it will automatically adjust to\n"
"the system you are using it on."
msgstr ""

#: usr_27.txt:450
msgid ""
"\tNote:\n"
"\tActually, Unix allows using just about any character in a file name,\n"
"\tincluding white space.  Including these characters in 'isfname' would\n"
"\tbe theoretically correct.  But it would make it impossible to find the\n"
"\tend of a file name in text.  Thus the default value of 'isfname' is a\n"
"\tcompromise."
msgstr ""

#: usr_27.txt:457
msgid "The character classes are:"
msgstr ""

#: usr_27.txt:459
msgid ""
"\titem\tmatches\t\t\t\toption ~\n"
"\t\\i\tidentifier characters\t\t'isident'\n"
"\t\\I\tlike \\i, excluding digits\n"
"\t\\k\tkeyword characters\t\t'iskeyword'\n"
"\t\\K\tlike \\k, excluding digits\n"
"\t\\p\tprintable characters\t\t'isprint'\n"
"\t\\P\tlike \\p, excluding digits\n"
"\t\\f\tfile name characters\t\t'isfname'\n"
"\t\\F\tlike \\f, excluding digits"
msgstr ""

#: usr_27.txt:469
msgid ""
"============================================================================"
"==\n"
"*27.8*\tMatching a line break"
msgstr ""

#: usr_27.txt:472
msgid ""
"Vim can find a pattern that includes a line break.  You need to specify "
"where\n"
"the line break happens, because all items mentioned so far don't match a "
"line\n"
"break.\n"
"   To check for a line break in a specific place, use the \"\\n\" item: >"
msgstr ""

#: usr_27.txt:477
msgid "\t/the\\nword"
msgstr ""

#: usr_27.txt:479
msgid ""
"This will match at a line that ends in \"the\" and the next line starts with\n"
"\"word\".  To match \"the word\" as well, you need to match a space or a line\n"
"break.  The item to use for it is \"\\_s\": >"
msgstr ""

#: usr_27.txt:483
msgid "\t/the\\_sword"
msgstr ""

#: usr_27.txt:485
msgid "To allow any amount of white space: >"
msgstr ""

#: usr_27.txt:487
msgid "\t/the\\_s\\+word"
msgstr ""

#: usr_27.txt:489
msgid ""
"This also matches when \"the  \" is at the end of a line and \"   word\" at the\n"
"start of the next one."
msgstr ""

#: usr_27.txt:492
msgid ""
"\"\\s\" matches white space, \"\\_s\" matches white space or a line break.\n"
"Similarly, \"\\a\" matches an alphabetic character, and \"\\_a\" matches an\n"
"alphabetic character or a line break.  The other character classes and "
"ranges\n"
"can be modified in the same way by inserting a \"_\"."
msgstr ""

#: usr_27.txt:497
msgid ""
"Many other items can be made to match a line break by prepending \"\\_\".  For\n"
"example: \"\\_.\" matches any character or a line break."
msgstr ""

#: usr_27.txt:500
msgid ""
"\tNote:\n"
"\t\"\\_.*\" matches everything until the end of the file.  Be careful with\n"
"\tthis, it can make a search command very slow."
msgstr ""

#: usr_27.txt:504
msgid ""
"Another example is \"\\_[]\", a character range that includes a line break: >"
msgstr ""

#: usr_27.txt:506
msgid "\t/\"\\_[^\"]*\""
msgstr ""

#: usr_27.txt:508
msgid ""
"This finds a text in double quotes that may be split up in several lines."
msgstr ""

#: usr_27.txt:510
msgid ""
"============================================================================"
"==\n"
"*27.9*\tExamples"
msgstr ""

#: usr_27.txt:513
msgid ""
"Here are a few search patterns you might find useful.  This shows how the\n"
"items mentioned above can be combined."
msgstr ""

#: usr_27.txt:517
msgid "FINDING A CALIFORNIA LICENSE PLATE"
msgstr ""

#: usr_27.txt:519
msgid ""
"A sample license plate number is \"1MGU103\".  It has one digit, three "
"uppercase\n"
"letters and three digits.  Directly putting this into a search pattern: >"
msgstr ""

#: usr_27.txt:522
msgid "\t/\\d\\u\\u\\u\\d\\d\\d"
msgstr ""

#: usr_27.txt:524
msgid ""
"Another way is to specify that there are three digits and letters with a\n"
"count: >"
msgstr ""

#: usr_27.txt:527
msgid "\t/\\d\\u\\{3}\\d\\{3}"
msgstr ""

#: usr_27.txt:529
msgid "Using [] ranges instead: >"
msgstr ""

#: usr_27.txt:531
msgid "\t/[0-9][A-Z]\\{3}[0-9]\\{3}"
msgstr ""

#: usr_27.txt:533
msgid ""
"Which one of these you should use?  Whichever one you can remember.  The\n"
"simple way you can remember is much faster than the fancy way that you "
"can't.\n"
"If you can remember them all, then avoid the last one, because it's both "
"more\n"
"typing and slower to execute."
msgstr ""

#: usr_27.txt:539
msgid "FINDING AN IDENTIFIER"
msgstr ""

#: usr_27.txt:541
msgid ""
"In C programs (and many other computer languages) an identifier starts with "
"a\n"
"letter and further consists of letters and digits.  Underscores can be used\n"
"too.  This can be found with: >"
msgstr ""

#: usr_27.txt:545
msgid "\t/\\<\\h\\w*\\>"
msgstr ""

#: usr_27.txt:547
msgid ""
"\"\\<\" and \"\\>\" are used to find only whole words.  \"\\h\" stands for "
"\"[A-Za-z_]\"\n"
"and \"\\w\" for \"[0-9A-Za-z_]\"."
msgstr ""

#: usr_27.txt:550
msgid ""
"\tNote:\n"
"\t\"\\<\" and \"\\>\" depend on the 'iskeyword' option.  If it includes \"-\",\n"
"\tfor example, then \"ident-\" is not matched.  In this situation use: >"
msgstr ""

#: usr_27.txt:554
msgid ""
"\t\t/\\w\\@<!\\h\\w*\\w\\@!\n"
"<\n"
"\tThis checks if \"\\w\" does not match before or after the identifier.\n"
"\tSee |/\\@<!| and |/\\@!|."
msgstr ""

#: usr_27.txt:559
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_27.txt:561
msgid "Next chapter: |usr_28.txt|  Folding"
msgstr ""

#: usr_27.txt:563
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
