# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the Vim package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vim 7.3\n"
"Report-Msgid-Bugs-To: vim@bugs.org\n"
"POT-Creation-Date: 2010-09-23 20:27+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: original/TXT/intro.txt:18 original/TXT/intro.txt:79
#: original/TXT/intro.txt:180 original/TXT/intro.txt:290
#: original/TXT/intro.txt:518 original/TXT/intro.txt:596
#: original/TXT/intro.txt:689 original/TXT/intro.txt:817
#: original/TXT/intro.txt:880 original/TXT/usr_toc.txt:7
#: original/TXT/usr_toc.txt:58 original/TXT/usr_toc.txt:172
#: original/TXT/usr_toc.txt:281 original/TXT/usr_toc.txt:340
#: original/TXT/usr_toc.txt:352 original/TXT/usr_01.txt:19
#: original/TXT/usr_01.txt:50 original/TXT/usr_01.txt:100
#: original/TXT/usr_01.txt:181 original/TXT/usr_02.txt:25
#: original/TXT/usr_02.txt:69 original/TXT/usr_02.txt:130
#: original/TXT/usr_02.txt:179 original/TXT/usr_02.txt:239
#: original/TXT/usr_02.txt:307 original/TXT/usr_02.txt:369
#: original/TXT/usr_02.txt:406 original/TXT/usr_02.txt:560
#: original/TXT/usr_03.txt:28 original/TXT/usr_03.txt:74
#: original/TXT/usr_03.txt:101 original/TXT/usr_03.txt:147
#: original/TXT/usr_03.txt:172 original/TXT/usr_03.txt:223
#: original/TXT/usr_03.txt:265 original/TXT/usr_03.txt:320
#: original/TXT/usr_03.txt:491 original/TXT/usr_03.txt:552
#: original/TXT/usr_03.txt:650 original/TXT/usr_04.txt:27
#: original/TXT/usr_04.txt:74 original/TXT/usr_04.txt:160
#: original/TXT/usr_04.txt:194 original/TXT/usr_04.txt:269
#: original/TXT/usr_04.txt:324 original/TXT/usr_04.txt:360
#: original/TXT/usr_04.txt:390 original/TXT/usr_04.txt:446
#: original/TXT/usr_04.txt:469 original/TXT/usr_04.txt:510
#: original/TXT/usr_05.txt:24 original/TXT/usr_05.txt:63
#: original/TXT/usr_05.txt:219 original/TXT/usr_05.txt:266
#: original/TXT/usr_05.txt:418 original/TXT/usr_05.txt:467
#: original/TXT/usr_05.txt:506 original/TXT/usr_05.txt:621
#: original/TXT/usr_06.txt:24 original/TXT/usr_06.txt:50
#: original/TXT/usr_06.txt:135 original/TXT/usr_06.txt:189
#: original/TXT/usr_06.txt:270 original/TXT/usr_06.txt:276
#: original/TXT/usr_07.txt:24 original/TXT/usr_07.txt:63
#: original/TXT/usr_07.txt:179 original/TXT/usr_07.txt:266
#: original/TXT/usr_07.txt:316 original/TXT/usr_07.txt:404
#: original/TXT/usr_07.txt:444 original/TXT/usr_07.txt:475
#: original/TXT/usr_08.txt:26 original/TXT/usr_08.txt:82
#: original/TXT/usr_08.txt:109 original/TXT/usr_08.txt:161
#: original/TXT/usr_08.txt:215 original/TXT/usr_08.txt:278
#: original/TXT/usr_08.txt:337 original/TXT/usr_08.txt:477
#: original/TXT/usr_08.txt:509 original/TXT/usr_08.txt:597
#: original/TXT/usr_09.txt:21 original/TXT/usr_09.txt:124
#: original/TXT/usr_09.txt:175 original/TXT/usr_09.txt:259
#: original/TXT/usr_09.txt:285 original/TXT/usr_10.txt:27
#: original/TXT/usr_10.txt:144 original/TXT/usr_10.txt:221
#: original/TXT/usr_10.txt:342 original/TXT/usr_10.txt:378
#: original/TXT/usr_10.txt:547 original/TXT/usr_10.txt:621
#: original/TXT/usr_10.txt:667 original/TXT/usr_10.txt:692
#: original/TXT/usr_10.txt:820 original/TXT/usr_11.txt:22
#: original/TXT/usr_11.txt:82 original/TXT/usr_11.txt:144
#: original/TXT/usr_11.txt:288 original/TXT/usr_11.txt:303
#: original/TXT/usr_12.txt:25 original/TXT/usr_12.txt:90
#: original/TXT/usr_12.txt:131 original/TXT/usr_12.txt:177
#: original/TXT/usr_12.txt:202 original/TXT/usr_12.txt:231
#: original/TXT/usr_12.txt:281 original/TXT/usr_12.txt:309
#: original/TXT/usr_12.txt:354 original/TXT/usr_20.txt:22
#: original/TXT/usr_20.txt:113 original/TXT/usr_20.txt:158
#: original/TXT/usr_20.txt:285 original/TXT/usr_20.txt:327
#: original/TXT/usr_20.txt:380 original/TXT/usr_21.txt:24
#: original/TXT/usr_21.txt:47 original/TXT/usr_21.txt:87
#: original/TXT/usr_21.txt:236 original/TXT/usr_21.txt:385
#: original/TXT/usr_21.txt:438 original/TXT/usr_21.txt:495
#: original/TXT/usr_22.txt:22 original/TXT/usr_22.txt:148
#: original/TXT/usr_22.txt:213 original/TXT/usr_22.txt:272
#: original/TXT/usr_22.txt:396 original/TXT/usr_23.txt:23
#: original/TXT/usr_23.txt:114 original/TXT/usr_23.txt:156
#: original/TXT/usr_23.txt:238 original/TXT/usr_23.txt:324
#: original/TXT/usr_23.txt:339 original/TXT/usr_24.txt:28
#: original/TXT/usr_24.txt:96 original/TXT/usr_24.txt:119
#: original/TXT/usr_24.txt:268 original/TXT/usr_24.txt:305
#: original/TXT/usr_24.txt:336 original/TXT/usr_24.txt:369
#: original/TXT/usr_24.txt:493 original/TXT/usr_24.txt:537
#: original/TXT/usr_24.txt:583 original/TXT/usr_24.txt:602
#: original/TXT/usr_25.txt:22 original/TXT/usr_25.txt:132
#: original/TXT/usr_25.txt:210 original/TXT/usr_25.txt:287
#: original/TXT/usr_25.txt:453 original/TXT/usr_25.txt:574
#: original/TXT/usr_26.txt:21 original/TXT/usr_26.txt:46
#: original/TXT/usr_26.txt:103 original/TXT/usr_26.txt:136
#: original/TXT/usr_26.txt:217 original/TXT/usr_27.txt:26
#: original/TXT/usr_27.txt:88 original/TXT/usr_27.txt:136
#: original/TXT/usr_27.txt:239 original/TXT/usr_27.txt:320
#: original/TXT/usr_27.txt:350 original/TXT/usr_27.txt:427
#: original/TXT/usr_27.txt:469 original/TXT/usr_27.txt:510
#: original/TXT/usr_27.txt:559 original/TXT/usr_28.txt:27
#: original/TXT/usr_28.txt:54 original/TXT/usr_28.txt:121
#: original/TXT/usr_28.txt:185 original/TXT/usr_28.txt:211
#: original/TXT/usr_28.txt:269 original/TXT/usr_28.txt:315
#: original/TXT/usr_28.txt:331 original/TXT/usr_28.txt:375
#: original/TXT/usr_28.txt:389 original/TXT/usr_28.txt:422
#: original/TXT/usr_29.txt:23 original/TXT/usr_29.txt:273
#: original/TXT/usr_29.txt:320 original/TXT/usr_29.txt:441
#: original/TXT/usr_29.txt:570 original/TXT/usr_29.txt:609
#: original/TXT/usr_30.txt:23 original/TXT/usr_30.txt:202
#: original/TXT/usr_30.txt:280 original/TXT/usr_30.txt:336
#: original/TXT/usr_30.txt:409 original/TXT/usr_30.txt:515
#: original/TXT/usr_30.txt:639 original/TXT/usr_31.txt:22
#: original/TXT/usr_31.txt:81 original/TXT/usr_31.txt:133
#: original/TXT/usr_31.txt:160 original/TXT/usr_31.txt:208
#: original/TXT/usr_31.txt:268
#, no-wrap
msgid "==============================================================================\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_toc.txt:4 original/TXT/usr_01.txt:4
#: original/TXT/usr_02.txt:4 original/TXT/usr_03.txt:4
#: original/TXT/usr_04.txt:4 original/TXT/usr_05.txt:4
#: original/TXT/usr_06.txt:4 original/TXT/usr_07.txt:4
#: original/TXT/usr_08.txt:4 original/TXT/usr_09.txt:4
#: original/TXT/usr_10.txt:4 original/TXT/usr_11.txt:4
#: original/TXT/usr_12.txt:4 original/TXT/usr_20.txt:4
#: original/TXT/usr_21.txt:4 original/TXT/usr_22.txt:4
#: original/TXT/usr_23.txt:4 original/TXT/usr_24.txt:4
#: original/TXT/usr_25.txt:4 original/TXT/usr_26.txt:4
#: original/TXT/usr_27.txt:4 original/TXT/usr_28.txt:4
#: original/TXT/usr_29.txt:4 original/TXT/usr_30.txt:4
#: original/TXT/usr_31.txt:4
#, no-wrap
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_toc.txt:354 original/TXT/usr_01.txt:185
#: original/TXT/usr_02.txt:564 original/TXT/usr_03.txt:654
#: original/TXT/usr_04.txt:514 original/TXT/usr_05.txt:625
#: original/TXT/usr_06.txt:280 original/TXT/usr_07.txt:479
#: original/TXT/usr_08.txt:601 original/TXT/usr_09.txt:289
#: original/TXT/usr_10.txt:824 original/TXT/usr_11.txt:307
#: original/TXT/usr_12.txt:358 original/TXT/usr_20.txt:384
#: original/TXT/usr_21.txt:499 original/TXT/usr_22.txt:400
#: original/TXT/usr_23.txt:343 original/TXT/usr_24.txt:606
#: original/TXT/usr_25.txt:578 original/TXT/usr_26.txt:221
#: original/TXT/usr_27.txt:563 original/TXT/usr_28.txt:426
#: original/TXT/usr_29.txt:613 original/TXT/usr_30.txt:643
#: original/TXT/usr_31.txt:272
msgid "Copyright: see |manual-copyright| vim:tw=78:ts=8:ft=help:norl:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_25.txt:254 original/TXT/usr_30.txt:448
#, no-wrap
msgid "\t:set softtabstop=4\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:2
#, no-wrap
msgid "*usr_30.txt*\tFor Vim version 7.3.  Last change: 2007 Nov 10\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:6
#, no-wrap
msgid "\t\t\t      Editing programs\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:11
msgid ""
"Vim has various commands that aid in writing computer programs.  Compile a "
"program and directly jump to reported errors.  Automatically set the indent "
"for many languages and format comments."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:18
#, no-wrap
msgid ""
"|30.1|\tCompiling\n"
"|30.2|\tIndenting C files\n"
"|30.3|\tAutomatic indenting\n"
"|30.4|\tOther indenting\n"
"|30.5|\tTabs and spaces\n"
"|30.6|\tFormatting comments\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:22
#, no-wrap
msgid ""
"     Next chapter: |usr_31.txt|  Exploiting the GUI\n"
" Previous chapter: |usr_29.txt|  Moving through programs\n"
"Table of contents: |usr_toc.txt|\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:25
#, no-wrap
msgid "*30.1*\tCompiling\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:30
msgid ""
"Vim has a set of so called \"quickfix\" commands.  They enable you to "
"compile a program from within Vim and then go through the errors generated "
"and fix them (hopefully).  You can then recompile and fix any new errors "
"that are found until finally your program compiles without any error."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:33
msgid ""
"The following command runs the program \"make\" (supplying it with any "
"argument you give) and captures the results: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:35
#, no-wrap
msgid "\t:make {arguments}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:41
#, no-wrap
msgid ""
"If errors were generated, they are captured and the editor positions you where\n"
"the first error occurred.\n"
"   Take a look at an example \":make\" session.  (Typical :make sessions generate\n"
"far more errors and fewer stupid ones.)  After typing \":make\" the screen looks\n"
"like this:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:49
#, no-wrap
msgid ""
"\t:!make | &tee /tmp/vim215953.err ~\n"
"\tgcc -g -Wall -o prog main.c sub.c ~\n"
"\tmain.c: In function 'main': ~\n"
"\tmain.c:6: too many arguments to function 'do_sub' ~\n"
"\tmain.c: At top level: ~\n"
"\tmain.c:10: parse error before '}' ~\n"
"\tmake: *** [prog] Error 1 ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:54
#, no-wrap
msgid ""
"\t2 returned ~\n"
"\t\"main.c\" 11L, 111C ~\n"
"\t(3 of 6): too many arguments to function 'do_sub' ~\n"
"\tPress ENTER or type command to continue ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:59
msgid ""
"From this you can see that you have errors in the file \"main.c\".  When you "
"press <Enter>, Vim displays the file \"main.c\", with the cursor positioned "
"on line 6, the first line with an error.  You did not need to specify the "
"file or the line number, Vim knew where to go by looking in the error "
"messages."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:72
#, no-wrap
msgid ""
"\t\t+---------------------------------------------------+\n"
"\t\t|int main()\t\t\t\t\t    |\n"
"\t\t|{\t\t\t\t\t\t    |\n"
"\t\t|\tint i=3;\t\t\t\t    |\n"
"      cursor -> |\tdo_sub(\"foo\");\t\t\t\t    |\n"
"\t\t|\t++i;\t\t\t\t\t    |\n"
"\t\t|\treturn (0);\t\t\t\t    |\n"
"\t\t|}\t\t\t\t\t\t    |\n"
"\t\t|}\t\t\t\t\t\t    |\n"
"\t\t| ~\t\t\t\t\t\t    |\n"
"\t\t|(3 of 12): too many arguments to function 'do_sub' |\n"
"\t\t+---------------------------------------------------+\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:74
msgid "The following command goes to where the next error occurs: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:76
#, no-wrap
msgid "\t:cnext\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:80
#, no-wrap
msgid ""
"Vim jumps to line 10, the last line in the file, where there is an extra '}'.\n"
"   When there is not enough room, Vim will shorten the error message.  To see\n"
"the whole message use: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:82
#, no-wrap
msgid "\t:cc\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:85
msgid ""
"You can get an overview of all the error messages with the \":clist\" "
"command.  The output looks like this: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:89
#, no-wrap
msgid ""
"\t:clist\n"
"<\t3 main.c: 6:too many arguments to function 'do_sub' ~\n"
"\t5 main.c: 10:parse error before '}' ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:95
msgid ""
"Only the lines where Vim recognized a file name and line number are listed "
"here.  It assumes those are the interesting lines and the rest is just "
"boring messages.  However, sometimes unrecognized lines do contain something "
"you want to see.  Output from the linker, for example, about an undefined "
"function.  To see all the messages add a \"!\" to the command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:103
#, no-wrap
msgid ""
"\t:clist!\n"
"<\t1 gcc -g -Wall -o prog main.c sub.c ~\n"
"\t2 main.c: In function 'main': ~\n"
"\t3 main.c:6: too many arguments to function 'do_sub' ~\n"
"\t4 main.c: At top level: ~\n"
"\t5 main.c:10: parse error before '}' ~\n"
"\t6 make: *** [prog] Error 1 ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:107
#, no-wrap
msgid ""
"Vim will highlight the current error.  To go back to the previous error, use:\n"
">\n"
"\t:cprevious\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:109
msgid "Other commands to move around in the error list:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:113
#, no-wrap
msgid ""
"\t:cfirst\t\tto first error\n"
"\t:clast\t\tto last error\n"
"\t:cc 3\t\tto error nr 3\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:116
msgid "USING ANOTHER COMPILER"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:120
msgid ""
"The name of the program to run when the \":make\" command is executed is "
"defined by the 'makeprg' option.  Usually this is set to \"make\", but "
"Visual C++ users should set this to \"nmake\" by executing the following "
"command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:122
#, no-wrap
msgid "\t:set makeprg=nmake\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:125
msgid ""
"You can also include arguments in this option.  Special characters need to "
"be escaped with a backslash.  Example: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:127
#, no-wrap
msgid "\t:set makeprg=nmake\\ -f\\ project.mak\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:132
#, no-wrap
msgid ""
"You can include special Vim keywords in the command specification.  The %\n"
"character expands to the name of the current file.  So if you execute the\n"
"command: >\n"
"\t:set makeprg=make\\ %\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:134
msgid ""
"When you are editing main.c, then \":make\" executes the following command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:136
#, no-wrap
msgid "\tmake main.c\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:139
msgid ""
"This is not too useful, so you will refine the command a little and use the :"
"r (root) modifier: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:141
#, no-wrap
msgid "\t:set makeprg=make\\ %:r.o\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:143
msgid "Now the command executed is as follows: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:145
#, no-wrap
msgid "\tmake main.o\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:147
msgid "More about these modifiers here: |filename-modifiers|."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:150
msgid "OLD ERROR LISTS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:156
msgid ""
"Suppose you \":make\" a program.  There is a warning message in one file and "
"an error message in another.  You fix the error and use \":make\" again to "
"check if it was really fixed.  Now you want to look at the warning message.  "
"It doesn't show up in the last error list, since the file with the warning "
"wasn't compiled again.  You can go back to the previous error list with: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:158
#, no-wrap
msgid "\t:colder\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:161
#, no-wrap
msgid ""
"Then use \":clist\" and \":cc {nr}\" to jump to the place with the warning.\n"
"   To go forward to the next error list: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:163
#, no-wrap
msgid "\t:cnewer\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:165
msgid "Vim remembers ten error lists."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:168
msgid "SWITCHING COMPILERS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:173
msgid ""
"You have to tell Vim what format the error messages are that your compiler "
"produces.  This is done with the 'errorformat' option.  The syntax of this "
"option is quite complicated and it can be made to fit almost any compiler.  "
"You can find the explanation here: |errorformat|."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:178
msgid ""
"You might be using various different compilers.  Setting the 'makeprg' "
"option, and especially the 'errorformat' each time is not easy.  Vim offers "
"a simple method for this.  For example, to switch to using the Microsoft "
"Visual C++ compiler: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:180
#, no-wrap
msgid "\t:compiler msvc\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:184
#, no-wrap
msgid ""
"This will find the Vim script for the \"msvc\" compiler and set the appropriate\n"
"options.\n"
"   You can write your own compiler files.  See |write-compiler-plugin|.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:187
msgid "OUTPUT REDIRECTION"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:193
msgid ""
"The \":make\" command redirects the output of the executed program to an "
"error file.  How this works depends on various things, such as the 'shell'.  "
"If your \":make\" command doesn't capture the output, check the 'makeef' and "
"'shellpipe' options.  The 'shellquote' and 'shellxquote' options might also "
"matter."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:197
msgid ""
"In case you can't get \":make\" to redirect the file for you, an alternative "
"is to compile the program in another window and redirect the output into a "
"file.  Then have Vim read this file with: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:199
#, no-wrap
msgid "\t:cfile {filename}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:201
msgid "Jumping to errors will work like with the \":make\" command."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:204
#, no-wrap
msgid "*30.2*\tIndenting C style text\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:211
msgid ""
"A program is much easier to understand when the lines have been properly "
"indented.  Vim offers various ways to make this less work.  For C or C style "
"programs like Java or C++, set the 'cindent' option.  Vim knows a lot about "
"C programs and will try very hard to automatically set the indent for you.  "
"Set the 'shiftwidth' option to the amount of spaces you want for a deeper "
"level.  Four spaces will work fine.  One \":set\" command will do it: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:213
#, no-wrap
msgid "\t:set cindent shiftwidth=4\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:216
msgid ""
"With this option enabled, when you type something such as \"if (x)\", the "
"next line will automatically be indented an additional level."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:223
#, no-wrap
msgid ""
"\t\t\t\t    if (flag)\n"
"\tAutomatic indent   --->\t\tdo_the_work();\n"
"\tAutomatic unindent <--\t    if (other_flag) {\n"
"\tAutomatic indent   --->\t\tdo_file();\n"
"\tkeep indent\t\t\tdo_some_more();\n"
"\tAutomatic unindent <--\t    }\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:227
msgid ""
"When you type something in curly braces ({}), the text will be indented at "
"the start and unindented at the end.  The unindenting will happen after "
"typing the '}', since Vim can't guess what you are going to type."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:235
#, no-wrap
msgid ""
"One side effect of automatic indentation is that it helps you catch errors in\n"
"your code early.  When you type a } to finish a function, only to find that\n"
"the automatic indentation gives it more indent than what you expected, there\n"
"is probably a } missing.  Use the \"%\" command to find out which { matches the\n"
"} you typed.\n"
"   A missing ) and ; also cause extra indent.  Thus if you get more white\n"
"space than you would expect, check the preceding lines.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:239
msgid ""
"When you have code that is badly formatted, or you inserted and deleted "
"lines, you need to re-indent the lines.  The \"=\" operator does this.  The "
"simplest form is: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:241
#, no-wrap
msgid "\t==\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:246
msgid ""
"This indents the current line.  Like with all operators, there are three "
"ways to use it.  In Visual mode \"=\" indents the selected lines.  A useful "
"text object is \"a{\".  This selects the current {} block.  Thus, to re-"
"indent the code block the cursor is in: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:248
#, no-wrap
msgid "\t=a{\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:252
#, no-wrap
msgid ""
"I you have really badly indented code, you can re-indent the whole file with:\n"
">\n"
"\tgg=G\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:256
msgid ""
"However, don't do this in files that have been carefully indented manually.  "
"The automatic indenting does a good job, but in some situations you might "
"want to overrule it."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:259
msgid "SETTING INDENT STYLE"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:267
#, no-wrap
msgid ""
"Different people have different styles of indentation.  By default Vim does a\n"
"pretty good job of indenting in a way that 90% of programmers do.  There are\n"
"different styles, however; so if you want to, you can customize the\n"
"indentation style with the 'cinoptions' option.\n"
"   By default 'cinoptions' is empty and Vim uses the default style.  You can\n"
"add various items where you want something different.  For example, to make\n"
"curly braces be placed like this:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:273
#, no-wrap
msgid ""
"\tif (flag) ~\n"
"\t  { ~\n"
"\t    i = 8; ~\n"
"\t    j = 0; ~\n"
"\t  } ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:275
msgid "Use this command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:277
#, no-wrap
msgid "\t:set cinoptions+={2\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:279
msgid "There are many of these items.  See |cinoptions-values|."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:282
#, no-wrap
msgid "*30.3*\tAutomatic indenting\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:285
msgid ""
"You don't want to switch on the 'cindent' option manually every time you "
"edit a C file.  This is how you make it work automatically: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:287
#, no-wrap
msgid "\t:filetype indent on\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:295
#, no-wrap
msgid ""
"Actually, this does a lot more than switching on 'cindent' for C files.  First\n"
"of all, it enables detecting the type of a file.  That's the same as what is\n"
"used for syntax highlighting.\n"
"   When the filetype is known, Vim will search for an indent file for this\n"
"type of file.  The Vim distribution includes a number of these for various\n"
"programming languages.  This indent file will then prepare for automatic\n"
"indenting specifically for this file.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:297
msgid ""
"If you don't like the automatic indenting, you can switch it off again: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:299
#, no-wrap
msgid "\t:filetype indent off\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:302
msgid ""
"If you don't like the indenting for one specific type of file, this is how "
"you avoid it.  Create a file with just this one line: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:304
#, no-wrap
msgid "\t:let b:did_indent = 1\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:306
msgid "Now you need to write this in a file with a specific name:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:308
#, no-wrap
msgid "\t{directory}/indent/{filetype}.vim\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:311
msgid ""
"The {filetype} is the name of the file type, such as \"cpp\" or \"java\".  "
"You can see the exact name that Vim detected with this command: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:313
#, no-wrap
msgid "\t:set filetype\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:315
msgid "In this file the output is:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:317
#, no-wrap
msgid "\tfiletype=help ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:321
#, no-wrap
msgid ""
"Thus you would use \"help\" for {filetype}.\n"
"   For the {directory} part you need to use your runtime directory.  Look at\n"
"the output of this command: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:323
#, no-wrap
msgid "\tset runtimepath\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:326
msgid ""
"Now use the first item, the name before the first comma.  Thus if the output "
"looks like this:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:328
#, no-wrap
msgid "\truntimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:330
msgid "You use \"~/.vim\" for {directory}.  Then the resulting file name is:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:332
#, no-wrap
msgid "\t~/.vim/indent/help.vim ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:335
msgid ""
"Instead of switching the indenting off, you could write your own indent "
"file.  How to do that is explained here: |indent-expression|."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:338
#, no-wrap
msgid "*30.4*\tOther indenting\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:349
#, no-wrap
msgid ""
"The most simple form of automatic indenting is with the 'autoindent' option.\n"
"It uses the indent from the previous line.  A bit smarter is the 'smartindent'\n"
"option.  This is useful for languages where no indent file is available.\n"
"'smartindent' is not as smart as 'cindent', but smarter than 'autoindent'.\n"
"   With 'smartindent' set, an extra level of indentation is added for each {\n"
"and removed for each }.  An extra level of indentation will also be added for\n"
"any of the words in the 'cinwords' option.  Lines that begin with # are\n"
"treated specially: all indentation is removed.  This is done so that\n"
"preprocessor directives will all start in column 1.  The indentation is\n"
"restored for the next line.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:352
msgid "CORRECTING INDENTS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:359
#, no-wrap
msgid ""
"When you are using 'autoindent' or 'smartindent' to get the indent of the\n"
"previous line, there will be many times when you need to add or remove one\n"
"'shiftwidth' worth of indent.  A quick way to do this is using the CTRL-D and\n"
"CTRL-T commands in Insert mode.\n"
"   For example, you are typing a shell script that is supposed to look like\n"
"this:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:364
#, no-wrap
msgid ""
"\tif test -n a; then ~\n"
"\t   echo a ~\n"
"\t   echo \"-------\" ~\n"
"\tfi ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:366
msgid "Start off by setting these options: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:368
#, no-wrap
msgid "\t:set autoindent shiftwidth=3\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:370
msgid ""
"You start by typing the first line, <Enter> and the start of the second line:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:373
#, no-wrap
msgid ""
"\tif test -n a; then ~\n"
"\techo ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:375
msgid "Now you see that you need an extra indent.  Type CTRL-T.  The result:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:378
#, no-wrap
msgid ""
"\tif test -n a; then ~\n"
"\t   echo ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:383
#, no-wrap
msgid ""
"The CTRL-T command, in Insert mode, adds one 'shiftwidth' to the indent, no\n"
"matter where in the line you are.\n"
"   You continue typing the second line, <Enter> and the third line.  This time\n"
"the indent is OK.  Then <Enter> and the last line.  Now you have this:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:388
#, no-wrap
msgid ""
"\tif test -n a; then ~\n"
"\t   echo a ~\n"
"\t   echo \"-------\" ~\n"
"\t   fi ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:394
#, no-wrap
msgid ""
"To remove the superfluous indent in the last line press CTRL-D.  This deletes\n"
"one 'shiftwidth' worth of indent, no matter where you are in the line.\n"
"   When you are in Normal mode, you can use the \">>\" and \"<<\" commands to\n"
"shift lines.  \">\" and \"<\" are operators, thus you have the usual three ways to\n"
"specify the lines you want to indent.  A useful combination is: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:396
#, no-wrap
msgid "\t>i{\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:400
msgid ""
"This adds one indent to the current block of lines, inside {}.  The { and } "
"lines themselves are left unmodified.  \">a{\" includes them.  In this "
"example the cursor is on \"printf\":"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:402
#, no-wrap
msgid "\toriginal text\t\tafter \">i{\"\t\tafter \">a{\"\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:408
#, no-wrap
msgid ""
"\tif (flag)\t\tif (flag)\t\tif (flag) ~\n"
"\t{\t\t\t{\t\t\t    { ~\n"
"\tprintf(\"yes\");\t\t    printf(\"yes\");\t    printf(\"yes\"); ~\n"
"\tflag = 0;\t\t    flag = 0;\t\t    flag = 0;  ~\n"
"\t}\t\t\t}\t\t\t    } ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:411
#, no-wrap
msgid "*30.5*\tTabs and spaces\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:425
#, no-wrap
msgid ""
"'tabstop' is set to eight by default.  Although you can change it, you quickly\n"
"run into trouble later.  Other programs won't know what tabstop value you\n"
"used.  They probably use the default value of eight, and your text suddenly\n"
"looks very different.  Also, most printers use a fixed tabstop value of eight.\n"
"Thus it's best to keep 'tabstop' alone.  (If you edit a file which was written\n"
"with a different tabstop setting, see |25.3| for how to fix that.)\n"
"   For indenting lines in a program, using a multiple of eight spaces makes\n"
"you quickly run into the right border of the window.  Using a single space\n"
"doesn't provide enough visual difference.  Many people prefer to use four\n"
"spaces, a good compromise.\n"
"   Since a <Tab> is eight spaces and you want to use an indent of four spaces,\n"
"you can't use a <Tab> character to make your indent.  There are two ways to\n"
"handle this:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:429
#, no-wrap
msgid ""
"1.  Use a mix of <Tab> and space characters.  Since a <Tab> takes the place of\n"
"    eight spaces, you have fewer characters in your file.  Inserting a <Tab>\n"
"    is quicker than eight spaces.  Backspacing works faster as well.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:432
#, no-wrap
msgid ""
"2.  Use spaces only.  This avoids the trouble with programs that use a\n"
"    different tabstop value.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:434
msgid "Fortunately, Vim supports both methods quite well."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:437
msgid "SPACES AND TABS"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:446
#, no-wrap
msgid ""
"If you are using a combination of tabs and spaces, you just edit normally.\n"
"The Vim defaults do a fine job of handling things.\n"
"   You can make life a little easier by setting the 'softtabstop' option.\n"
"This option tells Vim to make the <Tab> key look and feel as if tabs were set\n"
"at the value of 'softtabstop', but actually use a combination of tabs and\n"
"spaces.\n"
"   After you execute the following command, every time you press the <Tab> key\n"
"the cursor moves to the next 4-column boundary: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:458
#, no-wrap
msgid ""
"When you start in the first column and press <Tab>, you get 4 spaces inserted\n"
"in your text.  The second time, Vim takes out the 4 spaces and puts in a <Tab>\n"
"(thus taking you to column 8).  Thus Vim uses as many <Tab>s as possible, and\n"
"then fills up with spaces.\n"
"   When backspacing it works the other way around.  A <BS> will always delete\n"
"the amount specified with 'softtabstop'.  Then <Tab>s are used as many as\n"
"possible and spaces to fill the gap.\n"
"   The following shows what happens pressing <Tab> a few times, and then using\n"
"<BS>.  A \".\" stands for a space and \"------->\" for a <Tab>.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:465
#, no-wrap
msgid ""
"\ttype\t\t\t  result ~\n"
"\t<Tab>\t\t\t  ....\n"
"\t<Tab><Tab>\t\t  ------->\n"
"\t<Tab><Tab><Tab>\t\t  ------->....\n"
"\t<Tab><Tab><Tab><BS>\t  ------->\n"
"\t<Tab><Tab><Tab><BS><BS>   ....\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:470
msgid ""
"An alternative is to use the 'smarttab' option.  When it's set, Vim uses "
"'shiftwidth' for a <Tab> typed in the indent of a line, and a real <Tab> "
"when typed after the first non-blank character.  However, <BS> doesn't work "
"like with 'softtabstop'."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:473
msgid "JUST SPACES"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:476
msgid ""
"If you want absolutely no tabs in your file, you can set the 'expandtab' "
"option: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:478
#, no-wrap
msgid "\t:set expandtab\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:485
#, no-wrap
msgid ""
"When this option is set, the <Tab> key inserts a series of spaces.  Thus you\n"
"get the same amount of white space as if a <Tab> character was inserted, but\n"
"there isn't a real <Tab> character in your file.\n"
"   The backspace key will delete each space by itself.  Thus after typing one\n"
"<Tab> you have to press the <BS> key up to eight times to undo it.  If you are\n"
"in the indent, pressing CTRL-D will be a lot quicker.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:488
msgid "CHANGING TABS IN SPACES (AND BACK)"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:492
msgid ""
"Setting 'expandtab' does not affect any existing tabs.  In other words, any "
"tabs in the document remain tabs.  If you want to convert tabs to spaces, "
"use the \":retab\" command.  Use these commands: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:495
#, no-wrap
msgid ""
"\t:set expandtab\n"
"\t:%retab\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:499
msgid ""
"Now Vim will have changed all indents to use spaces instead of tabs.  "
"However, all tabs that come after a non-blank character are kept.  If you "
"want these to be converted as well, add a !: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:501
#, no-wrap
msgid "\t:%retab!\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:504
msgid ""
"This is a little bit dangerous, because it can also change tabs inside a "
"string.  To check if these exist, you could use this: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:506
#, no-wrap
msgid "\t/\"[^\"\\t]*\\t[^\"]*\"\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:509
msgid ""
"It's recommended not to use hard tabs inside a string.  Replace them with "
"\"\\t\" to avoid trouble."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:511
msgid "The other way around works just as well: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:514
#, no-wrap
msgid ""
"\t:set noexpandtab\n"
"\t:%retab!\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:517
#, no-wrap
msgid "*30.6*\tFormatting comments\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:521
#, no-wrap
msgid ""
"One of the great things about Vim is that it understands comments.  You can\n"
"ask Vim to format a comment and it will do the right thing.\n"
"   Suppose, for example, that you have the following comment:\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:526
#, no-wrap
msgid ""
"\t/* ~\n"
"\t * This is a test ~\n"
"\t * of the text formatting. ~\n"
"\t */ ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:529
msgid ""
"You then ask Vim to format it by positioning the cursor at the start of the "
"comment and type: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:531
#, no-wrap
msgid "\tgq]/\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:534
msgid ""
"\"gq\" is the operator to format text.  \"]/\" is the motion that takes you "
"to the end of a comment.  The result is:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:538
#, no-wrap
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t */ ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:542
#, no-wrap
msgid ""
"Notice that Vim properly handled the beginning of each line.\n"
"  An alternative is to select the text that is to be formatted in Visual mode\n"
"and type \"gq\".\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:545
msgid ""
"To add a new line to the comment, position the cursor on the middle line and "
"press \"o\".  The result looks like this:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:550
#, no-wrap
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t * ~\n"
"\t */ ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:554
msgid ""
"Vim has automatically inserted a star and a space for you.  Now you can type "
"the comment text.  When it gets longer than 'textwidth', Vim will break the "
"line.  Again, the star is inserted automatically:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:560
#, no-wrap
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t * Typing a lot of text here will make Vim ~\n"
"\t * break ~\n"
"\t */ ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:562
msgid "For this to work some flags must be present in 'formatoptions':"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:566
#, no-wrap
msgid ""
"\tr\tinsert the star when typing <Enter> in Insert mode\n"
"\to\tinsert the star when using \"o\" or \"O\" in Normal mode\n"
"\tc\tbreak comment text according to 'textwidth'\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:568
msgid "See |fo-table| for more flags."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:571
msgid "DEFINING A COMMENT"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:578
#, no-wrap
msgid ""
"The 'comments' option defines what a comment looks like.  Vim distinguishes\n"
"between a single-line comment and a comment that has a different start, end\n"
"and middle part.\n"
"   Many single-line comments start with a specific character.  In C++ // is\n"
"used, in Makefiles #, in Vim scripts \".  For example, to make Vim understand\n"
"C++ comments: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:580
#, no-wrap
msgid "\t:set comments=://\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:583
msgid ""
"The colon separates the flags of an item from the text by which the comment "
"is recognized.  The general form of an item in 'comments' is:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:585
#, no-wrap
msgid "\t{flags}:{text}\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:591
#, no-wrap
msgid ""
"The {flags} part can be empty, as in this case.\n"
"   Several of these items can be concatenated, separated by commas.  This\n"
"allows recognizing different types of comments at the same time.  For example,\n"
"let's edit an e-mail message.  When replying, the text that others wrote is\n"
"preceded with \">\" and \"!\" characters.  This command would work: >\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:593
#, no-wrap
msgid "\t:set comments=n:>,n:!\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:598
msgid ""
"There are two items, one for comments starting with \">\" and one for "
"comments that start with \"!\".  Both use the flag \"n\".  This means that "
"these comments nest.  Thus a line starting with \">\" may have another "
"comment after the \">\".  This allows formatting a message like this:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:605
#, no-wrap
msgid ""
"\t> ! Did you see that site? ~\n"
"\t> ! It looks really great. ~\n"
"\t> I don't like it.  The ~\n"
"\t> colors are terrible. ~\n"
"\tWhat is the URL of that ~\n"
"\tsite? ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:608
msgid ""
"Try setting 'textwidth' to a different value, e.g., 80, and format the text "
"by Visually selecting it and typing \"gq\".  The result is:"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:612
#, no-wrap
msgid ""
"\t> ! Did you see that site?  It looks really great. ~\n"
"\t> I don't like it.  The colors are terrible. ~\n"
"\tWhat is the URL of that site? ~\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:617
msgid ""
"You will notice that Vim did not move text from one type of comment to "
"another.  The \"I\" in the second line would have fit at the end of the "
"first line, but since that line starts with \"> !\" and the second line with "
"\">\", Vim knows that this is a different kind of comment."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:620
msgid "A THREE PART COMMENT"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:623
msgid ""
"A C comment starts with \"/*\", has \"*\" in the middle and \"*/\" at the "
"end.  The entry in 'comments' for this looks like this: >"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:625
#, no-wrap
msgid "\t:set comments=s1:/*,mb:*,ex:*/\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:636
#, no-wrap
msgid ""
"The start is defined with \"s1:/*\".  The \"s\" indicates the start of a\n"
"three-piece comment.  The colon separates the flags from the text by which the\n"
"comment is recognized: \"/*\".  There is one flag: \"1\".  This tells Vim that the\n"
"middle part has an offset of one space.\n"
"   The middle part \"mb:*\" starts with \"m\", which indicates it is a middle\n"
"part.  The \"b\" flag means that a blank must follow the text.  Otherwise Vim\n"
"would consider text like \"*pointer\" also to be the middle of a comment.\n"
"   The end part \"ex:*/\" has the \"e\" for identification.  The \"x\" flag has a\n"
"special meaning.  It means that after Vim automatically inserted a star,\n"
"typing / will remove the extra space.\n"
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:638
msgid "For more details see |format-comments|."
msgstr ""

#. type: Plain text
#: original/TXT/usr_30.txt:642
msgid "Next chapter: |usr_31.txt| Exploiting the GUI"
msgstr ""
