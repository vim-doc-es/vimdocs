#. extracted from usr_25.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-04 13:40+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_25.txt:1
msgid "*usr_25.txt*\tFor Vim version 7.2.  Last change: 2007 May 11"
msgstr ""

#: usr_25.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_25.txt:5
msgid "\t\t\t     Editing formatted text"
msgstr ""

#: usr_25.txt:8
msgid ""
"Text hardly ever comes in one sentence per line.  This chapter is about\n"
"breaking sentences to make them fit on a page and other formatting.\n"
"Vim also has useful features for editing single-line paragraphs and tables."
msgstr ""

#: usr_25.txt:12
msgid ""
"|25.1|\tBreaking lines\n"
"|25.2|\tAligning text\n"
"|25.3|\tIndents and tabs\n"
"|25.4|\tDealing with long lines\n"
"|25.5|\tEditing tables"
msgstr ""

#: usr_25.txt:18
msgid ""
"     Next chapter: |usr_26.txt|  Repeating\n"
" Previous chapter: |usr_24.txt|  Inserting quickly\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_25.txt:22
msgid ""
"============================================================================"
"==\n"
"*25.1*\tBreaking lines"
msgstr ""

#: usr_25.txt:25
msgid ""
"Vim has a number of functions that make dealing with text easier.  By "
"default,\n"
"the editor does not perform automatic line breaks.  In other words, you have\n"
"to press <Enter> yourself.  This is useful when you are writing programs "
"where\n"
"you want to decide where the line ends.  It is not so good when you are\n"
"creating documentation and want the text to be at most 70 character wide.\n"
"   If you set the 'textwidth' option, Vim automatically inserts line breaks.\n"
"Suppose, for example, that you want a very narrow column of only 30\n"
"characters.  You need to execute the following command: >"
msgstr ""

#: usr_25.txt:34
msgid "\t:set textwidth=30"
msgstr ""

#: usr_25.txt:36
msgid "Now you start typing (ruler added):"
msgstr ""

#: usr_25.txt:38
msgid ""
"\t\t 1\t   2\t     3\n"
"\t12345678901234567890123456789012345\n"
"\tI taught programming for a whi ~"
msgstr ""

#: usr_25.txt:42
msgid ""
"If you type \"l\" next, this makes the line longer than the 30-character "
"limit.\n"
"When Vim sees this, it inserts a line break and you get the following:"
msgstr ""

#: usr_25.txt:45
msgid ""
"\t\t 1\t   2\t     3\n"
"\t12345678901234567890123456789012345\n"
"\tI taught programming for a ~\n"
"\twhil ~"
msgstr ""

#: usr_25.txt:50
msgid "Continuing on, you can type in the rest of the paragraph:"
msgstr ""

#: usr_25.txt:52
msgid ""
"\t\t 1\t   2\t     3\n"
"\t12345678901234567890123456789012345\n"
"\tI taught programming for a ~\n"
"\twhile. One time, I was stopped ~\n"
"\tby the Fort Worth police, ~\n"
"\tbecause my homework was too ~\n"
"\thard. True story. ~"
msgstr ""

#: usr_25.txt:60
msgid "You do not have to type newlines; Vim puts them in automatically."
msgstr ""

#: usr_25.txt:62
msgid ""
"\tNote:\n"
"\tThe 'wrap' option makes Vim display lines with a line break, but this\n"
"\tdoesn't insert a line break in the file."
msgstr ""

#: usr_25.txt:67
msgid "REFORMATTING"
msgstr ""

#: usr_25.txt:69
msgid ""
"The Vim editor is not a word processor.  In a word processor, if you delete\n"
"something at the beginning of the paragraph, the line breaks are reworked.  "
"In\n"
"Vim they are not; so if you delete the word \"programming\" from the first "
"line,\n"
"all you get is a short line:"
msgstr ""

#: usr_25.txt:74
msgid ""
"\t\t 1\t   2\t     3\n"
"\t12345678901234567890123456789012345\n"
"\tI taught for a ~\n"
"\twhile. One time, I was stopped ~\n"
"\tby the Fort Worth police, ~\n"
"\tbecause my homework was too ~\n"
"\thard. True story. ~"
msgstr ""

#: usr_25.txt:82
msgid ""
"This does not look good.  To get the paragraph into shape you use the \"gq\"\n"
"operator.\n"
"   Let's first use this with a Visual selection.  Starting from the first\n"
"line, type: >"
msgstr ""

#: usr_25.txt:87
msgid "\tv4jgq"
msgstr ""

#: usr_25.txt:89
msgid ""
"\"v\" to start Visual mode, \"4j' to move to the end of the paragraph and then\n"
"the \"gq\" operator.  The result is:"
msgstr ""

#: usr_25.txt:92
msgid ""
"\t\t 1\t   2\t     3\n"
"\t12345678901234567890123456789012345\n"
"\tI taught for a while. One ~\n"
"\ttime, I was stopped by the ~\n"
"\tFort Worth police, because my ~\n"
"\thomework was too hard. True ~\n"
"\tstory. ~"
msgstr ""

#: usr_25.txt:100
msgid ""
"Note: there is a way to do automatic formatting for specific types of text\n"
"layouts, see |auto-format|."
msgstr ""

#: usr_25.txt:103
msgid ""
"Since \"gq\" is an operator, you can use one of the three ways to select the\n"
"text it works on: With Visual mode, with a movement and with a text object.\n"
"   The example above could also be done with \"gq4j\".  That's less typing, "
"but\n"
"you have to know the line count.  A more useful motion command is \"}\".  This\n"
"moves to the end of a paragraph.  Thus \"gq}\" formats from the cursor to the\n"
"end of the current paragraph.\n"
"   A very useful text object to use with \"gq\" is the paragraph.  Try this: >"
msgstr ""

#: usr_25.txt:111
msgid "\tgqap"
msgstr ""

#: usr_25.txt:113
msgid ""
"\"ap\" stands for \"a-paragraph\".  This formats the text of one paragraph\n"
"(separated by empty lines).  Also the part before the cursor.\n"
"   If you have your paragraphs separated by empty lines, you can format the\n"
"whole file by typing this: >"
msgstr ""

#: usr_25.txt:118
msgid "\tgggqG"
msgstr ""

#: usr_25.txt:120
msgid ""
"\"gg\" to move to the first line, \"gqG\" to format until the last line.\n"
"   Warning: If your paragraphs are not properly separated, they will be "
"joined\n"
"together.  A common mistake is to have a line with a space or tab.  That's a\n"
"blank line, but not an empty line."
msgstr ""

#: usr_25.txt:125
msgid ""
"Vim is able to format more than just plain text.  See |fo-table| for how to\n"
"change this.  See the 'joinspaces' option to change the number of spaces "
"used\n"
"after a full stop.\n"
"   It is possible to use an external program for formatting.  This is useful\n"
"if your text can't be properly formatted with Vim's builtin command.  See "
"the\n"
"'formatprg' option."
msgstr ""

#: usr_25.txt:132
msgid ""
"============================================================================"
"==\n"
"*25.2*\tAligning text"
msgstr ""

#: usr_25.txt:135
msgid "To center a range of lines, use the following command: >"
msgstr ""

#: usr_25.txt:137
msgid "\t:{range}center [width]"
msgstr ""

#: usr_25.txt:139
msgid ""
"{range} is the usual command-line range.  [width] is an optional line width "
"to\n"
"use for centering.  If [width] is not specified, it defaults to the value of\n"
"'textwidth'.  (If 'textwidth' is 0, the default is 80.)\n"
"   For example: >"
msgstr ""

#: usr_25.txt:144
msgid "\t:1,5center 40"
msgstr ""

#: usr_25.txt:146
msgid "results in the following:"
msgstr ""

#: usr_25.txt:148
msgid ""
"       I taught for a while. One ~\n"
"       time, I was stopped by the ~\n"
"     Fort Worth police, because my ~\n"
"      homework was too hard. True ~\n"
"\t\t story. ~"
msgstr ""

#: usr_25.txt:155
msgid "RIGHT ALIGNMENT"
msgstr ""

#: usr_25.txt:157
msgid "Similarly, the \":right\" command right-justifies the text: >"
msgstr ""

#: usr_25.txt:159
msgid "\t:1,5right 37"
msgstr ""

#: usr_25.txt:161
msgid "gives this result:"
msgstr ""

#: usr_25.txt:163
msgid ""
"\t    I taught for a while. One ~\n"
"\t   time, I was stopped by the ~\n"
"\tFort Worth police, because my ~\n"
"\t  homework was too hard. True ~\n"
"\t\t\t       story. ~"
msgstr ""

#: usr_25.txt:169
msgid "LEFT ALIGNMENT"
msgstr ""

#: usr_25.txt:171
msgid "Finally there is this command: >"
msgstr ""

#: usr_25.txt:173
msgid "\t:{range}left [margin]"
msgstr ""

#: usr_25.txt:175
msgid ""
"Unlike \":center\" and \":right\", however, the argument to \":left\" is not the\n"
"length of the line.  Instead it is the left margin.  If it is omitted, the\n"
"text will be put against the left side of the screen (using a zero margin\n"
"would do the same).  If it is 5, the text will be indented 5 spaces.  For\n"
"example, use these commands: >"
msgstr ""

#: usr_25.txt:181
msgid ""
"\t:1left 5\n"
"\t:2,5left"
msgstr ""

#: usr_25.txt:184
msgid "This results in the following:"
msgstr ""

#: usr_25.txt:186
msgid ""
"\t     I taught for a while. One ~\n"
"\ttime, I was stopped by the ~\n"
"\tFort Worth police, because my ~\n"
"\thomework was too hard. True ~\n"
"\tstory. ~"
msgstr ""

#: usr_25.txt:193
msgid "JUSTIFYING TEXT"
msgstr ""

#: usr_25.txt:195
msgid ""
"Vim has no built-in way of justifying text.  However, there is a neat macro\n"
"package that does the job.  To use this package, execute the following\n"
"command: >"
msgstr ""

#: usr_25.txt:199
msgid "\t:runtime macros/justify.vim"
msgstr ""

#: usr_25.txt:201
msgid ""
"This Vim script file defines a new visual command \"_j\".  To justify a block "
"of\n"
"text, highlight the text in Visual mode and then execute \"_j\".\n"
"   Look in the file for more explanations.  To go there, do \"gf\" on this "
"name:\n"
"$VIMRUNTIME/macros/justify.vim."
msgstr ""

#: usr_25.txt:206
msgid ""
"An alternative is to filter the text through an external program.  Example: "
">"
msgstr ""

#: usr_25.txt:208
msgid "\t:%!fmt"
msgstr ""

#: usr_25.txt:210
msgid ""
"============================================================================"
"==\n"
"*25.3*\tIndents and tabs"
msgstr ""

#: usr_25.txt:213
msgid ""
"Indents can be used to make text stand out from the rest.  The example texts\n"
"in this manual, for example, are indented by eight spaces or a tab.  You "
"would\n"
"normally enter this by typing a tab at the start of each line.  Take this\n"
"text:\n"
"\tthe first line ~\n"
"\tthe second line ~"
msgstr ""

#: usr_25.txt:220
msgid ""
"This is entered by typing a tab, some text, <Enter>, tab and more text.\n"
"   The 'autoindent' option inserts indents automatically: >"
msgstr ""

#: usr_25.txt:223
msgid "\t:set autoindent"
msgstr ""

#: usr_25.txt:225
msgid ""
"When a new line is started it gets the same indent as the previous line.  In\n"
"the above example, the tab after the <Enter> is not needed anymore."
msgstr ""

#: usr_25.txt:229
msgid "INCREASING INDENT"
msgstr ""

#: usr_25.txt:231
msgid ""
"To increase the amount of indent in a line, use the \">\" operator.  Often "
"this\n"
"is used as \">>\", which adds indent to the current line.\n"
"   The amount of indent added is specified with the 'shiftwidth' option.  "
"The\n"
"default value is 8.  To make \">>\" insert four spaces worth of indent, for\n"
"example, type this: >"
msgstr ""

#: usr_25.txt:237
msgid "\t:set shiftwidth=4"
msgstr ""

#: usr_25.txt:239
msgid "When used on the second line of the example text, this is what you get:"
msgstr ""

#: usr_25.txt:241
msgid ""
"\tthe first line ~\n"
"\t    the second line ~"
msgstr ""

#: usr_25.txt:244
msgid "\"4>>\" will increase the indent of four lines."
msgstr ""

#: usr_25.txt:247
msgid "TABSTOP"
msgstr ""

#: usr_25.txt:249
msgid ""
"If you want to make indents a multiple of 4, you set 'shiftwidth' to 4.  But\n"
"when pressing a <Tab> you still get 8 spaces worth of indent.  To change "
"this,\n"
"set the 'softtabstop' option: >"
msgstr ""

#: usr_25.txt:253
msgid "\t:set softtabstop=4"
msgstr ""

#: usr_25.txt:255
msgid ""
"This will make the <Tab> key insert 4 spaces worth of indent.  If there are\n"
"already four spaces, a <Tab> character is used (saving seven characters in "
"the\n"
"file).  (If you always want spaces and no tab characters, set the "
"'expandtab'\n"
"option.)"
msgstr ""

#: usr_25.txt:260
msgid ""
"\tNote:\n"
"\tYou could set the 'tabstop' option to 4.  However, if you edit the\n"
"\tfile another time, with 'tabstop' set to the default value of 8, it\n"
"\twill look wrong.  In other programs and when printing the indent will\n"
"\talso be wrong.  Therefore it is recommended to keep 'tabstop' at eight\n"
"\tall the time.  That's the standard value everywhere."
msgstr ""

#: usr_25.txt:268
msgid "CHANGING TABS"
msgstr ""

#: usr_25.txt:270
msgid ""
"You edit a file which was written with a tabstop of 3.  In Vim it looks "
"ugly,\n"
"because it uses the normal tabstop value of 8.  You can fix this by setting\n"
"'tabstop' to 3.  But you have to do this every time you edit this file.\n"
"   Vim can change the use of tabstops in your file.  First, set 'tabstop' to\n"
"make the indents look good, then use the \":retab\" command: >"
msgstr ""

#: usr_25.txt:276
msgid ""
"\t:set tabstop=3\n"
"\t:retab 8"
msgstr ""

#: usr_25.txt:279
msgid ""
"The \":retab\" command will change 'tabstop' to 8, while changing the text "
"such\n"
"that it looks the same.  It changes spans of white space into tabs and "
"spaces\n"
"for this.  You can now write the file.  Next time you edit it the indents "
"will\n"
"be right without setting an option.\n"
"   Warning: When using \":retab\" on a program, it may change white space "
"inside\n"
"a string constant.  Therefore it's a good habit to use \"\\t\" instead of a\n"
"real tab."
msgstr ""

#: usr_25.txt:287
msgid ""
"============================================================================"
"==\n"
"*25.4*\tDealing with long lines"
msgstr ""

#: usr_25.txt:290
msgid ""
"Sometimes you will be editing a file that is wider than the number of "
"columns\n"
"in the window.  When that occurs, Vim wraps the lines so that everything "
"fits\n"
"on the screen.\n"
"   If you switch the 'wrap' option off, each line in the file shows up as "
"one\n"
"line on the screen.  Then the ends of the long lines disappear off the "
"screen\n"
"to the right.\n"
"   When you move the cursor to a character that can't be seen, Vim will "
"scroll\n"
"the text to show it.  This is like moving a viewport over the text in the\n"
"horizontal direction.\n"
"   By default, Vim does not display a horizontal scrollbar in the GUI.  If "
"you\n"
"want to enable one, use the following command: >"
msgstr ""

#: usr_25.txt:302
msgid "\t:set guioptions+=b"
msgstr ""

#: usr_25.txt:304
msgid "One horizontal scrollbar will appear at the bottom of the Vim window."
msgstr ""

#: usr_25.txt:306
msgid ""
"If you don't have a scrollbar or don't want to use it, use these commands to\n"
"scroll the text.  The cursor will stay in the same place, but it's move back\n"
"into the visible text if necessary."
msgstr ""

#: usr_25.txt:310
msgid ""
"\tzh\t\tscroll right\n"
"\t4zh\t\tscroll four characters right\n"
"\tzH\t\tscroll half a window width right\n"
"\tze\t\tscroll right to put the cursor at the end\n"
"\tzl\t\tscroll left\n"
"\t4zl\t\tscroll four characters left\n"
"\tzL\t\tscroll half a window width left\n"
"\tzs\t\tscroll left to put the cursor at the start"
msgstr ""

#: usr_25.txt:319
msgid ""
"Let's attempt to show this with one line of text.  The cursor is on the \"w\" "
"of\n"
"\"which\".  The \"current window\" above the line indicates the text that is\n"
"currently visible.  The \"window\"s below the text indicate the text that is\n"
"visible after the command left of it."
msgstr ""

#: usr_25.txt:324
msgid ""
"\t\t\t      |<-- current window -->|\n"
"\t\tsome long text, part of which is visible in the window ~\n"
"\tze\t  |<--\t   window     -->|\n"
"\tzH\t   |<--     window     -->|\n"
"\t4zh\t\t  |<--\t   window     -->|\n"
"\tzh\t\t     |<--     window\t -->|\n"
"\tzl\t\t       |<--\twindow\t   -->|\n"
"\t4zl\t\t\t  |<--\t   window     -->|\n"
"\tzL\t\t\t\t|<--\t window     -->|\n"
"\tzs\t\t\t       |<--\twindow\t   -->|"
msgstr ""

#: usr_25.txt:336
msgid "MOVING WITH WRAP OFF"
msgstr ""

#: usr_25.txt:338
msgid ""
"When 'wrap' is off and the text has scrolled horizontally, you can use the\n"
"following commands to move the cursor to a character you can see.  Thus text\n"
"left and right of the window is ignored.  These never cause the text to\n"
"scroll:"
msgstr ""

#: usr_25.txt:343
msgid ""
"\tg0\t\tto first visible character in this line\n"
"\tg^\t\tto first non-blank visible character in this line\n"
"\tgm\t\tto middle of this line\n"
"\tg$\t\tto last visible character in this line"
msgstr ""

#: usr_25.txt:348
msgid ""
"\t\t|<--\t window    -->|\n"
"\tsome long    text, part of which is visible ~\n"
"\t\t g0  g^    gm\t     g$"
msgstr ""

#: usr_25.txt:353
msgid "BREAKING AT WORDS\t\t\t\t*edit-no-break*"
msgstr ""

#: usr_25.txt:355
msgid ""
"When preparing text for use by another program, you might have to make\n"
"paragraphs without a line break.  A disadvantage of using 'nowrap' is that "
"you\n"
"can't see the whole sentence you are working on.  When 'wrap' is on, words "
"are\n"
"broken halfway, which makes them hard to read.\n"
"   A good solution for editing this kind of paragraph is setting the\n"
"'linebreak' option.  Vim then breaks lines at an appropriate place when\n"
"displaying the line.  The text in the file remains unchanged.\n"
"   Without 'linebreak' text might look like this:"
msgstr ""

#: usr_25.txt:364
msgid ""
"\t+---------------------------------+\n"
"\t|letter generation program for a b|\n"
"\t|ank.  They wanted to send out a s|\n"
"\t|pecial, personalized letter to th|\n"
"\t|eir richest 1000 customers.  Unfo|\n"
"\t|rtunately for the programmer, he |\n"
"\t+---------------------------------+\n"
"After: >"
msgstr ""

#: usr_25.txt:373
msgid "\t:set linebreak"
msgstr ""

#: usr_25.txt:375
msgid "it looks like this:"
msgstr ""

#: usr_25.txt:377
msgid ""
"\t+---------------------------------+\n"
"\t|letter generation program for a  |\n"
"\t|bank.  They wanted to send out a |\n"
"\t|special, personalized letter to  |\n"
"\t|their richest 1000 customers.    |\n"
"\t|Unfortunately for the programmer,|\n"
"\t+---------------------------------+"
msgstr ""

#: usr_25.txt:385
msgid ""
"Related options:\n"
"'breakat' specifies the characters where a break can be inserted.\n"
"'showbreak' specifies a string to show at the start of broken line.\n"
"Set 'textwidth' to zero to avoid a paragraph to be split."
msgstr ""

#: usr_25.txt:391
msgid "MOVING BY VISIBLE LINES"
msgstr ""

#: usr_25.txt:393
msgid ""
"The \"j\" and \"k\" commands move to the next and previous lines.  When used on\n"
"a long line, this means moving a lot of screen lines at once.\n"
"   To move only one screen line, use the \"gj\" and \"gk\" commands.  When a "
"line\n"
"doesn't wrap they do the same as \"j\" and \"k\".  When the line does wrap, they\n"
"move to a character displayed one line below or above.\n"
"   You might like to use these mappings, which bind these movement commands "
"to\n"
"the cursor keys: >"
msgstr ""

#: usr_25.txt:401
msgid ""
"\t:map <Up> gk\n"
"\t:map <Down> gj"
msgstr ""

#: usr_25.txt:405
msgid "TURNING A PARAGRAPH INTO ONE LINE"
msgstr ""

#: usr_25.txt:407
msgid ""
"If you want to import text into a program like MS-Word, each paragraph "
"should\n"
"be a single line.  If your paragraphs are currently separated with empty\n"
"lines, this is how you turn each paragraph into a single line: >"
msgstr ""

#: usr_25.txt:411
msgid "\t:g/./,/^$/join"
msgstr ""

#: usr_25.txt:413
msgid "That looks complicated.  Let's break it up in pieces:"
msgstr ""

#: usr_25.txt:415
msgid ""
"\t:g/./\t\tA \":global\" command that finds all lines that contain\n"
"\t\t\tat least one character.\n"
"\t     ,/^$/\tA range, starting from the current line (the non-empty\n"
"\t\t\tline) until an empty line.\n"
"\t\t  join\tThe \":join\" command joins the range of lines together\n"
"\t\t\tinto one line."
msgstr ""

#: usr_25.txt:422
msgid "Starting with this text, containing eight lines broken at column 30:"
msgstr ""

#: usr_25.txt:424
msgid ""
"\t+----------------------------------+\n"
"\t|A letter generation program\t   |\n"
"\t|for a bank.  They wanted to\t   |\n"
"\t|send out a special,\t\t   |\n"
"\t|personalized letter.\t\t   |\n"
"\t|\t\t\t\t   |\n"
"\t|To their richest 1000\t\t   |\n"
"\t|customers.  Unfortunately for\t   |\n"
"\t|the programmer,\t\t   |\n"
"\t+----------------------------------+"
msgstr ""

#: usr_25.txt:435
msgid "You end up with two lines:"
msgstr ""

#: usr_25.txt:437
msgid ""
"\t+----------------------------------+\n"
"\t|A letter generation program for a |\n"
"\t|bank.\tThey wanted to send out a s|\n"
"\t|pecial, personalized letter.\t   |\n"
"\t|To their richest 1000 customers.  |\n"
"\t|Unfortunately for the programmer, |\n"
"\t+----------------------------------+"
msgstr ""

#: usr_25.txt:445
msgid ""
"Note that this doesn't work when the separating line is blank but not empty;\n"
"when it contains spaces and/or tabs.  This command does work with blank "
"lines:\n"
">\n"
"\t:g/\\S/,/^\\s*$/join"
msgstr ""

#: usr_25.txt:450
msgid ""
"This still requires a blank or empty line at the end of the file for the "
"last\n"
"paragraph to be joined."
msgstr ""

#: usr_25.txt:453
msgid ""
"============================================================================"
"==\n"
"*25.5*\tEditing tables"
msgstr ""

#: usr_25.txt:456
msgid "Suppose you are editing a table with four columns:"
msgstr ""

#: usr_25.txt:458
msgid ""
"\tnice table\t  test 1\ttest 2\t    test 3 ~\n"
"\tinput A\t\t  0.534 ~\n"
"\tinput B\t\t  0.913 ~"
msgstr ""

#: usr_25.txt:462
msgid ""
"You need to enter numbers in the third column.  You could move to the second\n"
"line, use \"A\", enter a lot of spaces and type the text.\n"
"   For this kind of editing there is a special option: >"
msgstr ""

#: usr_25.txt:466
msgid "\tset virtualedit=all"
msgstr ""

#: usr_25.txt:468
msgid ""
"Now you can move the cursor to positions where there isn't any text.  This "
"is\n"
"called \"virtual space\".  Editing a table is a lot easier this way.\n"
"   Move the cursor by searching for the header of the last column: >"
msgstr ""

#: usr_25.txt:472
msgid "\t/test 3"
msgstr ""

#: usr_25.txt:474
msgid ""
"Now press \"j\" and you are right where you can enter the value for \"input A\".\n"
"Typing \"0.693\" results in:"
msgstr ""

#: usr_25.txt:477
msgid ""
"\tnice table\t  test 1     test 2\t test 3 ~\n"
"\tinput A\t\t  0.534\t\t\t 0.693 ~\n"
"\tinput B\t\t  0.913 ~"
msgstr ""

#: usr_25.txt:481
msgid ""
"Vim has automatically filled the gap in front of the new text for you.  Now,\n"
"to enter the next field in this column use \"Bj\".  \"B\" moves back to the "
"start\n"
"of a white space separated word.  Then \"j\" moves to the place where the next\n"
"field can be entered."
msgstr ""

#: usr_25.txt:486
msgid ""
"\tNote:\n"
"\tYou can move the cursor anywhere in the display, also beyond the end\n"
"\tof a line.  But Vim will not insert spaces there, until you insert a\n"
"\tcharacter in that position."
msgstr ""

#: usr_25.txt:492
msgid "COPYING A COLUMN"
msgstr ""

#: usr_25.txt:494
msgid ""
"You want to add a column, which should be a copy of the third column and\n"
"placed before the \"test 1\" column.  Do this in seven steps:\n"
"1.  Move the cursor to the left upper corner of this column, e.g., with\n"
"    \"/test 3\".\n"
"2.  Press CTRL-V to start blockwise Visual mode.\n"
"3.  Move the cursor down two lines with \"2j\".  You are now in \"virtual "
"space\":\n"
"    the \"input B\" line of the \"test 3\" column.\n"
"4.  Move the cursor right, to include the whole column in the selection, "
"plus\n"
"    the space that you want between the columns.  \"9l\" should do it.\n"
"5.  Yank the selected rectangle with \"y\".\n"
"6.  Move the cursor to \"test 1\", where the new column must be placed.\n"
"7.  Press \"P\"."
msgstr ""

#: usr_25.txt:507
msgid "The result should be:"
msgstr ""

#: usr_25.txt:509
msgid ""
"\tnice table\t  test 3    test 1     test 2\t   test 3 ~\n"
"\tinput A\t\t  0.693     0.534\t\t   0.693 ~\n"
"\tinput B\t\t\t    0.913 ~"
msgstr ""

#: usr_25.txt:513
msgid ""
"Notice that the whole \"test 1\" column was shifted right, also the line where\n"
"the \"test 3\" column didn't have text."
msgstr ""

#: usr_25.txt:516
msgid "Go back to non-virtual cursor movements with: >"
msgstr ""

#: usr_25.txt:518
msgid "\t:set virtualedit="
msgstr ""

#: usr_25.txt:521
msgid "VIRTUAL REPLACE MODE"
msgstr ""

#: usr_25.txt:523
msgid ""
"The disadvantage of using 'virtualedit' is that it \"feels\" different.  You\n"
"can't recognize tabs or spaces beyond the end of line when moving the cursor\n"
"around.  Another method can be used: Virtual Replace mode.\n"
"   Suppose you have a line in a table that contains both tabs and other\n"
"characters.  Use \"rx\" on the first tab:"
msgstr ""

#: usr_25.txt:529
msgctxt "usr_25.txt:529"
msgid "\tinp\t0.693   0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:531
msgid ""
"\t       |\n"
"\t   rx  |\n"
"\t       V"
msgstr ""

#: usr_25.txt:535
msgid "\tinpx0.693   0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:537
msgid "The layout is messed up.  To avoid that, use the \"gr\" command:"
msgstr ""

#: usr_25.txt:539
msgctxt "usr_25.txt:539"
msgid "\tinp\t0.693   0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:541
msgid ""
"\t       |\n"
"\t  grx  |\n"
"\t       V"
msgstr ""

#: usr_25.txt:545
msgid "\tinpx\t0.693   0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:547
msgid ""
"What happens is that the \"gr\" command makes sure the new character takes the\n"
"right amount of screen space.  Extra spaces or tabs are inserted to fill the\n"
"gap.  Thus what actually happens is that a tab is replaced by \"x\" and then\n"
"blanks added to make the text after it keep it's place.  In this case a\n"
"tab is inserted.\n"
"   When you need to replace more than one character, you use the \"R\" command\n"
"to go to Replace mode (see |04.9|).  This messes up the layout and replaces\n"
"the wrong characters:"
msgstr ""

#: usr_25.txt:556
msgctxt "usr_25.txt:556"
msgid "\tinp\t0\t0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:558
msgid ""
"\t\t|\n"
"\t R0.786 |\n"
"\t\tV"
msgstr ""

#: usr_25.txt:562
msgid "\tinp\t0.78634\t0.693 ~"
msgstr ""

#: usr_25.txt:564
msgid "The \"gR\" command uses Virtual Replace mode.  This preserves the layout:"
msgstr ""

#: usr_25.txt:566
msgctxt "usr_25.txt:566"
msgid "\tinp\t0\t0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:568
msgid ""
"\t\t|\n"
"\tgR0.786 |\n"
"\t\tV"
msgstr ""

#: usr_25.txt:572
msgid "\tinp\t0.786\t0.534\t0.693 ~"
msgstr ""

#: usr_25.txt:574
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_25.txt:576
msgid "Next chapter: |usr_26.txt|  Repeating"
msgstr ""

#: usr_25.txt:578
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
