#. extracted from usr_12.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-01 19:54+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_12.txt:1
msgid "*usr_12.txt*\tFor Vim version 7.2.  Last change: 2007 May 11"
msgstr ""

#: usr_12.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_12.txt:5
msgid "\t\t\t\tClever tricks"
msgstr ""

#: usr_12.txt:8
msgid ""
"By combining several commands you can make Vim do nearly everything.  In "
"this\n"
"chapter a number of useful combinations will be presented.  This uses the\n"
"commands introduced in the previous chapters and a few more."
msgstr ""

#: usr_12.txt:12
msgid ""
"|12.1|\tReplace a word\n"
"|12.2|\tChange \"Last, First\" to \"First Last\"\n"
"|12.3|\tSort a list\n"
"|12.4|\tReverse line order\n"
"|12.5|\tCount words\n"
"|12.6|\tFind a man page\n"
"|12.7|\tTrim blanks\n"
"|12.8|\tFind where a word is used"
msgstr ""

#: usr_12.txt:21
msgid ""
"     Next chapter: |usr_20.txt|  Typing command-line commands quickly\n"
" Previous chapter: |usr_11.txt|  Recovering from a crash\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_12.txt:25
msgid ""
"============================================================================"
"==\n"
"*12.1*\tReplace a word"
msgstr ""

#: usr_12.txt:28
msgid ""
"The substitute command can be used to replace all occurrences of a word with\n"
"another word: >"
msgstr ""

#: usr_12.txt:31
msgid "\t:%s/four/4/g"
msgstr ""

#: usr_12.txt:33
msgid ""
"The \"%\" range means to replace in all lines.  The \"g\" flag at the end causes\n"
"all words in a line to be replaced.\n"
"   This will not do the right thing if your file also contains \"thirtyfour\".\n"
"It would be replaced with \"thirty4\".  To avoid this, use the \"\\<\" item to\n"
"match the start of a word: >"
msgstr ""

#: usr_12.txt:39
msgid "\t:%s/\\<four/4/g"
msgstr ""

#: usr_12.txt:41
msgid ""
"Obviously, this still goes wrong on \"fourteen\".  Use \"\\>\" to match the end "
"of\n"
"a word: >"
msgstr ""

#: usr_12.txt:44
msgid "\t:%s/\\<four\\>/4/g"
msgstr ""

#: usr_12.txt:46
msgid ""
"If you are programming, you might want to replace \"four\" in comments, but "
"not\n"
"in the code.  Since this is difficult to specify, add the \"c\" flag to have "
"the\n"
"substitute command prompt you for each replacement: >"
msgstr ""

#: usr_12.txt:51
msgid "\t:%s/\\<four\\>/4/gc"
msgstr ""

#: usr_12.txt:54
msgid "REPLACING IN SEVERAL FILES"
msgstr ""

#: usr_12.txt:56
msgid ""
"Suppose you want to replace a word in more than one file.  You could edit "
"each\n"
"file and type the command manually.  It's a lot faster to use record and\n"
"playback.\n"
"   Let's assume you have a directory with C++ files, all ending in \".cpp\".\n"
"There is a function called \"GetResp\" that you want to rename to \"GetAnswer\"."
msgstr ""

#: usr_12.txt:62
msgid ""
"\tvim *.cpp\t\tStart Vim, defining the argument list to\n"
"\t\t\t\tcontain all the C++ files.  You are now in the\n"
"\t\t\t\tfirst file.\n"
"\tqq\t\t\tStart recording into the q register\n"
"\t:%s/\\<GetResp\\>/GetAnswer/g\n"
"\t\t\t\tDo the replacements in the first file.\n"
"\t:wnext\t\t\tWrite this file and move to the next one.\n"
"\tq\t\t\tStop recording.\n"
"\t@q\t\t\tExecute the q register.  This will replay the\n"
"\t\t\t\tsubstitution and \":wnext\".  You can verify\n"
"\t\t\t\tthat this doesn't produce an error message.\n"
"\t999@q\t\t\tExecute the q register on the remaining files."
msgstr ""

#: usr_12.txt:75
msgid ""
"At the last file you will get an error message, because \":wnext\" cannot move\n"
"to the next file.  This stops the execution, and everything is done."
msgstr ""

#: usr_12.txt:78
msgid ""
"\tNote:\n"
"\tWhen playing back a recorded sequence, an error stops the execution.\n"
"\tTherefore, make sure you don't get an error message when recording."
msgstr ""

#: usr_12.txt:82
msgid ""
"There is one catch: If one of the .cpp files does not contain the word\n"
"\"GetResp\", you will get an error and replacing will stop.  To avoid this, "
"add\n"
"the \"e\" flag to the substitute command: >"
msgstr ""

#: usr_12.txt:86
msgid "\t:%s/\\<GetResp\\>/GetAnswer/ge"
msgstr ""

#: usr_12.txt:88
msgid ""
"The \"e\" flag tells \":substitute\" that not finding a match is not an error."
msgstr ""

#: usr_12.txt:90
msgid ""
"============================================================================"
"==\n"
"*12.2*\tChange \"Last, First\" to \"First Last\""
msgstr ""

#: usr_12.txt:93
msgid "You have a list of names in this form:"
msgstr ""

#: usr_12.txt:95
msgid ""
"\tDoe, John ~\n"
"\tSmith, Peter ~"
msgstr ""

#: usr_12.txt:98
msgid "You want to change that to:"
msgstr ""

#: usr_12.txt:100
msgid ""
"\tJohn Doe ~\n"
"\tPeter Smith ~"
msgstr ""

#: usr_12.txt:103
msgid "This can be done with just one command: >"
msgstr ""

#: usr_12.txt:105
msgid "\t:%s/\\([^,]*\\), \\(.*\\)/\\2 \\1/"
msgstr ""

#: usr_12.txt:107
msgid ""
"Let's break this down in parts.  Obviously it starts with a substitute\n"
"command.  The \"%\" is the line range, which stands for the whole file.  Thus\n"
"the substitution is done in every line in the file.\n"
"   The arguments for the substitute command are \"/from/to/\".  The slashes\n"
"separate the \"from\" pattern and the \"to\" string.  This is what the \"from\"\n"
"pattern contains:\n"
"\t\t\t\t\t\t\t\\([^,]*\\), \\(.*\\) ~"
msgstr ""

#: usr_12.txt:115
msgid ""
"\tThe first part between \\( \\) matches \"Last\"\t\\(     \\)\n"
"\t    match anything but a comma\t\t\t  [^,]\n"
"\t    any number of times\t\t\t\t      *\n"
"\tmatches \", \" literally\t\t\t\t\t ,\n"
"\tThe second part between \\( \\) matches \"First\"\t\t   \\(  \\)\n"
"\t    any character\t\t\t\t\t     .\n"
"\t    any number of times\t\t\t\t\t      *"
msgstr ""

#: usr_12.txt:123
msgid ""
"In the \"to\" part we have \"\\2\" and \"\\1\".  These are called backreferences.\n"
"They refer to the text matched by the \"\\( \\)\" parts in the pattern.  \"\\2\"\n"
"refers to the text matched by the second \"\\( \\)\", which is the \"First\" name.\n"
"\"\\1\" refers to the first \"\\( \\)\", which is the \"Last\" name.\n"
"   You can use up to nine backreferences in the \"to\" part of a substitute\n"
"command.  \"\\0\" stands for the whole matched pattern.  There are a few more\n"
"special items in a substitute command, see |sub-replace-special|."
msgstr ""

#: usr_12.txt:131
msgid ""
"============================================================================"
"==\n"
"*12.3*\tSort a list"
msgstr ""

#: usr_12.txt:134
msgid "In a Makefile you often have a list of files.  For example:"
msgstr ""

#: usr_12.txt:136
msgid ""
"\tOBJS = \\ ~\n"
"\t\tversion.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tbackup.o ~"
msgstr ""

#: usr_12.txt:146
msgid "To sort this list, filter the text through the external sort command: >"
msgstr ""

#: usr_12.txt:148
msgid ""
"\t/^OBJS\n"
"\tj\n"
"\t:.,/^$/-1!sort"
msgstr ""

#: usr_12.txt:152
msgid ""
"This goes to the first line, where \"OBJS\" is the first thing in the line.\n"
"Then it goes one line down and filters the lines until the next empty line.\n"
"You could also select the lines in Visual mode and then use \"!sort\".  That's\n"
"easier to type, but more work when there are many lines.\n"
"   The result is this:"
msgstr ""

#: usr_12.txt:158
msgid ""
"\tOBJS = \\ ~\n"
"\t\tbackup.o ~\n"
"\t\tgetopt.o \\ ~\n"
"\t\tgetopt1.o \\ ~\n"
"\t\tinp.o \\ ~\n"
"\t\tpatch.o \\ ~\n"
"\t\tpch.o \\ ~\n"
"\t\tutil.o \\ ~\n"
"\t\tversion.o \\ ~"
msgstr ""

#: usr_12.txt:169
msgid ""
"Notice that a backslash at the end of each line is used to indicate the line\n"
"continues.  After sorting, this is wrong!  The \"backup.o\" line that was at\n"
"the end didn't have a backslash.  Now that it sorts to another place, it\n"
"must have a backslash.\n"
"   The simplest solution is to add the backslash with \"A \\<Esc>\".  You can\n"
"keep the backslash in the last line, if you make sure an empty line comes\n"
"after it.  That way you don't have this problem again."
msgstr ""

#: usr_12.txt:177
msgid ""
"============================================================================"
"==\n"
"*12.4*\tReverse line order"
msgstr ""

#: usr_12.txt:180
msgid ""
"The |:global| command can be combined with the |:move| command to move all "
"the\n"
"lines before the first line, resulting in a reversed file.  The command is: "
">"
msgstr ""

#: usr_12.txt:183
msgid "\t:global/^/m 0"
msgstr ""

#: usr_12.txt:185
msgid "Abbreviated: >"
msgstr ""

#: usr_12.txt:187
msgid "\t:g/^/m 0"
msgstr ""

#: usr_12.txt:189
msgid ""
"The \"^\" regular expression matches the beginning of the line (even if the "
"line\n"
"is blank).  The |:move| command moves the matching line to after the "
"mythical\n"
"zeroth line, so the current matching line becomes the first line of the "
"file.\n"
"As the |:global| command is not confused by the changing line numbering,\n"
"|:global| proceeds to match all remaining lines of the file and puts each as\n"
"the first."
msgstr ""

#: usr_12.txt:196
msgid ""
"This also works on a range of lines.  First move to above the first line and\n"
"mark it with \"mt\".  Then move the cursor to the last line in the range and\n"
"type: >"
msgstr ""

#: usr_12.txt:200
msgid "\t:'t+1,.g/^/m 't"
msgstr ""

#: usr_12.txt:202
msgid ""
"============================================================================"
"==\n"
"*12.5*\tCount words"
msgstr ""

#: usr_12.txt:205
msgid ""
"Sometimes you have to write a text with a maximum number of words.  Vim can\n"
"count the words for you.\n"
"   When the whole file is what you want to count the words in, use this\n"
"command: >"
msgstr ""

#: usr_12.txt:210
msgid "\tg CTRL-G"
msgstr ""

#: usr_12.txt:212
msgid ""
"Do not type a space after the g, this is just used here to make the command\n"
"easy to read.\n"
"   The output looks like this:"
msgstr ""

#: usr_12.txt:216
msgid "\tCol 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 ~"
msgstr ""

#: usr_12.txt:218
msgid ""
"You can see on which word you are (748), and the total number of words in "
"the\n"
"file (774)."
msgstr ""

#: usr_12.txt:221
msgid ""
"When the text is only part of a file, you could move to the start of the "
"text,\n"
"type \"g CTRL-G\", move to the end of the text, type \"g CTRL-G\" again, and "
"then\n"
"use your brain to compute the difference in the word position.  That's a "
"good\n"
"exercise, but there is an easier way.  With Visual mode, select the text you\n"
"want to count words in.  Then type g CTRL-G.  The result:"
msgstr ""

#: usr_12.txt:227
msgid "\tSelected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes ~"
msgstr ""

#: usr_12.txt:229
msgid ""
"For other ways to count words, lines and other items, see |count-items|."
msgstr ""

#: usr_12.txt:231
msgid ""
"============================================================================"
"==\n"
"*12.6*\tFind a man page\t\t\t\t\t*find-manpage*"
msgstr ""

#: usr_12.txt:234
msgid ""
"While editing a shell script or C program, you are using a command or "
"function\n"
"that you want to find the man page for (this is on Unix).  Let's first use a\n"
"simple way: Move the cursor to the word you want to find help on and press >"
msgstr ""

#: usr_12.txt:238
msgid "\tK"
msgstr ""

#: usr_12.txt:240
msgid ""
"Vim will run the external \"man\" program on the word.  If the man page is\n"
"found, it is displayed.  This uses the normal pager to scroll through the "
"text\n"
"(mostly the \"more\" program).  When you get to the end pressing <Enter> will\n"
"get you back into Vim."
msgstr ""

#: usr_12.txt:245
msgid ""
"A disadvantage is that you can't see the man page and the text you are "
"working\n"
"on at the same time.  There is a trick to make the man page appear in a Vim\n"
"window.  First, load the man filetype plugin: >"
msgstr ""

#: usr_12.txt:249
msgid "\t:runtime! ftplugin/man.vim"
msgstr ""

#: usr_12.txt:251
msgid ""
"Put this command in your vimrc file if you intend to do this often.  Now you\n"
"can use the \":Man\" command to open a window on a man page: >"
msgstr ""

#: usr_12.txt:254
msgid "\t:Man csh"
msgstr ""

#: usr_12.txt:256
msgid ""
"You can scroll around and the text is highlighted.  This allows you to find\n"
"the help you were looking for.  Use CTRL-W w to jump to the window with the\n"
"text you were working on.\n"
"   To find a man page in a specific section, put the section number first.\n"
"For example, to look in section 3 for \"echo\": >"
msgstr ""

#: usr_12.txt:262
msgid "\t:Man 3 echo"
msgstr ""

#: usr_12.txt:264
msgid ""
"To jump to another man page, which is in the text with the typical form\n"
"\"word(1)\", press CTRL-] on it.  Further \":Man\" commands will use the same\n"
"window."
msgstr ""

#: usr_12.txt:268
msgid "To display a man page for the word under the cursor, use this: >"
msgstr ""

#: usr_12.txt:270
msgid "\t\\K"
msgstr ""

#: usr_12.txt:272
msgid ""
"(If you redefined the <Leader>, use it instead of the backslash).\n"
"For example, you want to know the return value of \"strstr()\" while editing\n"
"this line:"
msgstr ""

#: usr_12.txt:276
msgid "\tif ( strstr (input, \"aap\") == ) ~"
msgstr ""

#: usr_12.txt:278
msgid ""
"Move the cursor to somewhere on \"strstr\" and type \"\\K\".  A window will open\n"
"to display the man page for strstr()."
msgstr ""

#: usr_12.txt:281
msgid ""
"============================================================================"
"==\n"
"*12.7*\tTrim blanks"
msgstr ""

#: usr_12.txt:284
msgid ""
"Some people find spaces and tabs at the end of a line useless, wasteful, and\n"
"ugly.  To remove whitespace at the end of every line, execute the following\n"
"command: >"
msgstr ""

#: usr_12.txt:288
msgid "\t:%s/\\s\\+$//"
msgstr ""

#: usr_12.txt:290
msgid ""
"The line range \"%\" is used, thus this works on the whole file.  The pattern\n"
"that the \":substitute\" command matches with is \"\\s\\+$\".  This finds white\n"
"space characters (\\s), 1 or more of them (\\+), before the end-of-line ($).\n"
"Later will be explained how you write patterns like this |usr_27.txt|.\n"
"   The \"to\" part of the substitute command is empty: \"//\".  Thus it replaces\n"
"with nothing, effectively deleting the matched white space."
msgstr ""

#: usr_12.txt:297
msgid ""
"Another wasteful use of spaces is placing them before a tab.  Often these "
"can\n"
"be deleted without changing the amount of white space.  But not always!\n"
"Therefore, you can best do this manually.  Use this search command: >"
msgstr ""

#: usr_12.txt:301
msgid "\t/ \t"
msgstr ""

#: usr_12.txt:303
msgid ""
"You cannot see it, but there is a space before a tab in this command.  Thus\n"
"it's \"/<Space><Tab>\".   Now use \"x\" to delete the space and check that the\n"
"amount of white space doesn't change.  You might have to insert a tab if it\n"
"does change.  Type \"n\" to find the next match.  Repeat this until no more\n"
"matches can be found."
msgstr ""

#: usr_12.txt:309
msgid ""
"============================================================================"
"==\n"
"*12.8*\tFind where a word is used"
msgstr ""

#: usr_12.txt:312
msgid ""
"If you are a UNIX user, you can use a combination of Vim and the grep "
"command\n"
"to edit all the files that contain a given word.  This is extremely useful "
"if\n"
"you are working on a program and want to view or edit all the files that\n"
"contain a specific variable.\n"
"   For example, suppose you want to edit all the C program files that "
"contain\n"
"the word \"frame_counter\".  To do this you use the command: >"
msgstr ""

#: usr_12.txt:319
msgid "\tvim `grep -l frame_counter *.c`"
msgstr ""

#: usr_12.txt:321
msgid ""
"Let's look at this command in detail.  The grep command searches through a "
"set\n"
"of files for a given word.  Because the -l argument is specified, the "
"command\n"
"will only list the files containing the word and not print the matching "
"lines.\n"
"The word it is searching for is \"frame_counter\".  Actually, this can be any\n"
"regular expression.  (Note: What grep uses for regular expressions is not\n"
"exactly the same as what Vim uses.)\n"
"   The entire command is enclosed in backticks (`).  This tells the UNIX "
"shell\n"
"to run this command and pretend that the results were typed on the command\n"
"line.  So what happens is that the grep command is run and produces a list "
"of\n"
"files, these files are put on the Vim command line.  This results in Vim\n"
"editing the file list that is the output of grep.  You can then use commands\n"
"like \":next\" and \":first\" to browse through the files."
msgstr ""

#: usr_12.txt:335
msgid "FINDING EACH LINE"
msgstr ""

#: usr_12.txt:337
msgid ""
"The above command only finds the files in which the word is found.  You "
"still\n"
"have to find the word within the files.\n"
"   Vim has a built-in command that you can use to search a set of files for "
"a\n"
"given string.  If you want to find all occurrences of \"error_string\" in all "
"C\n"
"program files, for example, enter the following command: >"
msgstr ""

#: usr_12.txt:343
msgid "\t:grep error_string *.c"
msgstr ""

#: usr_12.txt:345
msgid ""
"This causes Vim to search for the string \"error_string\" in all the specified\n"
"files (*.c).  The editor will now open the first file where a match is found\n"
"and position the cursor on the first matching line.  To go to the next\n"
"matching line (no matter in what file it is), use the \":cnext\" command.  To "
"go\n"
"to the previous match, use the \":cprev\" command.  Use \":clist\" to see all "
"the\n"
"matches and where they are.\n"
"   The \":grep\" command uses the external commands grep (on Unix) or findstr\n"
"(on Windows).  You can change this by setting the option 'grepprg'."
msgstr ""

#: usr_12.txt:354
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_12.txt:356
msgid "Next chapter: |usr_20.txt|  Typing command-line commands quickly"
msgstr ""

#: usr_12.txt:358
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
