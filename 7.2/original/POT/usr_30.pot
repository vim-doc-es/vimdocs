#. extracted from usr_30.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-04 13:40+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_30.txt:1
msgid "*usr_30.txt*\tFor Vim version 7.2.  Last change: 2007 Nov 10"
msgstr ""

#: usr_30.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_30.txt:5
msgid "\t\t\t      Editing programs"
msgstr ""

#: usr_30.txt:8
msgid ""
"Vim has various commands that aid in writing computer programs.  Compile a\n"
"program and directly jump to reported errors.  Automatically set the indent\n"
"for many languages and format comments."
msgstr ""

#: usr_30.txt:12
msgid ""
"|30.1|\tCompiling\n"
"|30.2|\tIndenting C files\n"
"|30.3|\tAutomatic indenting\n"
"|30.4|\tOther indenting\n"
"|30.5|\tTabs and spaces\n"
"|30.6|\tFormatting comments"
msgstr ""

#: usr_30.txt:19
msgid ""
"     Next chapter: |usr_31.txt|  Exploiting the GUI\n"
" Previous chapter: |usr_29.txt|  Moving through programs\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_30.txt:23
msgid ""
"============================================================================"
"==\n"
"*30.1*\tCompiling"
msgstr ""

#: usr_30.txt:26
msgid ""
"Vim has a set of so called \"quickfix\" commands.  They enable you to compile "
"a\n"
"program from within Vim and then go through the errors generated and fix "
"them\n"
"(hopefully).  You can then recompile and fix any new errors that are found\n"
"until finally your program compiles without any error."
msgstr ""

#: usr_30.txt:31
msgid ""
"The following command runs the program \"make\" (supplying it with any "
"argument\n"
"you give) and captures the results: >"
msgstr ""

#: usr_30.txt:34
msgid "\t:make {arguments}"
msgstr ""

#: usr_30.txt:36
msgid ""
"If errors were generated, they are captured and the editor positions you "
"where\n"
"the first error occurred.\n"
"   Take a look at an example \":make\" session.  (Typical :make sessions "
"generate\n"
"far more errors and fewer stupid ones.)  After typing \":make\" the screen "
"looks\n"
"like this:"
msgstr ""

#: usr_30.txt:42
msgid ""
"\t:!make | &tee /tmp/vim215953.err ~\n"
"\tgcc -g -Wall -o prog main.c sub.c ~\n"
"\tmain.c: In function 'main': ~\n"
"\tmain.c:6: too many arguments to function 'do_sub' ~\n"
"\tmain.c: At top level: ~\n"
"\tmain.c:10: parse error before '}' ~\n"
"\tmake: *** [prog] Error 1 ~"
msgstr ""

#: usr_30.txt:50
msgid ""
"\t2 returned ~\n"
"\t\"main.c\" 11L, 111C ~\n"
"\t(3 of 6): too many arguments to function 'do_sub' ~\n"
"\tPress ENTER or type command to continue ~"
msgstr ""

#: usr_30.txt:55
msgid ""
"From this you can see that you have errors in the file \"main.c\".  When you\n"
"press <Enter>, Vim displays the file \"main.c\", with the cursor positioned on\n"
"line 6, the first line with an error.  You did not need to specify the file "
"or\n"
"the line number, Vim knew where to go by looking in the error messages."
msgstr ""

#: usr_30.txt:60
msgid ""
"\t\t+---------------------------------------------------+\n"
"\t\t|int main()\t\t\t\t\t    |\n"
"\t\t|{\t\t\t\t\t\t    |\n"
"\t\t|\tint i=3;\t\t\t\t    |\n"
"      cursor -> |\tdo_sub(\"foo\");\t\t\t\t    |\n"
"\t\t|\t++i;\t\t\t\t\t    |\n"
"\t\t|\treturn (0);\t\t\t\t    |\n"
"\t\t|}\t\t\t\t\t\t    |\n"
"\t\t|}\t\t\t\t\t\t    |\n"
"\t\t| ~\t\t\t\t\t\t    |\n"
"\t\t|(3 of 12): too many arguments to function 'do_sub' |\n"
"\t\t+---------------------------------------------------+"
msgstr ""

#: usr_30.txt:73
msgid "The following command goes to where the next error occurs: >"
msgstr ""

#: usr_30.txt:75
msgid "\t:cnext"
msgstr ""

#: usr_30.txt:77
msgid ""
"Vim jumps to line 10, the last line in the file, where there is an extra "
"'}'.\n"
"   When there is not enough room, Vim will shorten the error message.  To "
"see\n"
"the whole message use: >"
msgstr ""

#: usr_30.txt:81
msgid "\t:cc"
msgstr ""

#: usr_30.txt:83
msgid ""
"You can get an overview of all the error messages with the \":clist\" command.\n"
"The output looks like this: >"
msgstr ""

#: usr_30.txt:86
msgid ""
"\t:clist\n"
"<\t3 main.c: 6:too many arguments to function 'do_sub' ~\n"
"\t5 main.c: 10:parse error before '}' ~"
msgstr ""

#: usr_30.txt:90
msgid ""
"Only the lines where Vim recognized a file name and line number are listed\n"
"here.  It assumes those are the interesting lines and the rest is just "
"boring\n"
"messages.  However, sometimes unrecognized lines do contain something you "
"want\n"
"to see.  Output from the linker, for example, about an undefined function.\n"
"To see all the messages add a \"!\" to the command: >"
msgstr ""

#: usr_30.txt:96
msgid ""
"\t:clist!\n"
"<\t1 gcc -g -Wall -o prog main.c sub.c ~\n"
"\t2 main.c: In function 'main': ~\n"
"\t3 main.c:6: too many arguments to function 'do_sub' ~\n"
"\t4 main.c: At top level: ~\n"
"\t5 main.c:10: parse error before '}' ~\n"
"\t6 make: *** [prog] Error 1 ~"
msgstr ""

#: usr_30.txt:104
msgid ""
"Vim will highlight the current error.  To go back to the previous error, "
"use:\n"
">\n"
"\t:cprevious"
msgstr ""

#: usr_30.txt:108
msgid "Other commands to move around in the error list:"
msgstr ""

#: usr_30.txt:110
msgid ""
"\t:cfirst\t\tto first error\n"
"\t:clast\t\tto last error\n"
"\t:cc 3\t\tto error nr 3"
msgstr ""

#: usr_30.txt:115
msgid "USING ANOTHER COMPILER"
msgstr ""

#: usr_30.txt:117
msgid ""
"The name of the program to run when the \":make\" command is executed is "
"defined\n"
"by the 'makeprg' option.  Usually this is set to \"make\", but Visual C++ "
"users\n"
"should set this to \"nmake\" by executing the following command: >"
msgstr ""

#: usr_30.txt:121
msgid "\t:set makeprg=nmake"
msgstr ""

#: usr_30.txt:123
msgid ""
"You can also include arguments in this option.  Special characters need to\n"
"be escaped with a backslash.  Example: >"
msgstr ""

#: usr_30.txt:126
msgid "\t:set makeprg=nmake\\ -f\\ project.mak"
msgstr ""

#: usr_30.txt:128
msgid ""
"You can include special Vim keywords in the command specification.  The %\n"
"character expands to the name of the current file.  So if you execute the\n"
"command: >\n"
"\t:set makeprg=make\\ %"
msgstr ""

#: usr_30.txt:133
msgid ""
"When you are editing main.c, then \":make\" executes the following command: >"
msgstr ""

#: usr_30.txt:135
msgid "\tmake main.c"
msgstr ""

#: usr_30.txt:137
msgid ""
"This is not too useful, so you will refine the command a little and use the "
":r\n"
"(root) modifier: >"
msgstr ""

#: usr_30.txt:140
msgid "\t:set makeprg=make\\ %:r.o"
msgstr ""

#: usr_30.txt:142
msgid "Now the command executed is as follows: >"
msgstr ""

#: usr_30.txt:144
msgid "\tmake main.o"
msgstr ""

#: usr_30.txt:146
msgid "More about these modifiers here: |filename-modifiers|."
msgstr ""

#: usr_30.txt:149
msgid "OLD ERROR LISTS"
msgstr ""

#: usr_30.txt:151
msgid ""
"Suppose you \":make\" a program.  There is a warning message in one file and "
"an\n"
"error message in another.  You fix the error and use \":make\" again to check "
"if\n"
"it was really fixed.  Now you want to look at the warning message.  It "
"doesn't\n"
"show up in the last error list, since the file with the warning wasn't\n"
"compiled again.  You can go back to the previous error list with: >"
msgstr ""

#: usr_30.txt:157
msgid "\t:colder"
msgstr ""

#: usr_30.txt:159
msgid ""
"Then use \":clist\" and \":cc {nr}\" to jump to the place with the warning.\n"
"   To go forward to the next error list: >"
msgstr ""

#: usr_30.txt:162
msgid "\t:cnewer"
msgstr ""

#: usr_30.txt:164
msgid "Vim remembers ten error lists."
msgstr ""

#: usr_30.txt:167
msgid "SWITCHING COMPILERS"
msgstr ""

#: usr_30.txt:169
msgid ""
"You have to tell Vim what format the error messages are that your compiler\n"
"produces.  This is done with the 'errorformat' option.  The syntax of this\n"
"option is quite complicated and it can be made to fit almost any compiler.\n"
"You can find the explanation here: |errorformat|."
msgstr ""

#: usr_30.txt:174
msgid ""
"You might be using various different compilers.  Setting the 'makeprg' "
"option,\n"
"and especially the 'errorformat' each time is not easy.  Vim offers a simple\n"
"method for this.  For example, to switch to using the Microsoft Visual C++\n"
"compiler: >"
msgstr ""

#: usr_30.txt:179
msgid "\t:compiler msvc"
msgstr ""

#: usr_30.txt:181
msgid ""
"This will find the Vim script for the \"msvc\" compiler and set the "
"appropriate\n"
"options.\n"
"   You can write your own compiler files.  See |write-compiler-plugin|."
msgstr ""

#: usr_30.txt:186
msgid "OUTPUT REDIRECTION"
msgstr ""

#: usr_30.txt:188
msgid ""
"The \":make\" command redirects the output of the executed program to an error\n"
"file.  How this works depends on various things, such as the 'shell'.  If "
"your\n"
"\":make\" command doesn't capture the output, check the 'makeef' and\n"
"'shellpipe' options.  The 'shellquote' and 'shellxquote' options might also\n"
"matter."
msgstr ""

#: usr_30.txt:194
msgid ""
"In case you can't get \":make\" to redirect the file for you, an alternative "
"is\n"
"to compile the program in another window and redirect the output into a "
"file.\n"
"Then have Vim read this file with: >"
msgstr ""

#: usr_30.txt:198
msgid "\t:cfile {filename}"
msgstr ""

#: usr_30.txt:200
msgid "Jumping to errors will work like with the \":make\" command."
msgstr ""

#: usr_30.txt:202
msgid ""
"============================================================================"
"==\n"
"*30.2*\tIndenting C style text"
msgstr ""

#: usr_30.txt:205
msgid ""
"A program is much easier to understand when the lines have been properly\n"
"indented.  Vim offers various ways to make this less work.  For C or C style\n"
"programs like Java or C++, set the 'cindent' option.  Vim knows a lot about "
"C\n"
"programs and will try very hard to automatically set the indent for you.  "
"Set\n"
"the 'shiftwidth' option to the amount of spaces you want for a deeper level.\n"
"Four spaces will work fine.  One \":set\" command will do it: >"
msgstr ""

#: usr_30.txt:212
msgid "\t:set cindent shiftwidth=4"
msgstr ""

#: usr_30.txt:214
msgid ""
"With this option enabled, when you type something such as \"if (x)\", the next\n"
"line will automatically be indented an additional level."
msgstr ""

#: usr_30.txt:217
msgid ""
"\t\t\t\t    if (flag)\n"
"\tAutomatic indent   --->\t\tdo_the_work();\n"
"\tAutomatic unindent <--\t    if (other_flag) {\n"
"\tAutomatic indent   --->\t\tdo_file();\n"
"\tkeep indent\t\t\tdo_some_more();\n"
"\tAutomatic unindent <--\t    }"
msgstr ""

#: usr_30.txt:224
msgid ""
"When you type something in curly braces ({}), the text will be indented at "
"the\n"
"start and unindented at the end.  The unindenting will happen after typing "
"the\n"
"'}', since Vim can't guess what you are going to type."
msgstr ""

#: usr_30.txt:228
msgid ""
"One side effect of automatic indentation is that it helps you catch errors "
"in\n"
"your code early.  When you type a } to finish a function, only to find that\n"
"the automatic indentation gives it more indent than what you expected, there\n"
"is probably a } missing.  Use the \"%\" command to find out which { matches "
"the\n"
"} you typed.\n"
"   A missing ) and ; also cause extra indent.  Thus if you get more white\n"
"space than you would expect, check the preceding lines."
msgstr ""

#: usr_30.txt:236
msgid ""
"When you have code that is badly formatted, or you inserted and deleted "
"lines,\n"
"you need to re-indent the lines.  The \"=\" operator does this.  The simplest\n"
"form is: >"
msgstr ""

#: usr_30.txt:240
msgid "\t=="
msgstr ""

#: usr_30.txt:242
msgid ""
"This indents the current line.  Like with all operators, there are three "
"ways\n"
"to use it.  In Visual mode \"=\" indents the selected lines.  A useful text\n"
"object is \"a{\".  This selects the current {} block.  Thus, to re-indent the\n"
"code block the cursor is in: >"
msgstr ""

#: usr_30.txt:247
msgid "\t=a{"
msgstr ""

#: usr_30.txt:249
msgid ""
"I you have really badly indented code, you can re-indent the whole file "
"with:\n"
">\n"
"\tgg=G"
msgstr ""

#: usr_30.txt:253
msgid ""
"However, don't do this in files that have been carefully indented manually.\n"
"The automatic indenting does a good job, but in some situations you might "
"want\n"
"to overrule it."
msgstr ""

#: usr_30.txt:258
msgid "SETTING INDENT STYLE"
msgstr ""

#: usr_30.txt:260
msgid ""
"Different people have different styles of indentation.  By default Vim does "
"a\n"
"pretty good job of indenting in a way that 90% of programmers do.  There are\n"
"different styles, however; so if you want to, you can customize the\n"
"indentation style with the 'cinoptions' option.\n"
"   By default 'cinoptions' is empty and Vim uses the default style.  You can\n"
"add various items where you want something different.  For example, to make\n"
"curly braces be placed like this:"
msgstr ""

#: usr_30.txt:268
msgid ""
"\tif (flag) ~\n"
"\t  { ~\n"
"\t    i = 8; ~\n"
"\t    j = 0; ~\n"
"\t  } ~"
msgstr ""

#: usr_30.txt:274
msgid "Use this command: >"
msgstr ""

#: usr_30.txt:276
msgid "\t:set cinoptions+={2"
msgstr ""

#: usr_30.txt:278
msgid "There are many of these items.  See |cinoptions-values|."
msgstr ""

#: usr_30.txt:280
msgid ""
"============================================================================"
"==\n"
"*30.3*\tAutomatic indenting"
msgstr ""

#: usr_30.txt:283
msgid ""
"You don't want to switch on the 'cindent' option manually every time you "
"edit\n"
"a C file.  This is how you make it work automatically: >"
msgstr ""

#: usr_30.txt:286
msgid "\t:filetype indent on"
msgstr ""

#: usr_30.txt:288
msgid ""
"Actually, this does a lot more than switching on 'cindent' for C files.  "
"First\n"
"of all, it enables detecting the type of a file.  That's the same as what is\n"
"used for syntax highlighting.\n"
"   When the filetype is known, Vim will search for an indent file for this\n"
"type of file.  The Vim distribution includes a number of these for various\n"
"programming languages.  This indent file will then prepare for automatic\n"
"indenting specifically for this file."
msgstr ""

#: usr_30.txt:296
msgid ""
"If you don't like the automatic indenting, you can switch it off again: >"
msgstr ""

#: usr_30.txt:298
msgid "\t:filetype indent off"
msgstr ""

#: usr_30.txt:300
msgid ""
"If you don't like the indenting for one specific type of file, this is how "
"you\n"
"avoid it.  Create a file with just this one line: >"
msgstr ""

#: usr_30.txt:303
msgid "\t:let b:did_indent = 1"
msgstr ""

#: usr_30.txt:305
msgid "Now you need to write this in a file with a specific name:"
msgstr ""

#: usr_30.txt:307
msgid "\t{directory}/indent/{filetype}.vim"
msgstr ""

#: usr_30.txt:309
msgid ""
"The {filetype} is the name of the file type, such as \"cpp\" or \"java\".  You "
"can\n"
"see the exact name that Vim detected with this command: >"
msgstr ""

#: usr_30.txt:312
msgid "\t:set filetype"
msgstr ""

#: usr_30.txt:314
msgid "In this file the output is:"
msgstr ""

#: usr_30.txt:316
msgid "\tfiletype=help ~"
msgstr ""

#: usr_30.txt:318
msgid ""
"Thus you would use \"help\" for {filetype}.\n"
"   For the {directory} part you need to use your runtime directory.  Look at\n"
"the output of this command: >"
msgstr ""

#: usr_30.txt:322
msgid "\tset runtimepath"
msgstr ""

#: usr_30.txt:324
msgid ""
"Now use the first item, the name before the first comma.  Thus if the output\n"
"looks like this:"
msgstr ""

#: usr_30.txt:327
msgid "\truntimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after ~"
msgstr ""

#: usr_30.txt:329
msgid "You use \"~/.vim\" for {directory}.  Then the resulting file name is:"
msgstr ""

#: usr_30.txt:331
msgid "\t~/.vim/indent/help.vim ~"
msgstr ""

#: usr_30.txt:333
msgid ""
"Instead of switching the indenting off, you could write your own indent "
"file.\n"
"How to do that is explained here: |indent-expression|."
msgstr ""

#: usr_30.txt:336
msgid ""
"============================================================================"
"==\n"
"*30.4*\tOther indenting"
msgstr ""

#: usr_30.txt:339
msgid ""
"The most simple form of automatic indenting is with the 'autoindent' option.\n"
"It uses the indent from the previous line.  A bit smarter is the "
"'smartindent'\n"
"option.  This is useful for languages where no indent file is available.\n"
"'smartindent' is not as smart as 'cindent', but smarter than 'autoindent'.\n"
"   With 'smartindent' set, an extra level of indentation is added for each {\n"
"and removed for each }.  An extra level of indentation will also be added "
"for\n"
"any of the words in the 'cinwords' option.  Lines that begin with # are\n"
"treated specially: all indentation is removed.  This is done so that\n"
"preprocessor directives will all start in column 1.  The indentation is\n"
"restored for the next line."
msgstr ""

#: usr_30.txt:351
msgid "CORRECTING INDENTS"
msgstr ""

#: usr_30.txt:353
msgid ""
"When you are using 'autoindent' or 'smartindent' to get the indent of the\n"
"previous line, there will be many times when you need to add or remove one\n"
"'shiftwidth' worth of indent.  A quick way to do this is using the CTRL-D "
"and\n"
"CTRL-T commands in Insert mode.\n"
"   For example, you are typing a shell script that is supposed to look like\n"
"this:"
msgstr ""

#: usr_30.txt:360
msgid ""
"\tif test -n a; then ~\n"
"\t   echo a ~\n"
"\t   echo \"-------\" ~\n"
"\tfi ~"
msgstr ""

#: usr_30.txt:365
msgid "Start off by setting these option: >"
msgstr ""

#: usr_30.txt:367
msgid "\t:set autoindent shiftwidth=3"
msgstr ""

#: usr_30.txt:369
msgid ""
"You start by typing the first line, <Enter> and the start of the second "
"line:"
msgstr ""

#: usr_30.txt:371
msgid ""
"\tif test -n a; then ~\n"
"\techo ~"
msgstr ""

#: usr_30.txt:374
msgid "Now you see that you need an extra indent.  Type CTRL-T.  The result:"
msgstr ""

#: usr_30.txt:376
msgid ""
"\tif test -n a; then ~\n"
"\t   echo ~"
msgstr ""

#: usr_30.txt:379
msgid ""
"The CTRL-T command, in Insert mode, adds one 'shiftwidth' to the indent, no\n"
"matter where in the line you are.\n"
"   You continue typing the second line, <Enter> and the third line.  This "
"time\n"
"the indent is OK.  Then <Enter> and the last line.  Now you have this:"
msgstr ""

#: usr_30.txt:384
msgid ""
"\tif test -n a; then ~\n"
"\t   echo a ~\n"
"\t   echo \"-------\" ~\n"
"\t   fi ~"
msgstr ""

#: usr_30.txt:389
msgid ""
"To remove the superfluous indent in the last line press CTRL-D.  This "
"deletes\n"
"one 'shiftwidth' worth of indent, no matter where you are in the line.\n"
"   When you are in Normal mode, you can use the \">>\" and \"<<\" commands to\n"
"shift lines.  \">\" and \"<\" are operators, thus you have the usual three ways "
"to\n"
"specify the lines you want to indent.  A useful combination is: >"
msgstr ""

#: usr_30.txt:395
msgid "\t>i{"
msgstr ""

#: usr_30.txt:397
msgid ""
"This adds one indent to the current block of lines, inside {}.  The { and }\n"
"lines themselves are left unmodified.  \">a{\" includes them.  In this example\n"
"the cursor is on \"printf\":"
msgstr ""

#: usr_30.txt:401
msgid "\toriginal text\t\tafter \">i{\"\t\tafter \">a{\""
msgstr ""

#: usr_30.txt:403
msgid ""
"\tif (flag)\t\tif (flag)\t\tif (flag) ~\n"
"\t{\t\t\t{\t\t\t    { ~\n"
"\tprintf(\"yes\");\t\t    printf(\"yes\");\t    printf(\"yes\"); ~\n"
"\tflag = 0;\t\t    flag = 0;\t\t    flag = 0;  ~\n"
"\t}\t\t\t}\t\t\t    } ~"
msgstr ""

#: usr_30.txt:409
msgid ""
"============================================================================"
"==\n"
"*30.5*\tTabs and spaces"
msgstr ""

#: usr_30.txt:412
msgid ""
"'tabstop' is set to eight by default.  Although you can change it, you "
"quickly\n"
"run into trouble later.  Other programs won't know what tabstop value you\n"
"used.  They probably use the default value of eight, and your text suddenly\n"
"looks very different.  Also, most printers use a fixed tabstop value of "
"eight.\n"
"Thus it's best to keep 'tabstop' alone.  (If you edit a file which was "
"written\n"
"with a different tabstop setting, see |25.3| for how to fix that.)\n"
"   For indenting lines in a program, using a multiple of eight spaces makes\n"
"you quickly run into the right border of the window.  Using a single space\n"
"doesn't provide enough visual difference.  Many people prefer to use four\n"
"spaces, a good compromise.\n"
"   Since a <Tab> is eight spaces and you want to use an indent of four "
"spaces,\n"
"you can't use a <Tab> character to make your indent.  There are two ways to\n"
"handle this:"
msgstr ""

#: usr_30.txt:426
msgid ""
"1.  Use a mix of <Tab> and space characters.  Since a <Tab> takes the place "
"of\n"
"    eight spaces, you have fewer characters in your file.  Inserting a <Tab>\n"
"    is quicker than eight spaces.  Backspacing works faster as well."
msgstr ""

#: usr_30.txt:430
msgid ""
"2.  Use spaces only.  This avoids the trouble with programs that use a\n"
"    different tabstop value."
msgstr ""

#: usr_30.txt:433
msgid "Fortunately, Vim supports both methods quite well."
msgstr ""

#: usr_30.txt:436
msgid "SPACES AND TABS"
msgstr ""

#: usr_30.txt:438
msgid ""
"If you are using a combination of tabs and spaces, you just edit normally.\n"
"The Vim defaults do a fine job of handling things.\n"
"   You can make life a little easier by setting the 'softtabstop' option.\n"
"This option tells Vim to make the <Tab> key look and feel as if tabs were "
"set\n"
"at the value of 'softtabstop', but actually use a combination of tabs and\n"
"spaces.\n"
"   After you execute the following command, every time you press the <Tab> "
"key\n"
"the cursor moves to the next 4-column boundary: >"
msgstr ""

#: usr_30.txt:447
msgid "\t:set softtabstop=4"
msgstr ""

#: usr_30.txt:449
msgid ""
"When you start in the first column and press <Tab>, you get 4 spaces "
"inserted\n"
"in your text.  The second time, Vim takes out the 4 spaces and puts in a "
"<Tab>\n"
"(thus taking you to column 8).  Thus Vim uses as many <Tab>s as possible, "
"and\n"
"then fills up with spaces.\n"
"   When backspacing it works the other way around.  A <BS> will always "
"delete\n"
"the amount specified with 'softtabstop'.  Then <Tab>s are used as many as\n"
"possible and spaces to fill the gap.\n"
"   The following shows what happens pressing <Tab> a few times, and then "
"using\n"
"<BS>.  A \".\" stands for a space and \"------->\" for a <Tab>."
msgstr ""

#: usr_30.txt:459
msgid ""
"\ttype\t\t\t  result ~\n"
"\t<Tab>\t\t\t  ....\n"
"\t<Tab><Tab>\t\t  ------->\n"
"\t<Tab><Tab><Tab>\t\t  ------->....\n"
"\t<Tab><Tab><Tab><BS>\t  ------->\n"
"\t<Tab><Tab><Tab><BS><BS>   ...."
msgstr ""

#: usr_30.txt:466
msgid ""
"An alternative is to use the 'smarttab' option.  When it's set, Vim uses\n"
"'shiftwidth' for a <Tab> typed in the indent of a line, and a real <Tab> "
"when\n"
"typed after the first non-blank character.  However, <BS> doesn't work like\n"
"with 'softtabstop'."
msgstr ""

#: usr_30.txt:472
msgid "JUST SPACES"
msgstr ""

#: usr_30.txt:474
msgid ""
"If you want absolutely no tabs in your file, you can set the 'expandtab'\n"
"option: >"
msgstr ""

#: usr_30.txt:477
msgid "\t:set expandtab"
msgstr ""

#: usr_30.txt:479
msgid ""
"When this option is set, the <Tab> key inserts a series of spaces.  Thus you\n"
"get the same amount of white space as if a <Tab> character was inserted, but\n"
"there isn't a real <Tab> character in your file.\n"
"   The backspace key will delete each space by itself.  Thus after typing "
"one\n"
"<Tab> you have to press the <BS> key up to eight times to undo it.  If you "
"are\n"
"in the indent, pressing CTRL-D will be a lot quicker."
msgstr ""

#: usr_30.txt:487
msgid "CHANGING TABS IN SPACES (AND BACK)"
msgstr ""

#: usr_30.txt:489
msgid ""
"Setting 'expandtab' does not affect any existing tabs.  In other words, any\n"
"tabs in the document remain tabs.  If you want to convert tabs to spaces, "
"use\n"
"the \":retab\" command.  Use these commands: >"
msgstr ""

#: usr_30.txt:493
msgid ""
"\t:set expandtab\n"
"\t:%retab"
msgstr ""

#: usr_30.txt:496
msgid ""
"Now Vim will have changed all indents to use spaces instead of tabs.  "
"However,\n"
"all tabs that come after a non-blank character are kept.  If you want these "
"to\n"
"be converted as well, add a !: >"
msgstr ""

#: usr_30.txt:500
msgid "\t:%retab!"
msgstr ""

#: usr_30.txt:502
msgid ""
"This is a little bit dangerous, because it can also change tabs inside a\n"
"string.  To check if these exist, you could use this: >"
msgstr ""

#: usr_30.txt:505
msgid "\t/\"[^\"\\t]*\\t[^\"]*\""
msgstr ""

#: usr_30.txt:507
msgid ""
"It's recommended not to use hard tabs inside a string.  Replace them with\n"
"\"\\t\" to avoid trouble."
msgstr ""

#: usr_30.txt:510
msgid "The other way around works just as well: >"
msgstr ""

#: usr_30.txt:512
msgid ""
"\t:set noexpandtab\n"
"\t:%retab!"
msgstr ""

#: usr_30.txt:515
msgid ""
"============================================================================"
"==\n"
"*30.6*\tFormatting comments"
msgstr ""

#: usr_30.txt:518
msgid ""
"One of the great things about Vim is that it understands comments.  You can\n"
"ask Vim to format a comment and it will do the right thing.\n"
"   Suppose, for example, that you have the following comment:"
msgstr ""

#: usr_30.txt:522
msgid ""
"\t/* ~\n"
"\t * This is a test ~\n"
"\t * of the text formatting. ~\n"
"\t */ ~"
msgstr ""

#: usr_30.txt:527
msgid ""
"You then ask Vim to format it by positioning the cursor at the start of the\n"
"comment and type: >"
msgstr ""

#: usr_30.txt:530
msgid "\tgq]/"
msgstr ""

#: usr_30.txt:532
msgid ""
"\"gq\" is the operator to format text.  \"]/\" is the motion that takes you to "
"the\n"
"end of a comment.  The result is:"
msgstr ""

#: usr_30.txt:535
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t */ ~"
msgstr ""

#: usr_30.txt:539
msgid ""
"Notice that Vim properly handled the beginning of each line.\n"
"  An alternative is to select the text that is to be formatted in Visual "
"mode\n"
"and type \"gq\"."
msgstr ""

#: usr_30.txt:543
msgid ""
"To add a new line to the comment, position the cursor on the middle line and\n"
"press \"o\".  The result looks like this:"
msgstr ""

#: usr_30.txt:546
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t * ~\n"
"\t */ ~"
msgstr ""

#: usr_30.txt:551
msgid ""
"Vim has automatically inserted a star and a space for you.  Now you can type\n"
"the comment text.  When it gets longer than 'textwidth', Vim will break the\n"
"line.  Again, the star is inserted automatically:"
msgstr ""

#: usr_30.txt:555
msgid ""
"\t/* ~\n"
"\t * This is a test of the text formatting. ~\n"
"\t * Typing a lot of text here will make Vim ~\n"
"\t * break ~\n"
"\t */ ~"
msgstr ""

#: usr_30.txt:561
msgid "For this to work some flags must be present in 'formatoptions':"
msgstr ""

#: usr_30.txt:563
msgid ""
"\tr\tinsert the star when typing <Enter> in Insert mode\n"
"\to\tinsert the star when using \"o\" or \"O\" in Normal mode\n"
"\tc\tbreak comment text according to 'textwidth'"
msgstr ""

#: usr_30.txt:567
msgid "See |fo-table| for more flags."
msgstr ""

#: usr_30.txt:570
msgid "DEFINING A COMMENT"
msgstr ""

#: usr_30.txt:572
msgid ""
"The 'comments' option defines what a comment looks like.  Vim distinguishes\n"
"between a single-line comment and a comment that has a different start, end\n"
"and middle part.\n"
"   Many single-line comments start with a specific character.  In C++ // is\n"
"used, in Makefiles #, in Vim scripts \".  For example, to make Vim understand\n"
"C++ comments: >"
msgstr ""

#: usr_30.txt:579
msgid "\t:set comments=://"
msgstr ""

#: usr_30.txt:581
msgid ""
"The colon separates the flags of an item from the text by which the comment "
"is\n"
"recognized.  The general form of an item in 'comments' is:"
msgstr ""

#: usr_30.txt:584
msgid "\t{flags}:{text}"
msgstr ""

#: usr_30.txt:586
msgid ""
"The {flags} part can be empty, as in this case.\n"
"   Several of these items can be concatenated, separated by commas.  This\n"
"allows recognizing different types of comments at the same time.  For "
"example,\n"
"let's edit an e-mail message.  When replying, the text that others wrote is\n"
"preceded with \">\" and \"!\" characters.  This command would work: >"
msgstr ""

#: usr_30.txt:592
msgid "\t:set comments=n:>,n:!"
msgstr ""

#: usr_30.txt:594
msgid ""
"There are two items, one for comments starting with \">\" and one for comments\n"
"that start with \"!\".  Both use the flag \"n\".  This means that these comments\n"
"nest.  Thus a line starting with \">\" may have another comment after the \">\".\n"
"This allows formatting a message like this:"
msgstr ""

#: usr_30.txt:599
msgid ""
"\t> ! Did you see that site? ~\n"
"\t> ! It looks really great. ~\n"
"\t> I don't like it.  The ~\n"
"\t> colors are terrible. ~\n"
"\tWhat is the URL of that ~\n"
"\tsite? ~"
msgstr ""

#: usr_30.txt:606
msgid ""
"Try setting 'textwidth' to a different value, e.g., 80, and format the text "
"by\n"
"Visually selecting it and typing \"gq\".  The result is:"
msgstr ""

#: usr_30.txt:609
msgid ""
"\t> ! Did you see that site?  It looks really great. ~\n"
"\t> I don't like it.  The colors are terrible. ~\n"
"\tWhat is the URL of that site? ~"
msgstr ""

#: usr_30.txt:613
msgid ""
"You will notice that Vim did not move text from one type of comment to\n"
"another.  The \"I\" in the second line would have fit at the end of the first\n"
"line, but since that line starts with \"> !\" and the second line with \">\", "
"Vim\n"
"knows that this is a different kind of comment."
msgstr ""

#: usr_30.txt:619
msgid "A THREE PART COMMENT"
msgstr ""

#: usr_30.txt:621
msgid ""
"A C comment starts with \"/*\", has \"*\" in the middle and \"*/\" at the end.  "
"The\n"
"entry in 'comments' for this looks like this: >"
msgstr ""

#: usr_30.txt:624
msgid "\t:set comments=s1:/*,mb:*,ex:*/"
msgstr ""

#: usr_30.txt:626
msgid ""
"The start is defined with \"s1:/*\".  The \"s\" indicates the start of a\n"
"three-piece comment.  The colon separates the flags from the text by which "
"the\n"
"comment is recognized: \"/*\".  There is one flag: \"1\".  This tells Vim that "
"the\n"
"middle part has an offset of one space.\n"
"   The middle part \"mb:*\" starts with \"m\", which indicates it is a middle\n"
"part.  The \"b\" flag means that a blank must follow the text.  Otherwise Vim\n"
"would consider text like \"*pointer\" also to be the middle of a comment.\n"
"   The end part \"ex:*/\" has the \"e\" for identification.  The \"x\" flag has a\n"
"special meaning.  It means that after Vim automatically inserted a star,\n"
"typing / will remove the extra space."
msgstr ""

#: usr_30.txt:637
msgid "For more details see |format-comments|."
msgstr ""

#: usr_30.txt:639
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_30.txt:641
msgid "Next chapter: |usr_31.txt|  Exploiting the GUI"
msgstr ""

#: usr_30.txt:643
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
