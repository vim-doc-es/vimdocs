#. extracted from usr_29.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-04 13:40+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_29.txt:1
msgid "*usr_29.txt*\tFor Vim version 7.2.  Last change: 2008 Jun 28"
msgstr ""

#: usr_29.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_29.txt:5
msgid "\t\t\t    Moving through programs"
msgstr ""

#: usr_29.txt:8
msgid ""
"The creator of Vim is a computer programmer.  It's no surprise that Vim\n"
"contains many features to aid in writing programs.  Jump around to find "
"where\n"
"identifiers are defined and used.  Preview declarations in a separate "
"window.\n"
"There is more in the next chapter."
msgstr ""

#: usr_29.txt:13
msgid ""
"|29.1|\tUsing tags\n"
"|29.2|\tThe preview window\n"
"|29.3|\tMoving through a program\n"
"|29.4|\tFinding global identifiers\n"
"|29.5|\tFinding local identifiers"
msgstr ""

#: usr_29.txt:19
msgid ""
"     Next chapter: |usr_30.txt|  Editing programs\n"
" Previous chapter: |usr_28.txt|  Folding\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_29.txt:23
msgid ""
"============================================================================"
"==\n"
"*29.1*\tUsing tags"
msgstr ""

#: usr_29.txt:26
msgid ""
"What is a tag?  It is a location where an identifier is defined.  An example\n"
"is a function definition in a C or C++ program.  A list of tags is kept in a\n"
"tags file.  This can be used by Vim to directly jump from any place to the\n"
"tag, the place where an identifier is defined.\n"
"   To generate the tags file for all C files in the current directory, use "
"the\n"
"following command: >"
msgstr ""

#: usr_29.txt:33
msgid "\texuberant-ctags *.c"
msgstr ""

#: usr_29.txt:35
msgid ""
"\"exuberant-ctags\" is a separate program.  Most Unix systems already have it "
"installed.\n"
"If you do not have it yet, you can find Exuberant ctags here:"
msgstr ""

#: usr_29.txt:38
msgid "\thttp://ctags.sf.net ~"
msgstr ""

#: usr_29.txt:40
msgid ""
"Now when you are in Vim and you want to go to a function definition, you can\n"
"jump to it by using the following command: >"
msgstr ""

#: usr_29.txt:43
msgid "\t:tag startlist"
msgstr ""

#: usr_29.txt:45
msgid ""
"This command will find the function \"startlist\" even if it is in another "
"file.\n"
"   The CTRL-] command jumps to the tag of the word that is under the cursor.\n"
"This makes it easy to explore a tangle of C code.  Suppose, for example, "
"that\n"
"you are in the function \"write_block\".  You can see that it calls\n"
"\"write_line\".  But what does \"write_line\" do?  By placing the cursor on the\n"
"call to \"write_line\" and pressing CTRL-], you jump to the definition of this\n"
"function.\n"
"   The \"write_line\" function calls \"write_char\".  You need to figure out "
"what\n"
"it does.  So you position the cursor over the call to \"write_char\" and press\n"
"CTRL-].  Now you are at the definition of \"write_char\"."
msgstr ""

#: usr_29.txt:56
msgid ""
"\t+-------------------------------------+\n"
"\t|void write_block(char **s; int cnt)  |\n"
"\t|{\t\t\t\t      |\n"
"\t|   int i;\t\t\t      |\n"
"\t|   for (i = 0; i < cnt; ++i)\t      |\n"
"\t|      write_line(s[i]);\t      |\n"
"\t|}\t    |\t\t\t      |\n"
"\t+-----------|-------------------------+\n"
"\t\t    |\n"
"\t     CTRL-] |\n"
"\t\t    |\t +----------------------------+\n"
"\t\t    +--> |void write_line(char *s)    |\n"
"\t\t\t |{\t\t\t      |\n"
"\t\t\t |   while (*s != 0)\t      |\n"
"\t\t\t |\twrite_char(*s++);     |\n"
"\t\t\t |}\t  |\t\t      |\n"
"\t\t\t +--------|-------------------+\n"
"\t\t\t\t  |\n"
"\t\t\t   CTRL-] |\n"
"\t\t\t\t  |    +------------------------------------+\n"
"\t\t\t\t  +--> |void write_char(char c)\t\t    |\n"
"\t\t\t\t       |{\t\t\t\t    |\n"
"\t\t\t\t       |    putchar((int)(unsigned char)c); |\n"
"\t\t\t\t       |}\t\t\t\t    |\n"
"\t\t\t\t       +------------------------------------+"
msgstr ""

#: usr_29.txt:82
msgid "The \":tags\" command shows the list of tags that you traversed through:"
msgstr ""

#: usr_29.txt:84
msgid ""
"\t:tags\n"
"\t  # TO tag\t   FROM line  in file/text ~\n"
"\t  1  1 write_line\t   8  write_block.c ~\n"
"\t  2  1 write_char\t   7  write_line.c ~\n"
"\t> ~\n"
">\n"
"Now to go back.  The CTRL-T command goes to the preceding tag.  In the "
"example\n"
"above you get back to the \"write_line\" function, in the call to "
"\"write_char\".\n"
"   This command takes a count argument that indicates how many tags to jump\n"
"back.  You have gone forward, and now back.  Let's go forward again.  The\n"
"following command goes to the tag on top of the list: >"
msgstr ""

#: usr_29.txt:96
msgid "\t:tag"
msgstr ""

#: usr_29.txt:98
msgid ""
"You can prefix it with a count and jump forward that many tags.  For "
"example:\n"
"\":3tag\".  CTRL-T also can be preceded with a count.\n"
"   These commands thus allow you to go down a call tree with CTRL-] and back\n"
"up again with CTRL-T.  Use \":tags\" to find out where you are."
msgstr ""

#: usr_29.txt:104
msgid "SPLIT WINDOWS"
msgstr ""

#: usr_29.txt:106
msgid ""
"The \":tag\" command replaces the file in the current window with the one\n"
"containing the new function.  But suppose you want to see not only the old\n"
"function but also the new one?  You can split the window using the \":split\"\n"
"command followed by the \":tag\" command.  Vim has a shorthand command that "
"does\n"
"both: >\n"
"\t:stag tagname"
msgstr ""

#: usr_29.txt:113
msgid ""
"To split the current window and jump to the tag under the cursor use this\n"
"command: >"
msgstr ""

#: usr_29.txt:116
msgid "\tCTRL-W ]"
msgstr ""

#: usr_29.txt:118
msgid "If a count is specified, the new window will be that many lines high."
msgstr ""

#: usr_29.txt:121
msgid "MORE TAGS FILES"
msgstr ""

#: usr_29.txt:123
msgid ""
"When you have files in many directories, you can create a tags file in each "
"of\n"
"them.  Vim will then only be able to jump to tags within that directory.\n"
"   To find more tags files, set the 'tags' option to include all the "
"relevant\n"
"tags files.  Example: >"
msgstr ""

#: usr_29.txt:128
msgid "\t:set tags=./tags,./../tags,./*/tags"
msgstr ""

#: usr_29.txt:130
msgid ""
"This finds a tags file in the same directory as the current file, one\n"
"directory level higher and in all subdirectories.\n"
"   This is quite a number of tags files, but it may still not be enough.  "
"For\n"
"example, when editing a file in \"~/proj/src\", you will not find the tags "
"file\n"
"\"~/proj/sub/tags\".  For this situation Vim offers to search a whole "
"directory\n"
"tree for tags files.  Example: >"
msgstr ""

#: usr_29.txt:137
msgid "\t:set tags=~/proj/**/tags"
msgstr ""

#: usr_29.txt:140
msgid "ONE TAGS FILE"
msgstr ""

#: usr_29.txt:142
msgid ""
"When Vim has to search many places for tags files, you can hear the disk\n"
"rattling.  It may get a bit slow.  In that case it's better to spend this\n"
"time while generating one big tags file.  You might do this overnight.\n"
"   This requires the Exuberant ctags program, mentioned above.  It offers an\n"
"argument to search a whole directory tree: >"
msgstr ""

#: usr_29.txt:148
msgid ""
"\tcd ~/proj\n"
"\texuberant-ctags -R ."
msgstr ""

#: usr_29.txt:151
msgid ""
"The nice thing about this is that Exuberant ctags recognizes various file\n"
"types.  Thus this doesn't work just for C and C++ programs, also for Eiffel\n"
"and even Vim scripts.  See the ctags documentation to tune this.\n"
"   Now you only need to tell Vim where your big tags file is: >"
msgstr ""

#: usr_29.txt:156
msgid "\t:set tags=~/proj/tags"
msgstr ""

#: usr_29.txt:159
msgid "MULTIPLE MATCHES"
msgstr ""

#: usr_29.txt:161
msgid ""
"When a function is defined multiple times (or a method in several classes),\n"
"the \":tag\" command will jump to the first one.  If there is a match in the\n"
"current file, that one is used first.\n"
"   You can now jump to other matches for the same tag with: >"
msgstr ""

#: usr_29.txt:166
msgid "\t:tnext"
msgstr ""

#: usr_29.txt:168
msgid ""
"Repeat this to find further matches.  If there are many, you can select "
"which\n"
"one to jump to: >"
msgstr ""

#: usr_29.txt:171
msgid "\t:tselect tagname"
msgstr ""

#: usr_29.txt:173
msgid "Vim will present you with a list of choices:"
msgstr ""

#: usr_29.txt:175
msgid ""
"\t  # pri kind tag\t       file ~\n"
"\t  1 F\tf    mch_init\t       os_amiga.c ~\n"
"\t\t       mch_init() ~\n"
"\t  2 F\tf    mch_init\t       os_mac.c ~\n"
"\t\t       mch_init() ~\n"
"\t  3 F\tf    mch_init\t       os_msdos.c ~\n"
"\t\t       mch_init(void) ~\n"
"\t  4 F\tf    mch_init\t       os_riscos.c ~\n"
"\t\t       mch_init() ~\n"
"\tEnter nr of choice (<CR> to abort):  ~"
msgstr ""

#: usr_29.txt:186
msgid ""
"You can now enter the number (in the first column) of the match that you "
"would\n"
"like to jump to.  The information in the other columns give you a good idea "
"of\n"
"where the match is defined."
msgstr ""

#: usr_29.txt:190
msgid "To move between the matching tags, these commands can be used:"
msgstr ""

#: usr_29.txt:192
msgid ""
"\t:tfirst\t\t\tgo to first match\n"
"\t:[count]tprevious\tgo to [count] previous match\n"
"\t:[count]tnext\t\tgo to [count] next match\n"
"\t:tlast\t\t\tgo to last match"
msgstr ""

#: usr_29.txt:197
msgid "If [count] is omitted then one is used."
msgstr ""

#: usr_29.txt:200
msgid "GUESSING TAG NAMES"
msgstr ""

#: usr_29.txt:202
msgid ""
"Command line completion is a good way to avoid typing a long tag name.  Just\n"
"type the first bit and press <Tab>: >"
msgstr ""

#: usr_29.txt:205
msgid "\t:tag write_<Tab>"
msgstr ""

#: usr_29.txt:207
msgid ""
"You will get the first match.  If it's not the one you want, press <Tab> "
"until\n"
"you find the right one.\n"
"   Sometimes you only know part of the name of a function.  Or you have many\n"
"tags that start with the same string, but end differently.  Then you can "
"tell\n"
"Vim to use a pattern to find the tag.\n"
"   Suppose you want to jump to a tag that contains \"block\".  First type\n"
"this: >"
msgstr ""

#: usr_29.txt:215
msgid "\t:tag /block"
msgstr ""

#: usr_29.txt:217
msgid ""
"Now use command line completion: press <Tab>.  Vim will find all tags that\n"
"contain \"block\" and use the first match.\n"
"   The \"/\" before a tag name tells Vim that what follows is not a literal "
"tag\n"
"name, but a pattern.  You can use all the items for search patterns here.  "
"For\n"
"example, suppose you want to select a tag that starts with \"write_\": >"
msgstr ""

#: usr_29.txt:223
msgid "\t:tselect /^write_"
msgstr ""

#: usr_29.txt:225
msgid ""
"The \"^\" specifies that the tag starts with \"write_\".  Otherwise it would "
"also\n"
"be found halfway a tag name.  Similarly \"$\" at the end makes sure the "
"pattern\n"
"matches until the end of a tag."
msgstr ""

#: usr_29.txt:230
msgid "A TAGS BROWSER"
msgstr ""

#: usr_29.txt:232
msgid ""
"Since CTRL-] takes you to the definition of the identifier under the cursor,\n"
"you can use a list of identifier names as a table of contents.  Here is an\n"
"example.\n"
"   First create a list of identifiers (this requires Exuberant ctags): >"
msgstr ""

#: usr_29.txt:237
msgid "\texuberant-ctags --c-types=f -f functions *.c"
msgstr ""

#: usr_29.txt:239
msgid ""
"Now start Vim without a file, and edit this file in Vim, in a vertically "
"split\n"
"window: >"
msgstr ""

#: usr_29.txt:242
msgid ""
"\tvim\n"
"\t:vsplit functions"
msgstr ""

#: usr_29.txt:245
msgid ""
"The window contains a list of all the functions.  There is some more stuff,\n"
"but you can ignore that.  Do \":setlocal ts=99\" to clean it up a bit.\n"
"   In this window, define a mapping: >"
msgstr ""

#: usr_29.txt:249
msgid "\t:nnoremap <buffer> <CR> 0ye<C-W>w:tag <C-R>\"<CR>"
msgstr ""

#: usr_29.txt:251
msgid ""
"Move the cursor to the line that contains the function you want to go to.\n"
"Now press <Enter>.  Vim will go to the other window and jump to the selected\n"
"function."
msgstr ""

#: usr_29.txt:256
msgid "RELATED ITEMS"
msgstr ""

#: usr_29.txt:258
msgid "You can set 'ignorecase' to make case in tag names be ignored."
msgstr ""

#: usr_29.txt:260
msgid ""
"The 'tagbsearch' option tells if the tags file is sorted or not.  The "
"default\n"
"is to assume a sorted tags file, which makes a tags search a lot faster, but\n"
"doesn't work if the tags file isn't sorted."
msgstr ""

#: usr_29.txt:264
msgid ""
"The 'taglength' option can be used to tell Vim the number of significant\n"
"characters in a tag."
msgstr ""

#: usr_29.txt:267
msgid ""
"When you use the SNiFF+ program, you can use the Vim interface to it "
"|sniff|.\n"
"SNiFF+ is a commercial program."
msgstr ""

#: usr_29.txt:270
msgid ""
"Cscope is a free program.  It does not only find places where an identifier "
"is\n"
"declared, but also where it is used.  See |cscope|."
msgstr ""

#: usr_29.txt:273
msgid ""
"============================================================================"
"==\n"
"*29.2*\tThe preview window"
msgstr ""

#: usr_29.txt:276
msgid ""
"When you edit code that contains a function call, you need to use the "
"correct\n"
"arguments.  To know what values to pass you can look at how the function is\n"
"defined.  The tags mechanism works very well for this.  Preferably the\n"
"definition is displayed in another window.  For this the preview window can "
"be\n"
"used.\n"
"   To open a preview window to display the function \"write_char\": >"
msgstr ""

#: usr_29.txt:283
msgid "\t:ptag write_char"
msgstr ""

#: usr_29.txt:285
msgid ""
"Vim will open a window, and jumps to the tag \"write_char\".  Then it takes "
"you\n"
"back to the original position.  Thus you can continue typing without the "
"need\n"
"to use a CTRL-W command.\n"
"   If the name of a function appears in the text, you can get its definition\n"
"in the preview window with: >"
msgstr ""

#: usr_29.txt:291
msgid "\tCTRL-W }"
msgstr ""

#: usr_29.txt:293
msgid ""
"There is a script that automatically displays the text where the word under\n"
"the cursor was defined.  See |CursorHold-example|."
msgstr ""

#: usr_29.txt:296
msgid "To close the preview window use this command: >"
msgstr ""

#: usr_29.txt:298
msgid "\t:pclose"
msgstr ""

#: usr_29.txt:300
msgid ""
"To edit a specific file in the preview window, use \":pedit\".  This can be\n"
"useful to edit a header file, for example: >"
msgstr ""

#: usr_29.txt:303
msgid "\t:pedit defs.h"
msgstr ""

#: usr_29.txt:305
msgid ""
"Finally, \":psearch\" can be used to find a word in the current file and any\n"
"included files and display the match in the preview window.  This is\n"
"especially useful when using library functions, for which you do not have a\n"
"tags file.  Example: >"
msgstr ""

#: usr_29.txt:310
msgid "\t:psearch popen"
msgstr ""

#: usr_29.txt:312
msgid ""
"This will show the \"stdio.h\" file in the preview window, with the function\n"
"prototype for popen():"
msgstr ""

#: usr_29.txt:315
msgid "\tFILE\t*popen __P((const char *, const char *)); ~"
msgstr ""

#: usr_29.txt:317
msgid ""
"You can specify the height of the preview window, when it is opened, with "
"the\n"
"'previewheight' option."
msgstr ""

#: usr_29.txt:320
msgid ""
"============================================================================"
"==\n"
"*29.3*\tMoving through a program"
msgstr ""

#: usr_29.txt:323
msgid ""
"Since a program is structured, Vim can recognize items in it.  Specific\n"
"commands can be used to move around.\n"
"   C programs often contain constructs like this:"
msgstr ""

#: usr_29.txt:327
msgid ""
"\t#ifdef USE_POPEN ~\n"
"\t    fd = popen(\"ls\", \"r\") ~\n"
"\t#else ~\n"
"\t    fd = fopen(\"tmp\", \"w\") ~\n"
"\t#endif ~"
msgstr ""

#: usr_29.txt:333
msgid ""
"But then much longer, and possibly nested.  Position the cursor on the\n"
"\"#ifdef\" and press %.  Vim will jump to the \"#else\".  Pressing % again takes\n"
"you to the \"#endif\".  Another % takes you to the \"#ifdef\" again.\n"
"   When the construct is nested, Vim will find the matching items.  This is "
"a\n"
"good way to check if you didn't forget an \"#endif\".\n"
"   When you are somewhere inside a \"#if\" - \"#endif\", you can jump to the "
"start\n"
"of it with: >"
msgstr ""

#: usr_29.txt:341
msgid "\t[#"
msgstr ""

#: usr_29.txt:343
msgid ""
"If you are not after a \"#if\" or \"#ifdef\" Vim will beep.  To jump forward to\n"
"the next \"#else\" or \"#endif\" use: >"
msgstr ""

#: usr_29.txt:346
msgid "\t]#"
msgstr ""

#: usr_29.txt:348
msgid ""
"These two commands skip any \"#if\" - \"#endif\" blocks that they encounter.\n"
"Example:"
msgstr ""

#: usr_29.txt:351
msgid ""
"\t#if defined(HAS_INC_H) ~\n"
"\t    a = a + inc(); ~\n"
"\t# ifdef USE_THEME ~\n"
"\t    a += 3; ~\n"
"\t# endif ~\n"
"\t    set_width(a); ~"
msgstr ""

#: usr_29.txt:358
msgid ""
"With the cursor in the last line, \"[#\" moves to the first line.  The "
"\"#ifdef\"\n"
"- \"#endif\" block in the middle is skipped."
msgstr ""

#: usr_29.txt:362
msgid "MOVING IN CODE BLOCKS"
msgstr ""

#: usr_29.txt:364
msgid ""
"In C code blocks are enclosed in {}.  These can get pretty long.  To move to\n"
"the start of the outer block use the \"[[\" command.  Use \"][\" to find the "
"end.\n"
"This assumes that the \"{\" and \"}\" are in the first column.\n"
"   The \"[{\" command moves to the start of the current block.  It skips over\n"
"pairs of {} at the same level.  \"]}\" jumps to the end.\n"
"   An overview:"
msgstr ""

#: usr_29.txt:371
msgid ""
"\t\t\tfunction(int a)\n"
"\t   +->\t\t{\n"
"\t   |\t\t    if (a)\n"
"\t   |\t   +->\t    {\n"
"\t[[ |\t   |\t\tfor (;;)\t       --+\n"
"\t   |\t   |\t  +->\t{\t\t\t |\n"
"\t   |\t[{ |\t  |\t    foo(32);\t\t |     --+\n"
"\t   |\t   |   [{ |\t    if (bar(a))  --+\t | ]}\t |\n"
"\t   +--\t   |\t  +--\t\tbreak;\t   | ]}  |\t |\n"
"\t\t   |\t\t}\t\t <-+\t |\t | ][\n"
"\t\t   +--\t\tfoobar(a)\t\t |\t |\n"
"\t\t\t    }\t\t\t       <-+\t |\n"
"\t\t\t}\t\t\t\t       <-+"
msgstr ""

#: usr_29.txt:385
msgid ""
"When writing C++ or Java, the outer {} block is for the class.  The next "
"level\n"
"of {} is for a method.  When somewhere inside a class use \"[m\" to find the\n"
"previous start of a method.  \"]m\" finds the next start of a method."
msgstr ""

#: usr_29.txt:389
msgid ""
"Additionally, \"[]\" moves backward to the end of a function and \"]]\" moves\n"
"forward to the start of the next function.  The end of a function is defined\n"
"by a \"}\" in the first column."
msgstr ""

#: usr_29.txt:393
msgid ""
"\t\t\t\tint func1(void)\n"
"\t\t\t\t{\n"
"\t\t\t\t\treturn 1;\n"
"\t\t  +---------->  }\n"
"\t\t  |\n"
"\t      []  |\t\tint func2(void)\n"
"\t\t  |\t   +->\t{\n"
"\t\t  |    [[  |\t\tif (flag)\n"
"\tstart\t  +--\t   +--\t\t\treturn flag;\n"
"\t\t  |    ][  |\t\treturn 2;\n"
"\t\t  |\t   +->\t}\n"
"\t      ]]  |\n"
"\t\t  |\t\tint func3(void)\n"
"\t\t  +---------->\t{\n"
"\t\t\t\t\treturn 3;\n"
"\t\t\t\t}"
msgstr ""

#: usr_29.txt:410
msgid ""
"Don't forget you can also use \"%\" to move between matching (), {} and [].\n"
"That also works when they are many lines apart."
msgstr ""

#: usr_29.txt:414
msgid "MOVING IN BRACES"
msgstr ""

#: usr_29.txt:416
msgid ""
"The \"[(\" and \"])\" commands work similar to \"[{\" and \"]}\", except that they\n"
"work on () pairs instead of {} pairs.\n"
">\n"
"\t\t\t\t  [(\n"
"<\t\t    <--------------------------------\n"
"\t\t\t      <-------\n"
"\t\tif (a == b && (c == d || (e > f)) && x > y) ~\n"
"\t\t\t\t  -------------->\n"
"\t\t\t  --------------------------------> >\n"
"\t\t\t\t       ])"
msgstr ""

#: usr_29.txt:427
msgid "MOVING IN COMMENTS"
msgstr ""

#: usr_29.txt:429
msgid ""
"To move back to the start of a comment use \"[/\".  Move forward to the end of "
"a\n"
"comment with \"]/\".  This only works for /* - */ comments."
msgstr ""

#: usr_29.txt:432
msgid ""
"\t  +->\t  +-> /*\n"
"\t  |    [/ |    * A comment about      --+\n"
"       [/ |\t  +--  * wonderful life.\t| ]/\n"
"\t  |\t       */\t\t      <-+\n"
"\t  |\n"
"\t  +--\t       foo = bar * 3;\t      --+\n"
"\t\t\t\t\t\t| ]/\n"
"\t\t       /* a short comment */  <-+"
msgstr ""

#: usr_29.txt:441
msgid ""
"============================================================================"
"==\n"
"*29.4*\tFinding global identifiers"
msgstr ""

#: usr_29.txt:444
msgid ""
"You are editing a C program and wonder if a variable is declared as \"int\" or\n"
"\"unsigned\".  A quick way to find this is with the \"[I\" command.\n"
"   Suppose the cursor is on the word \"column\".  Type: >"
msgstr ""

#: usr_29.txt:448
msgid "\t[I"
msgstr ""

#: usr_29.txt:450
msgid ""
"Vim will list the matching lines it can find.  Not only in the current file,\n"
"but also in all included files (and files included in them, etc.).  The "
"result\n"
"looks like this:"
msgstr ""

#: usr_29.txt:454
msgid ""
"\tstructs.h ~\n"
"\t 1:   29     unsigned     column;    /* column number */ ~"
msgstr ""

#: usr_29.txt:457
msgid ""
"The advantage over using tags or the preview window is that included files "
"are\n"
"searched.  In most cases this results in the right declaration to be found.\n"
"Also when the tags file is out of date.  Also when you don't have tags for "
"the\n"
"included files.\n"
"   However, a few things must be right for \"[I\" to do its work.  First of "
"all,\n"
"the 'include' option must specify how a file is included.  The default value\n"
"works for C and C++.  For other languages you will have to change it."
msgstr ""

#: usr_29.txt:466
msgid "LOCATING INCLUDED FILES"
msgstr ""

#: usr_29.txt:468
msgid ""
"   Vim will find included files in the places specified with the 'path'\n"
"option.  If a directory is missing, some include files will not be found.  "
"You\n"
"can discover this with this command: >"
msgstr ""

#: usr_29.txt:472
msgid "\t:checkpath"
msgstr ""

#: usr_29.txt:474
msgid ""
"It will list the include files that could not be found.  Also files included\n"
"by the files that could be found.  An example of the output:"
msgstr ""

#: usr_29.txt:477
msgid ""
"\t--- Included files not found in path --- ~\n"
"\t<io.h> ~\n"
"\tvim.h --> ~\n"
"\t  <functions.h> ~\n"
"\t  <clib/exec_protos.h> ~"
msgstr ""

#: usr_29.txt:483
msgid ""
"The \"io.h\" file is included by the current file and can't be found.  \"vim.h\"\n"
"can be found, thus \":checkpath\" goes into this file and checks what it\n"
"includes.  The \"functions.h\" and \"clib/exec_protos.h\" files, included by\n"
"\"vim.h\" are not found."
msgstr ""

#: usr_29.txt:488
msgid ""
"\tNote:\n"
"\tVim is not a compiler.  It does not recognize \"#ifdef\" statements.\n"
"\tThis means every \"#include\" statement is used, also when it comes\n"
"\tafter \"#if NEVER\"."
msgstr ""

#: usr_29.txt:493
msgid ""
"To fix the files that could not be found, add a directory to the 'path'\n"
"option.  A good place to find out about this is the Makefile.  Look out for\n"
"lines that contain \"-I\" items, like \"-I/usr/local/X11\".  To add this "
"directory\n"
"use: >"
msgstr ""

#: usr_29.txt:498
msgid "\t:set path+=/usr/local/X11"
msgstr ""

#: usr_29.txt:500
msgid ""
"When there are many subdirectories, you can use the \"*\" wildcard.  Example: "
">"
msgstr ""

#: usr_29.txt:502
msgid "\t:set path+=/usr/*/include"
msgstr ""

#: usr_29.txt:504
msgid ""
"This would find files in \"/usr/local/include\" as well as \"/usr/X11/include\"."
msgstr ""

#: usr_29.txt:506
msgid ""
"When working on a project with a whole nested tree of included files, the "
"\"**\"\n"
"items is useful.  This will search down in all subdirectories.  Example: >"
msgstr ""

#: usr_29.txt:509
msgid "\t:set path+=/projects/invent/**/include"
msgstr ""

#: usr_29.txt:511
msgid "This will find files in the directories:"
msgstr ""

#: usr_29.txt:513
msgid ""
"\t/projects/invent/include ~\n"
"\t/projects/invent/main/include ~\n"
"\t/projects/invent/main/os/include ~\n"
"\tetc."
msgstr ""

#: usr_29.txt:518
msgid ""
"There are even more possibilities.  Check out the 'path' option for info.\n"
"   If you want to see which included files are actually found, use this\n"
"command: >"
msgstr ""

#: usr_29.txt:522
msgid "\t:checkpath!"
msgstr ""

#: usr_29.txt:524
msgid ""
"You will get a (very long) list of included files, the files they include, "
"and\n"
"so on.  To shorten the list a bit, Vim shows \"(Already listed)\" for files "
"that\n"
"were found before and doesn't list the included files in there again."
msgstr ""

#: usr_29.txt:529
msgid "JUMPING TO A MATCH"
msgstr ""

#: usr_29.txt:531
msgid ""
"\"[I\" produces a list with only one line of text.  When you want to have a\n"
"closer look at the first item, you can jump to that line with the command: >"
msgstr ""

#: usr_29.txt:534
msgid "\t[<Tab>"
msgstr ""

#: usr_29.txt:536
msgid ""
"You can also use \"[ CTRL-I\", since CTRL-I is the same as pressing <Tab>."
msgstr ""

#: usr_29.txt:538
msgid ""
"The list that \"[I\" produces has a number at the start of each line.  When "
"you\n"
"want to jump to another item than the first one, type the number first: >"
msgstr ""

#: usr_29.txt:541
msgid "\t3[<Tab>"
msgstr ""

#: usr_29.txt:543
msgid ""
"Will jump to the third item in the list.  Remember that you can use CTRL-O "
"to\n"
"jump back to where you started from."
msgstr ""

#: usr_29.txt:547
msgid "RELATED COMMANDS"
msgstr ""

#: usr_29.txt:549
msgid ""
"\t[i\t\tonly lists the first match\n"
"\t]I\t\tonly lists items below the cursor\n"
"\t]i\t\tonly lists the first item below the cursor"
msgstr ""

#: usr_29.txt:554
msgid "FINDING DEFINED IDENTIFIERS"
msgstr ""

#: usr_29.txt:556
msgid ""
"The \"[I\" command finds any identifier.  To find only macros, defined with\n"
"\"#define\" use: >"
msgstr ""

#: usr_29.txt:559
msgid "\t[D"
msgstr ""

#: usr_29.txt:561
msgid ""
"Again, this searches in included files.  The 'define' option specifies what "
"a\n"
"line looks like that defines the items for \"[D\".  You could change it to "
"make\n"
"it work with other languages than C or C++.\n"
"   The commands related to \"[D\" are:"
msgstr ""

#: usr_29.txt:566
msgid ""
"\t[d\t\tonly lists the first match\n"
"\t]D\t\tonly lists items below the cursor\n"
"\t]d\t\tonly lists the first item below the cursor"
msgstr ""

#: usr_29.txt:570
msgid ""
"============================================================================"
"==\n"
"*29.5*\tFinding local identifiers"
msgstr ""

#: usr_29.txt:573
msgid ""
"The \"[I\" command searches included files.  To search in the current file "
"only,\n"
"and jump to the first place where the word under the cursor is used: >"
msgstr ""

#: usr_29.txt:576
msgid "\tgD"
msgstr ""

#: usr_29.txt:578
msgid ""
"Hint: Goto Definition.  This command is very useful to find a variable or\n"
"function that was declared locally (\"static\", in C terms).  Example (cursor "
"on\n"
"\"counter\"):"
msgstr ""

#: usr_29.txt:582
msgid ""
"\t   +->   static int counter = 0;\n"
"\t   |\n"
"\t   |     int get_counter(void)\n"
"\tgD |     {\n"
"\t   |\t     ++counter;\n"
"\t   +--\t     return counter;\n"
"\t\t }"
msgstr ""

#: usr_29.txt:590
msgid ""
"To restrict the search even further, and look only in the current function,\n"
"use this command: >"
msgstr ""

#: usr_29.txt:593
msgid "\tgd"
msgstr ""

#: usr_29.txt:595
msgid ""
"This will go back to the start of the current function and find the first\n"
"occurrence of the word under the cursor.  Actually, it searches backwards to\n"
"an empty line above a \"{\" in the first column.  From there it searches "
"forward\n"
"for the identifier.  Example (cursor on \"idx\"):"
msgstr ""

#: usr_29.txt:600
msgid ""
"\t\tint find_entry(char *name)\n"
"\t\t{\n"
"\t   +->\t    int idx;\n"
"\t   |\n"
"\tgd |\t    for (idx = 0; idx < table_len; ++idx)\n"
"\t   |\t\tif (strcmp(table[idx].name, name) == 0)\n"
"\t   +--\t\t    return idx;\n"
"\t\t}"
msgstr ""

#: usr_29.txt:609
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_29.txt:611
msgid "Next chapter: |usr_30.txt|  Editing programs"
msgstr ""

#: usr_29.txt:613
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
