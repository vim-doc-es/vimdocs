#. extracted from usr_20.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-08-01 19:55+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.3.0\n"

#: usr_20.txt:1
msgid "*usr_20.txt*\tFor Vim version 7.2.  Last change: 2006 Apr 24"
msgstr ""

#: usr_20.txt:3
msgid "\t\t     VIM USER MANUAL - by Bram Moolenaar"
msgstr ""

#: usr_20.txt:5
msgid "\t\t     Typing command-line commands quickly"
msgstr ""

#: usr_20.txt:8
msgid ""
"Vim has a few generic features that makes it easier to enter commands.  "
"Colon\n"
"commands can be abbreviated, edited and repeated.  Completion is available "
"for\n"
"nearly everything."
msgstr ""

#: usr_20.txt:12
msgid ""
"|20.1|\tCommand line editing\n"
"|20.2|\tCommand line abbreviations\n"
"|20.3|\tCommand line completion\n"
"|20.4|\tCommand line history\n"
"|20.5|\tCommand line window"
msgstr ""

#: usr_20.txt:18
msgid ""
"     Next chapter: |usr_21.txt|  Go away and come back\n"
" Previous chapter: |usr_12.txt|  Clever tricks\n"
"Table of contents: |usr_toc.txt|"
msgstr ""

#: usr_20.txt:22
msgid ""
"============================================================================"
"==\n"
"*20.1*\tCommand line editing"
msgstr ""

#: usr_20.txt:25
msgid ""
"When you use a colon (:) command or search for a string with / or ?, Vim "
"puts\n"
"the cursor on the bottom of the screen.  There you type the command or "
"search\n"
"pattern.  This is called the Command line.  Also when it's used for entering "
"a\n"
"search command."
msgstr ""

#: usr_20.txt:30
msgid ""
"The most obvious way to edit the command you type is by pressing the <BS> "
"key.\n"
"This erases the character before the cursor.  To erase another character,\n"
"typed earlier, first move the cursor with the cursor keys.\n"
"   For example, you have typed this: >"
msgstr ""

#: usr_20.txt:35
msgid "\t:s/col/pig/"
msgstr ""

#: usr_20.txt:37
msgid ""
"Before you hit <Enter>, you notice that \"col\" should be \"cow\".  To correct\n"
"this, you type <Left> five times.  The cursor is now just after \"col\".  Type\n"
"<BS> and \"w\" to correct: >"
msgstr ""

#: usr_20.txt:41
msgid "\t:s/cow/pig/"
msgstr ""

#: usr_20.txt:43
msgid ""
"Now you can press <Enter> directly.  You don't have to move the cursor to "
"the\n"
"end of the line before executing the command."
msgstr ""

#: usr_20.txt:46
msgid "The most often used keys to move around in the command line:"
msgstr ""

#: usr_20.txt:48
msgid ""
"\t<Left>\t\t\tone character left\n"
"\t<Right>\t\t\tone character right\n"
"\t<S-Left> or <C-Left>\tone word left\n"
"\t<S-Right> or <C-Right>\tone word right\n"
"\tCTRL-B or <Home>\tto begin of command line\n"
"\tCTRL-E or <End>\t\tto end of command line"
msgstr ""

#: usr_20.txt:55
msgid ""
"\tNote:\n"
"\t<S-Left> (cursor left key with Shift key pressed) and <C-Left> (cursor\n"
"\tleft key with Control pressed) will not work on all keyboards.  Same\n"
"\tfor the other Shift and Control combinations."
msgstr ""

#: usr_20.txt:60
msgid "You can also use the mouse to move the cursor."
msgstr ""

#: usr_20.txt:63
msgid "DELETING"
msgstr ""

#: usr_20.txt:65
msgid ""
"As mentioned, <BS> deletes the character before the cursor.  To delete a "
"whole\n"
"word use CTRL-W."
msgstr ""

#: usr_20.txt:68
msgctxt "usr_20.txt:68"
msgid "\t/the fine pig ~"
msgstr ""

#: usr_20.txt:70
msgid "\t\t     CTRL-W"
msgstr ""

#: usr_20.txt:72
msgid "\t/the fine ~"
msgstr ""

#: usr_20.txt:74
msgid "CTRL-U removes all text, thus allows you to start all over again."
msgstr ""

#: usr_20.txt:77
msgid "OVERSTRIKE"
msgstr ""

#: usr_20.txt:79
msgid ""
"The <Insert> key toggles between inserting characters and replacing the\n"
"existing ones.  Start with this text:"
msgstr ""

#: usr_20.txt:82
msgctxt "usr_20.txt:82"
msgid "\t/the fine pig ~"
msgstr ""

#: usr_20.txt:84
msgid ""
"Move the cursor to the start of \"fine\" with <S-Left> twice (or <Left> eight\n"
"times, if <S-Left> doesn't work).  Now press <Insert> to switch to "
"overstrike\n"
"and type \"great\":"
msgstr ""

#: usr_20.txt:88
msgid "\t/the greatpig ~"
msgstr ""

#: usr_20.txt:90
msgid ""
"Oops, we lost the space.  Now, don't use <BS>, because it would delete the\n"
"\"t\" (this is different from Replace mode).  Instead, press <Insert> to "
"switch\n"
"from overstrike to inserting, and type the space:"
msgstr ""

#: usr_20.txt:94
msgid "\t/the great pig ~"
msgstr ""

#: usr_20.txt:97
msgid "CANCELLING"
msgstr ""

#: usr_20.txt:99
msgid ""
"You thought of executing a : or / command, but changed your mind.  To get "
"rid\n"
"of what you already typed, without executing it, press CTRL-C or <Esc>."
msgstr ""

#: usr_20.txt:102
msgid ""
"\tNote:\n"
"\t<Esc> is the universal \"get out\" key.  Unfortunately, in the good old\n"
"\tVi pressing <Esc> in a command line executed the command!  Since that\n"
"\tmight be considered to be a bug, Vim uses <Esc> to cancel the command.\n"
"\tBut with the 'cpoptions' option it can be made Vi compatible.  And\n"
"\twhen using a mapping (which might be written for Vi) <Esc> also works\n"
"\tVi compatible.  Therefore, using CTRL-C is a method that always works."
msgstr ""

#: usr_20.txt:110
msgid ""
"If you are at the start of the command line, pressing <BS> will cancel the\n"
"command.  It's like deleting the \":\" or \"/\" that the line starts with."
msgstr ""

#: usr_20.txt:113
msgid ""
"============================================================================"
"==\n"
"*20.2*\tCommand line abbreviations"
msgstr ""

#: usr_20.txt:116
msgid ""
"Some of the \":\" commands are really long.  We already mentioned that\n"
"\":substitute\" can be abbreviated to \":s\".  This is a generic mechanism, all\n"
"\":\" commands can be abbreviated."
msgstr ""

#: usr_20.txt:120
msgid ""
"How short can a command get?  There are 26 letters, and many more commands.\n"
"For example, \":set\" also starts with \":s\", but \":s\" doesn't start a \":set\"\n"
"command.  Instead \":set\" can be abbreviated to \":se\".\n"
"   When the shorter form of a command could be used for two commands, it\n"
"stands for only one of them.  There is no logic behind which one, you have "
"to\n"
"learn them.  In the help files the shortest form that works is mentioned.  "
"For\n"
"example: >"
msgstr ""

#: usr_20.txt:128
msgid "\t:s[ubstitute]"
msgstr ""

#: usr_20.txt:130
msgid ""
"This means that the shortest form of \":substitute\" is \":s\".  The following\n"
"characters are optional.  Thus \":su\" and \":sub\" also work."
msgstr ""

#: usr_20.txt:133
msgid ""
"In the user manual we will either use the full name of command, or a short\n"
"version that is still readable.  For example, \":function\" can be abbreviated\n"
"to \":fu\".  But since most people don't understand what that stands for, we\n"
"will use \":fun\".  (Vim doesn't have a \":funny\" command, otherwise \":fun\" "
"would\n"
"be confusing too.)"
msgstr ""

#: usr_20.txt:139
msgid ""
"It is recommended that in Vim scripts you write the full command name.  That\n"
"makes it easier to read back when you make later changes.  Except for some\n"
"often used commands like \":w\" (\":write\") and \":r\" (\":read\").\n"
"   A particularly confusing one is \":end\", which could stand for \":endif\",\n"
"\":endwhile\" or \":endfunction\".  Therefore, always use the full name."
msgstr ""

#: usr_20.txt:146
msgid "SHORT OPTION NAMES"
msgstr ""

#: usr_20.txt:148
msgid ""
"In the user manual the long version of the option names is used.  Many "
"options\n"
"also have a short name.  Unlike \":\" commands, there is only one short name\n"
"that works.  For example, the short name of 'autoindent' is 'ai'.  Thus "
"these\n"
"two commands do the same thing: >"
msgstr ""

#: usr_20.txt:153
msgid ""
"\t:set autoindent\n"
"\t:set ai"
msgstr ""

#: usr_20.txt:156
msgid "You can find the full list of long and short names here: |option-list|."
msgstr ""

#: usr_20.txt:158
msgid ""
"============================================================================"
"==\n"
"*20.3*\tCommand line completion"
msgstr ""

#: usr_20.txt:161
msgid ""
"This is one of those Vim features that, by itself, is a reason to switch "
"from\n"
"Vi to Vim.  Once you have used this, you can't do without."
msgstr ""

#: usr_20.txt:164
msgid "Suppose you have a directory that contains these files:"
msgstr ""

#: usr_20.txt:166
msgid ""
"\tinfo.txt\n"
"\tintro.txt\n"
"\tbodyofthepaper.txt"
msgstr ""

#: usr_20.txt:170
msgid "To edit the last one, you use the command: >"
msgstr ""

#: usr_20.txt:172
msgid "\t:edit bodyofthepaper.txt"
msgstr ""

#: usr_20.txt:174
msgid "It's easy to type this wrong.  A much quicker way is: >"
msgstr ""

#: usr_20.txt:176
msgid "\t:edit b<Tab>"
msgstr ""

#: usr_20.txt:178
msgid ""
"Which will result in the same command.  What happened?  The <Tab> key does\n"
"completion of the word before the cursor.  In this case \"b\".  Vim looks in "
"the\n"
"directory and finds only one file that starts with a \"b\".  That must be the\n"
"one you are looking for, thus Vim completes the file name for you."
msgstr ""

#: usr_20.txt:183
msgid "Now type: >"
msgstr ""

#: usr_20.txt:185
msgid "\t:edit i<Tab>"
msgstr ""

#: usr_20.txt:187
msgid "Vim will beep, and give you: >"
msgstr ""

#: usr_20.txt:189
msgid "\t:edit info.txt"
msgstr ""

#: usr_20.txt:191
msgid ""
"The beep means that Vim has found more than one match.  It then uses the "
"first\n"
"match it found (alphabetically).  If you press <Tab> again, you get: >"
msgstr ""

#: usr_20.txt:194
msgid "\t:edit intro.txt"
msgstr ""

#: usr_20.txt:196
msgid ""
"Thus, if the first <Tab> doesn't give you the file you were looking for, "
"press\n"
"it again.  If there are more matches, you will see them all, one at a time.\n"
"   If you press <Tab> on the last matching entry, you will go back to what "
"you\n"
"first typed: >"
msgstr ""

#: usr_20.txt:201
msgid "\t:edit i"
msgstr ""

#: usr_20.txt:203
msgid ""
"Then it starts all over again.  Thus Vim cycles through the list of matches.\n"
"Use CTRL-P to go through the list in the other direction:"
msgstr ""

#: usr_20.txt:206
msgid ""
"\t      <------------------- <Tab> -------------------------+\n"
"\t\t\t\t\t\t\t\t  |\n"
"\t\t  <Tab> -->\t\t       <Tab> -->\n"
"\t:edit i\t\t      :edit info.txt\t\t   :edit intro.txt\n"
"\t\t  <-- CTRL-P\t\t       <-- CTRL-P\n"
"\t   |\n"
"\t   +---------------------- CTRL-P ------------------------>"
msgstr ""

#: usr_20.txt:215
msgid "CONTEXT"
msgstr ""

#: usr_20.txt:217
msgid "When you type \":set i\" instead of \":edit i\" and press <Tab> you get: >"
msgstr ""

#: usr_20.txt:219
msgid "\t:set icon"
msgstr ""

#: usr_20.txt:221
msgid ""
"Hey, why didn't you get \":set info.txt\"?  That's because Vim has context\n"
"sensitive completion.  The kind of words Vim will look for depends on the\n"
"command before it.  Vim knows that you cannot use a file name just after a\n"
"\":set\" command, but you can use an option name.\n"
"   Again, if you repeat typing the <Tab>, Vim will cycle through all "
"matches.\n"
"There are quite a few, it's better to type more characters first: >"
msgstr ""

#: usr_20.txt:228
msgid "\t:set isk<Tab>"
msgstr ""

#: usr_20.txt:230
msgid "Gives: >"
msgstr ""

#: usr_20.txt:232
msgid "\t:set iskeyword"
msgstr ""

#: usr_20.txt:234
msgid "Now type \"=\" and press <Tab>: >"
msgstr ""

#: usr_20.txt:236
msgid "\t:set iskeyword=@,48-57,_,192-255"
msgstr ""

#: usr_20.txt:238
msgid ""
"What happens here is that Vim inserts the old value of the option.  Now you\n"
"can edit it.\n"
"   What is completed with <Tab> is what Vim expects in that place.  Just try\n"
"it out to see how it works.  In some situations you will not get what you\n"
"want.  That's either because Vim doesn't know what you want, or because\n"
"completion was not implemented for that situation.  In that case you will "
"get\n"
"a <Tab> inserted (displayed as ^I)."
msgstr ""

#: usr_20.txt:247
msgid "LIST MATCHES"
msgstr ""

#: usr_20.txt:249
msgid ""
"When there are many matches, you would like to see an overview.  Do this by\n"
"pressing CTRL-D.  For example, pressing CTRL-D after: >"
msgstr ""

#: usr_20.txt:252
msgid "\t:set is"
msgstr ""

#: usr_20.txt:254
msgid "results in: >"
msgstr ""

#: usr_20.txt:256
msgid ""
"\t:set is\n"
"\tincsearch  isfname    isident    iskeyword  isprint\n"
"\t:set is"
msgstr ""

#: usr_20.txt:260
msgid ""
"Vim lists the matches and then comes back with the text you typed.  You can\n"
"now check the list for the item you wanted.  If it isn't there, you can use\n"
"<BS> to correct the word.  If there are many matches, type a few more\n"
"characters before pressing <Tab> to complete the rest.\n"
"   If you have watched carefully, you will have noticed that \"incsearch\"\n"
"doesn't start with \"is\".  In this case \"is\" stands for the short name of\n"
"\"incsearch\".  (Many options have a short and a long name.)  Vim is clever\n"
"enough to know that you might have wanted to expand the short name of the\n"
"option into the long name."
msgstr ""

#: usr_20.txt:271
msgid "THERE IS MORE"
msgstr ""

#: usr_20.txt:273
msgid ""
"The CTRL-L command completes the word to the longest unambiguous string.  If\n"
"you type \":edit i\" and there are files \"info.txt\" and \"info_backup.txt\" you\n"
"will get \":edit info\"."
msgstr ""

#: usr_20.txt:277
msgid ""
"The 'wildmode' option can be used to change the way completion works.\n"
"The 'wildmenu' option can be used to get a menu-like list of matches.\n"
"Use the 'suffixes' option to specify files that are less important and "
"appear\n"
"at the end of the list of files.\n"
"The 'wildignore' option specifies files that are not listed at all."
msgstr ""

#: usr_20.txt:283
msgid "More about all of this here: |cmdline-completion|"
msgstr ""

#: usr_20.txt:285
msgid ""
"============================================================================"
"==\n"
"*20.4*\tCommand line history"
msgstr ""

#: usr_20.txt:288
msgid ""
"In chapter 3 we briefly mentioned the history.  The basics are that you can\n"
"use the <Up> key to recall an older command line.  <Down> then takes you "
"back\n"
"to newer commands."
msgstr ""

#: usr_20.txt:292
msgid ""
"There are actually four histories.  The ones we will mention here are for "
"\":\"\n"
"commands and for \"/\" and \"?\" search commands.  The \"/\" and \"?\" commands "
"share\n"
"the same history, because they are both search commands.  The two other\n"
"histories are for expressions and input lines for the input() function.\n"
"|cmdline-history|"
msgstr ""

#: usr_20.txt:298
msgid ""
"Suppose you have done a \":set\" command, typed ten more colon commands and "
"then\n"
"want to repeat that \":set\" command again.  You could press \":\" and then ten\n"
"times <Up>.  There is a quicker way: >"
msgstr ""

#: usr_20.txt:302
msgid "\t:se<Up>"
msgstr ""

#: usr_20.txt:304
msgid ""
"Vim will now go back to the previous command that started with \"se\".  You "
"have\n"
"a good chance that this is the \":set\" command you were looking for.  At "
"least\n"
"you should not have to press <Up> very often (unless \":set\" commands is all\n"
"you have done)."
msgstr ""

#: usr_20.txt:309
msgid ""
"The <Up> key will use the text typed so far and compare it with the lines in\n"
"the history.  Only matching lines will be used.\n"
"   If you do not find the line you were looking for, use <Down> to go back "
"to\n"
"what you typed and correct that.  Or use CTRL-U to start all over again."
msgstr ""

#: usr_20.txt:314
msgid "To see all the lines in the history: >"
msgstr ""

#: usr_20.txt:316
msgid "\t:history"
msgstr ""

#: usr_20.txt:318
msgid ""
"That's the history of \":\" commands.  The search history is displayed with "
"this\n"
"command: >"
msgstr ""

#: usr_20.txt:321
msgid "\t:history /"
msgstr ""

#: usr_20.txt:323
msgid ""
"CTRL-P will work like <Up>, except that it doesn't matter what you already\n"
"typed.  Similarly for CTRL-N and <Down>.  CTRL-P stands for previous, CTRL-N\n"
"for next."
msgstr ""

#: usr_20.txt:327
msgid ""
"============================================================================"
"==\n"
"*20.5*\tCommand line window"
msgstr ""

#: usr_20.txt:330
msgid ""
"Typing the text in the command line works different from typing text in "
"Insert\n"
"mode.  It doesn't allow many commands to change the text.  For most commands\n"
"that's OK, but sometimes you have to type a complicated command.  That's "
"where\n"
"the command line window is useful."
msgstr ""

#: usr_20.txt:335
msgid "Open the command line window with this command: >"
msgstr ""

#: usr_20.txt:337
msgid "\tq:"
msgstr ""

#: usr_20.txt:339
msgid ""
"Vim now opens a (small) window at the bottom.  It contains the command line\n"
"history, and an empty line at the end:"
msgstr ""

#: usr_20.txt:342
msgid ""
"\t+-------------------------------------+\n"
"\t|other window\t\t\t      |\n"
"\t|~\t\t\t\t      |\n"
"\t|file.txt=============================|\n"
"\t|:e c\t\t\t\t      |\n"
"\t|:e config.h.in\t\t\t      |\n"
"\t|:set path=.,/usr/include,,\t      |\n"
"\t|:set iskeyword=@,48-57,_,192-255     |\n"
"\t|:set is\t\t\t      |\n"
"\t|:q\t\t\t\t      |\n"
"\t|:\t\t\t\t      |\n"
"\t|command-line=========================|\n"
"\t|\t\t\t\t      |\n"
"\t+-------------------------------------+"
msgstr ""

#: usr_20.txt:357
msgid ""
"You are now in Normal mode.  You can use the \"hjkl\" keys to move around.  "
"For\n"
"example, move up with \"5k\" to the \":e config.h.in\" line.  Type \"$h\" to go to\n"
"the \"i\" of \"in\" and type \"cwout\".  Now you have changed the line to:"
msgstr ""

#: usr_20.txt:361
msgid "\t:e config.h.out ~"
msgstr ""

#: usr_20.txt:363
msgid ""
"Now press <Enter> and this command will be executed.  The command line "
"window\n"
"will close.\n"
"   The <Enter> command will execute the line under the cursor.  It doesn't\n"
"matter whether Vim is in Insert mode or in Normal mode.\n"
"   Changes in the command line window are lost.  They do not result in the\n"
"history to be changed.  Except that the command you execute will be added to\n"
"the end of the history, like with all executed commands."
msgstr ""

#: usr_20.txt:371
msgid ""
"The command line window is very useful when you want to have overview of the\n"
"history, lookup a similar command, change it a bit and execute it.  A search\n"
"command can be used to find something.\n"
"   In the previous example the \"?config\" search command could have been used\n"
"to find the previous command that contains \"config\".  It's a bit strange,\n"
"because you are using a command line to search in the command line window.\n"
"While typing that search command you can't open another command line window,\n"
"there can be only one."
msgstr ""

#: usr_20.txt:380
msgid ""
"============================================================================"
"=="
msgstr ""

#: usr_20.txt:382
msgid "Next chapter: |usr_21.txt|  Go away and come back"
msgstr ""

#: usr_20.txt:384
msgid "Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:"
msgstr ""
